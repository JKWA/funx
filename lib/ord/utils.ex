defmodule Monex.Ord.Utils do
  @moduledoc """
  Utility functions for working with the `Monex.Ord` protocol.
  These functions assume that types passed in either support Elixir's comparison operators
  or implement the `Monex.Ord` protocol.
  """

  alias Monex.Ord

  @doc """
  Transforms an ordering by applying a function `f` to values before comparison.

  The `ord` parameter can be an `Ord` module or a custom comparator map with comparison functions (`:lt?`, `:le?`, `:gt?`, and `:ge?`).
  When an `Ord` module is provided, it wraps the module’s functions to apply `f` to each value before invoking the comparison.
  If a custom comparator map is provided, it wraps the functions in the map to apply `f` to each value.

  ## Examples

    iex> ord = Monex.Ord.Utils.contramap(&String.length/1, Ord.Any)
    iex> ord[:lt?].("short", "longer")
    true
  """
  @spec contramap((any() -> any()), module() | map()) :: %{
          lt?: (any(), any() -> boolean()),
          le?: (any(), any() -> boolean()),
          gt?: (any(), any() -> boolean()),
          ge?: (any(), any() -> boolean())
        }
  def contramap(f, ord) when is_atom(ord) do
    %{
      lt?: fn a, b -> ord.lt?(f.(a), f.(b)) end,
      le?: fn a, b -> ord.le?(f.(a), f.(b)) end,
      gt?: fn a, b -> ord.gt?(f.(a), f.(b)) end,
      ge?: fn a, b -> ord.ge?(f.(a), f.(b)) end
    }
  end

  def contramap(f, ord) when is_map(ord) do
    %{
      lt?: fn a, b -> ord[:lt?].(f.(a), f.(b)) end,
      le?: fn a, b -> ord[:le?].(f.(a), f.(b)) end,
      gt?: fn a, b -> ord[:gt?].(f.(a), f.(b)) end,
      ge?: fn a, b -> ord[:ge?].(f.(a), f.(b)) end
    }
  end

  def contramap(f), do: contramap(f, Ord)

  @doc """
  Returns the maximum of two values, with an optional custom `Ord`.

  The `ord` parameter can be an `Ord` module (such as `Ord.Any`) or a custom comparator map generated by `contramap/2`.
  If an `Ord` module is provided, it calls `ge?/2` directly from that module.
  If a custom comparator map is provided, it expects a `:ge?` function in the map that compares the two values.
  """
  @spec max(any(), any()) :: any()
  def max(a, b, ord \\ Ord) do
    if (is_atom(ord) && ord.ge?(a, b)) || (is_map(ord) && ord[:ge?].(a, b)), do: a, else: b
  end

  @doc """
  Returns the minimum of two values, with an optional custom `Ord`.

  The `ord` parameter can be an `Ord` module or a custom comparator map generated by `contramap/2`.
  If an `Ord` module is provided, it calls `le?/2` directly from that module.
  If a custom comparator map is provided, it expects a `:le?` function in the map that compares the two values.
  """
  def min(a, b, ord \\ Ord) do
    if (is_atom(ord) && ord.le?(a, b)) || (is_map(ord) && ord[:le?].(a, b)), do: a, else: b
  end

  @doc """
  Clamps a value between `min` and `max`, with an optional custom `Ord`.

  The `ord` parameter can be an `Ord` module or a custom comparator map generated by `contramap/2`.
  If an `Ord` module is provided, it calls `lt?/2` and `gt?/2` directly from that module.
  If a custom comparator map is provided, it expects `:lt?` and `:gt?` functions in the map that compare the values.
  """
  def clamp(value, min, max, ord \\ Ord) do
    lt? = if is_atom(ord), do: &ord.lt?/2, else: ord[:lt?]
    gt? = if is_atom(ord), do: &ord.gt?/2, else: ord[:gt?]

    cond do
      lt?.(value, min) -> min
      gt?.(value, max) -> max
      true -> value
    end
  end

  @doc """
  Checks if `value` is between `min` and `max`, inclusive, with an optional custom `Ord`.

  The `ord` parameter can be an `Ord` module or a custom comparator map generated by `contramap/2`.
  If an `Ord` module is provided, it calls `ge?/2` and `le?/2` directly from that module.
  If a custom comparator map is provided, it expects `:ge?` and `:le?` functions in the map that compare the values.
  """
  def between(value, min, max, ord \\ Ord) do
    (is_atom(ord) && ord.ge?(value, min) && ord.le?(value, max)) ||
      (is_map(ord) && ord[:ge?].(value, min) && ord[:le?].(value, max))
  end

  @doc """
  Compares two values and returns `:lt`, `:eq`, or `:gt`, with an optional custom `Ord`.

  The `ord` parameter can be an `Ord` module or a custom comparator map generated by `contramap/2`.
  If an `Ord` module is provided, it calls `lt?/2` and `gt?/2` directly from that module.
  If a custom comparator map is provided, it expects `:lt?` and `:gt?` functions in the map that compare the values.
  """
  def compare(a, b, ord \\ Ord) do
    lt? = if is_atom(ord), do: &ord.lt?/2, else: ord[:lt?]
    gt? = if is_atom(ord), do: &ord.gt?/2, else: ord[:gt?]

    cond do
      lt?.(a, b) -> :lt
      gt?.(a, b) -> :gt
      true -> :eq
    end
  end

  @doc """
  Reverses the ordering logic.
  """
  def reverse(ord \\ Ord)

  def reverse(ord) when is_atom(ord) do
    %{
      lt?: fn a, b -> ord.gt?(a, b) end,
      le?: fn a, b -> ord.ge?(a, b) end,
      gt?: fn a, b -> ord.lt?(a, b) end,
      ge?: fn a, b -> ord.le?(a, b) end
    }
  end

  def reverse(%{lt?: lt?, le?: le?, gt?: gt?, ge?: ge?}) do
    %{
      lt?: gt?,
      le?: ge?,
      gt?: lt?,
      ge?: le?
    }
  end

  @doc """
  Creates a comparator function from the given `Ord` module, returning `true`
  if `a` is less than or equal to `b` according to the module’s ordering.

  Useful for sorting with `Enum.sort/2` or similar functions.
  """
  @spec comparator(module() | map()) :: (any(), any() -> boolean())
  def comparator(ord_module) do
    fn a, b -> compare(a, b, ord_module) != :gt end
  end
end
