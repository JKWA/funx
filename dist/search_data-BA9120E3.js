searchData={"items":[{"type":"protocol","title":"Funx.Appendable","doc":"A protocol for combining values in a generic, extensible way.\n\nThe `Appendable` protocol defines how two values of the same type can be combined. It is\nused throughout Funx in functions like `traverse_a/2` and `wither_a/2` to accumulate\nintermediate results without coupling logic to a specific type.\n\nThis protocol enables functions to remain flexible and composable when reducing,\naggregating, or accumulating values across a wide variety of domains.","ref":"Funx.Appendable.html"},{"type":"protocol","title":"Required functions - Funx.Appendable","doc":"* `coerce/1` – Normalizes an input value into a form suitable for aggregation.\n* `append/2` – Combines two values of the same type into one.","ref":"Funx.Appendable.html#module-required-functions"},{"type":"protocol","title":"Default – Flat list aggregation - Funx.Appendable","doc":"A fallback implementation is provided for all types that do not define a specific\n`Appendable` instance. This default uses list concatenation as a universal aggregation\nstrategy: all inputs are coerced into lists (if not already), and combined using `++`.\n\nWhen using the default aggregation strategy, values are collected in a plain list:\n\n```elixir\nvalidate_positive = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(&1 > 0), fn v -> \"Value must be positive: \" <> to_string(v) end)\nend\n\nvalidate_even = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(rem(&1, 2) == 0), fn v -> \"Value must be even: \" <> to_string(v) end)\nend\n\nFunx.Monad.Either.validate(4, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Right{right: 4}\n\nFunx.Monad.Either.validate(3, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Left{left: [\"Value must be even: 3\"]}\n\nFunx.Monad.Either.validate(-3, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Left{left: [\"Value must be positive: -3\", \"Value must be even: -3\"]}\n```","ref":"Funx.Appendable.html#module-default-flat-list-aggregation"},{"type":"protocol","title":"Structured aggregation with `ValidationError` - Funx.Appendable","doc":"You can also use a custom struct to hold errors. This example uses `ValidationError`:\n\n```elixir\nalias Funx.Errors.ValidationError\n\nvalidate_positive = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(&1 > 0), fn v -> \"Value must be positive: \" <> to_string(v) end)\n  |> Funx.Monad.Either.map_left(&ValidationError.new/1)\nend\n\nvalidate_even = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(rem(&1, 2) == 0), fn v -> \"Value must be even: \" <> to_string(v) end)\n  |> Funx.Monad.Either.map_left(&ValidationError.new/1)\nend\n\nFunx.Monad.Either.validate(-3, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Left{\n#     left: %ValidationError{\n#       errors: [\"Value must be positive: -3\", \"Value must be even: -3\"]\n#     }\n#   }\n```","ref":"Funx.Appendable.html#module-structured-aggregation-with-validationerror"},{"type":"function","title":"Funx.Appendable.append/2","doc":"Combines two values into a single result.\n\nImplementations must ensure the operation is associative within their type. For types\nthat require disambiguation or structural control, define a custom implementation.","ref":"Funx.Appendable.html#append/2"},{"type":"function","title":"Funx.Appendable.coerce/1","doc":"Normalizes a single input value into a form suitable for accumulation.","ref":"Funx.Appendable.html#coerce/1"},{"type":"type","title":"Funx.Appendable.t/0","doc":"All the types that implement this protocol.","ref":"Funx.Appendable.html#t:t/0"},{"type":"module","title":"Funx.Config","doc":"Internal access to `:funx` application configuration.\n\nThese functions read from `Application.get_env/3` with sane defaults.\nUsed by effect modules for settings like timeouts, telemetry, and summarization.","ref":"Funx.Config.html"},{"type":"module","title":"Supported config keys - Funx.Config","doc":"- `:timeout` — default timeout for running effects (default: `5_000` ms)\n- `:telemetry_prefix` — base prefix for telemetry events (default: `[:funx]`)\n- `:telemetry_enabled` — whether telemetry spans are emitted (default: `true`)\n- `:summarizer` — function used to summarize effect results for telemetry\n- `:default_span_name` — fallback span name for telemetry traces","ref":"Funx.Config.html#module-supported-config-keys"},{"type":"function","title":"Funx.Config.default_span_name/0","doc":"","ref":"Funx.Config.html#default_span_name/0"},{"type":"function","title":"Funx.Config.summarizer/0","doc":"","ref":"Funx.Config.html#summarizer/0"},{"type":"function","title":"Funx.Config.telemetry_enabled?/0","doc":"","ref":"Funx.Config.html#telemetry_enabled?/0"},{"type":"function","title":"Funx.Config.telemetry_prefix/0","doc":"","ref":"Funx.Config.html#telemetry_prefix/0"},{"type":"function","title":"Funx.Config.timeout/0","doc":"","ref":"Funx.Config.html#timeout/0"},{"type":"protocol","title":"Funx.Eq","doc":"The `Funx.Eq` protocol defines an equality function, `eq?/2`, for comparing two values,\nand its complement, `not_eq?/2`, for checking inequality.\n\nTypes that implement this protocol can define custom equality logic, allowing for\ndomain-specific comparisons.","ref":"Funx.Eq.html"},{"type":"protocol","title":"Fallback - Funx.Eq","doc":"The protocol uses `@fallback_to_any true`, meaning that if a specific type does not\nimplement `Funx.Eq`, it falls back to the default implementation for `Any`, which\nuses Elixir's built-in equality operator (`==`).","ref":"Funx.Eq.html#module-fallback"},{"type":"protocol","title":"Examples - Funx.Eq","doc":"With a custom implementation for a `Funx.Monad.Maybe` type:\n\n    iex> Funx.Eq.eq?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(3))\n    true\n\n    iex> Funx.Eq.eq?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(5))\n    false\n\n    iex> Funx.Eq.eq?(Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.nothing())\n    true\n\n    iex> Funx.Eq.eq?(Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.just(5))\n    false\n\nChecking inequality with `not_eq?/2`:\n\n    iex> Funx.Eq.not_eq?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(3))\n    false\n\n    iex> Funx.Eq.not_eq?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(5))\n    true\n\n    iex> Funx.Eq.not_eq?(Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.nothing())\n    false\n\n    iex> Funx.Eq.not_eq?(Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.just(5))\n    true","ref":"Funx.Eq.html#module-examples"},{"type":"function","title":"Funx.Eq.eq?/2","doc":"Returns `true` if `a` is equal to `b`, otherwise returns `false`.","ref":"Funx.Eq.html#eq?/2"},{"type":"function","title":"Examples - Funx.Eq.eq?/2","doc":"iex> Funx.Eq.eq?(1, 1)\n    true\n\n    iex> Funx.Eq.eq?(1, 2)\n    false","ref":"Funx.Eq.html#eq?/2-examples"},{"type":"function","title":"Funx.Eq.not_eq?/2","doc":"Returns `true` if `a` is not equal to `b`, otherwise returns `false`.","ref":"Funx.Eq.html#not_eq?/2"},{"type":"function","title":"Examples - Funx.Eq.not_eq?/2","doc":"iex> Funx.Eq.not_eq?(1, 1)\n    false\n\n    iex> Funx.Eq.not_eq?(1, 2)\n    true","ref":"Funx.Eq.html#not_eq?/2-examples"},{"type":"type","title":"Funx.Eq.t/0","doc":"All the types that implement this protocol.","ref":"Funx.Eq.html#t:t/0"},{"type":"module","title":"Funx.Eq.Utils","doc":"Utility functions for working with the `Funx.Eq` protocol.\nThese functions assume that types passed in either support Elixir's equality operator\nor implement the `Funx.Eq` protocol.","ref":"Funx.Eq.Utils.html"},{"type":"function","title":"Funx.Eq.Utils.append_all/2","doc":"Combines two equality comparators using the `Eq.All` monoid.\n\nThis function merges two equality comparisons, requiring **both** to return `true`\nfor the final result to be considered equal. This enforces a **strict** equality rule,\nwhere all comparators must agree.","ref":"Funx.Eq.Utils.html#append_all/2"},{"type":"function","title":"Examples - Funx.Eq.Utils.append_all/2","doc":"iex> eq1 = Funx.Eq.Utils.contramap(& &1.name)\n    iex> eq2 = Funx.Eq.Utils.contramap(& &1.age)\n    iex> combined = Funx.Eq.Utils.append_all(eq1, eq2)\n    iex> Funx.Eq.Utils.eq?(%{name: \"Alice\", age: 30}, %{name: \"Alice\", age: 30}, combined)\n    true\n    iex> Funx.Eq.Utils.eq?(%{name: \"Alice\", age: 30}, %{name: \"Alice\", age: 25}, combined)\n    false","ref":"Funx.Eq.Utils.html#append_all/2-examples"},{"type":"function","title":"Funx.Eq.Utils.append_any/2","doc":"Combines two equality comparators using the `Eq.Any` monoid.\n\nThis function merges two equality comparisons, where **at least one**\nmust return `true` for the final result to be considered equal.","ref":"Funx.Eq.Utils.html#append_any/2"},{"type":"function","title":"Examples - Funx.Eq.Utils.append_any/2","doc":"iex> eq1 = Funx.Eq.Utils.contramap(& &1.name)\n    iex> eq2 = Funx.Eq.Utils.contramap(& &1.age)\n    iex> combined = Funx.Eq.Utils.append_any(eq1, eq2)\n    iex> Funx.Eq.Utils.eq?(%{name: \"Alice\", age: 30}, %{name: \"Alice\", age: 25}, combined)\n    true\n    iex> Funx.Eq.Utils.eq?(%{name: \"Alice\", age: 30}, %{name: \"Bob\", age: 25}, combined)\n    false","ref":"Funx.Eq.Utils.html#append_any/2-examples"},{"type":"function","title":"Funx.Eq.Utils.concat_all/1","doc":"Concatenates a list of equality comparators using the `Eq.All` monoid.\n\nThe resulting comparator requires **all** comparators in the list to agree\nthat two values are equal.","ref":"Funx.Eq.Utils.html#concat_all/1"},{"type":"function","title":"Examples - Funx.Eq.Utils.concat_all/1","doc":"iex> eq1 = Funx.Eq.Utils.contramap(& &1.name)\n    iex> eq2 = Funx.Eq.Utils.contramap(& &1.age)\n    iex> combined = Funx.Eq.Utils.concat_all([eq1, eq2])\n    iex> Funx.Eq.Utils.eq?(%{name: \"Alice\", age: 30}, %{name: \"Alice\", age: 30}, combined)\n    true\n    iex> Funx.Eq.Utils.eq?(%{name: \"Alice\", age: 30}, %{name: \"Alice\", age: 25}, combined)\n    false","ref":"Funx.Eq.Utils.html#concat_all/1-examples"},{"type":"function","title":"Funx.Eq.Utils.concat_any/1","doc":"Concatenates a list of equality comparators using the `Eq.Any` monoid.\n\nThe resulting comparator allows **any** comparator in the list to determine\nequality, making it more permissive.","ref":"Funx.Eq.Utils.html#concat_any/1"},{"type":"function","title":"Examples - Funx.Eq.Utils.concat_any/1","doc":"iex> eq1 = Funx.Eq.Utils.contramap(& &1.name)\n    iex> eq2 = Funx.Eq.Utils.contramap(& &1.age)\n    iex> combined = Funx.Eq.Utils.concat_any([eq1, eq2])\n    iex> Funx.Eq.Utils.eq?(%{name: \"Alice\", age: 30}, %{name: \"Alice\", age: 25}, combined)\n    true\n    iex> Funx.Eq.Utils.eq?(%{name: \"Alice\", age: 30}, %{name: \"Bob\", age: 25}, combined)\n    false","ref":"Funx.Eq.Utils.html#concat_any/1-examples"},{"type":"function","title":"Funx.Eq.Utils.contramap/2","doc":"Transforms an equality check by applying a function `f` to values before comparison.\n\nThe `eq` parameter can be an `Eq` module or a custom comparator map with an `:eq?` function.\nIf an `Eq` module is provided, it wraps the module’s function to apply `f` to each value before invoking the equality check.\nIf a custom comparator map is provided, it wraps the function in the map to apply `f` to each value.","ref":"Funx.Eq.Utils.html#contramap/2"},{"type":"function","title":"Examples - Funx.Eq.Utils.contramap/2","doc":"iex> eq = Funx.Eq.Utils.contramap(& &1.age)\n    iex> eq.eq?.(%{age: 30}, %{age: 30})\n    true\n    iex> eq.eq?.(%{age: 30}, %{age: 25})\n    false","ref":"Funx.Eq.Utils.html#contramap/2-examples"},{"type":"function","title":"Funx.Eq.Utils.eq?/3","doc":"Returns true if two values are equal, using a specified or default `Eq`.","ref":"Funx.Eq.Utils.html#eq?/3"},{"type":"function","title":"Examples - Funx.Eq.Utils.eq?/3","doc":"iex> Funx.Eq.Utils.eq?(42, 42)\n    true\n    iex> Funx.Eq.Utils.eq?(\"foo\", \"bar\")\n    false","ref":"Funx.Eq.Utils.html#eq?/3-examples"},{"type":"function","title":"Funx.Eq.Utils.eq_by?/4","doc":"Checks equality of values by applying a projection function, using a specified or default `Eq`.\n\nThe `eq` parameter can be an `Eq` module or a custom comparator map with an `:eq?` function.","ref":"Funx.Eq.Utils.html#eq_by?/4"},{"type":"function","title":"Examples - Funx.Eq.Utils.eq_by?/4","doc":"iex> Funx.Eq.Utils.eq_by?(& &1.age, %{age: 30}, %{age: 30})\n    true\n    iex> Funx.Eq.Utils.eq_by?(& &1.age, %{age: 30}, %{age: 25})\n    false","ref":"Funx.Eq.Utils.html#eq_by?/4-examples"},{"type":"function","title":"Funx.Eq.Utils.not_eq?/3","doc":"Returns false if two values are not equal, using a specified or default `Eq`.","ref":"Funx.Eq.Utils.html#not_eq?/3"},{"type":"function","title":"Examples - Funx.Eq.Utils.not_eq?/3","doc":"iex> Funx.Eq.Utils.not_eq?(42, 99)\n    true\n    iex> Funx.Eq.Utils.not_eq?(\"foo\", \"foo\")\n    false","ref":"Funx.Eq.Utils.html#not_eq?/3-examples"},{"type":"function","title":"Funx.Eq.Utils.to_eq_map/1","doc":"","ref":"Funx.Eq.Utils.html#to_eq_map/1"},{"type":"function","title":"Funx.Eq.Utils.to_predicate/2","doc":"Converts an `Eq` comparator into a single-argument predicate function for use in `Enum` functions.\n\nThe resulting predicate takes a single element and returns `true` if it matches the `target`\nbased on the specified `Eq`. If no custom `Eq` is provided, it defaults to `Funx.Eq`.","ref":"Funx.Eq.Utils.html#to_predicate/2"},{"type":"function","title":"Examples - Funx.Eq.Utils.to_predicate/2","doc":"iex> eq = Funx.Eq.Utils.contramap(& &1.name)\n    iex> predicate = Funx.Eq.Utils.to_predicate(%{name: \"Alice\"}, eq)\n    iex> Funx.Filterable.filter([%{name: \"Alice\"}, %{name: \"Bob\"}], predicate)\n    [%{name: \"Alice\"}]","ref":"Funx.Eq.Utils.html#to_predicate/2-examples"},{"type":"type","title":"Funx.Eq.Utils.eq_map/0","doc":"","ref":"Funx.Eq.Utils.html#t:eq_map/0"},{"type":"type","title":"Funx.Eq.Utils.eq_t/0","doc":"","ref":"Funx.Eq.Utils.html#t:eq_t/0"},{"type":"protocol","title":"Funx.Filterable","doc":"The `Funx.Filterable` protocol defines functions for conditionally retaining or discarding\nvalues within a context. It generalizes the concepts of `filter`, `filter_map`, and `guard`\nacross different data structures like `Maybe`, `List`, and others.\n\nThese functions enable conditional value retention, transformation, and short-circuiting based\non boolean conditions or predicate functions.","ref":"Funx.Filterable.html"},{"type":"function","title":"Funx.Filterable.filter/2","doc":"Retains values that satisfy the given predicate.\n\nThe `filter/2` function applies a predicate to the value(s) inside the context. If the predicate returns `true`,\nthe value is retained; otherwise, it is discarded. For collections, it filters all elements based on the predicate.","ref":"Funx.Filterable.html#filter/2"},{"type":"function","title":"Parameters: - Funx.Filterable.filter/2","doc":"- `structure`: The context-wrapped value or collection.\n- `predicate`: A function `(a -> boolean)` determining whether to retain each value.","ref":"Funx.Filterable.html#filter/2-parameters"},{"type":"function","title":"Examples - Funx.Filterable.filter/2","doc":"iex> Funx.Filterable.filter(Funx.Monad.Maybe.just(5), &(&1 > 3))\n    %Funx.Monad.Maybe.Just{value: 5}\n\n    iex> Funx.Filterable.filter(Funx.Monad.Maybe.just(2), &(&1 > 3))\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Filterable.html#filter/2-examples"},{"type":"function","title":"Funx.Filterable.filter_map/2","doc":"Applies a function that returns a `Maybe` value, combining filtering and mapping in a single pass.\n\n`filter_map/2` applies the provided function to the value(s) within the context. If the function returns `Just`,\nthe transformed value is retained; if it returns `Nothing`, the value is discarded. This avoids multiple traversals\nwhen both mapping and filtering are required.","ref":"Funx.Filterable.html#filter_map/2"},{"type":"function","title":"Parameters: - Funx.Filterable.filter_map/2","doc":"- `structure`: The context-wrapped value or collection.\n- `func`: A function `(a -> Maybe b)` that both transforms and conditionally retains values.","ref":"Funx.Filterable.html#filter_map/2-parameters"},{"type":"function","title":"Examples - Funx.Filterable.filter_map/2","doc":"iex> Funx.Filterable.filter_map(Funx.Monad.Maybe.just(5), fn x -> if x > 3, do: Funx.Monad.Maybe.just(x * 2), else: Funx.Monad.Maybe.nothing() end)\n    %Funx.Monad.Maybe.Just{value: 10}\n\n    iex> Funx.Filterable.filter_map(Funx.Monad.Maybe.just(2), fn x -> if x > 3, do: Funx.Monad.Maybe.just(x * 2), else: Funx.Monad.Maybe.nothing() end)\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Filterable.html#filter_map/2-examples"},{"type":"function","title":"Funx.Filterable.guard/2","doc":"Conditionally retains a value within the context. If the boolean is true, returns the existing value;\notherwise, returns an empty value for the context.","ref":"Funx.Filterable.html#guard/2"},{"type":"function","title":"Parameters: - Funx.Filterable.guard/2","doc":"- `structure`: The context-wrapped value (e.g., `Just`, list, etc.).\n- `bool`: A boolean indicating whether to retain the value.","ref":"Funx.Filterable.html#guard/2-parameters"},{"type":"function","title":"Examples - Funx.Filterable.guard/2","doc":"iex> Funx.Filterable.guard(Funx.Monad.Maybe.just(42), true)\n    %Funx.Monad.Maybe.Just{value: 42}\n\n    iex> Funx.Filterable.guard(Funx.Monad.Maybe.just(42), false)\n    %Funx.Monad.Maybe.Nothing{}\n\n    iex> Funx.Filterable.guard(Funx.Monad.Maybe.nothing(), true)\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Filterable.html#guard/2-examples"},{"type":"type","title":"Funx.Filterable.t/0","doc":"All the types that implement this protocol.","ref":"Funx.Filterable.html#t:t/0"},{"type":"protocol","title":"Funx.Foldable","doc":"The `Funx.Foldable` protocol defines two core folding operations: `fold_l/3` (fold left) and `fold_r/3` (fold right).\n\nThese functions allow structures to be collapsed into a single value by applying functions in a specific order.\nDepending on the structure, folding can be done from the left (`fold_l/3`) or from the right (`fold_r/3`).","ref":"Funx.Foldable.html"},{"type":"function","title":"Funx.Foldable.fold_l/3","doc":"Folds the structure from the left, applying `func_a` if a condition is met, otherwise applying `func_b`.\n\nThis function collapses a structure by recursively applying the provided functions from the leftmost element to the rightmost.","ref":"Funx.Foldable.html#fold_l/3"},{"type":"function","title":"Parameters: - Funx.Foldable.fold_l/3","doc":"- `structure`: The structure to fold.\n- `func_a`: The function to apply in case of a matching condition.\n- `func_b`: The function to apply if the condition is not met.","ref":"Funx.Foldable.html#fold_l/3-parameters"},{"type":"function","title":"Examples - Funx.Foldable.fold_l/3","doc":"iex> Funx.Foldable.fold_l(Funx.Monad.Maybe.just(5), fn x -> x + 1 end, fn -> 0 end)\n    6\n\n    iex> Funx.Foldable.fold_l(Funx.Monad.Maybe.nothing(), fn _ -> 1 end, fn -> 0 end)\n    0","ref":"Funx.Foldable.html#fold_l/3-examples"},{"type":"function","title":"Funx.Foldable.fold_r/3","doc":"Folds the structure from the right, applying `func_a` if a condition is met, otherwise applying `func_b`.\n\nThis function collapses a structure by recursively applying the provided functions from the rightmost element to the leftmost.","ref":"Funx.Foldable.html#fold_r/3"},{"type":"function","title":"Parameters: - Funx.Foldable.fold_r/3","doc":"- `structure`: The structure to fold.\n- `func_a`: The function to apply in case of a matching condition.\n- `func_b`: The function to apply if the condition is not met.","ref":"Funx.Foldable.html#fold_r/3-parameters"},{"type":"function","title":"Examples - Funx.Foldable.fold_r/3","doc":"iex> Funx.Foldable.fold_r(Funx.Monad.Maybe.just(5), fn x -> x + 1 end, fn -> 0 end)\n    6\n\n    iex> Funx.Foldable.fold_r(Funx.Monad.Maybe.nothing(), fn _ -> 1 end, fn -> 0 end)\n    0","ref":"Funx.Foldable.html#fold_r/3-examples"},{"type":"type","title":"Funx.Foldable.t/0","doc":"All the types that implement this protocol.","ref":"Funx.Foldable.html#t:t/0"},{"type":"module","title":"Funx.List","doc":"The `Funx.List` module provides utility functions for working with lists while respecting `Eq` and `Ord` instances. This allows for set-like operations, uniqueness constraints, and sorted collections that align with functional programming principles.","ref":"Funx.List.html"},{"type":"module","title":"Features - Funx.List","doc":"- **Equality-based Operations**: Use `Eq` instances to compare elements for uniqueness, intersection, and difference.\n- **Ordering Functions**: Leverage `Ord` instances to sort and enforce uniqueness in sorted collections.\n- **Set Operations**: Perform union, intersection, difference, and symmetric difference while preserving custom equality logic.\n- **Subset & Superset Checks**: Verify relationships between lists in terms of inclusion.\n- **Functional Constructs**: Implements `Monad` and `Foldable` protocols for lists, supporting mapping, binding, and folding.","ref":"Funx.List.html#module-features"},{"type":"module","title":"Usage Overview - Funx.List","doc":"1. **Deduplicate**: Use `uniq/1` to remove duplicates based on `Eq`.\n2. **Combine**: Use `union/2` to merge lists without duplicates.\n3. **Filter**: Use `intersection/2` or `difference/2` for set operations.\n4. **Sort**: Use `sort/2` or `strict_sort/2` with `Ord` instances.\n5. **Check Membership**: Use `subset?/2` or `superset?/2` to verify inclusion relationships.","ref":"Funx.List.html#module-usage-overview"},{"type":"module","title":"Equality-Based Operations - Funx.List","doc":"- `uniq/1`: Removes duplicates using `Eq`.\n- `union/2`: Merges lists while preserving uniqueness.\n- `intersection/2`: Returns elements common to both lists.\n- `difference/2`: Returns elements from the first list not in the second.\n- `symmetric_difference/2`: Returns elements unique to each list.","ref":"Funx.List.html#module-equality-based-operations"},{"type":"module","title":"Ordering Functions - Funx.List","doc":"- `sort/2`: Sorts a list using `Ord`.\n- `strict_sort/2`: Sorts while ensuring uniqueness.","ref":"Funx.List.html#module-ordering-functions"},{"type":"module","title":"Set Operations - Funx.List","doc":"- `subset?/2`: Checks if one list is a subset of another.\n- `superset?/2`: Checks if one list is a superset of another.","ref":"Funx.List.html#module-set-operations"},{"type":"module","title":"Monad Implementation - Funx.List","doc":"- `map/2`: Transforms list elements.\n- `bind/2`: Applies a function returning lists and flattens the result.\n- `ap/2`: Applies functions in a list to elements in another list.","ref":"Funx.List.html#module-monad-implementation"},{"type":"module","title":"Foldable Implementation - Funx.List","doc":"- `fold_l/3`: Performs left-associative folding.\n- `fold_r/3`: Performs right-associative folding.","ref":"Funx.List.html#module-foldable-implementation"},{"type":"function","title":"Funx.List.concat/1","doc":"Concatenates a list of lists from left to right.\n\nThis uses the `ListConcat` monoid, preserving the original order of elements.","ref":"Funx.List.html#concat/1"},{"type":"function","title":"Examples - Funx.List.concat/1","doc":"iex> Funx.List.concat([[1], [2, 3], [4]])\n    [1, 2, 3, 4]","ref":"Funx.List.html#concat/1-examples"},{"type":"function","title":"Funx.List.difference/3","doc":"Returns the difference of two lists.","ref":"Funx.List.html#difference/3"},{"type":"function","title":"Examples - Funx.List.difference/3","doc":"iex> Funx.List.difference([1, 2, 3, 4], [3, 4, 5])\n    [1, 2]","ref":"Funx.List.html#difference/3-examples"},{"type":"function","title":"Funx.List.intersection/3","doc":"Returns the intersection of two lists.","ref":"Funx.List.html#intersection/3"},{"type":"function","title":"Examples - Funx.List.intersection/3","doc":"iex> Funx.List.intersection([1, 2, 3, 4], [3, 4, 5])\n    [3, 4]","ref":"Funx.List.html#intersection/3-examples"},{"type":"function","title":"Funx.List.sort/2","doc":"Sorts a list using the given ordering module.","ref":"Funx.List.html#sort/2"},{"type":"function","title":"Examples - Funx.List.sort/2","doc":"iex> Funx.List.sort([3, 1, 4, 1, 5])\n    [1, 1, 3, 4, 5]","ref":"Funx.List.html#sort/2-examples"},{"type":"function","title":"Funx.List.strict_sort/2","doc":"Sorts a list while ensuring uniqueness.","ref":"Funx.List.html#strict_sort/2"},{"type":"function","title":"Examples - Funx.List.strict_sort/2","doc":"iex> Funx.List.strict_sort([3, 1, 4, 1, 5])\n    [1, 3, 4, 5]","ref":"Funx.List.html#strict_sort/2-examples"},{"type":"function","title":"Funx.List.subset?/3","doc":"Checks if the first list is a subset of the second.","ref":"Funx.List.html#subset?/3"},{"type":"function","title":"Examples - Funx.List.subset?/3","doc":"iex> Funx.List.subset?([1, 2], [1, 2, 3, 4])\n    true\n\n    iex> Funx.List.subset?([1, 5], [1, 2, 3, 4])\n    false","ref":"Funx.List.html#subset?/3-examples"},{"type":"function","title":"Funx.List.superset?/3","doc":"Checks if the first list is a superset of the second.","ref":"Funx.List.html#superset?/3"},{"type":"function","title":"Examples - Funx.List.superset?/3","doc":"iex> Funx.List.superset?([1, 2, 3, 4], [1, 2])\n    true\n\n    iex> Funx.List.superset?([1, 2, 3, 4], [1, 5])\n    false","ref":"Funx.List.html#superset?/3-examples"},{"type":"function","title":"Funx.List.symmetric_difference/3","doc":"Returns the symmetric difference of two lists.","ref":"Funx.List.html#symmetric_difference/3"},{"type":"function","title":"Examples - Funx.List.symmetric_difference/3","doc":"iex> Funx.List.symmetric_difference([1, 2, 3], [3, 4, 5])\n    [1, 2, 4, 5]","ref":"Funx.List.html#symmetric_difference/3-examples"},{"type":"function","title":"Funx.List.union/3","doc":"Returns the union of two lists, removing duplicates.","ref":"Funx.List.html#union/3"},{"type":"function","title":"Examples - Funx.List.union/3","doc":"iex> Funx.List.union([1, 2, 3], [3, 4, 5])\n    [1, 2, 3, 4, 5]","ref":"Funx.List.html#union/3-examples"},{"type":"function","title":"Funx.List.uniq/2","doc":"Removes duplicate elements from a list based on the given equality module.","ref":"Funx.List.html#uniq/2"},{"type":"function","title":"Examples - Funx.List.uniq/2","doc":"iex> Funx.List.uniq([1, 2, 2, 3, 1, 4, 5])\n    [1, 2, 3, 4, 5]","ref":"Funx.List.html#uniq/2-examples"},{"type":"module","title":"Funx.Macros","doc":"Provides macros for automatically implementing `Funx.Eq` and `Funx.Ord` protocols\nfor a given struct based on a specified field.\n\nThese macros simplify the process of defining equality and ordering behaviors\nfor custom structs by leveraging an existing field's comparison operations.","ref":"Funx.Macros.html"},{"type":"macro","title":"Funx.Macros.eq_for/2","doc":"Generates an implementation of the `Funx.Eq` protocol for the given struct,\nusing the specified field as the basis for equality comparison.","ref":"Funx.Macros.html#eq_for/2"},{"type":"macro","title":"Examples - Funx.Macros.eq_for/2","doc":"defmodule Person do\n      defstruct [:name, :age]\n    end\n\n    require Funx.Macros\n    Funx.Macros.eq_for(Person, :age)\n\n    iex> Eq.eq?(%Person{age: 30}, %Person{age: 30})\n    true\n\n    iex> Eq.eq?(%Person{age: 25}, %Person{age: 30})\n    false","ref":"Funx.Macros.html#eq_for/2-examples"},{"type":"macro","title":"Funx.Macros.ord_for/2","doc":"Generates an implementation of the `Funx.Ord` protocol for the given struct,\nusing the specified field as the basis for ordering comparisons.","ref":"Funx.Macros.html#ord_for/2"},{"type":"macro","title":"Examples - Funx.Macros.ord_for/2","doc":"defmodule Person do\n      defstruct [:name, :age]\n    end\n\n    require Funx.Macros\n    Funx.Macros.ord_for(Person, :age)\n\n    iex> Ord.lt?(%Person{age: 25}, %Person{age: 30})\n    true\n\n    iex> Ord.gt?(%Person{age: 35}, %Person{age: 30})\n    true","ref":"Funx.Macros.html#ord_for/2-examples"},{"type":"module","title":"Funx.Math","doc":"Provides mathematical operations using Monoids.\n\nThis module uses the `Sum` and `Product` monoids to perform operations\nsuch as addition and multiplication over values or lists of values.","ref":"Funx.Math.html"},{"type":"function","title":"Funx.Math.deviation/1","doc":"Computes the deviations from the mean for a list of numbers.\n\nReturns `Nothing` if the list is empty.","ref":"Funx.Math.html#deviation/1"},{"type":"function","title":"Examples - Funx.Math.deviation/1","doc":"iex> Funx.Math.deviation([1, 2, 3, 4])\n    Funx.Monad.Maybe.pure([-1.5, -0.5, 0.5, 1.5])\n\n    iex> Funx.Math.deviation([5, 5, 5])\n    Funx.Monad.Maybe.pure([0.0, 0.0, 0.0])\n\n    iex> Funx.Math.deviation([])\n    Funx.Monad.Maybe.nothing()","ref":"Funx.Math.html#deviation/1-examples"},{"type":"function","title":"Funx.Math.max/1","doc":"Finds the maximum value in a list using the `Max` monoid.\n\nReturns `Float.min_finite()` if the list is empty.","ref":"Funx.Math.html#max/1"},{"type":"function","title":"Examples - Funx.Math.max/1","doc":"iex> Funx.Math.max([3, 7, 2])\n    7\n\n    iex> Funx.Math.max([])\n    Float.min_finite()","ref":"Funx.Math.html#max/1-examples"},{"type":"function","title":"Funx.Math.max/2","doc":"Returns the maximum of two numbers using the `Max` monoid.","ref":"Funx.Math.html#max/2"},{"type":"function","title":"Examples - Funx.Math.max/2","doc":"iex> Funx.Math.max(3, 7)\n    7\n\n    iex> Funx.Math.max(-1, -5)\n    -1","ref":"Funx.Math.html#max/2-examples"},{"type":"function","title":"Funx.Math.mean/1","doc":"Computes the arithmetic mean of a list of numbers.\n\nReturns `Nothing` if the list is empty.","ref":"Funx.Math.html#mean/1"},{"type":"function","title":"Examples - Funx.Math.mean/1","doc":"iex> Funx.Math.mean([1, 2, 3, 4])\n    Funx.Monad.Maybe.pure(2.5)\n\n    iex> Funx.Math.mean([])\n    Funx.Monad.Maybe.nothing()","ref":"Funx.Math.html#mean/1-examples"},{"type":"function","title":"Funx.Math.min/1","doc":"Finds the minimum value in a list using the `Min` monoid.\n\nReturns `Float.max_finite()` if the list is empty.","ref":"Funx.Math.html#min/1"},{"type":"function","title":"Examples - Funx.Math.min/1","doc":"iex> Funx.Math.min([3, 7, 2])\n    2\n\n    iex> Funx.Math.min([])\n    Float.max_finite()","ref":"Funx.Math.html#min/1-examples"},{"type":"function","title":"Funx.Math.min/2","doc":"Returns the minimum of two numbers using the `Min` monoid.","ref":"Funx.Math.html#min/2"},{"type":"function","title":"Examples - Funx.Math.min/2","doc":"iex> Funx.Math.min(3, 7)\n    3\n\n    iex> Funx.Math.min(-1, -5)\n    -5","ref":"Funx.Math.html#min/2-examples"},{"type":"function","title":"Funx.Math.product/1","doc":"Multiplies a list of numbers using the `Product` monoid.","ref":"Funx.Math.html#product/1"},{"type":"function","title":"Examples - Funx.Math.product/1","doc":"iex> Funx.Math.product([2, 3, 4])\n    24\n\n    iex> Funx.Math.product([])\n    1","ref":"Funx.Math.html#product/1-examples"},{"type":"function","title":"Funx.Math.product/2","doc":"Multiplies two numbers using the `Product` monoid.","ref":"Funx.Math.html#product/2"},{"type":"function","title":"Examples - Funx.Math.product/2","doc":"iex> Funx.Math.product(3, 4)\n    12","ref":"Funx.Math.html#product/2-examples"},{"type":"function","title":"Funx.Math.range/1","doc":"Computes the range (difference between max and min) of a list.\n\nReturns `nothing()` if the list is empty.","ref":"Funx.Math.html#range/1"},{"type":"function","title":"Examples - Funx.Math.range/1","doc":"iex> Funx.Math.range([3, 7, 2])\n    Funx.Monad.Maybe.pure(5)\n\n    iex> Funx.Math.range([])\n    Funx.Monad.Maybe.nothing()","ref":"Funx.Math.html#range/1-examples"},{"type":"function","title":"Funx.Math.square/1","doc":"Computes the square of a number.","ref":"Funx.Math.html#square/1"},{"type":"function","title":"Examples - Funx.Math.square/1","doc":"iex> Funx.Math.square(3)\n    9\n\n    iex> Funx.Math.square(-4)\n    16","ref":"Funx.Math.html#square/1-examples"},{"type":"function","title":"Funx.Math.std_dev/1","doc":"Computes the standard deviation of a list of numbers.\n\nReturns `Nothing` if the list is empty.","ref":"Funx.Math.html#std_dev/1"},{"type":"function","title":"Examples - Funx.Math.std_dev/1","doc":"iex> Funx.Math.std_dev([1, 2, 3, 4])\n    Funx.Monad.Maybe.pure(1.118033988749895)\n\n    iex> Funx.Math.std_dev([5, 5, 5])\n    Funx.Monad.Maybe.pure(0.0)\n\n    iex> Funx.Math.std_dev([])\n    Funx.Monad.Maybe.nothing()","ref":"Funx.Math.html#std_dev/1-examples"},{"type":"function","title":"Funx.Math.sum/1","doc":"Sums a list of numbers using the `Sum` monoid.","ref":"Funx.Math.html#sum/1"},{"type":"function","title":"Examples - Funx.Math.sum/1","doc":"iex> Funx.Math.sum([1, 2, 3])\n    6\n\n    iex> Funx.Math.sum([])\n    0","ref":"Funx.Math.html#sum/1-examples"},{"type":"function","title":"Funx.Math.sum/2","doc":"Sums two numbers using the `Sum` monoid.","ref":"Funx.Math.html#sum/2"},{"type":"function","title":"Examples - Funx.Math.sum/2","doc":"iex> Funx.Math.sum(1, 2)\n    3","ref":"Funx.Math.html#sum/2-examples"},{"type":"function","title":"Funx.Math.sum_of_squares/1","doc":"Computes the sum of squares of a list of numbers.\n\nReturns `0` if the list is empty.","ref":"Funx.Math.html#sum_of_squares/1"},{"type":"function","title":"Examples - Funx.Math.sum_of_squares/1","doc":"iex> Funx.Math.sum_of_squares([1, 2, 3])\n    14\n\n    iex> Funx.Math.sum_of_squares([-2, 5])\n    29\n\n    iex> Funx.Math.sum_of_squares([])\n    0","ref":"Funx.Math.html#sum_of_squares/1-examples"},{"type":"function","title":"Funx.Math.variance/1","doc":"Computes the variance of a list of numbers.\n\nReturns `Nothing` if the list is empty.","ref":"Funx.Math.html#variance/1"},{"type":"function","title":"Examples - Funx.Math.variance/1","doc":"iex> Funx.Math.variance([1, 2, 3, 4])\n    Funx.Monad.Maybe.pure(1.25)\n\n    iex> Funx.Math.variance([5, 5, 5])\n    Funx.Monad.Maybe.pure(0.0)\n\n    iex> Funx.Math.variance([])\n    Funx.Monad.Maybe.nothing()","ref":"Funx.Math.html#variance/1-examples"},{"type":"protocol","title":"Funx.Monad","doc":"The `Funx.Monad` protocol defines the core monadic operations: `ap/2`, `bind/2`, and `map/2`.\n\nA monad is an abstraction that represents computations as a series of steps.\nThis protocol is designed to be implemented by types that wrap a value and allow chaining of operations while preserving the wrapped context.","ref":"Funx.Monad.html"},{"type":"protocol","title":"Functions - Funx.Monad","doc":"- `map/2`: Applies a function to the value within the monad.\n- `bind/2`: Chains operations by passing the unwrapped value into a function that returns another monad.\n- `ap/2`: Applies a monadic function to another monadic value.","ref":"Funx.Monad.html#module-functions"},{"type":"function","title":"Funx.Monad.ap/2","doc":"Applies a monadic function to another monadic value.\n\nThe function `func` is expected to be wrapped in a monadic context and is applied to the value `m` within its own monadic context.\nThe result is wrapped in the same context as the original monad.","ref":"Funx.Monad.html#ap/2"},{"type":"function","title":"Examples - Funx.Monad.ap/2","doc":"iex> Funx.Monad.ap(Funx.Monad.Maybe.just(fn x -> x * 2 end), Funx.Monad.Maybe.just(3))\n    %Funx.Monad.Maybe.Just{value: 6}\n\nIn the case of `Nothing`:\n\n    iex> Funx.Monad.ap(Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.just(3))\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Monad.html#ap/2-examples"},{"type":"function","title":"Funx.Monad.bind/2","doc":"Chains a monadic operation.\n\nThe `bind/2` function takes a monad `m` and a function `func`. The function `func` is applied to the unwrapped value of `m`,\nand must return another monad. The result is the new monad produced by `func`.\n\nThis is the core operation that allows chaining of computations, with the value being passed from one function to the next in a sequence.","ref":"Funx.Monad.html#bind/2"},{"type":"function","title":"Examples - Funx.Monad.bind/2","doc":"iex> Funx.Monad.bind(Funx.Monad.Maybe.just(5), fn x -> Funx.Monad.Maybe.just(x * 2) end)\n    %Funx.Monad.Maybe.Just{value: 10}\n\nIn the case of `Nothing`:\n\n    iex> Funx.Monad.bind(Funx.Monad.Maybe.nothing(), fn _ -> Funx.Monad.Maybe.just(5) end)\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Monad.html#bind/2-examples"},{"type":"function","title":"Funx.Monad.map/2","doc":"Maps a function over the value inside the monad.\n\nThe `map/2` function takes a monad `m` and a function `func`, applies the function to the value inside `m`, and returns a new monad\ncontaining the result. The original monadic context is preserved.","ref":"Funx.Monad.html#map/2"},{"type":"function","title":"Examples - Funx.Monad.map/2","doc":"iex> Funx.Monad.map(Funx.Monad.Maybe.just(2), fn x -> x + 3 end)\n    %Funx.Monad.Maybe.Just{value: 5}\n\nIn the case of `Nothing`:\n\n    iex> Funx.Monad.map(Funx.Monad.Maybe.nothing(), fn x -> x + 3 end)\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Monad.html#map/2-examples"},{"type":"type","title":"Funx.Monad.t/0","doc":"","ref":"Funx.Monad.html#t:t/0"},{"type":"module","title":"Funx.Monad.Effect","doc":"The `Funx.Monad.Effect` module defines the `Effect` monad, which represents asynchronous computations\nthat may succeed (`Right`) or fail (`Left`). Execution is deferred until explicitly run, making\n`Effect` useful for structuring lazy, asynchronous workflows.\n\nThis module integrates tracing and telemetry, making it suitable for observability in concurrent\nElixir systems. All effects carry a `Effect.Context`, which links operations and records spans\nwhen `run/2` is called.","ref":"Funx.Monad.Effect.html"},{"type":"module","title":"Constructors - Funx.Monad.Effect","doc":"* `right/1` – Wraps a value in a successful `Right` effect.\n  * `left/1` – Wraps a value in a failing `Left` effect.\n  * `pure/1` – Alias for `right/1`.","ref":"Funx.Monad.Effect.html#module-constructors"},{"type":"module","title":"Execution - Funx.Monad.Effect","doc":"* `run/2` – Executes the deferred effect and returns an `Either` result (`Right` or `Left`).\n\nYou may pass `:task_supervisor` in the `opts` to run the effect under a specific `Task.Supervisor`. This supervises the top-level task, any internal tasks spawned within the effect function are not supervised.","ref":"Funx.Monad.Effect.html#module-execution"},{"type":"module","title":"Sequencing - Funx.Monad.Effect","doc":"* `sequence/1` – Runs a list of effects, stopping at the first `Left`.\n  * `traverse/2` – Applies a function returning an `Effect` to each element of a list, sequencing results.\n  * `sequence_a/2` – Runs a list of effects, collecting all `Left` errors instead of short-circuiting.\n  * `traverse_a/3` – Like `traverse/2`, but accumulates errors across the list.","ref":"Funx.Monad.Effect.html#module-sequencing"},{"type":"module","title":"Validation - Funx.Monad.Effect","doc":"* `validate/2` – Validates a value using one or more effectful validators.","ref":"Funx.Monad.Effect.html#module-validation"},{"type":"module","title":"Error Handling - Funx.Monad.Effect","doc":"* `map_left/2` – Transforms a `Left` using a function, leaving `Right` values unchanged.\n  * `flip_either/1` –  Inverts the success and failure branches of an `Effect`.","ref":"Funx.Monad.Effect.html#module-error-handling"},{"type":"module","title":"Lifting - Funx.Monad.Effect","doc":"* `lift_func/2` – Lifts a thunk that returns any value into an `Effect`, wrapping it in `Right`. If the thunk raises, the error is captured as a `Left(EffectError)`.\n  * `lift_either/2` – Lifts a thunk that returns an `Either` into an `Effect`. Evaluation is deferred until the effect is run. Errors are also captured and wrapped in `Left(EffectError)`.\n  * `lift_maybe/3` – Lifts a `Maybe` into an `Effect`, using a fallback error if the value is `Nothing`.\n  * `lift_predicate/3` – Lifts a predicate check into an `Effect`. Returns `Right(value)` if the predicate passes; otherwise returns `Left(fallback)`.","ref":"Funx.Monad.Effect.html#module-lifting"},{"type":"module","title":"Reader Operations - Funx.Monad.Effect","doc":"* `ask/0` – Returns the environment passed to `run/2` as a `Right`.\n  * `asks/1` – Applies a function to the environment passed to `run/2`, wrapping the result in a `Right`.\n  * `fail/0` – Returns the environment passed to `run/2` as a `Left`.\n  * `fails/1` – Applies a function to the environment passed to `run/2`, wrapping the result in a `Left`.","ref":"Funx.Monad.Effect.html#module-reader-operations"},{"type":"module","title":"Elixir Interop - Funx.Monad.Effect","doc":"* `from_result/2` – Converts a `{:ok, _}` or `{:error, _}` tuple into an `Effect`.\n  * `to_result/1` – Converts an `Effect` to `{:ok, _}` or `{:error, _}`.\n  * `from_try/2` – Wraps a function that may raise, returning Right on success, or Left if an exception is raised.\n  * `to_try!/1` – Extracts the value from a `Right`, or raises an exception if `Left`.","ref":"Funx.Monad.Effect.html#module-elixir-interop"},{"type":"module","title":"Protocols - Funx.Monad.Effect","doc":"The Left and Right structs implement the following protocols:\n\n   * Funx.Monad – Provides map/2, ap/2, and bind/2 for compositional workflows.\n\n  Although protocol implementations are defined on Left and Right individually, the behavior\n  is unified under the Effect abstraction.\n\n  This module enables structured concurrency, error handling, and observability in\n  asynchronous workflows.","ref":"Funx.Monad.Effect.html#module-protocols"},{"type":"module","title":"Telemetry - Funx.Monad.Effect","doc":"The `run/2` function emits telemetry using `:telemetry.span/3`.","ref":"Funx.Monad.Effect.html#module-telemetry"},{"type":"module","title":"Events - Funx.Monad.Effect","doc":"* `[:funx, :effect, :run, :start]`\n  * `[:funx, :effect, :run, :stop]`","ref":"Funx.Monad.Effect.html#module-events"},{"type":"module","title":"Measurements - Funx.Monad.Effect","doc":"* `:monotonic_time` – included in both `:start` and `:stop` events.\n  * `:system_time` – included only in the `:start` event.\n  * `:duration` – included only in the `:stop` event.","ref":"Funx.Monad.Effect.html#module-measurements"},{"type":"module","title":"Metadata - Funx.Monad.Effect","doc":"* `:timeout` – the timeout in milliseconds passed to `run/2`.\n  * `:result` – a summarized version of the result using `Funx.Summarizable`.\n  * `:effect_type` – `:right` or `:left`, depending on the effect being run.\n  * `:status` – `:ok` if the result is a `Right`, or `:error` if it's a `Left`.\n  * `:trace_id` – optional value used to correlate traces across boundaries.\n  * `:span_name` – optional name for the span (defaults to `\"funx.effect.run\"`).\n  * `:telemetry_span_context` – reference to correlate `:start` and `:stop` events.","ref":"Funx.Monad.Effect.html#module-metadata"},{"type":"module","title":"Example - Funx.Monad.Effect","doc":":telemetry.attach(\n      \"effect-run-handler\",\n      [:funx, :effect, :run, :stop],\n      fn event, measurements, metadata, _config ->\n        IO.inspect({event, measurements, metadata}, label: \"Effect telemetry\")\n      end,\n      nil\n    )","ref":"Funx.Monad.Effect.html#module-example"},{"type":"function","title":"Funx.Monad.Effect.ask/0","doc":"Returns a `Funx.Monad.Effect.Right` that yields the environment passed to `Funx.Monad.Effect.run/2`.\n\nThis is the Reader-style `ask`, used to access the full environment inside an effectful computation.","ref":"Funx.Monad.Effect.html#ask/0"},{"type":"function","title":"Example - Funx.Monad.Effect.ask/0","doc":"iex> Funx.Monad.Effect.ask()\n    ...> |> Funx.Monad.map(& &1[:region])\n    ...> |> Funx.Monad.Effect.run(%{region: \"us-west\"})\n    %Funx.Monad.Either.Right{right: \"us-west\"}","ref":"Funx.Monad.Effect.html#ask/0-example"},{"type":"function","title":"Funx.Monad.Effect.asks/1","doc":"Returns a `Funx.Monad.Effect.Right` that applies the given function to the environment passed to `Funx.Monad.Effect.run/2`.\n\nThis allows extracting a value from the environment and using it in an effectful computation,\nfollowing the Reader pattern.","ref":"Funx.Monad.Effect.html#asks/1"},{"type":"function","title":"Example - Funx.Monad.Effect.asks/1","doc":"iex> Funx.Monad.Effect.asks(fn env -> env[:user] end)\n    ...> |> Funx.Monad.bind(fn user -> Funx.Monad.Effect.right(user) end)\n    ...> |> Funx.Monad.Effect.run(%{user: \"alice\"})\n    %Funx.Monad.Either.Right{right: \"alice\"}","ref":"Funx.Monad.Effect.html#asks/1-example"},{"type":"function","title":"Funx.Monad.Effect.await/2","doc":"","ref":"Funx.Monad.Effect.html#await/2"},{"type":"function","title":"Funx.Monad.Effect.fail/0","doc":"Returns a `Funx.Monad.Effect.Left` that fails with the entire environment passed to `Funx.Monad.Effect.run/2`.\n\nThis is the Reader-style equivalent of `ask/0`, but marks the environment as a failure.\nUseful when the presence of certain runtime data should short-circuit execution.","ref":"Funx.Monad.Effect.html#fail/0"},{"type":"function","title":"Example - Funx.Monad.Effect.fail/0","doc":"iex> Funx.Monad.Effect.fail()\n    ...> |> Funx.Monad.Effect.run(%{error: :invalid_token})\n    %Funx.Monad.Either.Left{left: %{error: :invalid_token}}","ref":"Funx.Monad.Effect.html#fail/0-example"},{"type":"function","title":"Funx.Monad.Effect.fails/1","doc":"Returns a `Funx.Monad.Effect.Left` that applies the given function to the environment passed to `Funx.Monad.Effect.run/2`.\n\nThis is the failure-side equivalent of `asks/1`, used to produce an error effect based on runtime context.","ref":"Funx.Monad.Effect.html#fails/1"},{"type":"function","title":"Example - Funx.Monad.Effect.fails/1","doc":"iex> Funx.Monad.Effect.fails(fn env -> {:missing_key, env} end)\n    ...> |> Funx.Monad.Effect.run(%{input: nil})\n    %Funx.Monad.Either.Left{left: {:missing_key, %{input: nil}}}","ref":"Funx.Monad.Effect.html#fails/1-example"},{"type":"function","title":"Funx.Monad.Effect.flip_either/1","doc":"Inverts the success and failure branches of an `Effect`.\n\nFor a `Right`, this reverses the result: a successful value becomes a failure, and\na failure becomes a success. For a `Left`, only failure is expected; if the `Left`\nproduces a success, it is ignored.\n\nThis is useful when you want to reverse the semantics of a computation—treating\nan expected error as success, or vice versa.","ref":"Funx.Monad.Effect.html#flip_either/1"},{"type":"function","title":"Examples - Funx.Monad.Effect.flip_either/1","doc":"iex> effect = Funx.Monad.Effect.pure(42)\n    iex> flipped = Funx.Monad.Effect.flip_either(effect)\n    iex> Funx.Monad.Effect.run(flipped)\n    %Funx.Monad.Either.Left{left: 42}\n    iex> effect = Funx.Monad.Effect.left(\"fail\")\n    iex> flipped = Funx.Monad.Effect.flip_either(effect)\n    iex> Funx.Monad.Effect.run(flipped)\n    %Funx.Monad.Either.Right{right: \"fail\"}","ref":"Funx.Monad.Effect.html#flip_either/1-examples"},{"type":"function","title":"Funx.Monad.Effect.from_result/2","doc":"Converts an Elixir `{:ok, value}` or `{:error, reason}` tuple into an `Effect`.\n\nAccepts an optional context context which includes telemetry tracking.","ref":"Funx.Monad.Effect.html#from_result/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.from_result/2","doc":"iex> result = Funx.Monad.Effect.from_result({:ok, 42})\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}\n\n    iex> result = Funx.Monad.Effect.from_result({:error, \"error\"})\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: \"error\"}","ref":"Funx.Monad.Effect.html#from_result/2-examples"},{"type":"function","title":"Funx.Monad.Effect.from_try/2","doc":"Lifts a potentially exception-raising function into a Kleisli function for the `Effect` monad.\n\nThis returns a function of type (`input -> Effect`) that applies the given function to a value.\nIf the function raises, the error is captured and returned in a `Left`. You can optionally\nprovide a context (or opts) for tracing and telemetry.","ref":"Funx.Monad.Effect.html#from_try/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.from_try/2","doc":"iex> safe_div = Funx.Monad.Effect.from_try(fn x -> 10 / x end)\n    iex> effect = Funx.Monad.Effect.pure(2) |> Funx.Monad.bind(safe_div)\n    iex> Funx.Monad.Effect.run(effect)\n    %Funx.Monad.Either.Right{right: 5.0}\n    iex> bad_div = Funx.Monad.Effect.pure(0) |> Funx.Monad.bind(safe_div)\n    iex> Funx.Monad.Effect.run(bad_div)\n    %Funx.Monad.Either.Left{left: %ArithmeticError{}}","ref":"Funx.Monad.Effect.html#from_try/2-examples"},{"type":"function","title":"Funx.Monad.Effect.left/2","doc":"Wraps a value in the `Left` variant of the `Effect` monad, representing a failed asynchronous computation.\n\nAccepts either a keyword list of context options or a `Effect.Context` struct.","ref":"Funx.Monad.Effect.html#left/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.left/2","doc":"iex> result = Funx.Monad.Effect.left(\"error\")\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: \"error\"}\n\n    iex> context = Funx.Monad.Effect.Context.new(trace_id: \"err-id\", span_name: \"failure\")\n    iex> result = Funx.Monad.Effect.left(\"error\", context)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: \"error\"}","ref":"Funx.Monad.Effect.html#left/2-examples"},{"type":"function","title":"Funx.Monad.Effect.lift_either/2","doc":"Lifts a thunk that returns an `Either` into the `Effect` monad.\n\nInstead of passing an `Either` value directly, you provide a zero-arity function (`thunk`) that returns one.\nThis defers execution until the effect is run, allowing integration with tracing and composable pipelines.\n\nYou may also pass a context or options (`opts`) to configure telemetry or span metadata.\n\nIf the thunk raises an exception, it is caught and returned as a `Left` containing an `EffectError` tagged with `:lift`.","ref":"Funx.Monad.Effect.html#lift_either/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.lift_either/2","doc":"iex> result = Funx.Monad.Effect.lift_either(fn -> %Funx.Monad.Either.Right{right: 42} end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}\n\n    iex> result = Funx.Monad.Effect.lift_either(fn -> %Funx.Monad.Either.Left{left: \"error\"} end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: \"error\"}","ref":"Funx.Monad.Effect.html#lift_either/2-examples"},{"type":"function","title":"Funx.Monad.Effect.lift_func/2","doc":"Lifts a thunk into the `Effect` monad, wrapping its result in a `Right`.\n\nThis function defers execution of the given zero-arity function (`thunk`) until the effect is run.\nThe result is automatically wrapped as `Either.Right`.\n\nYou may also pass a context or options (`opts`) to configure telemetry or span metadata.\n\nIf the thunk raises an exception, it is caught and returned as a `Left` containing an `EffectError` tagged with `:lift`.","ref":"Funx.Monad.Effect.html#lift_func/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.lift_func/2","doc":"iex> result = Funx.Monad.Effect.lift_func(fn -> 42 end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}\n\n    iex> result = Funx.Monad.Effect.lift_func(fn -> raise \"boom\" end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{\n      left: %Funx.Errors.EffectError{stage: :lift_func, reason: %RuntimeError{message: \"boom\"}}\n    }","ref":"Funx.Monad.Effect.html#lift_func/2-examples"},{"type":"function","title":"Funx.Monad.Effect.lift_maybe/3","doc":"Converts a `Maybe` value into the `Effect` monad.\nIf the `Maybe` is `Just`, the value is wrapped in `Right`.\nIf it is `Nothing`, the result of `on_none` is wrapped in `Left`.\n\nYou can optionally provide context metadata via `opts`.","ref":"Funx.Monad.Effect.html#lift_maybe/3"},{"type":"function","title":"Examples - Funx.Monad.Effect.lift_maybe/3","doc":"iex> maybe = Funx.Monad.Maybe.just(42)\n    iex> result = Funx.Monad.Effect.lift_maybe(maybe, fn -> \"No value\" end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}\n\n    iex> maybe = Funx.Monad.Maybe.nothing()\n    iex> result = Funx.Monad.Effect.lift_maybe(maybe, fn -> \"No value\" end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: \"No value\"}","ref":"Funx.Monad.Effect.html#lift_maybe/3-examples"},{"type":"function","title":"Funx.Monad.Effect.lift_predicate/4","doc":"Lifts a value into the `Effect` monad based on a predicate.\nIf the predicate returns true, the value is wrapped in `Right`.\nOtherwise, the result of calling `on_false` with the value is wrapped in `Left`.\n\nOptional context metadata (e.g. `:span_name`, `:trace_id`) can be passed via `opts`.","ref":"Funx.Monad.Effect.html#lift_predicate/4"},{"type":"function","title":"Examples - Funx.Monad.Effect.lift_predicate/4","doc":"iex> result = Funx.Monad.Effect.lift_predicate(10, &(&1 > 5), fn x -> \"#{x} is too small\" end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 10}\n\n    iex> result = Funx.Monad.Effect.lift_predicate(3, &(&1 > 5), fn x -> \"#{x} is too small\" end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: \"3 is too small\"}","ref":"Funx.Monad.Effect.html#lift_predicate/4-examples"},{"type":"function","title":"Funx.Monad.Effect.map_left/2","doc":"Transforms the `Left` branch of an `Effect`.\n\nIf the `Effect` resolves to a `Left`, the provided function is applied to the error.\nIf the `Effect` resolves to a `Right`, the value is returned unchanged.\n\nThis function is useful when you want to rewrite or wrap errors without affecting successful computations.","ref":"Funx.Monad.Effect.html#map_left/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.map_left/2","doc":"iex> effect = Funx.Monad.Effect.left(\"error\")\n    iex> transformed = Funx.Monad.Effect.map_left(effect, fn e -> \"wrapped: \" <> e end)\n    iex> Funx.Monad.Effect.run(transformed)\n    %Funx.Monad.Either.Left{left: \"wrapped: error\"}\n\n    iex> effect = Funx.Monad.Effect.pure(42)\n    iex> transformed = Funx.Monad.Effect.map_left(effect, fn _ -> \"should not be called\" end)\n    iex> Funx.Monad.Effect.run(transformed)\n    %Funx.Monad.Either.Right{right: 42}","ref":"Funx.Monad.Effect.html#map_left/2-examples"},{"type":"function","title":"Funx.Monad.Effect.pure/2","doc":"Alias for `right/2`.\n\nWraps a value in the `Right` variant of the `Effect` monad, representing a successful asynchronous computation.\n\nAccepts either a keyword list of context options or a `Effect.Context` struct.","ref":"Funx.Monad.Effect.html#pure/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.pure/2","doc":"iex> result = Funx.Monad.Effect.pure(42)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}\n\n    iex> context = Funx.Monad.Effect.Context.new(trace_id: \"custom-id\", span_name: \"pure example\")\n    iex> result = Funx.Monad.Effect.pure(42, context)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}","ref":"Funx.Monad.Effect.html#pure/2-examples"},{"type":"function","title":"Funx.Monad.Effect.right/2","doc":"Wraps a value in the `Right` variant of the `Effect` monad, representing a successful asynchronous computation.\n\nThis is an alias for `pure/2`. You may optionally provide execution context, either as a keyword list or\na `%Funx.Monad.Effect.Context{}` struct. The context is attached to the effect and propagated during execution.","ref":"Funx.Monad.Effect.html#right/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.right/2","doc":"iex> result = Funx.Monad.Effect.right(42)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}\n\n    iex> context = Funx.Monad.Effect.Context.new(trace_id: \"custom-id\", span_name: \"from right\")\n    iex> result = Funx.Monad.Effect.right(42, context)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}","ref":"Funx.Monad.Effect.html#right/2-examples"},{"type":"function","title":"Funx.Monad.Effect.run/1","doc":"Runs the `Effect` and returns the result, awaiting the task if necessary.\n\nYou may provide optional telemetry metadata using `opts`, such as `:span_name`\nto promote the current context with a new label.","ref":"Funx.Monad.Effect.html#run/1"},{"type":"function","title":"Options - Funx.Monad.Effect.run/1","doc":"* `:span_name` – (optional) promotes the trace to a new span with the given name.","ref":"Funx.Monad.Effect.html#run/1-options"},{"type":"function","title":"Examples - Funx.Monad.Effect.run/1","doc":"iex> result = Funx.Monad.Effect.right(42)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}\n\n    iex> result = Funx.Monad.Effect.right(42, span_name: \"initial\")\n    iex> Funx.Monad.Effect.run(result, span_name: \"promoted\")\n    %Funx.Monad.Either.Right{right: 42}","ref":"Funx.Monad.Effect.html#run/1-examples"},{"type":"function","title":"Funx.Monad.Effect.run/2","doc":"","ref":"Funx.Monad.Effect.html#run/2"},{"type":"function","title":"Funx.Monad.Effect.run/3","doc":"","ref":"Funx.Monad.Effect.html#run/3"},{"type":"function","title":"Funx.Monad.Effect.sequence/2","doc":"Sequences a list of `Effect` computations, running each in order.\n\nIf all effects resolve to `Right`, the result is a `Right` containing a list of values.\nIf any effect resolves to `Left`, the sequencing stops early and that `Left` is returned.\n\nEach effect is executed with its own context context, and telemetry spans are emitted for observability.","ref":"Funx.Monad.Effect.html#sequence/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.sequence/2","doc":"iex> effects = [Funx.Monad.Effect.right(1), Funx.Monad.Effect.right(2)]\n    iex> result = Funx.Monad.Effect.sequence(effects)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: [1, 2]}\n\n    iex> effects = [Funx.Monad.Effect.right(1), Funx.Monad.Effect.left(\"error\")]\n    iex> result = Funx.Monad.Effect.sequence(effects)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: \"error\"}","ref":"Funx.Monad.Effect.html#sequence/2-examples"},{"type":"function","title":"Funx.Monad.Effect.sequence_a/2","doc":"Sequences a list of `Effect` computations, collecting all `Right` results\nor accumulating all `Left` errors if present.\n\nUnlike `sequence/1`, which stops at the first `Left`, this version continues processing\nall effects, returning a list of errors if any failures occur.\n\nEach effect emits its own telemetry span, and error contexts are preserved through tracing.","ref":"Funx.Monad.Effect.html#sequence_a/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.sequence_a/2","doc":"iex> effects = [\n    ...>   Funx.Monad.Effect.right(1),\n    ...>   Funx.Monad.Effect.left(\"Error 1\"),\n    ...>   Funx.Monad.Effect.left(\"Error 2\")\n    ...> ]\n    iex> result = Funx.Monad.Effect.sequence_a(effects)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: [\"Error 1\", \"Error 2\"]}","ref":"Funx.Monad.Effect.html#sequence_a/2-examples"},{"type":"function","title":"Funx.Monad.Effect.to_result/2","doc":"Converts an `Effect` into an Elixir `{:ok, _}` or `{:error, _}` tuple by running the effect.\n\nIf the effect completes successfully (`Right`), the result is wrapped in `{:ok, value}`.\nIf the effect fails (`Left`), the error is returned as `{:error, reason}`.\n\nThis function also emits telemetry via `run/2` and supports optional context metadata through keyword options.","ref":"Funx.Monad.Effect.html#to_result/2"},{"type":"function","title":"Options - Funx.Monad.Effect.to_result/2","doc":"* `:span_name` – sets a custom span name for tracing and telemetry.","ref":"Funx.Monad.Effect.html#to_result/2-options"},{"type":"function","title":"Examples - Funx.Monad.Effect.to_result/2","doc":"iex> effect = Funx.Monad.Effect.right(42, span_name: \"convert-ok\")\n    iex> Funx.Monad.Effect.to_result(effect, span_name: \"to_result\")\n    {:ok, 42}\n\n    iex> error = Funx.Monad.Effect.left(\"fail\", span_name: \"convert-error\")\n    iex> Funx.Monad.Effect.to_result(error, span_name: \"to_result\")\n    {:error, \"fail\"}\n\nTelemetry will include the promoted span name (`\"to_result -> convert-ok\"`) and context metadata.","ref":"Funx.Monad.Effect.html#to_result/2-examples"},{"type":"function","title":"Funx.Monad.Effect.to_try!/2","doc":"Executes an `Effect` and returns the result if it is a `Right`. If the result is a `Left`,\nthis function raises the contained error.\n\nThis is useful when you want to interoperate with code that expects regular exceptions,\nsuch as within test assertions or imperative pipelines.\n\nRuns the effect with full telemetry tracing.","ref":"Funx.Monad.Effect.html#to_try!/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.to_try!/2","doc":"iex> effect = Funx.Monad.Effect.right(42, span_name: \"return\")\n    iex> Funx.Monad.Effect.to_try!(effect)\n    42\n\n    iex> error = Funx.Monad.Effect.left(%RuntimeError{message: \"failure\"}, span_name: \"error\")\n    iex> Funx.Monad.Effect.to_try!(error)\n    ** (RuntimeError) failure\n\nTelemetry will emit a `:stop` event with `:status` set to `:ok` or `:error`, depending on the outcome.","ref":"Funx.Monad.Effect.html#to_try!/2-examples"},{"type":"function","title":"Funx.Monad.Effect.traverse/2","doc":"Traverses a list with a function that returns `Effect` computations,\nrunning each in sequence and collecting the `Right` results.\n\nIf all effects resolve to `Right`, returns a single `Effect` with a list of results.\nIf any effect resolves to `Left`, the traversal stops early and returns that `Left`.\n\nEach step preserves context context and emits telemetry spans, including nested spans when bound.","ref":"Funx.Monad.Effect.html#traverse/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.traverse/2","doc":"iex> is_positive = fn num ->\n    ...>   Funx.Monad.Effect.lift_predicate(num, fn x -> x > 0 end, fn x -> Integer.to_string(x) <> \" is not positive\" end)\n    ...> end\n    iex> result = Funx.Monad.Effect.traverse([1, 2, 3], fn num -> is_positive.(num) end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: [1, 2, 3]}\n    iex> result = Funx.Monad.Effect.traverse([1, -2, 3], fn num -> is_positive.(num) end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: \"-2 is not positive\"}","ref":"Funx.Monad.Effect.html#traverse/2-examples"},{"type":"function","title":"Funx.Monad.Effect.traverse/3","doc":"","ref":"Funx.Monad.Effect.html#traverse/3"},{"type":"function","title":"Funx.Monad.Effect.traverse_a/2","doc":"Traverses a list with a function that returns `Effect` values, combining results\ninto a single `Effect`. Unlike `traverse/2`, this version accumulates all errors\nrather than stopping at the first `Left`.\n\nEach successful computation contributes to the final list of results.\nIf any computations fail, all errors are collected and returned as a single `Left`.\n\nThis function also manages telemetry trace context across all nested effects,\nensuring that span relationships and trace IDs are preserved through the traversal.","ref":"Funx.Monad.Effect.html#traverse_a/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.traverse_a/2","doc":"iex> validate = fn n ->\n    ...>   Funx.Monad.Effect.lift_predicate(n, fn x -> x > 0 end, fn x -> Integer.to_string(x) <> \" is not positive\" end)\n    ...> end\n    iex> result = Funx.Monad.Effect.traverse_a([1, -2, 3], validate)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: [\"-2 is not positive\"]}\n    iex> result = Funx.Monad.Effect.traverse_a([1, 2, 3], validate)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: [1, 2, 3]}","ref":"Funx.Monad.Effect.html#traverse_a/2-examples"},{"type":"function","title":"Funx.Monad.Effect.traverse_a/3","doc":"","ref":"Funx.Monad.Effect.html#traverse_a/3"},{"type":"function","title":"Funx.Monad.Effect.validate/3","doc":"Validates a value using one or more validator functions, each returning an `Effect`.\n\nIf all validators succeed (`Right`), the original value is returned in a `Right`.\nIf any validator fails (`Left`), all errors are accumulated and returned as a single `Left`.\n\nThis function also manages telemetry trace context across all nested validations,\nensuring that span relationships and trace IDs are preserved throughout.\n\nSupports optional `opts` for span metadata (e.g. `:span_name`).","ref":"Funx.Monad.Effect.html#validate/3"},{"type":"function","title":"Examples - Funx.Monad.Effect.validate/3","doc":"iex> validate_positive = fn x ->\n    ...>   Funx.Monad.Effect.lift_predicate(x, fn n -> n > 0 end, fn n -> \"Value \" <> Integer.to_string(n) <> \" must be positive\" end)\n    ...> end\n    iex> validate_even = fn x ->\n    ...>   Funx.Monad.Effect.lift_predicate(x, fn n -> rem(n, 2) == 0 end, fn n -> \"Value \" <> Integer.to_string(n) <> \" must be even\" end)\n    ...> end\n    iex> validators = [validate_positive, validate_even]\n    iex> result = Funx.Monad.Effect.validate(4, validators)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 4}\n    iex> result = Funx.Monad.Effect.validate(3, validators)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: [\"Value 3 must be even\"]}\n    iex> result = Funx.Monad.Effect.validate(-3, validators)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: [\"Value -3 must be positive\", \"Value -3 must be even\"]}","ref":"Funx.Monad.Effect.html#validate/3-examples"},{"type":"type","title":"Funx.Monad.Effect.t/2","doc":"Represents a deferred computation in the `Effect` monad that may either succeed (`Right`) or fail (`Left`).\n\nThis type unifies `Effect.Right.t/1` and `Effect.Left.t/1` under a common interface, allowing code to\noperate over asynchronous effects regardless of success or failure outcome.\n\nEach variant carries a `context` for telemetry and a deferred `effect` function that takes an environment.","ref":"Funx.Monad.Effect.html#t:t/2"},{"type":"module","title":"Funx.Monad.Effect.Context","doc":"Represents the execution context attached to an effect.\n\nThis struct carries contextual information such as `trace_id`, `span_name`,\ntimeouts, and arbitrary metadata (`baggage` and `metadata`). It supports\ntelemetry integration, span linking, and timeout control, and is propagated\nautomatically across composed effects.\n\nDevelopers can set fields like `timeout`, `trace_id`, or `span_name` when\nconstructing `Left` and `Right` effects. The context is merged or promoted\nas needed when chaining effects to preserve trace continuity and execution scope.\n\nThis context is not injected at runtime via `run/2`—it is bound to the effect\nwhen created.","ref":"Funx.Monad.Effect.Context.html"},{"type":"function","title":"Funx.Monad.Effect.Context.default_span_name?/1","doc":"","ref":"Funx.Monad.Effect.Context.html#default_span_name?/1"},{"type":"function","title":"Funx.Monad.Effect.Context.default_span_name_if_empty/2","doc":"","ref":"Funx.Monad.Effect.Context.html#default_span_name_if_empty/2"},{"type":"function","title":"Funx.Monad.Effect.Context.empty_or_default_span_name?/1","doc":"","ref":"Funx.Monad.Effect.Context.html#empty_or_default_span_name?/1"},{"type":"function","title":"Funx.Monad.Effect.Context.generate_trace_id/0","doc":"Generates a random lowercase hexadecimal trace ID.\n\nThis function is used internally to ensure each trace is uniquely identifiable.","ref":"Funx.Monad.Effect.Context.html#generate_trace_id/0"},{"type":"function","title":"Examples - Funx.Monad.Effect.Context.generate_trace_id/0","doc":"iex> id = Funx.Monad.Effect.Context.generate_trace_id()\n    iex> String.length(id)\n    32\n    iex> id =~ ~r/^[a-f0-9]+$/\n    true","ref":"Funx.Monad.Effect.Context.html#generate_trace_id/0-examples"},{"type":"function","title":"Funx.Monad.Effect.Context.merge/2","doc":"Merges two `%Funx.Monad.Effect.Context{}` structs into one, preferring non-nil values from the first context.\n\nThis is used to preserve trace continuity and propagate context across composed effects.\n\n- Non-nil fields from the first context take precedence.\n- `baggage` and `metadata` maps are deeply merged.\n- This operation is idempotent and safe for reuse across nested effect chains.","ref":"Funx.Monad.Effect.Context.html#merge/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.Context.merge/2","doc":"iex> c1 = Funx.Monad.Effect.Context.new(trace_id: \"a\", baggage: %{user: 1})\n    iex> c2 = Funx.Monad.Effect.Context.new(trace_id: \"b\", baggage: %{region: \"us-west\"})\n    iex> Funx.Monad.Effect.Context.merge(c1, c2).baggage\n    %{user: 1, region: \"us-west\"}","ref":"Funx.Monad.Effect.Context.html#merge/2-examples"},{"type":"function","title":"Funx.Monad.Effect.Context.new/0","doc":"Creates a new `Funx.Monad.Effect.Context` struct for use with effectful computations.\n\nIf no `:trace_id` is provided, a unique one is generated automatically.\nYou may also set optional fields such as `:span_name`, `:timeout`, `:baggage`, and `:metadata`.\n\nThe returned context is intended to be passed into `Left` and `Right` effects,\nwhere it will be propagated and updated across chained computations.","ref":"Funx.Monad.Effect.Context.html#new/0"},{"type":"function","title":"Examples - Funx.Monad.Effect.Context.new/0","doc":"iex> ctx = Funx.Monad.Effect.Context.new(span_name: \"load-data\", timeout: 2000)\n    iex> ctx.span_name\n    \"load-data\"\n\n    iex> ctx = Funx.Monad.Effect.Context.new(trace_id: \"abc123\")\n    iex> ctx.trace_id\n    \"abc123\"","ref":"Funx.Monad.Effect.Context.html#new/0-examples"},{"type":"function","title":"Funx.Monad.Effect.Context.new/1","doc":"","ref":"Funx.Monad.Effect.Context.html#new/1"},{"type":"function","title":"Funx.Monad.Effect.Context.override/2","doc":"Returns a new `%Funx.Monad.Effect.Context{}` with fields overridden by values from the given keyword list.\n\n- Direct fields like `:trace_id`, `:parent_trace_id`, `:span_name`, and `:timeout` are replaced if present.\n- Nested maps `:baggage` and `:metadata` are deeply merged, with the keyword list taking precedence.\n\nThis is useful for refining or extending an existing context in a specific part of an effect chain.","ref":"Funx.Monad.Effect.Context.html#override/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.Context.override/2","doc":"iex> ctx = Funx.Monad.Effect.Context.new(trace_id: \"abc\", baggage: %{x: 1}, metadata: %{debug: false})\n    iex> updated = Funx.Monad.Effect.Context.override(ctx, span_name: \"child\", baggage: %{x: 2}, metadata: %{debug: true})\n    iex> updated.span_name\n    \"child\"\n    iex> updated.baggage\n    %{x: 2}\n    iex> updated.metadata\n    %{debug: true}","ref":"Funx.Monad.Effect.Context.html#override/2-examples"},{"type":"function","title":"Funx.Monad.Effect.Context.promote_trace/2","doc":"Promotes the current context into a child trace by generating a new `trace_id` and linking to the original.\n\n- The current `trace_id` is moved to `parent_trace_id`.\n- A new `trace_id` is generated for the child context.\n- The given `label` is prepended to the existing `span_name` as `\"label -> span\"`.\n\nThis is typically used to represent a nested span or sub-operation within a larger effect chain,\npreserving trace lineage across composed effects.","ref":"Funx.Monad.Effect.Context.html#promote_trace/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.Context.promote_trace/2","doc":"iex> parent = Funx.Monad.Effect.Context.new(trace_id: \"abc123\", span_name: \"load\")\n    iex> child = Funx.Monad.Effect.Context.promote_trace(parent, \"decode\")\n    iex> child.parent_trace_id\n    \"abc123\"\n    iex> child.trace_id != \"abc123\"\n    true\n    iex> child.span_name\n    \"decode -> load\"","ref":"Funx.Monad.Effect.Context.html#promote_trace/2-examples"},{"type":"function","title":"Funx.Monad.Effect.Context.span_name?/1","doc":"","ref":"Funx.Monad.Effect.Context.html#span_name?/1"},{"type":"type","title":"Funx.Monad.Effect.Context.opts_or_context/0","doc":"Represents input for constructing an `Effect.Context`.\n\nAccepts either a keyword list of options (`trace_id`, `span_name`, etc.) or an existing `Context` struct.\nUsed throughout the `Effect` system for flexible context propagation.","ref":"Funx.Monad.Effect.Context.html#t:opts_or_context/0"},{"type":"type","title":"Funx.Monad.Effect.Context.t/0","doc":"Represents the contextual metadata associated with an `Effect`.\n\nThe context carries telemetry and tracing information such as `trace_id`, `span_name`, and `timeout`,\nas well as arbitrary metadata and user-defined `baggage`. It is passed through all effectful computations\nand can be promoted to represent nested spans.","ref":"Funx.Monad.Effect.Context.html#t:t/0"},{"type":"module","title":"Funx.Monad.Effect.Left","doc":"Represents the `Left` variant of the `Effect` monad, used to model a failure or error in an asynchronous context.\n\nThis module implements the following protocols:\n  - `Funx.Monad`: Implements `bind/2`, `map/2`, and `ap/2` for monadic sequencing in a lazy, effectful context.\n  - `String.Chars`: Provides a string representation of the effect for debugging and inspection.\n\nA `Left` effect propagates its failure value without invoking further computations, preserving short-circuit behavior.","ref":"Funx.Monad.Effect.Left.html"},{"type":"module","title":"Reader Operations - Funx.Monad.Effect.Left","doc":"* `ask/1` – Returns the environment passed to `run/2` as a `Left`.\n  * `asks/2` – Applies a function to the environment passed to `run/2`, wrapping the result in a `Left`.","ref":"Funx.Monad.Effect.Left.html#module-reader-operations"},{"type":"function","title":"Funx.Monad.Effect.Left.ask/1","doc":"Returns a `Funx.Monad.Effect.Left` that yields the environment passed to `Funx.Monad.Effect.run/2`.\n\nThis is the Reader-style `ask`, used to construct a failure from the full injected environment.\nIt can be useful for debugging, instrumentation, or propagating request-scoped failure information.","ref":"Funx.Monad.Effect.Left.html#ask/1"},{"type":"function","title":"Example - Funx.Monad.Effect.Left.ask/1","doc":"iex> Funx.Monad.Effect.Left.ask()\n    ...> |> Funx.Monad.Effect.run(%{error: :unauthorized})\n    %Funx.Monad.Either.Left{left: %{error: :unauthorized}}","ref":"Funx.Monad.Effect.Left.html#ask/1-example"},{"type":"function","title":"Funx.Monad.Effect.Left.asks/2","doc":"Returns a `Funx.Monad.Effect.Left` that applies the given function to the environment passed to `Funx.Monad.Effect.run/2`.\n\nThis allows constructing a failure (`Left`) based on runtime input. It complements `Right.asks/2`,\nbut marks the result as a failure rather than a success.","ref":"Funx.Monad.Effect.Left.html#asks/2"},{"type":"function","title":"Example - Funx.Monad.Effect.Left.asks/2","doc":"iex> Funx.Monad.Effect.Left.asks(fn env -> {:error, env[:reason]} end)\n    ...> |> Funx.Monad.Effect.run(%{reason: :invalid})\n    %Funx.Monad.Either.Left{left: {:error, :invalid}}","ref":"Funx.Monad.Effect.Left.html#asks/2-example"},{"type":"function","title":"Funx.Monad.Effect.Left.pure/2","doc":"Creates a new `Left` effect.\n\nWraps a failure value in an asynchronous effect. You may provide context either as a keyword list or\nan `Effect.Context` struct.","ref":"Funx.Monad.Effect.Left.html#pure/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.Left.pure/2","doc":"iex> effect = Funx.Monad.Effect.Left.pure(\"error\")\n    iex> Funx.Monad.Effect.run(effect)\n    %Funx.Monad.Either.Left{left: \"error\"}","ref":"Funx.Monad.Effect.Left.html#pure/2-examples"},{"type":"type","title":"Funx.Monad.Effect.Left.t/0","doc":"","ref":"Funx.Monad.Effect.Left.html#t:t/0"},{"type":"type","title":"Funx.Monad.Effect.Left.t/1","doc":"Represents an asynchronous computation that produces a `Left` value.\n\nThe `effect` function is typically a deferred task that takes an environment and returns a `Task`.\nSince Elixir does not support parameterized `Task.t()` types, the return type is written as a union:\neither a `Task.t()` or a plain `Either.Left.t(left)` to support testing and internal optimizations.\n\nThe `context` carries telemetry, trace metadata, and environment configuration for error flows.","ref":"Funx.Monad.Effect.Left.html#t:t/1"},{"type":"module","title":"Funx.Monad.Effect.Right","doc":"Represents the `Right` variant of the `Effect` monad, used to model a successful computation in an asynchronous context.\n\nThis module implements the following protocols:\n  - `Funx.Monad`: Implements the `bind/2`, `map/2`, and `ap/2` functions to handle monadic operations within an effectful, lazy execution context.\n  - `String.Chars`: Provides a `to_string/1` function to represent `Right` values as strings.\n\nThe `Right` effect allows the computation to proceed with successful values, supporting lazy, asynchronous tasks\nand capturing execution context through the `Effect.Context` struct.","ref":"Funx.Monad.Effect.Right.html"},{"type":"module","title":"Reader Operations - Funx.Monad.Effect.Right","doc":"* `ask/1` – Returns the environment passed to `run/2` as a `Right`.\n  * `asks/2` – Applies a function to the environment passed to `run/2`, wrapping the result in a `Right`.","ref":"Funx.Monad.Effect.Right.html#module-reader-operations"},{"type":"function","title":"Funx.Monad.Effect.Right.ask/1","doc":"Returns a `Funx.Monad.Effect.Right` that yields the environment passed to `Funx.Monad.Effect.run/2`.\n\nThis is the Reader monad's equivalent of `ask`, giving access to the entire injected environment\nfor further computation.","ref":"Funx.Monad.Effect.Right.html#ask/1"},{"type":"function","title":"Example - Funx.Monad.Effect.Right.ask/1","doc":"iex> Funx.Monad.Effect.Right.ask()\n    ...> |> Funx.Monad.map(& &1[:user])\n    ...> |> Funx.Monad.Effect.run(%{user: \"alice\"})\n    %Funx.Monad.Either.Right{right: \"alice\"}","ref":"Funx.Monad.Effect.Right.html#ask/1-example"},{"type":"function","title":"Funx.Monad.Effect.Right.asks/2","doc":"Returns a `Funx.Monad.Effect.Right` that applies the given function to the environment passed to `Funx.Monad.Effect.run/2`.\n\nThis allows extracting a value from the environment and using it in an effectful computation,\nfollowing the Reader pattern.","ref":"Funx.Monad.Effect.Right.html#asks/2"},{"type":"function","title":"Example - Funx.Monad.Effect.Right.asks/2","doc":"iex> Funx.Monad.Effect.Right.asks(fn env -> env[:user] end)\n    ...> |> Funx.Monad.bind(fn user -> Funx.Monad.Effect.right(user) end)\n    ...> |> Funx.Monad.Effect.run(%{user: \"alice\"})\n    %Funx.Monad.Either.Right{right: \"alice\"}","ref":"Funx.Monad.Effect.Right.html#asks/2-example"},{"type":"function","title":"Funx.Monad.Effect.Right.pure/2","doc":"Creates a new `Right` effect.\n\nThe `pure/2` function wraps a value in the `Right` effect monad, representing an asynchronous success.","ref":"Funx.Monad.Effect.Right.html#pure/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.Right.pure/2","doc":"iex> effect = Funx.Monad.Effect.Right.pure(\"success\")\n    iex> Funx.Monad.Effect.run(effect)\n    %Funx.Monad.Either.Right{right: \"success\"}","ref":"Funx.Monad.Effect.Right.html#pure/2-examples"},{"type":"type","title":"Funx.Monad.Effect.Right.t/0","doc":"","ref":"Funx.Monad.Effect.Right.html#t:t/0"},{"type":"type","title":"Funx.Monad.Effect.Right.t/1","doc":"Represents an asynchronous computation that produces a `Right` value.\n\nThe `effect` function is typically a deferred task that takes an environment and returns a `Task`.\nSince Elixir does not support parameterized `Task.t()` types, the return type is described as a union:\neither a `Task.t()` or a plain `Either.Right.t(right)` for testability and flexibility.\n\nThe `context` carries telemetry and trace information used during execution.","ref":"Funx.Monad.Effect.Right.html#t:t/1"},{"type":"module","title":"Funx.Monad.Either","doc":"The `Funx.Monad.Either` module provides an implementation of the `Either` monad, a functional abstraction used to model computations that may fail.\n\nAn `Either` represents one of two possibilities:\n\n  - `Right(value)`: a successful result\n  - `Left(error)`: a failure or error\n\nThis pattern is commonly used in place of exceptions to handle errors explicitly and safely in functional pipelines.","ref":"Funx.Monad.Either.html"},{"type":"module","title":"Constructors - Funx.Monad.Either","doc":"- `right/1`: Wraps a value in the `Right` branch.\n  - `left/1`: Wraps a value in the `Left` branch.\n  - `pure/1`: Alias for `right/1`.","ref":"Funx.Monad.Either.html#module-constructors"},{"type":"module","title":"Refinement - Funx.Monad.Either","doc":"- `right?/1`: Returns `true` if the value is a `Right`.\n  - `left?/1`: Returns `true` if the value is a `Left`.","ref":"Funx.Monad.Either.html#module-refinement"},{"type":"module","title":"Fallback and Extraction - Funx.Monad.Either","doc":"- `get_or_else/2`: Returns the value from a `Right`, or a default if `Left`.\n  - `or_else/2`: Returns the original `Right`, or invokes a fallback function if `Left`.\n  - `map_left/2`: Transforms a `Left` using a function, leaving `Right` values unchanged.\n  - `flip/1`: Swaps `Left` and `Right`, turning errors into successes and vice versa.\n  - `filter_or_else/3`: Applies a predicate to the `Right` value; if false, returns a fallback `Left`.","ref":"Funx.Monad.Either.html#module-fallback-and-extraction"},{"type":"module","title":"List Operations - Funx.Monad.Either","doc":"- `concat/1`: Removes all `Left` values and unwraps the `Right` values from a list.\n  - `concat_map/2`: Applies a function and collects only `Right` results.\n  - `sequence/1`: Converts a list of `Either` values into a single `Either` of list.\n  - `traverse/2`: Applies a function to each element in a list and sequences the results.\n  - `sequence_a/1`: Like `sequence/1`, but accumulates all errors from `Left` values.\n  - `traverse_a/2`: Like `traverse/2`, but accumulates all `Left` values instead of short-circuiting.\n  - `wither_a/2`: Like `traverse_a/2`, but filters out `Nothing` results and collects only `Just` values.","ref":"Funx.Monad.Either.html#module-list-operations"},{"type":"module","title":"Validation - Funx.Monad.Either","doc":"- `validate/2`: Applies multiple validators to a single input, collecting all errors.","ref":"Funx.Monad.Either.html#module-validation"},{"type":"module","title":"Lifting - Funx.Monad.Either","doc":"- `lift_predicate/3`: Turns a predicate into an `Either`, returning `Right` on `true` and `Left` on `false`.\n  - `lift_maybe/2`: Converts a `Maybe` to an `Either` using a fallback value.\n  - `lift_eq/1`: Lifts an equality function into the `Either` context.\n  - `lift_ord/1`: Lifts an ordering function into the `Either` context.","ref":"Funx.Monad.Either.html#module-lifting"},{"type":"module","title":"Transformation - Funx.Monad.Either","doc":"- `map_left/2` – Transforms the error inside a `Left`, leaving `Right` values untouched.","ref":"Funx.Monad.Either.html#module-transformation"},{"type":"module","title":"Elixir Interoperability - Funx.Monad.Either","doc":"- `from_result/1`: Converts `{:ok, val}` or `{:error, err}` into an `Either`.\n  - `to_result/1`: Converts an `Either` into a result tuple.\n  - `from_try/1`: Runs a function and returns `Right` on success or `Left` on exception.\n  - `to_try!/1`: Unwraps a `Right`, or raises an error from a `Left`.","ref":"Funx.Monad.Either.html#module-elixir-interoperability"},{"type":"module","title":"Protocols - Funx.Monad.Either","doc":"The `Left` and `Right` structs implement the following protocols, making the `Either` abstraction composable and extensible:\n\n  - `Funx.Eq`: Enables equality comparisons between `Either` values.\n  - `Funx.Foldable`: Implements `fold_l/3` and `fold_r/3` for reducing over contained values.\n  - `Funx.Monad`: Provides `map/2`, `ap/2`, and `bind/2` for monadic composition.\n  - `Funx.Ord`: Defines ordering behavior for comparing `Left` and `Right` values.\n\nAlthough these implementations are defined on each constructor (`Left` and `Right`), the behavior is consistent across the `Either` abstraction.\n\nThis module helps you model failure explicitly, compose error-aware logic, and integrate cleanly with Elixir's functional idioms.","ref":"Funx.Monad.Either.html#module-protocols"},{"type":"function","title":"Funx.Monad.Either.concat/1","doc":"Removes `Left` values from a list of `Either` and returns a list of unwrapped `Right` values.\n\nUseful for discarding failed computations while keeping successful results.","ref":"Funx.Monad.Either.html#concat/1"},{"type":"function","title":"Examples - Funx.Monad.Either.concat/1","doc":"iex> Funx.Monad.Either.concat([Funx.Monad.Either.right(1), Funx.Monad.Either.left(:error), Funx.Monad.Either.right(2)])\n    [1, 2]\n\n    iex> Funx.Monad.Either.concat([Funx.Monad.Either.left(:a), Funx.Monad.Either.left(:b)])\n    []\n\n    iex> Funx.Monad.Either.concat([Funx.Monad.Either.right(\"a\"), Funx.Monad.Either.right(\"b\"), Funx.Monad.Either.right(\"c\")])\n    [\"a\", \"b\", \"c\"]","ref":"Funx.Monad.Either.html#concat/1-examples"},{"type":"function","title":"Funx.Monad.Either.concat_map/2","doc":"Applies the given function to each element in the list and collects the `Right` results, discarding any `Left`.\n\nThis is useful when mapping a function that may fail and you only want the successful results.","ref":"Funx.Monad.Either.html#concat_map/2"},{"type":"function","title":"Examples - Funx.Monad.Either.concat_map/2","doc":"iex> Funx.Monad.Either.concat_map([1, 2, 3], fn x -> if rem(x, 2) == 1, do: Funx.Monad.Either.right(x), else: Funx.Monad.Either.left(:even) end)\n    [1, 3]\n\n    iex> Funx.Monad.Either.concat_map([2, 4], fn x -> if x > 3, do: Funx.Monad.Either.right(x), else: Funx.Monad.Either.left(:too_small) end)\n    [4]\n\n    iex> Funx.Monad.Either.concat_map([], fn _ -> Funx.Monad.Either.left(:none) end)\n    []","ref":"Funx.Monad.Either.html#concat_map/2-examples"},{"type":"function","title":"Funx.Monad.Either.filter_or_else/3","doc":"Filters the value inside a `Right` using the given `predicate`. If the predicate returns `false`,\na `Left` is returned using the `left_func`.","ref":"Funx.Monad.Either.html#filter_or_else/3"},{"type":"function","title":"Examples - Funx.Monad.Either.filter_or_else/3","doc":"iex> Funx.Monad.Either.filter_or_else(Funx.Monad.Either.right(5), fn x -> x > 3 end, fn -> \"error\" end)\n    %Funx.Monad.Either.Right{right: 5}\n\n    iex> Funx.Monad.Either.filter_or_else(Funx.Monad.Either.right(2), fn x -> x > 3 end, fn -> \"error\" end)\n    %Funx.Monad.Either.Left{left: \"error\"}","ref":"Funx.Monad.Either.html#filter_or_else/3-examples"},{"type":"function","title":"Funx.Monad.Either.flip/1","doc":"Swaps the `Left` and `Right` branches of the `Either`.\n\nTurns a `Left` into a `Right` and vice versa, preserving the contained term.","ref":"Funx.Monad.Either.html#flip/1"},{"type":"function","title":"Examples - Funx.Monad.Either.flip/1","doc":"iex> Funx.Monad.Either.flip(Funx.Monad.Either.left(:error))\n    %Funx.Monad.Either.Right{right: :error}\n\n    iex> Funx.Monad.Either.flip(Funx.Monad.Either.right(42))\n    %Funx.Monad.Either.Left{left: 42}","ref":"Funx.Monad.Either.html#flip/1-examples"},{"type":"function","title":"Funx.Monad.Either.from_result/1","doc":"Converts a result (`{:ok, _}` or `{:error, _}`) to an `Either`.","ref":"Funx.Monad.Either.html#from_result/1"},{"type":"function","title":"Examples - Funx.Monad.Either.from_result/1","doc":"iex> Funx.Monad.Either.from_result({:ok, 5})\n    %Funx.Monad.Either.Right{right: 5}\n\n    iex> Funx.Monad.Either.from_result({:error, \"error\"})\n    %Funx.Monad.Either.Left{left: \"error\"}","ref":"Funx.Monad.Either.html#from_result/1-examples"},{"type":"function","title":"Funx.Monad.Either.from_try/1","doc":"Wraps a value in an `Either`, catching any exceptions. If an exception occurs, a `Left` is returned with the exception.","ref":"Funx.Monad.Either.html#from_try/1"},{"type":"function","title":"Examples - Funx.Monad.Either.from_try/1","doc":"iex> Funx.Monad.Either.from_try(fn -> 5 end)\n    %Funx.Monad.Either.Right{right: 5}\n\n    iex> Funx.Monad.Either.from_try(fn -> raise \"error\" end)\n    %Funx.Monad.Either.Left{left: %RuntimeError{message: \"error\"}}","ref":"Funx.Monad.Either.html#from_try/1-examples"},{"type":"function","title":"Funx.Monad.Either.get_or_else/2","doc":"Retrieves the value from a `Right`, returning the `default` value if `Left`.","ref":"Funx.Monad.Either.html#get_or_else/2"},{"type":"function","title":"Examples - Funx.Monad.Either.get_or_else/2","doc":"iex> Funx.Monad.Either.get_or_else(Funx.Monad.Either.right(5), 0)\n    5\n\n    iex> Funx.Monad.Either.get_or_else(Funx.Monad.Either.left(\"error\"), 0)\n    0","ref":"Funx.Monad.Either.html#get_or_else/2-examples"},{"type":"function","title":"Funx.Monad.Either.left/1","doc":"Wraps a value in the `Left` monad.","ref":"Funx.Monad.Either.html#left/1"},{"type":"function","title":"Examples - Funx.Monad.Either.left/1","doc":"iex> Funx.Monad.Either.left(\"error\")\n    %Funx.Monad.Either.Left{left: \"error\"}","ref":"Funx.Monad.Either.html#left/1-examples"},{"type":"function","title":"Funx.Monad.Either.left?/1","doc":"Returns `true` if the `Either` is a `Left` value.","ref":"Funx.Monad.Either.html#left?/1"},{"type":"function","title":"Examples - Funx.Monad.Either.left?/1","doc":"iex> Funx.Monad.Either.left?(Funx.Monad.Either.left(\"error\"))\n    true\n\n    iex> Funx.Monad.Either.left?(Funx.Monad.Either.right(5))\n    false","ref":"Funx.Monad.Either.html#left?/1-examples"},{"type":"function","title":"Funx.Monad.Either.lift_eq/1","doc":"Lifts an equality function to compare `Either` values:\n  - `Right` vs `Right`: Uses the custom equality function.\n  - `Left` vs `Left`: Uses the custom equality function.\n  - `Left` vs `Right` or vice versa: Always `false`.","ref":"Funx.Monad.Either.html#lift_eq/1"},{"type":"function","title":"Examples - Funx.Monad.Either.lift_eq/1","doc":"iex> eq = Funx.Monad.Either.lift_eq(%{\n    ...>   eq?: fn x, y -> x == y end,\n    ...>   not_eq?: fn x, y -> x != y end\n    ...> })\n    iex> eq.eq?.(Funx.Monad.Either.right(5), Funx.Monad.Either.right(5))\n    true\n    iex> eq.eq?.(Funx.Monad.Either.right(5), Funx.Monad.Either.right(10))\n    false\n    iex> eq.eq?.(Funx.Monad.Either.left(:a), Funx.Monad.Either.left(:a))\n    true\n    iex> eq.eq?.(Funx.Monad.Either.left(:a), Funx.Monad.Either.left(:b))\n    false\n    iex> eq.eq?.(Funx.Monad.Either.right(5), Funx.Monad.Either.left(:a))\n    false","ref":"Funx.Monad.Either.html#lift_eq/1-examples"},{"type":"function","title":"Funx.Monad.Either.lift_maybe/2","doc":"Converts a `Maybe` value to an `Either`. If the `Maybe` is `Nothing`, a `Left` is returned using `on_none`.","ref":"Funx.Monad.Either.html#lift_maybe/2"},{"type":"function","title":"Examples - Funx.Monad.Either.lift_maybe/2","doc":"iex> Funx.Monad.Either.lift_maybe(Funx.Monad.Maybe.just(5), fn -> \"error\" end)\n    %Funx.Monad.Either.Right{right: 5}\n\n    iex> Funx.Monad.Either.lift_maybe(Funx.Monad.Maybe.nothing(), fn -> \"error\" end)\n    %Funx.Monad.Either.Left{left: \"error\"}","ref":"Funx.Monad.Either.html#lift_maybe/2-examples"},{"type":"function","title":"Funx.Monad.Either.lift_ord/1","doc":"Creates a custom ordering function for `Either` values using the provided `custom_ord`.\n\nThe `custom_ord` must be a map with `:lt?`, `:le?`, `:gt?`, and `:ge?` functions. These are used to compare the internal `left` or `right` values.","ref":"Funx.Monad.Either.html#lift_ord/1"},{"type":"function","title":"Examples - Funx.Monad.Either.lift_ord/1","doc":"iex> ord = Funx.Monad.Either.lift_ord(%{\n    ...>   lt?: fn x, y -> x     le?: fn x, y -> x <= y end,\n    ...>   gt?: fn x, y -> x > y end,\n    ...>   ge?: fn x, y -> x >= y end\n    ...> })\n    iex> ord.lt?.(Funx.Monad.Either.right(3), Funx.Monad.Either.right(5))\n    true\n    iex> ord.lt?.(Funx.Monad.Either.left(3), Funx.Monad.Either.right(5))\n    true\n    iex> ord.lt?.(Funx.Monad.Either.right(3), Funx.Monad.Either.left(5))\n    false\n    iex> ord.lt?.(Funx.Monad.Either.left(3), Funx.Monad.Either.left(5))\n    true","ref":"Funx.Monad.Either.html#lift_ord/1-examples"},{"type":"function","title":"Funx.Monad.Either.lift_predicate/3","doc":"Lifts a value into an `Either` based on the result of a predicate.\n\nReturns `Right(value)` if the predicate returns `true`, or `Left(on_false.(value))` if it returns `false`.\n\nThis allows you to wrap a conditional check in a functional context with a custom error message.","ref":"Funx.Monad.Either.html#lift_predicate/3"},{"type":"function","title":"Examples - Funx.Monad.Either.lift_predicate/3","doc":"iex> Funx.Monad.Either.lift_predicate(5, fn x -> x > 3 end, fn x -> \"#{x} is too small\" end)\n    %Funx.Monad.Either.Right{right: 5}\n\n    iex> Funx.Monad.Either.lift_predicate(2, fn x -> x > 3 end, fn x -> \"#{x} is too small\" end)\n    %Funx.Monad.Either.Left{left: \"2 is too small\"}","ref":"Funx.Monad.Either.html#lift_predicate/3-examples"},{"type":"function","title":"Funx.Monad.Either.map_left/2","doc":"Transforms the `Left` value using the given function if the `Either` is a `Left`.\nIf the value is `Right`, it is returned unchanged.","ref":"Funx.Monad.Either.html#map_left/2"},{"type":"function","title":"Examples - Funx.Monad.Either.map_left/2","doc":"iex> Funx.Monad.Either.map_left(Funx.Monad.Either.left(\"error\"), fn e -> \"wrapped: \" <> e end)\n    %Funx.Monad.Either.Left{left: \"wrapped: error\"}\n\n    iex> Funx.Monad.Either.map_left(Funx.Monad.Either.right(42), fn _ -> \"ignored\" end)\n    %Funx.Monad.Either.Right{right: 42}","ref":"Funx.Monad.Either.html#map_left/2-examples"},{"type":"function","title":"Funx.Monad.Either.or_else/2","doc":"Returns the current `Right` value or invokes the `fallback_fun` if `Left`.\n\nUseful for recovering from a failure by providing an alternate computation.","ref":"Funx.Monad.Either.html#or_else/2"},{"type":"function","title":"Examples - Funx.Monad.Either.or_else/2","doc":"iex> Funx.Monad.Either.or_else(Funx.Monad.Either.left(\"error\"), fn -> Funx.Monad.Either.right(42) end)\n    %Funx.Monad.Either.Right{right: 42}\n\n    iex> Funx.Monad.Either.or_else(Funx.Monad.Either.right(10), fn -> Funx.Monad.Either.right(42) end)\n    %Funx.Monad.Either.Right{right: 10}","ref":"Funx.Monad.Either.html#or_else/2-examples"},{"type":"function","title":"Funx.Monad.Either.pure/1","doc":"Alias for `right/1`.","ref":"Funx.Monad.Either.html#pure/1"},{"type":"function","title":"Examples - Funx.Monad.Either.pure/1","doc":"iex> Funx.Monad.Either.pure(2)\n    %Funx.Monad.Either.Right{right: 2}","ref":"Funx.Monad.Either.html#pure/1-examples"},{"type":"function","title":"Funx.Monad.Either.right/1","doc":"Wraps a value in the `Right` monad.","ref":"Funx.Monad.Either.html#right/1"},{"type":"function","title":"Examples - Funx.Monad.Either.right/1","doc":"iex> Funx.Monad.Either.right(5)\n    %Funx.Monad.Either.Right{right: 5}","ref":"Funx.Monad.Either.html#right/1-examples"},{"type":"function","title":"Funx.Monad.Either.right?/1","doc":"Returns `true` if the `Either` is a `Right` value.","ref":"Funx.Monad.Either.html#right?/1"},{"type":"function","title":"Examples - Funx.Monad.Either.right?/1","doc":"iex> Funx.Monad.Either.right?(Funx.Monad.Either.right(5))\n    true\n\n    iex> Funx.Monad.Either.right?(Funx.Monad.Either.left(\"error\"))\n    false","ref":"Funx.Monad.Either.html#right?/1-examples"},{"type":"function","title":"Funx.Monad.Either.sequence/1","doc":"Sequences a list of `Either` values into an `Either` of a list.","ref":"Funx.Monad.Either.html#sequence/1"},{"type":"function","title":"Examples - Funx.Monad.Either.sequence/1","doc":"iex> Funx.Monad.Either.sequence([Funx.Monad.Either.right(1), Funx.Monad.Either.right(2)])\n    %Funx.Monad.Either.Right{right: [1, 2]}\n\n    iex> Funx.Monad.Either.sequence([Funx.Monad.Either.right(1), Funx.Monad.Either.left(\"error\")])\n    %Funx.Monad.Either.Left{left: \"error\"}","ref":"Funx.Monad.Either.html#sequence/1-examples"},{"type":"function","title":"Funx.Monad.Either.sequence_a/1","doc":"Sequences a list of `Either` values, collecting all errors from `Left` values, rather than short-circuiting.","ref":"Funx.Monad.Either.html#sequence_a/1"},{"type":"function","title":"Examples - Funx.Monad.Either.sequence_a/1","doc":"iex> Funx.Monad.Either.sequence_a([Funx.Monad.Either.right(1), Funx.Monad.Either.left(\"error\"), Funx.Monad.Either.left(\"another error\")])\n    %Funx.Monad.Either.Left{left: [\"error\", \"another error\"]}","ref":"Funx.Monad.Either.html#sequence_a/1-examples"},{"type":"function","title":"Funx.Monad.Either.to_result/1","doc":"Converts an `Either` to a result (`{:ok, value}` or `{:error, reason}`).","ref":"Funx.Monad.Either.html#to_result/1"},{"type":"function","title":"Examples - Funx.Monad.Either.to_result/1","doc":"iex> Funx.Monad.Either.to_result(Funx.Monad.Either.right(5))\n    {:ok, 5}\n\n    iex> Funx.Monad.Either.to_result(Funx.Monad.Either.left(\"error\"))\n    {:error, \"error\"}","ref":"Funx.Monad.Either.html#to_result/1-examples"},{"type":"function","title":"Funx.Monad.Either.to_try!/1","doc":"Converts an `Either` to its inner value, raising an exception if it is `Left`.\n\nIf the `Left` holds an exception struct, it is raised directly. If it holds a string or list of errors, they are converted into a `RuntimeError`. Unexpected types are inspected and raised as a `RuntimeError`.","ref":"Funx.Monad.Either.html#to_try!/1"},{"type":"function","title":"Examples - Funx.Monad.Either.to_try!/1","doc":"iex> Funx.Monad.Either.to_try!(Funx.Monad.Either.right(5))\n    5\n\n    iex> Funx.Monad.Either.to_try!(Funx.Monad.Either.left(\"error\"))\n    ** (RuntimeError) error\n\n    iex> Funx.Monad.Either.to_try!(Funx.Monad.Either.left([\"error 1\", \"error 2\"]))\n    ** (RuntimeError) error 1, error 2\n\n    iex> Funx.Monad.Either.to_try!(Funx.Monad.Either.left(%ArgumentError{message: \"bad argument\"}))\n    ** (ArgumentError) bad argument","ref":"Funx.Monad.Either.html#to_try!/1-examples"},{"type":"function","title":"Funx.Monad.Either.traverse/2","doc":"Traverses a list, applying the given function to each element and collecting the results in a single `Right`, or short-circuiting with the first `Left`.\n\nThis is useful for validating or transforming a list of values where each step may fail.","ref":"Funx.Monad.Either.html#traverse/2"},{"type":"function","title":"Examples - Funx.Monad.Either.traverse/2","doc":"iex> Funx.Monad.Either.traverse([1, 2, 3], &Funx.Monad.Either.right/1)\n    %Funx.Monad.Either.Right{right: [1, 2, 3]}\n\n    iex> Funx.Monad.Either.traverse([1, -2, 3], fn x -> if x > 0, do: Funx.Monad.Either.right(x), else: Funx.Monad.Either.left(\"error\") end)\n    %Funx.Monad.Either.Left{left: \"error\"}","ref":"Funx.Monad.Either.html#traverse/2-examples"},{"type":"function","title":"Funx.Monad.Either.traverse_a/2","doc":"Traverses a list, applying the given function to each element and collecting the results in a single `Right`.\n\nUnlike `traverse/2`, this version accumulates all `Left` values rather than stopping at the first failure.\nIt is useful for validations where you want to gather all errors at once.","ref":"Funx.Monad.Either.html#traverse_a/2"},{"type":"function","title":"Examples - Funx.Monad.Either.traverse_a/2","doc":"iex> validate = fn x -> Funx.Monad.Either.lift_predicate(x, &(&1 > 0), fn v -> \"must be positive: #{v}\" end) end\n    iex> Funx.Monad.Either.traverse_a([1, 2, 3], validate)\n    %Funx.Monad.Either.Right{right: [1, 2, 3]}\n    iex> Funx.Monad.Either.traverse_a([1, -2, -3], validate)\n    %Funx.Monad.Either.Left{left: [\"must be positive: -2\", \"must be positive: -3\"]}","ref":"Funx.Monad.Either.html#traverse_a/2-examples"},{"type":"function","title":"Funx.Monad.Either.validate/2","doc":"Validates a value using a list of validator functions. Each validator returns an `Either.Right` if\nthe check passes, or an `Either.Left` with an error message if it fails. If any validation fails,\nall errors are aggregated and returned in a single `Left`.","ref":"Funx.Monad.Either.html#validate/2"},{"type":"function","title":"Flat list aggregation - Funx.Monad.Either.validate/2","doc":"When using the default aggregation strategy, errors are collected in a plain list:\n\n```elixir\nvalidate_positive = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(&1 > 0), fn v -> \"Value must be positive: \" <> to_string(v) end)\nend\n\nvalidate_even = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(rem(&1, 2) == 0), fn v -> \"Value must be even: \" <> to_string(v) end)\nend\n\nFunx.Monad.Either.validate(4, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Right{right: 4}\n\nFunx.Monad.Either.validate(3, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Left{left: [\"Value must be even: 3\"]}\n\nFunx.Monad.Either.validate(-3, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Left{left: [\"Value must be positive: -3\", \"Value must be even: -3\"]}\n```","ref":"Funx.Monad.Either.html#validate/2-flat-list-aggregation"},{"type":"function","title":"Structured aggregation with `ValidationError` - Funx.Monad.Either.validate/2","doc":"You can also use a custom struct to hold errors. This example uses `ValidationError` and a corresponding\n`Funx.Semigroup` implementation to accumulate errors into a single structure:\n\n```elixir\nalias Funx.Errors.ValidationError\n\nvalidate_positive = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(&1 > 0), fn v -> \"Value must be positive: \" <> to_string(v) end)\n  |> Funx.Monad.Either.map_left(&ValidationError.new/1)\nend\n\nvalidate_even = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(rem(&1, 2) == 0), fn v -> \"Value must be even: \" <> to_string(v) end)\n  |> Funx.Monad.Either.map_left(&ValidationError.new/1)\nend\n\nFunx.Monad.Either.validate(-3, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Left{\n#     left: %ValidationError{\n#       errors: [\"Value must be positive: -3\", \"Value must be even: -3\"]\n#     }\n#   }\n```","ref":"Funx.Monad.Either.html#validate/2-structured-aggregation-with-validationerror"},{"type":"function","title":"Funx.Monad.Either.wither_a/2","doc":"Traverses a list, applying the given function to each element, and collects the successful `Just` results into a single `Right`.\n\nThe given function must return an `Either` of `Maybe`. `Right(Just x)` values are kept; `Right(Nothing)` values are filtered out.\nIf any application returns `Left`, all `Left` values are accumulated.\n\nThis is useful for effectful filtering, where you want to validate or transform elements and conditionally keep them, while still reporting all errors.","ref":"Funx.Monad.Either.html#wither_a/2"},{"type":"function","title":"Examples - Funx.Monad.Either.wither_a/2","doc":"iex> filter_positive = fn x ->\n    ...>   Funx.Monad.Either.lift_predicate(x, &is_integer/1, fn v -> \"not an integer: #{inspect(v)}\" end)\n    ...>   |> Funx.Monad.map(fn x -> if x > 0, do: Funx.Monad.Maybe.just(x), else: Funx.Monad.Maybe.nothing() end)\n    ...> end\n    iex> Funx.Monad.Either.wither_a([1, -2, 3], filter_positive)\n    %Funx.Monad.Either.Right{right: [1, 3]}\n    iex> Funx.Monad.Either.wither_a([\"oops\", -2], filter_positive)\n    %Funx.Monad.Either.Left{left: [\"not an integer: \\\"oops\\\"\"]}","ref":"Funx.Monad.Either.html#wither_a/2-examples"},{"type":"type","title":"Funx.Monad.Either.t/2","doc":"","ref":"Funx.Monad.Either.html#t:t/2"},{"type":"module","title":"Funx.Monad.Either.Left","doc":"Represents the `Left` variant of the `Either` monad, used to model an error or failure.\n\nThis module implements the following protocols:\n  - `Funx.Eq`: Defines equality checks between `Left` and other `Either` values.\n  - `Funx.Foldable`: Provides `fold_l/3` and `fold_r/3` to handle folding for `Left` values.\n  - `Funx.Monad`: Implements the `bind/2`, `map/2`, and `ap/2` functions for monadic operations.\n  - `Funx.Ord`: Defines ordering logic for `Left` and `Right` values.\n\nThe `Left` monad propagates the wrapped error through operations without executing the success logic.","ref":"Funx.Monad.Either.Left.html"},{"type":"function","title":"Funx.Monad.Either.Left.pure/1","doc":"Creates a new `Left` value.\n\nThe `pure/1` function wraps a value in the `Left` monad, representing an error or failure.","ref":"Funx.Monad.Either.Left.html#pure/1"},{"type":"function","title":"Examples - Funx.Monad.Either.Left.pure/1","doc":"iex> Funx.Monad.Either.Left.pure(\"error\")\n    %Funx.Monad.Either.Left{left: \"error\"}","ref":"Funx.Monad.Either.Left.html#pure/1-examples"},{"type":"type","title":"Funx.Monad.Either.Left.t/1","doc":"","ref":"Funx.Monad.Either.Left.html#t:t/1"},{"type":"module","title":"Funx.Monad.Either.Right","doc":"Represents the `Right` variant of the `Either` monad, used to model a success or valid result.\n\nThis module implements the following protocols:\n  - `Funx.Eq`: Defines equality checks between `Right` and other `Either` values.\n  - `Funx.Foldable`: Provides `fold_l/3` and `fold_r/3` to handle folding for `Right` values.\n  - `Funx.Monad`: Implements the `bind/2`, `map/2`, and `ap/2` functions for monadic operations.\n  - `Funx.Ord`: Defines ordering logic for `Right` and `Left` values.\n\nThe `Right` monad represents a valid result, and the contained value is propagated through operations.","ref":"Funx.Monad.Either.Right.html"},{"type":"function","title":"Funx.Monad.Either.Right.pure/1","doc":"Creates a new `Right` value.\n\nThe `pure/1` function wraps a value in the `Right` monad, representing a valid result.","ref":"Funx.Monad.Either.Right.html#pure/1"},{"type":"function","title":"Examples - Funx.Monad.Either.Right.pure/1","doc":"iex> Funx.Monad.Either.Right.pure(5)\n    %Funx.Monad.Either.Right{right: 5}","ref":"Funx.Monad.Either.Right.html#pure/1-examples"},{"type":"type","title":"Funx.Monad.Either.Right.t/1","doc":"","ref":"Funx.Monad.Either.Right.html#t:t/1"},{"type":"module","title":"Funx.Monad.Identity","doc":"The `Funx.Monad.Identity` module represents the identity monad, where values are simply wrapped in a structure\nand operations are applied directly to those values.\n\nThis module implements the following protocols:\n  - `Funx.Monad`: Implements the `bind/2`, `map/2`, and `ap/2` functions for monadic operations.\n  - `Funx.Eq`: Defines equality checks for `Identity` values.\n  - `Funx.Ord`: Defines ordering logic for `Identity` values.\n  - `String.Chars`: Converts an `Identity` value into a string representation.","ref":"Funx.Monad.Identity.html"},{"type":"function","title":"Funx.Monad.Identity.extract/1","doc":"Extracts the value from an `Identity`.","ref":"Funx.Monad.Identity.html#extract/1"},{"type":"function","title":"Examples - Funx.Monad.Identity.extract/1","doc":"iex> Funx.Monad.Identity.extract(Funx.Monad.Identity.pure(5))\n    5","ref":"Funx.Monad.Identity.html#extract/1-examples"},{"type":"function","title":"Funx.Monad.Identity.lift_eq/1","doc":"","ref":"Funx.Monad.Identity.html#lift_eq/1"},{"type":"function","title":"Funx.Monad.Identity.lift_ord/1","doc":"","ref":"Funx.Monad.Identity.html#lift_ord/1"},{"type":"function","title":"Funx.Monad.Identity.pure/1","doc":"Creates a new `Identity` value by wrapping a given value.","ref":"Funx.Monad.Identity.html#pure/1"},{"type":"function","title":"Examples - Funx.Monad.Identity.pure/1","doc":"iex> Funx.Monad.Identity.pure(5)\n    %Funx.Monad.Identity{value: 5}","ref":"Funx.Monad.Identity.html#pure/1-examples"},{"type":"type","title":"Funx.Monad.Identity.t/1","doc":"","ref":"Funx.Monad.Identity.html#t:t/1"},{"type":"module","title":"Funx.Monad.Maybe","doc":"The `Funx.Monad.Maybe` module provides an implementation of the `Maybe` monad, a functional abstraction used to represent optional values in Elixir.\n\nA `Maybe` represents one of two possibilities:\n\n  - `Just(value)`: the presence of a value\n  - `Nothing`: the absence of a value\n\nThis pattern is useful for eliminating `nil` checks and handling missing data explicitly and safely in functional pipelines.","ref":"Funx.Monad.Maybe.html"},{"type":"module","title":"Constructors - Funx.Monad.Maybe","doc":"- `just/1`: Wraps a value in the `Just` variant.\n  - `nothing/0`: Returns a `Nothing` value.\n  - `pure/1`: Alias for `just/1`.","ref":"Funx.Monad.Maybe.html#module-constructors"},{"type":"module","title":"Refinement - Funx.Monad.Maybe","doc":"- `just?/1`: Returns `true` if the value is a `Just`.\n  - `nothing?/1`: Returns `true` if the value is a `Nothing`.","ref":"Funx.Monad.Maybe.html#module-refinement"},{"type":"module","title":"Fallback and Extraction - Funx.Monad.Maybe","doc":"- `get_or_else/2`: Returns the value from a `Just`, or a default if `Nothing`.\n  - `or_else/2`: Returns the original `Just`, or invokes a fallback function if `Nothing`.","ref":"Funx.Monad.Maybe.html#module-fallback-and-extraction"},{"type":"module","title":"List Operations - Funx.Monad.Maybe","doc":"- `concat/1`: Removes all `Nothing` values and unwraps the `Just` values from a list.\n  - `concat_map/2`: Applies a function and collects only `Just` results.\n  - `sequence/1`: Converts a list of `Maybe` values into a single `Maybe` of list.\n  - `traverse/2`: Applies a function to each element in a list and sequences the results.","ref":"Funx.Monad.Maybe.html#module-list-operations"},{"type":"module","title":"Lifting - Funx.Monad.Maybe","doc":"- `lift_predicate/2`: Converts a value to `Just` if it meets a predicate, otherwise `Nothing`.\n  - `lift_identity/1`: Converts an `Identity` to a `Maybe`.\n  - `lift_either/1`: Converts an `Either` to a `Maybe`.\n  - `lift_eq/1`: Lifts an equality function for use in the `Maybe` context.\n  - `lift_ord/1`: Lifts an ordering function for use in the `Maybe` context.","ref":"Funx.Monad.Maybe.html#module-lifting"},{"type":"module","title":"Elixir Interoperability - Funx.Monad.Maybe","doc":"- `from_nil/1`: Converts `nil` to `Nothing`, otherwise wraps the value in `Just`.\n  - `to_nil/1`: Returns the underlying value or `nil`.\n  - `from_result/1`: Converts `{:ok, val}` or `{:error, _}` into a `Maybe`.\n  - `to_result/1`: Converts a `Maybe` to a result tuple.\n  - `from_try/1`: Runs a function and returns `Just` on success, or `Nothing` if an exception is raised.\n  - `to_try!/2`: Unwraps a `Just`, or raises an error if `Nothing`.","ref":"Funx.Monad.Maybe.html#module-elixir-interoperability"},{"type":"module","title":"Protocols - Funx.Monad.Maybe","doc":"The `Just` and `Nothing` structs implement the following protocols, making the `Maybe` abstraction composable and extensible:\n\n  - `Funx.Eq`: Enables equality comparisons between `Maybe` values.\n  - `Funx.Foldable`: Implements `fold_l/3` and `fold_r/3` for reducing over the value or fallback.\n  - `Funx.Filterable`: Supports conditional retention with `filter/2`, `guard/2`, and `filter_map/2`.\n  - `Funx.Monad`: Provides `map/2`, `ap/2`, and `bind/2` for monadic composition.\n  - `Funx.Ord`: Defines ordering behavior between `Just` and `Nothing` values.\n\nAlthough these implementations are defined per constructor (`Just` and `Nothing`), the behavior is consistent across the `Maybe` abstraction.\n\nThis module helps you represent optional data explicitly, structure conditional logic safely, and eliminate reliance on `nil` in functional pipelines.","ref":"Funx.Monad.Maybe.html#module-protocols"},{"type":"function","title":"Funx.Monad.Maybe.concat/1","doc":"Removes `Nothing` values from a list of `Maybe` and returns a list of unwrapped `Just` values.","ref":"Funx.Monad.Maybe.html#concat/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.concat/1","doc":"iex> Funx.Monad.Maybe.concat([Funx.Monad.Maybe.pure(1), Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.pure(2)])\n    [1, 2]\n\n    iex> Funx.Monad.Maybe.concat([Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.nothing()])\n    []\n\n    iex> Funx.Monad.Maybe.concat([Funx.Monad.Maybe.pure(\"a\"), Funx.Monad.Maybe.pure(\"b\"), Funx.Monad.Maybe.pure(\"c\")])\n    [\"a\", \"b\", \"c\"]","ref":"Funx.Monad.Maybe.html#concat/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.concat_map/2","doc":"Maps a function over a list, collecting unwrapped `Just` values and ignoring `Nothing` in a single pass.","ref":"Funx.Monad.Maybe.html#concat_map/2"},{"type":"function","title":"Examples - Funx.Monad.Maybe.concat_map/2","doc":"iex> Funx.Monad.Maybe.concat_map([1, 2, 3, 4], fn x ->\n    ...>   if rem(x, 2) == 0, do: Funx.Monad.Maybe.pure(x), else: Funx.Monad.Maybe.nothing()\n    ...> end)\n    [2, 4]\n\n    iex> Funx.Monad.Maybe.concat_map([1, nil, 3], fn\n    ...>   nil -> Funx.Monad.Maybe.nothing()\n    ...>   x -> Funx.Monad.Maybe.pure(x * 2)\n    ...> end)\n    [2, 6]\n\n    iex> Funx.Monad.Maybe.concat_map([1, 2, 3], fn x -> Funx.Monad.Maybe.pure(x + 1) end)\n    [2, 3, 4]\n\n    iex> Funx.Monad.Maybe.concat_map([], fn x -> Funx.Monad.Maybe.pure(x) end)\n    []","ref":"Funx.Monad.Maybe.html#concat_map/2-examples"},{"type":"function","title":"Funx.Monad.Maybe.from_nil/1","doc":"Converts `nil` to `Nothing`; any other value becomes `Just`.","ref":"Funx.Monad.Maybe.html#from_nil/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.from_nil/1","doc":"iex> Funx.Monad.Maybe.from_nil(nil)\n    %Funx.Monad.Maybe.Nothing{}\n\n    iex> Funx.Monad.Maybe.from_nil(5)\n    %Funx.Monad.Maybe.Just{value: 5}","ref":"Funx.Monad.Maybe.html#from_nil/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.from_result/1","doc":"Converts a result tuple to a `Maybe`. `{:ok, value}` becomes `Just(value)`, while `{:error, _}` becomes `Nothing`.","ref":"Funx.Monad.Maybe.html#from_result/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.from_result/1","doc":"iex> Funx.Monad.Maybe.from_result({:ok, 5})\n    %Funx.Monad.Maybe.Just{value: 5}\n\n    iex> Funx.Monad.Maybe.from_result({:error, :something})\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Monad.Maybe.html#from_result/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.from_try/1","doc":"Executes a function within a `Maybe` context, returning `Nothing` if an exception occurs.","ref":"Funx.Monad.Maybe.html#from_try/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.from_try/1","doc":"iex> Funx.Monad.Maybe.from_try(fn -> 5 end)\n    %Funx.Monad.Maybe.Just{value: 5}\n\n    iex> Funx.Monad.Maybe.from_try(fn -> raise \"error\" end)\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Monad.Maybe.html#from_try/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.get_or_else/2","doc":"Retrieves the value from a `Maybe`, returning `default` if `Nothing`.","ref":"Funx.Monad.Maybe.html#get_or_else/2"},{"type":"function","title":"Examples - Funx.Monad.Maybe.get_or_else/2","doc":"iex> Funx.Monad.Maybe.get_or_else(Funx.Monad.Maybe.just(5), 0)\n    5\n\n    iex> Funx.Monad.Maybe.get_or_else(Funx.Monad.Maybe.nothing(), 0)\n    0","ref":"Funx.Monad.Maybe.html#get_or_else/2-examples"},{"type":"function","title":"Funx.Monad.Maybe.just/1","doc":"Wraps a value in `Just`.","ref":"Funx.Monad.Maybe.html#just/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.just/1","doc":"iex> Funx.Monad.Maybe.just(2)\n    %Funx.Monad.Maybe.Just{value: 2}","ref":"Funx.Monad.Maybe.html#just/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.just?/1","doc":"Returns `true` if the `Maybe` is `Just`, otherwise `false`.","ref":"Funx.Monad.Maybe.html#just?/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.just?/1","doc":"iex> Funx.Monad.Maybe.just?(Funx.Monad.Maybe.just(5))\n    true\n\n    iex> Funx.Monad.Maybe.just?(Funx.Monad.Maybe.nothing())\n    false","ref":"Funx.Monad.Maybe.html#just?/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.lift_either/1","doc":"Converts an `Either` to a `Maybe`. `Right` becomes `Just`, and `Left` becomes `Nothing`.","ref":"Funx.Monad.Maybe.html#lift_either/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.lift_either/1","doc":"iex> Funx.Monad.Maybe.lift_either(Funx.Monad.Either.right(5))\n    %Funx.Monad.Maybe.Just{value: 5}\n\n    iex> Funx.Monad.Maybe.lift_either(Funx.Monad.Either.left(\"Error\"))\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Monad.Maybe.html#lift_either/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.lift_eq/1","doc":"Lifts an equality function to compare `Maybe` values:\n  - `Just` vs `Just`: Uses the custom equality function.\n  - `Nothing` vs `Nothing`: Always `true`.\n  - `Just` vs `Nothing` or vice versa: Always `false`.","ref":"Funx.Monad.Maybe.html#lift_eq/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.lift_eq/1","doc":"iex> eq = Funx.Monad.Maybe.lift_eq(%{\n    ...>   eq?: fn x, y -> x == y end,\n    ...>   not_eq?: fn x, y -> x != y end\n    ...> })\n    iex> eq.eq?.(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.just(5))\n    true\n    iex> eq.eq?.(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.just(10))\n    false\n    iex> eq.eq?.(Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.nothing())\n    true\n    iex> eq.eq?.(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.nothing())\n    false","ref":"Funx.Monad.Maybe.html#lift_eq/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.lift_identity/1","doc":"Converts an `Identity` value into a `Maybe`. If the value is `nil`, returns `Nothing`; otherwise `Just`.","ref":"Funx.Monad.Maybe.html#lift_identity/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.lift_identity/1","doc":"iex> Funx.Monad.Maybe.lift_identity(Funx.Monad.Identity.pure(5))\n    %Funx.Monad.Maybe.Just{value: 5}\n\n    iex> Funx.Monad.Maybe.lift_identity(Funx.Monad.Identity.pure(nil))\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Monad.Maybe.html#lift_identity/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.lift_ord/1","doc":"Adapts an ordering function to compare `Maybe` values:\n  - `Nothing` is considered less than any `Just`.\n  - Two `Just` values are compared by the provided function.","ref":"Funx.Monad.Maybe.html#lift_ord/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.lift_ord/1","doc":"iex> ord = Funx.Monad.Maybe.lift_ord(%{\n    ...>   lt?: &</2,\n    ...>   le?: &<=/2,\n    ...>   gt?: &>/2,\n    ...>   ge?: &>=/2\n    ...> })\n    iex> ord.lt?.(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(5))\n    true\n    iex> ord.lt?.(Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.just(5))\n    true","ref":"Funx.Monad.Maybe.html#lift_ord/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.lift_predicate/2","doc":"Lifts a value into `Maybe` based on a predicate. If `predicate.(value)` is `true`, returns `Just(value)`; otherwise `Nothing`.","ref":"Funx.Monad.Maybe.html#lift_predicate/2"},{"type":"function","title":"Examples - Funx.Monad.Maybe.lift_predicate/2","doc":"iex> Funx.Monad.Maybe.lift_predicate(5, fn x -> x > 3 end)\n    %Funx.Monad.Maybe.Just{value: 5}\n\n    iex> Funx.Monad.Maybe.lift_predicate(2, fn x -> x > 3 end)\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Monad.Maybe.html#lift_predicate/2-examples"},{"type":"function","title":"Funx.Monad.Maybe.nothing/0","doc":"Returns a `Nothing` value.","ref":"Funx.Monad.Maybe.html#nothing/0"},{"type":"function","title":"Examples - Funx.Monad.Maybe.nothing/0","doc":"iex> Funx.Monad.Maybe.nothing()\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Monad.Maybe.html#nothing/0-examples"},{"type":"function","title":"Funx.Monad.Maybe.nothing?/1","doc":"Returns `true` if the `Maybe` is `Nothing`, otherwise `false`.","ref":"Funx.Monad.Maybe.html#nothing?/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.nothing?/1","doc":"iex> Funx.Monad.Maybe.nothing?(Funx.Monad.Maybe.nothing())\n    true\n\n    iex> Funx.Monad.Maybe.nothing?(Funx.Monad.Maybe.just(5))\n    false","ref":"Funx.Monad.Maybe.html#nothing?/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.or_else/2","doc":"Returns the current `Just` value or invokes the `fallback_fun` if `Nothing`.","ref":"Funx.Monad.Maybe.html#or_else/2"},{"type":"function","title":"Examples - Funx.Monad.Maybe.or_else/2","doc":"iex> Funx.Monad.Maybe.or_else(Funx.Monad.Maybe.nothing(), fn -> Funx.Monad.Maybe.just(42) end)\n    %Funx.Monad.Maybe.Just{value: 42}\n\n    iex> Funx.Monad.Maybe.or_else(Funx.Monad.Maybe.just(10), fn -> Funx.Monad.Maybe.just(42) end)\n    %Funx.Monad.Maybe.Just{value: 10}","ref":"Funx.Monad.Maybe.html#or_else/2-examples"},{"type":"function","title":"Funx.Monad.Maybe.pure/1","doc":"Alias for `just/1`.","ref":"Funx.Monad.Maybe.html#pure/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.pure/1","doc":"iex> Funx.Monad.Maybe.pure(5)\n    %Funx.Monad.Maybe.Just{value: 5}","ref":"Funx.Monad.Maybe.html#pure/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.sequence/1","doc":"Converts a list of `Maybe` values into a `Maybe` containing a list. If any element is `Nothing`, the entire result is `Nothing`.","ref":"Funx.Monad.Maybe.html#sequence/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.sequence/1","doc":"iex> Funx.Monad.Maybe.sequence([Funx.Monad.Maybe.just(1), Funx.Monad.Maybe.just(2)])\n    %Funx.Monad.Maybe.Just{value: [1, 2]}\n\n    iex> Funx.Monad.Maybe.sequence([Funx.Monad.Maybe.just(1), Funx.Monad.Maybe.nothing()])\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Monad.Maybe.html#sequence/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.to_nil/1","doc":"Converts a `Maybe` to its wrapped value or `nil`.","ref":"Funx.Monad.Maybe.html#to_nil/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.to_nil/1","doc":"iex> Funx.Monad.Maybe.to_nil(Funx.Monad.Maybe.just(5))\n    5\n\n    iex> Funx.Monad.Maybe.to_nil(Funx.Monad.Maybe.nothing())\n    nil","ref":"Funx.Monad.Maybe.html#to_nil/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.to_predicate/1","doc":"Returns `true` if the given `Maybe` is a `Just`, or `false` if it is `Nothing`.\n\nThis provides a simple way to treat a `Maybe` as a boolean condition, useful when filtering or making branching decisions based on presence.","ref":"Funx.Monad.Maybe.html#to_predicate/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.to_predicate/1","doc":"iex> Funx.Monad.Maybe.to_predicate(Funx.Monad.Maybe.just(42))\n    true\n\n    iex> Funx.Monad.Maybe.to_predicate(Funx.Monad.Maybe.nothing())\n    false\n\nRaises an error if the input is not a `Just` or `Nothing`.","ref":"Funx.Monad.Maybe.html#to_predicate/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.to_result/1","doc":"Converts a `Maybe` to a result tuple. `Just(value)` becomes `{:ok, value}`, while `Nothing` becomes `{:error, :nothing}`.","ref":"Funx.Monad.Maybe.html#to_result/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.to_result/1","doc":"iex> Funx.Monad.Maybe.to_result(Funx.Monad.Maybe.just(5))\n    {:ok, 5}\n\n    iex> Funx.Monad.Maybe.to_result(Funx.Monad.Maybe.nothing())\n    {:error, :nothing}","ref":"Funx.Monad.Maybe.html#to_result/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.to_try!/2","doc":"Extracts a value from a `Maybe`, raising an exception if `Nothing`.","ref":"Funx.Monad.Maybe.html#to_try!/2"},{"type":"function","title":"Examples - Funx.Monad.Maybe.to_try!/2","doc":"iex> Funx.Monad.Maybe.to_try!(Funx.Monad.Maybe.just(5))\n    5\n\n    iex> Funx.Monad.Maybe.to_try!(Funx.Monad.Maybe.nothing(), \"No value found\")\n    ** (RuntimeError) No value found","ref":"Funx.Monad.Maybe.html#to_try!/2-examples"},{"type":"function","title":"Funx.Monad.Maybe.traverse/2","doc":"Applies a function to each element of a list, collecting results into a single `Maybe`. If any call returns `Nothing`, the operation halts and returns `Nothing`.","ref":"Funx.Monad.Maybe.html#traverse/2"},{"type":"function","title":"Examples - Funx.Monad.Maybe.traverse/2","doc":"iex> Funx.Monad.Maybe.traverse([1, 2], fn x -> Funx.Monad.Maybe.just(x * 2) end)\n    %Funx.Monad.Maybe.Just{value: [2, 4]}\n\n    iex> Funx.Monad.Maybe.traverse([1, nil, 3], fn\n    ...>   nil -> Funx.Monad.Maybe.nothing()\n    ...>   x -> Funx.Monad.Maybe.just(x * 2)\n    ...> end)\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Monad.Maybe.html#traverse/2-examples"},{"type":"type","title":"Funx.Monad.Maybe.t/1","doc":"","ref":"Funx.Monad.Maybe.html#t:t/1"},{"type":"module","title":"Funx.Monad.Maybe.Just","doc":"Represents the `Just` variant of the `Maybe` monad, used to model the presence of a value.\n\nA `Just` wraps a single value and participates in functional composition by propagating the contained value through monadic operations.\n\nThis module implements the following protocols:\n\n  - `Funx.Monad`: Implements `bind/2`, `map/2`, and `ap/2` for monadic composition.\n  - `Funx.Foldable`: Provides `fold_l/3` and `fold_r/3` to fold over the wrapped value.\n  - `Funx.Filterable`: Supports filtering with `filter/2`, `filter_map/2`, and `guard/2`.\n  - `Funx.Eq`: Enables equality checks between `Just` and other `Maybe` values.\n  - `Funx.Ord`: Defines ordering behavior between `Just` and `Nothing`.\n\nThese protocol implementations allow `Just` to participate in structured computation, validation, filtering, and comparison within the `Maybe` context.","ref":"Funx.Monad.Maybe.Just.html"},{"type":"function","title":"Funx.Monad.Maybe.Just.pure/1","doc":"Creates a new `Just` value.\n\nThe `pure/1` function wraps a value in the `Just` monad, representing the presence of the value.","ref":"Funx.Monad.Maybe.Just.html#pure/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.Just.pure/1","doc":"iex> Funx.Monad.Maybe.Just.pure(5)\n    %Funx.Monad.Maybe.Just{value: 5}","ref":"Funx.Monad.Maybe.Just.html#pure/1-examples"},{"type":"function","title":"Raises - Funx.Monad.Maybe.Just.pure/1","doc":"- `ArgumentError` if `nil` is provided.\n\n    iex> Funx.Monad.Maybe.Just.pure(nil)\n    ** (ArgumentError) Cannot wrap nil in a Just","ref":"Funx.Monad.Maybe.Just.html#pure/1-raises"},{"type":"type","title":"Funx.Monad.Maybe.Just.t/1","doc":"","ref":"Funx.Monad.Maybe.Just.html#t:t/1"},{"type":"module","title":"Funx.Monad.Maybe.Nothing","doc":"Represents the `Nothing` variant of the `Maybe` monad, used to model the absence of a value.\n\nA `Nothing` indicates that no value is present. All operations in the monad context simply propagate the absence, making `Nothing` an identity for failure or emptiness.\n\nThis module implements the following protocols:\n\n  - `Funx.Monad`: Implements `bind/2`, `map/2`, and `ap/2`, all of which return `Nothing`.\n  - `Funx.Foldable`: Provides `fold_l/3` and `fold_r/3`, invoking the fallback function when folding.\n  - `Funx.Filterable`: Supports filtering operations, which always return `Nothing`.\n  - `Funx.Eq`: Enables equality checks between `Nothing` and other `Maybe` values.\n  - `Funx.Ord`: Defines ordering behavior between `Nothing` and `Just`.\n\nThese implementations ensure that `Nothing` behaves consistently in functional composition, filtering, and comparison, treating absence as a stable and composable case.","ref":"Funx.Monad.Maybe.Nothing.html"},{"type":"function","title":"Funx.Monad.Maybe.Nothing.pure/0","doc":"Creates a new `Nothing` value.","ref":"Funx.Monad.Maybe.Nothing.html#pure/0"},{"type":"function","title":"Examples - Funx.Monad.Maybe.Nothing.pure/0","doc":"iex> Funx.Monad.Maybe.Nothing.pure()\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Monad.Maybe.Nothing.html#pure/0-examples"},{"type":"type","title":"Funx.Monad.Maybe.Nothing.t/0","doc":"","ref":"Funx.Monad.Maybe.Nothing.html#t:t/0"},{"type":"module","title":"Funx.Monad.Reader","doc":"The `Funx.Monad.Reader` module represents the Reader monad, which allows computations to access\nshared, read-only environment values.\n\nThis module defines core Reader functions:\n\n  * `pure/1` – Lifts a value into the Reader context.\n  * `run/2` – Executes the Reader with a given environment.\n  * `asks/1` – Extracts and transforms a value from the environment.\n  * `ask/0` – Extracts the full environment.\n\nThis module implements the following protocol:\n\n  * `Funx.Monad`: Implements `bind/2`, `map/2`, and `ap/2` for monadic composition.\n\nNote: The Reader monad does not implement `Eq` or `Ord`, since Readers are lazy— they do not actually contain a value until they are run. We only can compare the results of a Reader, not the Reader itself.","ref":"Funx.Monad.Reader.html"},{"type":"function","title":"Funx.Monad.Reader.ask/0","doc":"Extracts the value contained in the environment, making it available within the Reader context.","ref":"Funx.Monad.Reader.html#ask/0"},{"type":"function","title":"Examples - Funx.Monad.Reader.ask/0","doc":"iex> reader = Funx.Monad.Reader.ask()\n    iex> Funx.Monad.Reader.run(reader, %{foo: \"bar\"})\n    %{foo: \"bar\"}","ref":"Funx.Monad.Reader.html#ask/0-examples"},{"type":"function","title":"Funx.Monad.Reader.asks/1","doc":"Extracts and transforms the value contained in the environment, making it available within the Reader context.","ref":"Funx.Monad.Reader.html#asks/1"},{"type":"function","title":"Examples - Funx.Monad.Reader.asks/1","doc":"iex> reader = Funx.Monad.Reader.asks(fn env -> Map.get(env, :foo) end)\n    iex> Funx.Monad.Reader.run(reader, %{foo: \"bar\"})\n    \"bar\"","ref":"Funx.Monad.Reader.html#asks/1-examples"},{"type":"function","title":"Funx.Monad.Reader.pure/1","doc":"Lifts a value into the `Reader` context.","ref":"Funx.Monad.Reader.html#pure/1"},{"type":"function","title":"Examples - Funx.Monad.Reader.pure/1","doc":"iex> reader = Funx.Monad.Reader.pure(42)\n    iex> Funx.Monad.Reader.run(reader, %{})\n    42","ref":"Funx.Monad.Reader.html#pure/1-examples"},{"type":"function","title":"Funx.Monad.Reader.run/2","doc":"Runs the `Reader` with the provided environment, returning the computed value.","ref":"Funx.Monad.Reader.html#run/2"},{"type":"function","title":"Examples - Funx.Monad.Reader.run/2","doc":"iex> reader = Funx.Monad.Reader.pure(42)\n    iex> Funx.Monad.Reader.run(reader, %{})\n    42","ref":"Funx.Monad.Reader.html#run/2-examples"},{"type":"type","title":"Funx.Monad.Reader.t/2","doc":"","ref":"Funx.Monad.Reader.html#t:t/2"},{"type":"module","title":"Funx.Monad.Writer","doc":"The `Funx.Monad.Writer` module defines the Writer monad, which threads a log alongside a computed result.\n\nLogs are accumulated using a `Monoid` implementation, injected lazily at runtime. This makes the Writer monad flexible and monoid-polymorphic—supporting lists, strings, or any user-defined monoid.","ref":"Funx.Monad.Writer.html"},{"type":"module","title":"Core functions - Funx.Monad.Writer","doc":"* `pure/1` – Wraps a result with an empty log.\n  * `writer/1` – Wraps a result and an explicit log.\n  * `tell/1` – Emits a log with no result.\n  * `listen/1` – Returns both result and log as a pair.\n  * `censor/2` – Applies a function to transform the final log.\n  * `pass/1` – Uses a log-transforming function returned from within the computation.\n  * `run/2` – Executes the Writer and returns a `%Writer.Result{}` with result and log.\n  * `eval/2` – Executes and returns only the result.\n  * `exec/2` – Executes and returns only the log.\n\nBy default, the `ListConcat` monoid is used unless a different monoid is passed to `run`, `eval`, or `exec`.\n\nThis module also implements the `Funx.Monad` protocol.","ref":"Funx.Monad.Writer.html#module-core-functions"},{"type":"function","title":"Funx.Monad.Writer.censor/2","doc":"Transforms the final log by applying a function to it.\n\nThe result remains unchanged—only the log is modified.","ref":"Funx.Monad.Writer.html#censor/2"},{"type":"function","title":"Example - Funx.Monad.Writer.censor/2","doc":"iex> writer = Funx.Monad.Writer.writer({\"ok\", [:a, :b]})\n    iex> censored = Funx.Monad.Writer.censor(writer, fn log -> Enum.reverse(log) end)\n    iex> result = Funx.Monad.Writer.run(censored)\n    iex> result.value\n    \"ok\"\n    iex> result.log\n    [:b, :a]","ref":"Funx.Monad.Writer.html#censor/2-example"},{"type":"function","title":"Funx.Monad.Writer.eval/2","doc":"Executes the Writer and returns only the final result value.\n\nUses `ListConcat` by default.","ref":"Funx.Monad.Writer.html#eval/2"},{"type":"function","title":"Example - Funx.Monad.Writer.eval/2","doc":"iex> writer =\n    ...>   Funx.Monad.Writer.writer({10, [:init]})\n    ...>   |> Funx.Monad.bind(fn x ->\n    ...>     Funx.Monad.Writer.tell([:logged])\n    ...>     |> Funx.Monad.bind(fn _ -> Funx.Monad.Writer.pure(x * 2) end)\n    ...>   end)\n    iex> Funx.Monad.Writer.eval(writer)\n    20","ref":"Funx.Monad.Writer.html#eval/2-example"},{"type":"function","title":"Funx.Monad.Writer.exec/2","doc":"Executes the Writer and returns only the final accumulated log.\n\nUses `ListConcat` by default.","ref":"Funx.Monad.Writer.html#exec/2"},{"type":"function","title":"Example - Funx.Monad.Writer.exec/2","doc":"iex> writer =\n    ...>   Funx.Monad.Writer.writer({:ok, [:step1]})\n    ...>   |> Funx.Monad.bind(fn _ -> Funx.Monad.Writer.tell([:step2]) end)\n    iex> Funx.Monad.Writer.exec(writer)\n    [:step1, :step2]","ref":"Funx.Monad.Writer.html#exec/2-example"},{"type":"function","title":"Funx.Monad.Writer.listen/1","doc":"Captures the current log and returns it alongside the result.\n\nThe log remains unchanged—only the result is modified to include it.","ref":"Funx.Monad.Writer.html#listen/1"},{"type":"function","title":"Example - Funx.Monad.Writer.listen/1","doc":"iex> writer = Funx.Monad.Writer.writer({\"done\", [:start, :finish]})\n    iex> listened = Funx.Monad.Writer.listen(writer)\n    iex> result = Funx.Monad.Writer.run(listened)\n    iex> result.value\n    {\"done\", [:start, :finish]}\n    iex> result.log\n    [:start, :finish]","ref":"Funx.Monad.Writer.html#listen/1-example"},{"type":"function","title":"Funx.Monad.Writer.pass/1","doc":"Applies a log-transforming function that is returned from within the computation.\n\nThis allows the result of a computation to include not only a value, but also\na function that modifies the final accumulated log.\n\nThe input to `pass/1` must be a Writer containing a tuple `{result, f}`, where\n`f` is a function from log to log. This function will be applied to the final log\njust before it's returned.","ref":"Funx.Monad.Writer.html#pass/1"},{"type":"function","title":"Example - Funx.Monad.Writer.pass/1","doc":"iex> result =\n    ...>   Funx.Monad.Writer.pure({\"done\", fn log -> log ++ [:transformed] end})\n    ...>   |> Funx.Monad.Writer.pass()\n    ...>   |> Funx.Monad.Writer.run()\n    iex> result.value\n    \"done\"\n    iex> result.log\n    [:transformed]","ref":"Funx.Monad.Writer.html#pass/1-example"},{"type":"function","title":"Funx.Monad.Writer.pure/1","doc":"Wraps a value with no log.","ref":"Funx.Monad.Writer.html#pure/1"},{"type":"function","title":"Example - Funx.Monad.Writer.pure/1","doc":"iex> writer = Funx.Monad.Writer.pure(42)\n    iex> result = Funx.Monad.Writer.run(writer)\n    iex> result.value\n    42\n    iex> result.log\n    []","ref":"Funx.Monad.Writer.html#pure/1-example"},{"type":"function","title":"Funx.Monad.Writer.run/2","doc":"Executes the Writer and returns both the result and the final accumulated log.\n\nBy default, it uses `ListConcat` unless a monoid is explicitly passed.","ref":"Funx.Monad.Writer.html#run/2"},{"type":"function","title":"Example - Funx.Monad.Writer.run/2","doc":"iex> writer = Funx.Monad.Writer.writer({\"ok\", [:a, :b]})\n    iex> result = Funx.Monad.Writer.run(writer)\n    iex> result.value\n    \"ok\"\n    iex> result.log\n    [:a, :b]","ref":"Funx.Monad.Writer.html#run/2-example"},{"type":"function","title":"Funx.Monad.Writer.tell/1","doc":"Appends a log value using the monoid, returning `:ok` as the result.","ref":"Funx.Monad.Writer.html#tell/1"},{"type":"function","title":"Example - Funx.Monad.Writer.tell/1","doc":"iex> writer = Funx.Monad.Writer.tell([:event])\n    iex> result = Funx.Monad.Writer.run(writer)\n    iex> result.value\n    :ok\n    iex> result.log\n    [:event]","ref":"Funx.Monad.Writer.html#tell/1-example"},{"type":"function","title":"Funx.Monad.Writer.writer/1","doc":"Wraps both a value and a raw log into the Writer context.","ref":"Funx.Monad.Writer.html#writer/1"},{"type":"function","title":"Example - Funx.Monad.Writer.writer/1","doc":"iex> writer = Funx.Monad.Writer.writer({:ok, [:step1, :step2]})\n    iex> result = Funx.Monad.Writer.run(writer)\n    iex> result.value\n    :ok\n    iex> result.log\n    [:step1, :step2]","ref":"Funx.Monad.Writer.html#writer/1-example"},{"type":"type","title":"Funx.Monad.Writer.t/1","doc":"Represents a computation that produces a result along with a log,\naccumulated using a monoid.\n\nThe internal `writer` function takes an initial monoid and returns\na `{value, monoid}` tuple, where the monoid contains the accumulated log.","ref":"Funx.Monad.Writer.html#t:t/1"},{"type":"module","title":"Funx.Monad.Writer.Result","doc":"Represents the result of running a Writer computation:\nthe final value and the accumulated monoid.","ref":"Funx.Monad.Writer.Result.html"},{"type":"type","title":"Funx.Monad.Writer.Result.t/2","doc":"","ref":"Funx.Monad.Writer.Result.html#t:t/2"},{"type":"protocol","title":"Funx.Monoid","doc":"A protocol defining the Monoid algebraic structure, which consists of\nan identity element and an associative binary operation for combining values.\n\nThis protocol provides four key functions:\n\n- `empty/1`: Returns the identity element for the given monoid.\n- `append/2`: Combines two monoid structs.\n- `wrap/2`: Wraps a value into the monoid struct.\n- `unwrap/1`: Extracts the underlying value from the monoid struct.","ref":"Funx.Monoid.html"},{"type":"function","title":"Funx.Monoid.append/2","doc":"Combines two monoid structs.\n\nThe operation must satisfy associativity:\n\n    append(append(a, b), c) == append(a, append(b, c))","ref":"Funx.Monoid.html#append/2"},{"type":"function","title":"Examples - Funx.Monoid.append/2","doc":"iex> Funx.Monoid.append(%Funx.Monoid.Sum{value: 1}, %Funx.Monoid.Sum{value: 2})\n    %Funx.Monoid.Sum{value: 3}","ref":"Funx.Monoid.html#append/2-examples"},{"type":"function","title":"Funx.Monoid.empty/1","doc":"Returns the identity element for the given monoid struct.\n\nThe identity element is a special value that satisfies the property:\n\n    append(empty(monoid_struct), x) == x\n    append(x, empty(monoid_struct)) == x","ref":"Funx.Monoid.html#empty/1"},{"type":"function","title":"Examples - Funx.Monoid.empty/1","doc":"iex> Funx.Monoid.empty(%Funx.Monoid.Sum{})\n    %Funx.Monoid.Sum{value: 0}","ref":"Funx.Monoid.html#empty/1-examples"},{"type":"function","title":"Funx.Monoid.unwrap/1","doc":"Extracts the underlying value from the monoid struct.","ref":"Funx.Monoid.html#unwrap/1"},{"type":"function","title":"Examples - Funx.Monoid.unwrap/1","doc":"iex> Funx.Monoid.unwrap(%Funx.Monoid.Sum{value: 10})\n    10","ref":"Funx.Monoid.html#unwrap/1-examples"},{"type":"function","title":"Funx.Monoid.wrap/2","doc":"Wraps a value into the given monoid struct.","ref":"Funx.Monoid.html#wrap/2"},{"type":"function","title":"Examples - Funx.Monoid.wrap/2","doc":"iex> Funx.Monoid.wrap(%Funx.Monoid.Sum{}, 10)\n    %Funx.Monoid.Sum{value: 10}","ref":"Funx.Monoid.html#wrap/2-examples"},{"type":"type","title":"Funx.Monoid.t/0","doc":"All the types that implement this protocol.","ref":"Funx.Monoid.html#t:t/0"},{"type":"module","title":"Funx.Monoid.Eq.All","doc":"A Monoid implementation for equality checks for All.","ref":"Funx.Monoid.Eq.All.html"},{"type":"function","title":"Funx.Monoid.Eq.All.default_eq?/2","doc":"","ref":"Funx.Monoid.Eq.All.html#default_eq?/2"},{"type":"function","title":"Funx.Monoid.Eq.All.default_not_eq?/2","doc":"","ref":"Funx.Monoid.Eq.All.html#default_not_eq?/2"},{"type":"type","title":"Funx.Monoid.Eq.All.t/0","doc":"","ref":"Funx.Monoid.Eq.All.html#t:t/0"},{"type":"module","title":"Funx.Monoid.Eq.Any","doc":"A Monoid implementation for equality checks for Any.","ref":"Funx.Monoid.Eq.Any.html"},{"type":"function","title":"Funx.Monoid.Eq.Any.default_eq?/2","doc":"","ref":"Funx.Monoid.Eq.Any.html#default_eq?/2"},{"type":"function","title":"Funx.Monoid.Eq.Any.default_not_eq?/2","doc":"","ref":"Funx.Monoid.Eq.Any.html#default_not_eq?/2"},{"type":"type","title":"Funx.Monoid.Eq.Any.t/0","doc":"","ref":"Funx.Monoid.Eq.Any.html#t:t/0"},{"type":"module","title":"Funx.Monoid.ListConcat","doc":"A Monoid implementation for concatenating lists.\n\nThis monoid uses list concatenation as its associative operation\nand `[]` as the identity element.","ref":"Funx.Monoid.ListConcat.html"},{"type":"type","title":"Funx.Monoid.ListConcat.t/0","doc":"","ref":"Funx.Monoid.ListConcat.html#t:t/0"},{"type":"module","title":"Funx.Monoid.Max","doc":"A Monoid implementation for maximum values.","ref":"Funx.Monoid.Max.html"},{"type":"module","title":"Funx.Monoid.Min","doc":"A Monoid implementation for minimum values.","ref":"Funx.Monoid.Min.html"},{"type":"module","title":"Funx.Monoid.Ord","doc":"A monoid implementation for ordering logic (Ord).\nProvides default comparison functions and supports combining multiple\n`Ord` comparators into a single composite comparator.","ref":"Funx.Monoid.Ord.html"},{"type":"function","title":"Funx.Monoid.Ord.default?/2","doc":"","ref":"Funx.Monoid.Ord.html#default?/2"},{"type":"type","title":"Funx.Monoid.Ord.t/0","doc":"","ref":"Funx.Monoid.Ord.html#t:t/0"},{"type":"module","title":"Funx.Monoid.Predicate.All","doc":"A Monoid implementation for combining predicates using logical AND.","ref":"Funx.Monoid.Predicate.All.html"},{"type":"function","title":"Funx.Monoid.Predicate.All.default_pred?/1","doc":"","ref":"Funx.Monoid.Predicate.All.html#default_pred?/1"},{"type":"module","title":"Funx.Monoid.Predicate.Any","doc":"A Monoid implementation for combining predicates using logical OR.","ref":"Funx.Monoid.Predicate.Any.html"},{"type":"function","title":"Funx.Monoid.Predicate.Any.default_pred?/1","doc":"","ref":"Funx.Monoid.Predicate.Any.html#default_pred?/1"},{"type":"module","title":"Funx.Monoid.Product","doc":"A Monoid implementation for products.\n\nThis monoid uses multiplication as its associative operation\nand `1` as the identity element.","ref":"Funx.Monoid.Product.html"},{"type":"type","title":"Funx.Monoid.Product.t/0","doc":"","ref":"Funx.Monoid.Product.html#t:t/0"},{"type":"module","title":"Funx.Monoid.StringConcat","doc":"A Monoid implementation for concatenating strings.\n\nThis monoid uses binary string concatenation (`<>`) as its associative operation\nand `\"\"` (empty string) as the identity element.","ref":"Funx.Monoid.StringConcat.html"},{"type":"type","title":"Funx.Monoid.StringConcat.t/0","doc":"","ref":"Funx.Monoid.StringConcat.html#t:t/0"},{"type":"module","title":"Funx.Monoid.Sum","doc":"A Monoid implementation for sums.\n\nThis monoid uses addition as its associative operation\nand `0` as the identity element.","ref":"Funx.Monoid.Sum.html"},{"type":"type","title":"Funx.Monoid.Sum.t/0","doc":"","ref":"Funx.Monoid.Sum.html#t:t/0"},{"type":"module","title":"Funx.Monoid.Utils","doc":"Utility functions for working with Monoids.\n\nThis module provides functions to combine monoidal values using\n`m_append/3` and `m_concat/2`.","ref":"Funx.Monoid.Utils.html"},{"type":"function","title":"Funx.Monoid.Utils.m_append/3","doc":"Appends two values within a given monoid.\n\nThis function wraps the input values using the provided `monoid`, applies\nthe `append/2` operation, and then unwraps the result.","ref":"Funx.Monoid.Utils.html#m_append/3"},{"type":"function","title":"Parameters - Funx.Monoid.Utils.m_append/3","doc":"- `monoid` – A monoid struct defining how values should be combined.\n  - `a` – The first raw value.\n  - `b` – The second raw value.","ref":"Funx.Monoid.Utils.html#m_append/3-parameters"},{"type":"function","title":"Examples - Funx.Monoid.Utils.m_append/3","doc":"iex> alias Funx.Monoid.Sum\n    iex> Funx.Monoid.Utils.m_append(%Sum{}, 3, 5)\n    8","ref":"Funx.Monoid.Utils.html#m_append/3-examples"},{"type":"function","title":"Funx.Monoid.Utils.m_concat/2","doc":"Concatenates a list of values using the given monoid.\n\nThis function wraps each value using the provided `monoid`, folds the list\nusing the monoid's identity and append operation, and then unwraps the result.","ref":"Funx.Monoid.Utils.html#m_concat/2"},{"type":"function","title":"Parameters - Funx.Monoid.Utils.m_concat/2","doc":"- `monoid` – A monoid struct defining how values should be combined.\n  - `values` – A list of raw values.","ref":"Funx.Monoid.Utils.html#m_concat/2-parameters"},{"type":"function","title":"Examples - Funx.Monoid.Utils.m_concat/2","doc":"iex> alias Funx.Monoid.Sum\n    iex> Funx.Monoid.Utils.m_concat(%Sum{}, [1, 2, 3])\n    6","ref":"Funx.Monoid.Utils.html#m_concat/2-examples"},{"type":"protocol","title":"Funx.Ord","doc":"The `Funx.Ord` protocol defines a set of comparison functions: `lt?/2`, `le?/2`, `gt?/2`, and `ge?/2`.\n\nThis protocol is intended for types that can be ordered, allowing values to be compared for their relative positions in a total order.\n\nBy implementing this protocol, you can provide custom logic for how values of a certain type are compared.","ref":"Funx.Ord.html"},{"type":"protocol","title":"Fallback - Funx.Ord","doc":"The protocol uses `@fallback_to_any true`, which means if a specific type does not implement `Funx.Ord`,\nthe default implementation for `Any` will be used, which relies on Elixir's built-in comparison operators.","ref":"Funx.Ord.html#module-fallback"},{"type":"function","title":"Funx.Ord.ge?/2","doc":"Returns `true` if `a` is greater than or equal to `b`, otherwise returns `false`.","ref":"Funx.Ord.html#ge?/2"},{"type":"function","title":"Examples - Funx.Ord.ge?/2","doc":"iex> Funx.Ord.ge?(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.just(3))\n    true\n\n    iex> Funx.Ord.ge?(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.just(5))\n    true\n\n    iex> Funx.Ord.ge?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(5))\n    false","ref":"Funx.Ord.html#ge?/2-examples"},{"type":"function","title":"Funx.Ord.gt?/2","doc":"Returns `true` if `a` is greater than `b`, otherwise returns `false`.","ref":"Funx.Ord.html#gt?/2"},{"type":"function","title":"Examples - Funx.Ord.gt?/2","doc":"iex> Funx.Ord.gt?(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.just(3))\n    true\n\n    iex> Funx.Ord.gt?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(5))\n    false\n\n    iex> Funx.Ord.gt?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.nothing())\n    true","ref":"Funx.Ord.html#gt?/2-examples"},{"type":"function","title":"Funx.Ord.le?/2","doc":"Returns `true` if `a` is less than or equal to `b`, otherwise returns `false`.","ref":"Funx.Ord.html#le?/2"},{"type":"function","title":"Examples - Funx.Ord.le?/2","doc":"iex> Funx.Ord.le?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(5))\n    true\n\n    iex> Funx.Ord.le?(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.just(5))\n    true\n\n    iex> Funx.Ord.le?(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.just(3))\n    false","ref":"Funx.Ord.html#le?/2-examples"},{"type":"function","title":"Funx.Ord.lt?/2","doc":"Returns `true` if `a` is less than `b`, otherwise returns `false`.","ref":"Funx.Ord.html#lt?/2"},{"type":"function","title":"Examples - Funx.Ord.lt?/2","doc":"iex> Funx.Ord.lt?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(5))\n    true\n\n    iex> Funx.Ord.lt?(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.just(3))\n    false\n\n    iex> Funx.Ord.lt?(Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.just(3))\n    true","ref":"Funx.Ord.html#lt?/2-examples"},{"type":"type","title":"Funx.Ord.t/0","doc":"All the types that implement this protocol.","ref":"Funx.Ord.html#t:t/0"},{"type":"module","title":"Funx.Ord.Utils","doc":"Utility functions for working with the `Funx.Ord` protocol.\nThese functions assume that types passed in either support Elixir's comparison operators\nor implement the `Funx.Ord` protocol.","ref":"Funx.Ord.Utils.html"},{"type":"function","title":"Funx.Ord.Utils.append/2","doc":"Appends two `Ord` instances, combining their comparison logic.\n\nIf the first `Ord` comparator determines an order, that result is used.\nIf not, the second comparator is used as a fallback.","ref":"Funx.Ord.Utils.html#append/2"},{"type":"function","title":"Examples - Funx.Ord.Utils.append/2","doc":"iex> ord1 = Funx.Ord.Utils.contramap(& &1.age, Funx.Ord.Any)\n    iex> ord2 = Funx.Ord.Utils.contramap(& &1.name, Funx.Ord.Any)\n    iex> combined = Funx.Ord.Utils.append(ord1, ord2)\n    iex> combined.lt?.(%{age: 30, name: \"Alice\"}, %{age: 30, name: \"Bob\"})\n    true","ref":"Funx.Ord.Utils.html#append/2-examples"},{"type":"function","title":"Funx.Ord.Utils.between/4","doc":"Checks if `value` is between `min` and `max`, inclusive, with an optional custom `Ord`.","ref":"Funx.Ord.Utils.html#between/4"},{"type":"function","title":"Examples - Funx.Ord.Utils.between/4","doc":"iex> Funx.Ord.Utils.between(5, 1, 10)\n    true\n\n    iex> Funx.Ord.Utils.between(0, 1, 10)\n    false\n\n    iex> Funx.Ord.Utils.between(11, 1, 10)\n    false","ref":"Funx.Ord.Utils.html#between/4-examples"},{"type":"function","title":"Funx.Ord.Utils.clamp/4","doc":"Clamps a value between `min` and `max`, with an optional custom `Ord`.","ref":"Funx.Ord.Utils.html#clamp/4"},{"type":"function","title":"Examples - Funx.Ord.Utils.clamp/4","doc":"iex> Funx.Ord.Utils.clamp(5, 1, 10)\n    5\n\n    iex> Funx.Ord.Utils.clamp(0, 1, 10)\n    1\n\n    iex> Funx.Ord.Utils.clamp(15, 1, 10)\n    10","ref":"Funx.Ord.Utils.html#clamp/4-examples"},{"type":"function","title":"Funx.Ord.Utils.comparator/1","doc":"Creates a comparator function from the given `Ord` module, returning `true`\nif `a` is less than or equal to `b` according to the module’s ordering.\n\nUseful for sorting with `Enum.sort/2` or similar functions.","ref":"Funx.Ord.Utils.html#comparator/1"},{"type":"function","title":"Examples - Funx.Ord.Utils.comparator/1","doc":"iex> comparator = Funx.Ord.Utils.comparator(Funx.Ord.Any)\n    iex> Enum.sort([3, 1, 2], comparator)\n    [1, 2, 3]","ref":"Funx.Ord.Utils.html#comparator/1-examples"},{"type":"function","title":"Funx.Ord.Utils.compare/3","doc":"Compares two values and returns `:lt`, `:eq`, or `:gt`, with an optional custom `Ord`.","ref":"Funx.Ord.Utils.html#compare/3"},{"type":"function","title":"Examples - Funx.Ord.Utils.compare/3","doc":"iex> Funx.Ord.Utils.compare(3, 5)\n    :lt\n\n    iex> Funx.Ord.Utils.compare(7, 7)\n    :eq\n\n    iex> Funx.Ord.Utils.compare(9, 4)\n    :gt","ref":"Funx.Ord.Utils.html#compare/3-examples"},{"type":"function","title":"Funx.Ord.Utils.concat/1","doc":"Concatenates a list of `Ord` instances into a single composite comparator.\n\nThis function reduces a list of `Ord` comparators into a single `Ord`,\napplying them in sequence until an order is determined.","ref":"Funx.Ord.Utils.html#concat/1"},{"type":"function","title":"Examples - Funx.Ord.Utils.concat/1","doc":"iex> ord_list = [\n    ...>   Funx.Ord.Utils.contramap(& &1.age, Funx.Ord.Any),\n    ...>   Funx.Ord.Utils.contramap(& &1.name, Funx.Ord.Any)\n    ...> ]\n    iex> combined = Funx.Ord.Utils.concat(ord_list)\n    iex> combined.gt?.(%{age: 25, name: \"Charlie\"}, %{age: 25, name: \"Bob\"})\n    true","ref":"Funx.Ord.Utils.html#concat/1-examples"},{"type":"function","title":"Funx.Ord.Utils.contramap/2","doc":"Transforms an ordering by applying a function `f` to values before comparison.\n\nThe `ord` parameter can be an `Ord` module or a custom comparator map with comparison functions (`:lt?`, `:le?`, `:gt?`, and `:ge?`).\nWhen an `Ord` module is provided, it wraps the module’s functions to apply `f` to each value before invoking the comparison.\nIf a custom comparator map is provided, it wraps the functions in the map to apply `f` to each value.","ref":"Funx.Ord.Utils.html#contramap/2"},{"type":"function","title":"Examples - Funx.Ord.Utils.contramap/2","doc":"iex> ord = Funx.Ord.Utils.contramap(&String.length/1, Funx.Ord.Any)\n    iex> ord.lt?.(\"cat\", \"zebra\")\n    true","ref":"Funx.Ord.Utils.html#contramap/2-examples"},{"type":"function","title":"Funx.Ord.Utils.max/3","doc":"Returns the maximum of two values, with an optional custom `Ord`.","ref":"Funx.Ord.Utils.html#max/3"},{"type":"function","title":"Examples - Funx.Ord.Utils.max/3","doc":"iex> Funx.Ord.Utils.max(3, 5)\n    5\n\n    iex> ord = Funx.Ord.Utils.contramap(&String.length/1, Funx.Ord.Any)\n    iex> Funx.Ord.Utils.max(\"cat\", \"zebra\", ord)\n    \"zebra\"","ref":"Funx.Ord.Utils.html#max/3-examples"},{"type":"function","title":"Funx.Ord.Utils.min/3","doc":"Returns the minimum of two values, with an optional custom `Ord`.","ref":"Funx.Ord.Utils.html#min/3"},{"type":"function","title":"Examples - Funx.Ord.Utils.min/3","doc":"iex> Funx.Ord.Utils.min(10, 7)\n    7\n\n    iex> ord = Funx.Ord.Utils.contramap(&String.length/1, Funx.Ord.Any)\n    iex> Funx.Ord.Utils.min(\"apple\", \"kiwi\", ord)\n    \"kiwi\"","ref":"Funx.Ord.Utils.html#min/3-examples"},{"type":"function","title":"Funx.Ord.Utils.reverse/1","doc":"Reverses the ordering logic.","ref":"Funx.Ord.Utils.html#reverse/1"},{"type":"function","title":"Examples - Funx.Ord.Utils.reverse/1","doc":"iex> ord = Funx.Ord.Utils.reverse(Funx.Ord.Any)\n    iex> ord.lt?.(10, 5)\n    true","ref":"Funx.Ord.Utils.html#reverse/1-examples"},{"type":"function","title":"Funx.Ord.Utils.to_eq/1","doc":"Converts an `Ord` instance into an equality comparator.\n\nThis function creates a map containing two functions:\n  - `eq?/2`: Returns `true` if `a` and `b` are considered equal by the given `Ord`.\n  - `not_eq?/2`: Returns `true` if `a` and `b` are not considered equal by the given `Ord`.","ref":"Funx.Ord.Utils.html#to_eq/1"},{"type":"function","title":"Examples - Funx.Ord.Utils.to_eq/1","doc":"iex> eq = Funx.Ord.Utils.to_eq(Funx.Ord.Any)\n    iex> eq.eq?.(5, 5)\n    true","ref":"Funx.Ord.Utils.html#to_eq/1-examples"},{"type":"function","title":"Funx.Ord.Utils.to_ord_map/1","doc":"","ref":"Funx.Ord.Utils.html#to_ord_map/1"},{"type":"type","title":"Funx.Ord.Utils.ord_map/0","doc":"","ref":"Funx.Ord.Utils.html#t:ord_map/0"},{"type":"type","title":"Funx.Ord.Utils.ord_t/0","doc":"","ref":"Funx.Ord.Utils.html#t:ord_t/0"},{"type":"module","title":"Funx.Predicate","doc":"Provides utility functions for working with predicates—functions that return `true` or `false`.\n\nThis module enables combining predicates in a declarative way using logical operations:\n\n- `p_and/2`: Returns `true` if **both** predicates are `true`.\n- `p_or/2`: Returns `true` if **at least one** predicate is `true`.\n- `p_not/1`: Negates a predicate.\n- `p_all/1`: Returns `true` if **all** predicates in a list are `true`.\n- `p_any/1`: Returns `true` if **any** predicate in a list is `true`.\n- `p_none/1`: Returns `true` if **none** of the predicates in a list are `true`.\n\nThese functions simplify complex conditional logic.","ref":"Funx.Predicate.html"},{"type":"module","title":"Examples - Funx.Predicate","doc":"","ref":"Funx.Predicate.html#module-examples"},{"type":"module","title":"Combining predicates with `p_and/2`: - Funx.Predicate","doc":"iex> is_adult = fn person -> person.age >= 18 end\n    iex> has_ticket = fn person -> person.tickets > 0 end\n    iex> can_enter = Funx.Predicate.p_and(is_adult, has_ticket)\n\n    iex> can_enter.(%{age: 20, tickets: 1})\n    true\n    iex> can_enter.(%{age: 16, tickets: 1})\n    false","ref":"Funx.Predicate.html#module-combining-predicates-with-p_and-2"},{"type":"module","title":"Using `p_or/2` for alternative conditions: - Funx.Predicate","doc":"iex> is_vip = fn person -> person.vip end\n    iex> is_sponsor = fn person -> person.sponsor end\n    iex> can_access_vip_area = Funx.Predicate.p_or(is_vip, is_sponsor)\n\n    iex> can_access_vip_area.(%{vip: true, sponsor: false})\n    true\n    iex> can_access_vip_area.(%{vip: false, sponsor: false})\n    false","ref":"Funx.Predicate.html#module-using-p_or-2-for-alternative-conditions"},{"type":"module","title":"Negating predicates with `p_not/1`: - Funx.Predicate","doc":"iex> is_minor = fn person -> person.age < 18 end\n    iex> is_adult = Funx.Predicate.p_not(is_minor)\n\n    iex> is_adult.(%{age: 20})\n    true\n    iex> is_adult.(%{age: 16})\n    false","ref":"Funx.Predicate.html#module-negating-predicates-with-p_not-1"},{"type":"module","title":"Using `p_all/1` and `p_any/1` for predicate lists: - Funx.Predicate","doc":"iex> conditions = [is_adult, has_ticket]\n    iex> must_meet_all = Funx.Predicate.p_all(conditions)\n    iex> must_meet_any = Funx.Predicate.p_any(conditions)\n\n    iex> must_meet_all.(%{age: 20, tickets: 1})\n    true\n    iex> must_meet_all.(%{age: 20, tickets: 0})\n    false\n\n    iex> must_meet_any.(%{age: 20, tickets: 0})\n    true\n    iex> must_meet_any.(%{age: 16, tickets: 0})\n    false","ref":"Funx.Predicate.html#module-using-p_all-1-and-p_any-1-for-predicate-lists"},{"type":"module","title":"Using `p_none/1` to reject multiple conditions: - Funx.Predicate","doc":"iex> cannot_enter = Funx.Predicate.p_none([is_adult, is_vip])\n\n    iex> cannot_enter.(%{age: 20, ticket: :vip})\n    false\n    iex> cannot_enter.(%{age: 16, ticket: :basic})\n    true","ref":"Funx.Predicate.html#module-using-p_none-1-to-reject-multiple-conditions"},{"type":"function","title":"Funx.Predicate.p_all/1","doc":"Combines a list of predicates (`p_list`) using logical AND.\nReturns `true` only if all predicates return `true`. An empty list returns `true`.","ref":"Funx.Predicate.html#p_all/1"},{"type":"function","title":"Examples - Funx.Predicate.p_all/1","doc":"iex> can_enter = Funx.Predicate.p_all([is_adult, has_ticket])\n\n    iex> can_enter.(%{age: 20, tickets: 1})\n    true\n    iex> can_enter.(%{age: 16, tickets: 1})\n    false","ref":"Funx.Predicate.html#p_all/1-examples"},{"type":"function","title":"Funx.Predicate.p_and/2","doc":"Combines two predicates (`pred1` and `pred2`) using logical AND.\nReturns a predicate that evaluates to `true` only if both `pred1` and `pred2` return `true`.","ref":"Funx.Predicate.html#p_and/2"},{"type":"function","title":"Examples - Funx.Predicate.p_and/2","doc":"iex> is_adult = fn person -> person.age >= 18 end\n    iex> has_ticket = fn person -> person.tickets > 0 end\n    iex> can_enter = Funx.Predicate.p_and(is_adult, has_ticket)\n\n    iex> can_enter.(%{age: 20, tickets: 1})\n    true\n    iex> can_enter.(%{age: 16, tickets: 1})\n    false","ref":"Funx.Predicate.html#p_and/2-examples"},{"type":"function","title":"Funx.Predicate.p_any/1","doc":"Combines a list of predicates (`p_list`) using logical OR.\nReturns `true` if at least one predicate returns `true`. An empty list returns `false`.","ref":"Funx.Predicate.html#p_any/1"},{"type":"function","title":"Examples - Funx.Predicate.p_any/1","doc":"iex> can_access_vip_area = Funx.Predicate.p_any([is_vip, is_sponsor])\n\n    iex> can_access_vip_area.(%{vip: true, sponsor: false})\n    true\n    iex> can_access_vip_area.(%{vip: false, sponsor: false})\n    false","ref":"Funx.Predicate.html#p_any/1-examples"},{"type":"function","title":"Funx.Predicate.p_none/1","doc":"Combines a list of predicates (`p_list`) using logical NOR (negated OR).\nReturns `true` only if **none** of the predicates return `true`. An empty list returns `true`.","ref":"Funx.Predicate.html#p_none/1"},{"type":"function","title":"Examples - Funx.Predicate.p_none/1","doc":"iex> cannot_enter = Funx.Predicate.p_none([is_adult, is_vip])\n\n    iex> cannot_enter.(%{age: 20, ticket: :vip})\n    false\n    iex> cannot_enter.(%{age: 16, ticket: :basic})\n    true","ref":"Funx.Predicate.html#p_none/1-examples"},{"type":"function","title":"Funx.Predicate.p_not/1","doc":"Negates a predicate (`pred`).\nReturns a predicate that evaluates to `true` when `pred` returns `false`, and vice versa.","ref":"Funx.Predicate.html#p_not/1"},{"type":"function","title":"Examples - Funx.Predicate.p_not/1","doc":"iex> is_minor = fn person -> person.age < 18 end\n    iex> is_adult = Funx.Predicate.p_not(is_minor)\n\n    iex> is_adult.(%{age: 20})\n    true\n    iex> is_adult.(%{age: 16})\n    false","ref":"Funx.Predicate.html#p_not/1-examples"},{"type":"function","title":"Funx.Predicate.p_or/2","doc":"Combines two predicates (`pred1` and `pred2`) using logical OR.\nReturns a predicate that evaluates to `true` if either `pred1` or `pred2` return `true`.","ref":"Funx.Predicate.html#p_or/2"},{"type":"function","title":"Examples - Funx.Predicate.p_or/2","doc":"iex> is_vip = fn person -> person.vip end\n    iex> is_sponsor = fn person -> person.sponsor end\n    iex> can_access_vip_area = Funx.Predicate.p_or(is_vip, is_sponsor)\n\n    iex> can_access_vip_area.(%{vip: true, sponsor: false})\n    true\n    iex> can_access_vip_area.(%{vip: false, sponsor: false})\n    false","ref":"Funx.Predicate.html#p_or/2-examples"},{"type":"type","title":"Funx.Predicate.t/0","doc":"","ref":"Funx.Predicate.html#t:t/0"},{"type":"protocol","title":"Funx.Summarizable","doc":"","ref":"Funx.Summarizable.html"},{"type":"function","title":"Funx.Summarizable.summarize/1","doc":"Summarizes a value in a telemetry-safe, compact format.","ref":"Funx.Summarizable.html#summarize/1"},{"type":"type","title":"Funx.Summarizable.t/0","doc":"All the types that implement this protocol.","ref":"Funx.Summarizable.html#t:t/0"},{"type":"module","title":"Funx.Utils","doc":"A collection of higher-order functions for functional programming in Elixir.\n\nThis module provides utilities for working with functions in a functional\nprogramming style. It includes:\n\n- `curry/1`: Transforms a multi-argument function into a curried version.\n- `curry_r/1`: Transforms a multi-argument function into a curried version, but from right to left.\n- `flip/1`: Reverses the argument order of a two-argument function.","ref":"Funx.Utils.html"},{"type":"function","title":"Funx.Utils.curry/1","doc":"Transforms a function of arity `n` into a curried version,\nallowing it to be applied one argument at a time.","ref":"Funx.Utils.html#curry/1"},{"type":"function","title":"Example - Funx.Utils.curry/1","doc":"iex> add = fn a, b -> a + b end\n    iex> curried_add = FunPark.Utils.curry(add)\n    iex> add_three = curried_add.(3)\n    iex> add_three.(2)\n    5","ref":"Funx.Utils.html#curry/1-example"},{"type":"function","title":"Funx.Utils.curry_l/1","doc":"Alias for `curry/1`, explicitly denoting left-to-right argument application.","ref":"Funx.Utils.html#curry_l/1"},{"type":"function","title":"Example - Funx.Utils.curry_l/1","doc":"iex> subtract = fn a, b -> a - b end\n    iex> curried_subtract = FunPark.Utils.curry_l(subtract)\n    iex> subtract_five = curried_subtract.(5)\n    iex> subtract_five.(3)\n    2","ref":"Funx.Utils.html#curry_l/1-example"},{"type":"function","title":"Funx.Utils.curry_r/1","doc":"Transforms a function of arity `n` into a right-curried version,\napplying arguments from right to left.","ref":"Funx.Utils.html#curry_r/1"},{"type":"function","title":"Example - Funx.Utils.curry_r/1","doc":"iex> divide = fn a, b -> a / b end\n    iex> curried_divide = FunPark.Utils.curry_r(divide)\n    iex> divide_by_two = curried_divide.(2)\n    iex> divide_by_two.(10)\n    5.0","ref":"Funx.Utils.html#curry_r/1-example"},{"type":"function","title":"Funx.Utils.flip/1","doc":"Reverses the argument order of a two-argument function.\n\nThe `flip/1` function takes a function of arity 2 and returns a new function\nwhere the first and second arguments are swapped.","ref":"Funx.Utils.html#flip/1"},{"type":"function","title":"Examples - Funx.Utils.flip/1","doc":"iex> divide = fn a, b -> a / b end\n    iex> flipped_divide = Utils.flip(divide)\n    iex> flipped_divide.(2, 10)\n    5.0","ref":"Funx.Utils.html#flip/1-examples"},{"type":"function","title":"Funx.Utils.summarize_string/2","doc":"","ref":"Funx.Utils.html#summarize_string/2"},{"type":"exception","title":"Funx.Errors.EffectError","doc":"Represents a system-level failure in an effectful computation.\n\n`EffectError` is raised or returned when a failure occurs during the execution\nof an `Effect` stage, such as `map`, `bind`, or `ap`. It is not meant for user-facing\nvalidation, but rather for internal tracing, telemetry, and diagnostics.","ref":"Funx.Errors.EffectError.html"},{"type":"exception","title":"Fields - Funx.Errors.EffectError","doc":"* `stage` – the name of the effect stage where the error occurred (`:map`, `:bind`, `:ap`, etc.)\n  * `reason` – the term (often an exception) that caused the failure\n\nThis error implements the `Exception`, `String.Chars`, and `Funx.Summarizable` behaviours.","ref":"Funx.Errors.EffectError.html#module-fields"},{"type":"function","title":"Funx.Errors.EffectError.new/2","doc":"Creates a new `EffectError` from the given stage and reason.","ref":"Funx.Errors.EffectError.html#new/2"},{"type":"function","title":"Examples - Funx.Errors.EffectError.new/2","doc":"iex> Funx.Errors.EffectError.new(:bind, %RuntimeError{message: \"boom\"})\n    %Funx.Errors.EffectError{stage: :bind, reason: %RuntimeError{message: \"boom\"}}","ref":"Funx.Errors.EffectError.html#new/2-examples"},{"type":"type","title":"Funx.Errors.EffectError.t/0","doc":"","ref":"Funx.Errors.EffectError.html#t:t/0"},{"type":"exception","title":"Funx.Errors.ValidationError","doc":"Represents a validation error in the Funx library.\n\nA `ValidationError` wraps one or more domain-level validation messages. It is typically used with `Either.Left` to indicate that a value failed validation and should not proceed in a computation. It can also be raised directly, as it implements the `Exception` behaviour.\n\nThis module provides functions to construct, merge, and convert validation errors, enabling structured, composable error handling across pipelines and validation chains.","ref":"Funx.Errors.ValidationError.html"},{"type":"exception","title":"Functions - Funx.Errors.ValidationError","doc":"* `new/1` – Creates a `ValidationError` from a single error string or a list of error strings.\n* `empty/0` – Returns an empty `ValidationError`.\n* `merge/2` – Combines two `ValidationError` structs into one.\n* `from_tagged/1` – Converts a tagged error tuple (`{:error, errors}`) into a `ValidationError`.\n\nThis module also implements the `Exception`, `String.Chars`, and `Funx.Summarizable` protocols, supporting both human-readable output and structured reporting.","ref":"Funx.Errors.ValidationError.html#module-functions"},{"type":"exception","title":"Usage in validation - Funx.Errors.ValidationError","doc":"You can validate a value using a list of validator functions. Each validator returns an `Either.Right` if\nthe check passes, or an `Either.Left` with an error message if it fails. If any validation fails,\nall errors are aggregated and returned in a single `Left`.\n\nIn contexts where an error must halt execution, `ValidationError` can be raised directly using `raise/1`.","ref":"Funx.Errors.ValidationError.html#module-usage-in-validation"},{"type":"exception","title":"Examples - Funx.Errors.ValidationError","doc":"You can also use a `ValidationError` to hold errors:\n\n```elixir\nalias Funx.Errors.ValidationError\n\nvalidate_positive = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(&1 > 0), fn v -> \"Value must be positive: \" <> to_string(v) end)\n  |> Funx.Monad.Either.map_left(&ValidationError.new/1)\nend\n\nvalidate_even = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(rem(&1, 2) == 0), fn v -> \"Value must be even: \" <> to_string(v) end)\n  |> Funx.Monad.Either.map_left(&ValidationError.new/1)\nend\n\nFunx.Monad.Either.validate(-3, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Left{\n#     left: %ValidationError{\n#       errors: [\"Value must be positive: -3\", \"Value must be even: -3\"]\n#     }\n#   }\n```","ref":"Funx.Errors.ValidationError.html#module-examples"},{"type":"function","title":"Funx.Errors.ValidationError.empty/0","doc":"Returns an empty `ValidationError`.","ref":"Funx.Errors.ValidationError.html#empty/0"},{"type":"function","title":"Examples - Funx.Errors.ValidationError.empty/0","doc":"iex> Funx.Errors.ValidationError.empty()\n    %Funx.Errors.ValidationError{errors: []}","ref":"Funx.Errors.ValidationError.html#empty/0-examples"},{"type":"function","title":"Funx.Errors.ValidationError.from_tagged/1","doc":"Converts a tagged error tuple into a `ValidationError`.","ref":"Funx.Errors.ValidationError.html#from_tagged/1"},{"type":"function","title":"Examples - Funx.Errors.ValidationError.from_tagged/1","doc":"iex> Funx.Errors.ValidationError.from_tagged({:error, [\"must be positive\"]})\n    %Funx.Errors.ValidationError{errors: [\"must be positive\"]}","ref":"Funx.Errors.ValidationError.html#from_tagged/1-examples"},{"type":"function","title":"Funx.Errors.ValidationError.merge/2","doc":"Merges two `ValidationError` structs into one by concatenating their error lists.","ref":"Funx.Errors.ValidationError.html#merge/2"},{"type":"function","title":"Examples - Funx.Errors.ValidationError.merge/2","doc":"iex> e1 = Funx.Errors.ValidationError.new(\"must be positive\")\n    iex> e2 = Funx.Errors.ValidationError.new(\"must be even\")\n    iex> Funx.Errors.ValidationError.merge(e1, e2)\n    %Funx.Errors.ValidationError{errors: [\"must be positive\", \"must be even\"]}","ref":"Funx.Errors.ValidationError.html#merge/2-examples"},{"type":"function","title":"Funx.Errors.ValidationError.new/1","doc":"Creates a `ValidationError` from a single string or list of strings.","ref":"Funx.Errors.ValidationError.html#new/1"},{"type":"function","title":"Examples - Funx.Errors.ValidationError.new/1","doc":"iex> Funx.Errors.ValidationError.new(\"must be positive\")\n    %Funx.Errors.ValidationError{errors: [\"must be positive\"]}\n\n    iex> Funx.Errors.ValidationError.new([\"must be positive\", \"must be even\"])\n    %Funx.Errors.ValidationError{errors: [\"must be positive\", \"must be even\"]}","ref":"Funx.Errors.ValidationError.html#new/1-examples"},{"type":"type","title":"Funx.Errors.ValidationError.t/0","doc":"","ref":"Funx.Errors.ValidationError.html#t:t/0"},{"type":"extras","title":"README","doc":"# Funx - Functional Programming Patterns for Elixir\n\n[![Continuous Integration](https://github.com/JKWA/funx/actions/workflows/ci.yml/badge.svg)](https://github.com/JKWA/funx/actions/workflows/ci.yml)\n\n[![Hex.pm](https://img.shields.io/hexpm/v/funx.svg)](https://hex.pm/packages/funx)\n\n⚠️ **Beta notice:** Funx is in active development. APIs may change until version 1.0. Feedback and contributions are welcome.\n\nAs a rule, functional libraries consider teaching functional programming as out of scope. This one does not.\n\nFunx was built alongside [**Advanced Functional Programming with Elixir**](https://pragprog.com/titles/jkelixir/advanced-functional-programming-with-elixir), which helps you build lasting mental models of functional programming—showing not just how these abstractions work, but how to apply them in real systems using Elixir.\n\n \n\n \n\n**Funx** is a functional programming library for Elixir providing protocols and combinators for equality, ordering, monoids, monads, and other core abstractions.\n\nElixir doesn’t have a static type system, so it can’t enforce functional patterns through the compiler. Instead, it uses pattern matching, protocols, and structs to model abstractions at runtime.\n\nFunx brings functional programming patterns into Elixir using the language’s own tools—without sacrificing its dynamic nature.","ref":"readme.html"},{"type":"extras","title":"Equality - README","doc":"The `Eq` protocol defines how two values are compared, making equality explicit and adaptable to your domain.\n\n- Define what “equal” means—compare by ID, name, or any derived attribute.\n- Compose multiple comparisons—require all to match or just one.\n- Implement for structs, built-in types, or custom comparators.","ref":"readme.html#equality"},{"type":"extras","title":"Ordering - README","doc":"The `Ord` protocol defines ordering relationships in a structured way, without relying on Elixir’s built-in comparison operators.\n\n- Define comparisons based on properties like size, age, or priority.\n- Chain orderings to create fallback tiebreakers.\n- Implement for any type, including custom structs.","ref":"readme.html#ordering"},{"type":"extras","title":"Monads - README","doc":"Monads encapsulate computations, allowing operations to be chained while handling concerns like optional values, failures, dependencies, or deferred effects.\n\n- `Identity`: Wraps a value with no additional behavior—useful for organizing transformations.\n- `Maybe`: Represents optional data using `Just` for presence and `Nothing` for absence.\n- `Either`: Models computations with two possibilities—`Left` and `Right`.\n- `Effect`: Encapsulates deferred execution with error handling, similar to `Task`.\n- `Reader`: Passes an immutable environment through a computation for dependency injection or configuration.\n- `Writer`: Threads a log alongside a result using any monoid—useful for tracing, reporting, or accumulating metadata during computation.","ref":"readme.html#monads"},{"type":"extras","title":"Monoids - README","doc":"Monoids combine values using an associative operation and an identity element. They are useful for accumulation, selection, and combining logic.\n\n- `Sum`: Adds numbers (`0` is the identity).\n- `Product`: Multiplies numbers (`1` is the identity).\n- `Eq.All`: Values are equal only if all comparators agree.\n- `Eq.Any`: Values are equal if any comparator agrees.\n- `Predicate.All`: All predicates must hold.\n- `Predicate.Any`: At least one predicate must hold.\n- `Ord`: Defines ordering compositionally.\n- `Max` and `Min`: Select the largest or smallest value by custom ordering.\n- `ListConcat`: Concatenates lists (`[]` is the identity).\n- `StringConcat`: Concatenates strings (`\"\"` is the identity).","ref":"readme.html#monoids"},{"type":"extras","title":"Predicates - README","doc":"Predicates are functions that return `true` or `false`. Funx provides combinators for composing them cleanly.\n\n- `p_and`: Returns `true` if both predicates pass.\n- `p_or`: Returns `true` if either predicate passes.\n- `p_not`: Negates a predicate.\n- `p_all`: Returns `true` if all predicates in a list pass.\n- `p_any`: Returns `true` if any predicate in a list passes.\n- `p_none`: Returns `true` if none pass.","ref":"readme.html#predicates"},{"type":"extras","title":"Folding - README","doc":"The `Foldable` protocol defines how to reduce a structure to a single result.\n\n- `fold_l`: Reduces from the left, applying functions in order.\n- `fold_r`: Reduces from the right, applying functions in reverse.\n\nUseful for accumulating values, transforming collections, or extracting data.","ref":"readme.html#folding"},{"type":"extras","title":"Filtering - README","doc":"The `Filterable` protocol defines how to conditionally retain values within a context.\n\n- `guard`: Keeps a value if a condition is met; otherwise returns an empty context.\n- `filter`: Retains values that satisfy a predicate.\n- `filter_map`: Applies a transformation and keeps results only when the transformed value is present.","ref":"readme.html#filtering"},{"type":"extras","title":"Sequencing - README","doc":"Sequencing runs a series of monadic operations in order, combining the results.\n\n- `concat/1`: Removes empty values and unwraps the present results from a list.\n- `concat_map/2`: Applies a function to each element and collects only the present results.\n- `sequence/1`: Converts a list of monadic values into a single monadic value containing a list. Short-circuits on the first failure or absence.\n- `traverse/2`: Applies a function to each element and sequences the resulting monadic values.\n- `sequence_a/1`: Applicative version of sequence—combines all and collects results.\n- `traverse_a/2`: Applicative version of traverse—applies a function to each element and collects results.","ref":"readme.html#sequencing"},{"type":"extras","title":"Lifting - README","doc":"Lifting functions promote ordinary logic into a monadic or contextual form.\n\n- `lift_predicate/3`: Wraps a value in a monad if a condition holds; returns an empty or failed context otherwise.\n- `lift_eq/1`: Adapts an `Eq` comparator to work within a monadic context.\n- `lift_ord/1`: Adapts an `Ord` comparator to work within a monadic context.","ref":"readme.html#lifting"},{"type":"extras","title":"Interop - README","doc":"Funx integrates with common Elixir patterns like `{:ok, value}` and `{:error, reason}`.\n\n- `from_result/1`: Converts a result tuple into a monadic context that distinguishes success from failure.\n- `to_result/1`: Converts a monadic value back into a result tuple.\n- `from_try/1`: Wraps a function call in a monad, capturing exceptions as failures.\n- `to_try!/1`: Extracts the value from a monad or raises if it represents a failure.","ref":"readme.html#interop"},{"type":"extras","title":"Installation - README","doc":"To use Funx, add it to the list of dependencies in `mix.exs`:\n\n```elixir\ndef deps do\n  [\n    {:funx, \"~> 0.1.4\"}\n  ]\nend\n```\n\nThen, run the following command to fetch the dependencies:\n\n```bash\nmix deps.get\n```","ref":"readme.html#installation"},{"type":"extras","title":"Documentation - README","doc":"Full documentation is available on [GitHub Pages](https://jkwa.github.io/funx/readme.html).","ref":"readme.html#documentation"},{"type":"extras","title":"Contributing - README","doc":"1. Fork the repository.  \n2. Create a new branch for the feature or bugfix (`git checkout -b feature-branch`).  \n3. Commit changes (`git commit -am 'Add new feature'`).  \n4. Push the branch (`git push origin feature-branch`).  \n5. Create a pull request.","ref":"readme.html#contributing"},{"type":"extras","title":"License - README","doc":"This project is licensed under the MIT License.","ref":"readme.html#license"},{"type":"extras","title":"Changelog","doc":"# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\nand this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n\n## [Unreleased]","ref":"changelog.html"},{"type":"extras","title":"Added - Changelog","doc":"- Initial project structure and setup.\n- Implemented the following modules:\n  - `Funx.Eq`\n  - `Funx.Foldable`\n  - `Funx.Ord`\n  - `Funx.Predicate`\n  - `Funx.Monad`\n  - `Funx.Monad.Identity`\n  - `Funx.Monad.Maybe`\n  - `Funx.Monad.Either`\n  - `Funx.Monad.Effect`","ref":"changelog.html#added"},{"type":"extras","title":"Documentation - Changelog","doc":"- Added basic documentation for modules and functions.\n- Set up project to generate documentation using ExDoc.","ref":"changelog.html#documentation"},{"type":"extras","title":"LICENSE","doc":"# MIT License\n\nCopyright (c) 2024 Joseph Koski\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.","ref":"license.html"},{"type":"extras","title":"Funx Usage Rules","doc":"# Funx Usage Rules (Index)\n\nUsage rules describe how to use Funx protocols and utilities in practice.  \nThey complement the module docs (which describe *what* the APIs do).  \n\nEach protocol or major module has its own `usage-rules.md`, stored next to the code.  \nThis index links them together.\n\n---","ref":"usage-rules.html"},{"type":"extras","title":"Available Rules - Funx Usage Rules","doc":"- [Funx.Utils Usage Rules](./utils/usage-rules.md)  \n  Currying, flipping, and function transformation for point-free and pipeline-based composition.\n\n- [Funx.Eq Usage Rules](./eq/usage-rules.md)  \n  Equality and identity logic across domain types.\n\n- [Funx.Ord Usage Rules](./ord/usage-rules.md)  \n  Ordering and comparison logic for domain types.\n\n- [Funx.List Usage Rules](./list/usage-rules.md)  \n  Set operations, deduplication, and sorting that respect `Eq` and `Ord`.\n\n- [Funx.Monoid Usage Rules](./monoid/usage-rules.md)  \n  Identities and associative combination, powering folds and composition.\n\n- [Funx.Predicate Usage Rules](./predicate/usage-rules.md)  \n  Logical composition of predicates using short-circuiting, reusable combinators.\n  \n- [Funx.Monad Usage Rules](./monad/usage-rules.md)\n  Declarative control flow through `map`, `bind`, and `ap`—composing context-aware steps without manual branching.\n\n---","ref":"usage-rules.html#available-rules"},{"type":"extras","title":"Conventions - Funx Usage Rules","doc":"- Collocation: rules live beside the code they describe.  \n- Scope: focus on *usage guidance* and best practices, not API reference.  \n- LLM-friendly: small sections, explicit examples, stable links.\n\n---","ref":"usage-rules.html#conventions"},{"type":"extras","title":"Project Layout (rules only) - Funx Usage Rules","doc":"```text\nlib/\n  usage-rules.md        # ← index (this file)\n  utils/\n    usage-rules.md      # ← Funx.Utils rules\n  eq/\n    usage-rules.md      # ← Funx.Eq rules\n  ord/\n    usage-rules.md      # ← Funx.Ord rules\n  list/\n    usage-rules.md      # ← Funx.List rules\n  monoid/\n    usage-rules.md      # ← Funx.Monoid rules\n  predicate/\n    usage-rules.md      # ← Funx.Predicate rules\n  monad/\n    usage-rules.md      # ← Funx.Monad rules\n```","ref":"usage-rules.html#project-layout-rules-only"},{"type":"extras","title":"Funx.Utils Usage Rules","doc":"# `Funx.Utils` Usage Rules","ref":"utils-usage-rules.html"},{"type":"extras","title":"Quick Reference - Funx.Utils Usage Rules","doc":"* Use `curry_r/1` to curry functions right-to-left—ideal for Elixir’s `|>` pipe style.\n* Use `curry/1` or `curry_l/1` to curry left-to-right when needed.\n* Use `flip/1` to reverse arguments in binary functions.\n* All currying functions adapt to any arity and return nested unary functions.\n\n---","ref":"utils-usage-rules.html#quick-reference"},{"type":"extras","title":"Overview - Funx.Utils Usage Rules","doc":"`Funx.Utils` provides functional utilities for reshaping multi-argument functions to support composition, partial application, and point-free style.\nUse `curry_r/1` by default—it aligns with Elixir’s `|>` operator by shifting configuration to the right and leaving the data position first.\n\nThese tools are especially useful with predicates, monads, and other combinators where composition and reuse are key.\n\n---","ref":"utils-usage-rules.html#overview"},{"type":"extras","title":"Composition Rules - Funx.Utils Usage Rules","doc":"| Function    | Description                                                  |\n| ----------- | ------------------------------------------------------------ |\n| `curry_r/1` | Curries a function right-to-left (recommended for pipelines) |\n| `curry/1`   | Curries left-to-right                                        |\n| `curry_l/1` | Alias for `curry/1`, makes intent explicit                   |\n| `flip/1`    | Reverses arguments of a binary function                      |\n\nEach function returns a chain of unary functions that accumulate arguments until fully applied.\n\n---","ref":"utils-usage-rules.html#composition-rules"},{"type":"extras","title":"Usage Patterns - Funx.Utils Usage Rules","doc":"","ref":"utils-usage-rules.html#usage-patterns"},{"type":"extras","title":"Right-to-Left Currying for Pipelines - Funx.Utils Usage Rules","doc":"```elixir\nf = fn prefix, name -> prefix <> name end\ngreet = curry_r(f).(\"Hello, \")\n\"Alice\" |> greet()\n# => \"Hello, Alice\"\n```","ref":"utils-usage-rules.html#right-to-left-currying-for-pipelines"},{"type":"extras","title":"Flip for Reordering Binary Functions - Funx.Utils Usage Rules","doc":"```elixir\ndiv = fn a, b -> a / b end\nflipped = flip(div)\nflipped.(2, 10)  # => 5.0\n```","ref":"utils-usage-rules.html#flip-for-reordering-binary-functions"},{"type":"extras","title":"Left-to-Right Currying (Less Common) - Funx.Utils Usage Rules","doc":"```elixir\nsum = curry(fn a, b, c -> a + b + c end)\nsum.(1).(2).(3)  # => 6\n```\n\n---","ref":"utils-usage-rules.html#left-to-right-currying-less-common"},{"type":"extras","title":"Guidelines for Composition - Funx.Utils Usage Rules","doc":"Follow these patterns when reshaping or generating function transformations:\n\n* Prefer `curry_r/1` for functions that appear in pipelines.\n* Use `flip/1` when argument order doesn’t match surrounding context.\n* Use `curry/1` or `curry_l/1` when left-to-right application is more natural.\n* Avoid manual `fn` nesting—use the provided helpers instead.\n* Avoid fixed-arity assumptions—currying adapts dynamically.\n* Avoid capture syntax (`&mod.fun/arity`) when partial application is needed.\n  Capture locks arity and order, and cannot be curried or reordered.\n\nCurrying is often most useful when composed with lifted combinators like `map`, `bind`, `filter`, and so on.\n\n---","ref":"utils-usage-rules.html#guidelines-for-composition"},{"type":"extras","title":"Stability Contract - Funx.Utils Usage Rules","doc":"Ensure that generated or transformed functions preserve:\n\n* Purity — returned functions are referentially transparent.\n* Laziness — arguments are applied only when provided.\n* Equivalence — full application matches the original function:\n\n```elixir\ncurry_r(f).(b).(a) == f.(a, b)\n```\n\n---","ref":"utils-usage-rules.html#stability-contract"},{"type":"extras","title":"Anti-Patterns - Funx.Utils Usage Rules","doc":"Avoid generating or emitting:\n\n* Manual currying via nested `fn` chains: `fn a -> fn b -> f.(a, b) end end`\n* Fixed-arity assumptions that break with dynamic currying\n* Argument reordering by hand—prefer `flip/1`\n* Full application immediately after currying\n* Capture syntax (`&fun/2`) when transformation is required\n\n---","ref":"utils-usage-rules.html#anti-patterns"},{"type":"extras","title":"Good Patterns - Funx.Utils Usage Rules","doc":"Encourage completions like:\n\n```elixir\n# Partial right-to-left application for pipelines\nassign_role = curry_r(fn role, user -> %{user | role: role} end)\nuser |> assign_role.(\"admin\")\n```\n\n```elixir\n# Flipping to enable higher-order composition\ncompare = flip(fn a, b -> a > b end)\nEnum.filter(list, compare.(10))\n```\n\n```elixir\n# Contextual function with partial application\ntransform =\n  curry_r(fn format, name -> format.(\"<\" <> name <> \">\") end)\n\"Alex\" |> transform.(&String.upcase/1)\n```\n\n---","ref":"utils-usage-rules.html#good-patterns"},{"type":"extras","title":"When to Use - Funx.Utils Usage Rules","doc":"Reach for these utilities when you want to:\n\n* Enable point-free style\n* Compose partial functions within a pipeline\n* Shift configuration before data\n* Adapt argument order to match surrounding combinators\n* Prepare functions before lifting into a monadic or applicative context\n\n---","ref":"utils-usage-rules.html#when-to-use"},{"type":"extras","title":"Built-in Behavior - Funx.Utils Usage Rules","doc":"* `curry_r/1`, `curry/1`, and `curry_l/1` inspect function arity via `:erlang.fun_info/2`.\n* Returned functions accumulate arguments until fully applied.\n* `flip/1` applies only to functions of arity 2.","ref":"utils-usage-rules.html#built-in-behavior"},{"type":"extras","title":"Funx.Eq Usage Rules","doc":"# `Funx.Eq` Usage Rules","ref":"eq-usage-rules.html"},{"type":"extras","title":"Quick Reference - Funx.Eq Usage Rules","doc":"* Use `Eq.eq?/2` instead of `==`.\n* Implement both `eq?/2` and `not_eq?/2`.\n* If no instance exists, the fallback uses Elixir’s `==` and `!=` via `Any`.\n* `Eq.Utils.*` defaults to protocol dispatch—no extra wiring needed.\n* `Funx.List` functions (`uniq`, `union`, `intersection`, etc.) respect `Eq`.\n* `Eq` is composable (`contramap`, `append_all`, `concat_any`); `==` is not.\n\n---","ref":"eq-usage-rules.html#quick-reference"},{"type":"extras","title":"Overview - Funx.Eq Usage Rules","doc":"`Funx.Eq` defines contextual equality in Elixir.\nUse `Eq` instead of `==` for identity checks, filters, and deduplication.\n\n* `==` is structural and fixed. It cannot be changed or composed.\n* `Eq` is extensible and composable. You can define it for your own types, and build new comparisons with helpers like `contramap`, `append_all`, and `concat_any`.\n\n`Eq.Utils` provides combinators for building custom equality rules.\n`Funx.List` uses `Eq` automatically—set operations respect domain semantics.\n\n---","ref":"eq-usage-rules.html#overview"},{"type":"extras","title":"Protocol Rules - Funx.Eq Usage Rules","doc":"* Implement both `eq?/2` and `not_eq?/2`.\n\n* Follow the standard equality laws:\n\n  * Reflexivity: `eq?(a, a) == true`\n  * Symmetry: `eq?(a, b) == eq?(b, a)`\n  * Transitivity: if `eq?(a, b)` and `eq?(b, c)`, then `eq?(a, c)`\n\n* Prefer semantic equality over structural equality:\n\n  * Identity fields\n  * Business logic\n  * Domain rules","ref":"eq-usage-rules.html#protocol-rules"},{"type":"extras","title":"Fallback (`Any`) - Funx.Eq Usage Rules","doc":"If no explicit implementation is provided, `Any` uses Elixir’s `==`:\n\n```elixir\ndefimpl Funx.Eq, for: Any do\n  def eq?(a, b), do: a == b\n  def not_eq?(a, b), do: a != b\nend\n```\n\nFallback is fine for primitives.\nFor maps and structs, define your own `Eq` instance.\n\n---","ref":"eq-usage-rules.html#fallback-any"},{"type":"extras","title":"Preferred Usage - Funx.Eq Usage Rules","doc":"","ref":"eq-usage-rules.html#preferred-usage"},{"type":"extras","title":"Use `Eq.eq?/2` Instead of `==` - Funx.Eq Usage Rules","doc":"Define equality in terms of domain identity.\nPrefer projecting and delegating:\n\n```elixir\ndefimpl Funx.Eq, for: User do\n  def eq?(%User{id: v1}, %User{id: v2}), do: Funx.Eq.eq?(v1, v2)\n  def not_eq?(a, b), do: not eq?(a, b)\nend\n```\n\nThis delegates to the `Eq` instance for `id`, if one exists.\nIt keeps your comparison logic composable and consistent.\n\nYou can also build custom equality on the fly:\n\n```elixir\neq = Eq.Utils.contramap(& &1.id)\nEq.Utils.eq?(user1, user2, eq)\n```\n\n---","ref":"eq-usage-rules.html#use-eq-eq-2-instead-of"},{"type":"extras","title":"Default Dispatch in `Eq.Utils` - Funx.Eq Usage Rules","doc":"All helpers default to protocol dispatch—you don’t need to pass logic manually.\n\n```elixir\nEq.Utils.eq?(a, b)\nEq.Utils.not_eq?(a, b)\nEq.Utils.eq_by?(&proj/1, a, b)\nEq.Utils.to_predicate(target)\n```\n\n---","ref":"eq-usage-rules.html#default-dispatch-in-eq-utils"},{"type":"extras","title":"Projections and Composition - Funx.Eq Usage Rules","doc":"```elixir\n# Compare by ID\neq = Eq.Utils.contramap(& &1.id)\nEq.Utils.eq?(%User{id: 1}, %User{id: 1}, eq)\n\n# Filter a list by identity\nEnum.filter(users, Eq.Utils.to_predicate(current_user, eq))\n\n# Combine comparators\nEq.Utils.concat_all([\n  Eq.Utils.contramap(& &1.name),\n  Eq.Utils.contramap(& &1.age)\n])\n```\n\nYou can also use:\n\n* `append_all/2` (left-to-right composition)\n* `concat_all/1` (multi-key lexicographic comparison)\n* `concat_any/1` (any-match logic)\n\n---","ref":"eq-usage-rules.html#projections-and-composition"},{"type":"extras","title":"In `Funx.List` - Funx.Eq Usage Rules","doc":"`Funx.List` uses `Eq` automatically via `Eq.Utils`.\nNo extra setup required.","ref":"eq-usage-rules.html#in-funx-list"},{"type":"extras","title":"Equality-Sensitive Functions - Funx.Eq Usage Rules","doc":"* `uniq/2`\n* `union/3`\n* `intersection/3`\n* `difference/3`\n* `symmetric_difference/3`\n* `subset?/3`\n* `superset?/3`\n\n> Sorting is handled by `Funx.Ord` (`sort/2`, `strict_sort/2`).","ref":"eq-usage-rules.html#equality-sensitive-functions"},{"type":"extras","title":"Examples - Funx.Eq Usage Rules","doc":"```elixir\n# With a protocol impl\nFunx.List.uniq([%User{id: 1}, %User{id: 1}])\n# => [%User{id: 1}]\n\n# With fallback (Any)\nFunx.List.uniq([1, 1.0])\n# => [1]  # Elixir: 1 == 1.0\n\n# With ad-hoc comparator\neq = Eq.Utils.contramap(& &1.name)\nFunx.List.uniq(users, eq)\n```\n\n---","ref":"eq-usage-rules.html#examples"},{"type":"extras","title":"Stability Contract - Funx.Eq Usage Rules","doc":"* `eq?/2` must be pure (same inputs → same output).\n* `eq?/2` and `not_eq?/2` must be exact complements.\n* Instances should be domain-aware and consistent.\n\n---","ref":"eq-usage-rules.html#stability-contract"},{"type":"extras","title":"Anti-Patterns - Funx.Eq Usage Rules","doc":"* Mixing `==` and `Eq` in the same logic:\n\n  ```elixir\n  # BAD\n  if a == b and Eq.eq?(a, b), do: ...\n  ```\n\n* Comparing unrelated types:\n\n  ```elixir\n  Eq.eq?(:ok, %{ok: true})  # meaningless\n  ```\n\n---","ref":"eq-usage-rules.html#anti-patterns"},{"type":"extras","title":"Good Patterns - Funx.Eq Usage Rules","doc":"* Use `Eq` for identity checks, filters, and deduplication.\n* Use `contramap` to project domain keys.\n* Compose equality logic close to its use.\n* Avoid relying on fallback for domain types.\n\n---","ref":"eq-usage-rules.html#good-patterns"},{"type":"extras","title":"When to Define an `Eq` Instance - Funx.Eq Usage Rules","doc":"Define an `Eq` instance when you need control over what counts as equal.","ref":"eq-usage-rules.html#when-to-define-an-eq-instance"},{"type":"extras","title":"Common Cases - Funx.Eq Usage Rules","doc":"* Identity fields (`id`, `slug`, `handle`)\n* Semantic keys (birthdays = same day/month)\n* Ignoring metadata (timestamps, versions)\n* Composite identity (multiple fields together)\n* Domain logic (business rules define equality)\n* Set-like operations (deduplication, membership)","ref":"eq-usage-rules.html#common-cases"},{"type":"extras","title":"Why `Eq` Instead of `==` - Funx.Eq Usage Rules","doc":"* `==` is fixed and structural.\n* `Eq` is extensible through protocols.\n* `Eq` is composable (`contramap`, `append_all`, `concat_any`).\n* `Eq` integrates with `Eq.Utils` and `Funx.List`.\n\n---","ref":"eq-usage-rules.html#why-eq-instead-of"},{"type":"extras","title":"Built-in Instances - Funx.Eq Usage Rules","doc":"`Funx.Eq` provides ready-to-use instances for Elixir’s time types:\nEach uses the standard library’s `compare/2`, but only checks for equality:\n\n* `DateTime` → `DateTime.compare(a, b) == :eq`\n* `Date` → `Date.compare(a, b) == :eq`\n* `Time` → `Time.compare(a, b) == :eq`\n* `NaiveDateTime` → `NaiveDateTime.compare(a, b) == :eq`\n\nAlso included:\nA fallback for `Any` using Elixir’s `==` and `!=`:\n\n```elixir\nEq.eq?(1, 1.0)  # true\nEq.eq?(\"a\", \"a\")  # true\n```\n\nSafe for primitives.\n**For domain types, define an explicit instance.**","ref":"eq-usage-rules.html#built-in-instances"},{"type":"extras","title":"Funx.Ord Usage Rules","doc":"# `Funx.Ord` Usage Rules","ref":"ord-usage-rules.html"},{"type":"extras","title":"Quick Reference - Funx.Ord Usage Rules","doc":"* Use `Ord.lt?/2`, `Ord.le?/2`, `Ord.gt?/2`, and `Ord.ge?/2` instead of raw comparison operators.\n* Always implement all four functions when defining an instance.\n* The fallback implementation uses Elixir's native operators and may raise for some types.\n* `Ord.Utils.*` functions default to protocol dispatch.\n* `Funx.List.sort/2` and `strict_sort/2` use `Ord`, not `Eq`.\n* `Ord` is composable with helpers like `contramap`, `append`, `concat`, and `reverse`.\n\n---","ref":"ord-usage-rules.html#quick-reference"},{"type":"extras","title":"Overview - Funx.Ord Usage Rules","doc":"`Funx.Ord` defines contextual ordering in Elixir.\nUse `Ord` to express domain-specific comparison rules.\n\n* Raw operators like `<` and `>` are not extensible or composable.\n* `Ord` is implemented via protocol and can be customized per type.\n* `Ord` integrates with `Funx.List`, `Ord.Utils`, and sorting operations.\n* `Ord` supports composition and projection via utility helpers.\n\n---","ref":"ord-usage-rules.html#overview"},{"type":"extras","title":"Protocol Rules - Funx.Ord Usage Rules","doc":"* Implement all of the following:\n\n  ```elixir\n  lt?(a, b)  # less than\n  le?(a, b)  # less than or equal\n  gt?(a, b)  # greater than\n  ge?(a, b)  # greater than or equal\n  ```\n\n* Implementations should define a total order and follow standard laws:\n\n  * Antisymmetry: if `a <= b` and `b <= a`, then `a == b`\n  * Transitivity: if `a <= b` and `b <= c`, then `a <= c`\n  * Connexity: for any `a`, `b`, either `a <= b` or `b <= a`\n\n* Prefer semantic ordering (e.g., domain fields) over structural details.\n\n---","ref":"ord-usage-rules.html#protocol-rules"},{"type":"extras","title":"Fallback (`Any`) - Funx.Ord Usage Rules","doc":"If no instance is defined, the protocol falls back to Elixir’s built-in comparison operators:\n\n```elixir\ndefimpl Funx.Ord, for: Any do\n  def lt?(a, b), do: a    b\n  def ge?(a, b), do: a >= b\nend\n```","ref":"ord-usage-rules.html#fallback-any"},{"type":"extras","title":"Safe fallback types: - Funx.Ord Usage Rules","doc":"* Numbers (`1 < 2`)\n* Strings and binaries (`\"a\" < \"b\"`)\n* Tuples and lists (compared lexicographically)","ref":"ord-usage-rules.html#safe-fallback-types"},{"type":"extras","title":"Unsafe fallback types: - Funx.Ord Usage Rules","doc":"* Maps and structs: raise `ArgumentError` when compared with `<`, `<=`, etc.\n* Cross-type comparisons: may raise or produce invalid results\n\nUse fallback only if you know the inputs are safe.\nDefine explicit `Ord` instances for structs and domain types.\n\n---","ref":"ord-usage-rules.html#unsafe-fallback-types"},{"type":"extras","title":"Preferred Usage - Funx.Ord Usage Rules","doc":"","ref":"ord-usage-rules.html#preferred-usage"},{"type":"extras","title":"Use `Ord` Instead of Raw Operators - Funx.Ord Usage Rules","doc":"```elixir\ndefimpl Funx.Ord, for: User do\n  def lt?(%User{joined_at: a}, %User{joined_at: b}),\n    do: Funx.Ord.lt?(a, b)\n\n  def le?(a, b), do: lt?(a, b) or eq?(a, b)\n  def gt?(a, b), do: not le?(a, b)\n  def ge?(a, b), do: not lt?(a, b)\n\n  defp eq?(%User{joined_at: a}, %User{joined_at: b}),\n    do: Funx.Eq.eq?(a, b)\nend\n```\n\nProject domain fields and delegate to `Ord` on those fields.\nIf the projected field also has an `Eq` instance, use it for consistency.\n\n---","ref":"ord-usage-rules.html#use-ord-instead-of-raw-operators"},{"type":"extras","title":"Use `Ord.Utils` for Dispatch - Funx.Ord Usage Rules","doc":"All `Ord.Utils` functions default to the protocol.\nYou do not need to pass logic manually if the type has an instance.\n\n```elixir\nOrd.Utils.compare(a, b)      # :lt | :eq | :gt\nOrd.Utils.min(a, b)\nOrd.Utils.max(a, b)\nOrd.Utils.clamp(value, min, max)\nOrd.Utils.between(value, min, max)\nOrd.Utils.comparator()       # For Enum.sort/2\n```\n\n---","ref":"ord-usage-rules.html#use-ord-utils-for-dispatch"},{"type":"extras","title":"Projections and Composition - Funx.Ord Usage Rules","doc":"```elixir\n# Order by projected key\nby_length = Ord.Utils.contramap(&String.length/1)\nOrd.Utils.max(\"cat\", \"zebra\", by_length)  # \"zebra\"\n\n# Reverse an ordering\ndesc = Ord.Utils.reverse(by_length)\n\n# Compose by multiple fields\nord =\n  Ord.Utils.concat([\n    Ord.Utils.contramap(& &1.age),\n    Ord.Utils.contramap(& &1.name)\n  ])\n\nOrd.Utils.compare(%{age: 30, name: \"Bob\"}, %{age: 30, name: \"Charlie\"}, ord)\n# => :lt\n```\n\nUse `append/2` or `concat/1` to build lexicographic orderings.\nUse `reverse/1` to invert direction.\n\n---","ref":"ord-usage-rules.html#projections-and-composition"},{"type":"extras","title":"Convert `Ord` to `Eq` - Funx.Ord Usage Rules","doc":"You can derive equality from ordering:\n\n```elixir\neq = Ord.Utils.to_eq()\neq.eq?.(7, 7)  # true\n```\n\nThis ensures consistent logic across equality and ordering.\n\n---","ref":"ord-usage-rules.html#convert-ord-to-eq"},{"type":"extras","title":"In `Funx.List` - Funx.Ord Usage Rules","doc":"Sorting uses `Ord`.\nAll `Funx.List` sorting functions accept a comparator, defaulting to the protocol.\n\n```elixir\nFunx.List.sort(list, ord \\\\ Funx.Ord)\nFunx.List.strict_sort(list, ord \\\\ Funx.Ord)\n```\n\n`strict_sort/2` removes duplicates using `Ord.Utils.to_eq/1`.","ref":"ord-usage-rules.html#in-funx-list"},{"type":"extras","title":"Examples - Funx.Ord Usage Rules","doc":"```elixir\n# Default: numeric sort\nFunx.List.sort([3, 1, 2])\n# => [1, 2, 3]\n\n# Custom: by string length, then alphabetically\nord =\n  Ord.Utils.concat([\n    Ord.Utils.contramap(&String.length/1),\n    Ord.Utils.contramap(& &1)\n  ])\n\nFunx.List.sort(~w(zero one two three), ord)\n# => [\"one\", \"two\", \"zero\", \"three\"]\n\nFunx.List.strict_sort([\"aa\", \"a\", \"aa\"], ord)\n# => [\"a\", \"aa\"]\n```\n\n---","ref":"ord-usage-rules.html#examples"},{"type":"extras","title":"Stability Contract - Funx.Ord Usage Rules","doc":"* All functions must be pure.\n* Each instance must define a total order.\n* If the type also defines `Eq`, keep the implementations consistent:\n\n```elixir\nOrd.Utils.compare(a, b) == :eq  <=>  Eq.eq?(a, b)\n```\n\n---","ref":"ord-usage-rules.html#stability-contract"},{"type":"extras","title":"Anti-Patterns - Funx.Ord Usage Rules","doc":"* Using `<` or `>` on maps or structs.\n* Comparing values of unrelated types.\n* Mixing protocol-based and ad-hoc logic in the same function.\n\n---","ref":"ord-usage-rules.html#anti-patterns"},{"type":"extras","title":"Good Patterns - Funx.Ord Usage Rules","doc":"* Use `contramap` to project comparison keys.\n* Use `append` or `concat` to build multi-key orderings.\n* Use `reverse` to define descending order without rewriting logic.\n* Use `Ord.Utils.comparator/1` when sorting with `Enum.sort/2`.\n\n---","ref":"ord-usage-rules.html#good-patterns"},{"type":"extras","title":"When to Define an `Ord` Instance - Funx.Ord Usage Rules","doc":"Define an `Ord` instance when you need to control how values are ordered.","ref":"ord-usage-rules.html#when-to-define-an-ord-instance"},{"type":"extras","title":"Common cases - Funx.Ord Usage Rules","doc":"* Time-based comparisons (`inserted_at`, `scheduled_on`)\n* Lexicographic fallback (sort by age, then name)\n* Score-based ordering (revenue, priority, bonus)\n* Domain-specific sort (e.g., \"VIP before General\")\n\n---","ref":"ord-usage-rules.html#common-cases"},{"type":"extras","title":"Built-in Instances - Funx.Ord Usage Rules","doc":"`Funx.Ord` includes protocol implementations for Elixir’s temporal types:\n\n* `DateTime` → uses `DateTime.compare/2`\n* `Date` → uses `Date.compare/2`\n* `Time` → uses `Time.compare/2`\n* `NaiveDateTime` → uses `NaiveDateTime.compare/2`\n\nThese implementations support full ordering: `lt?/2`, `le?/2`, `gt?/2`, `ge?/2`.\nThey are safe for use with `Ord.Utils` and `Funx.List`.\n\nAvoid relying on the fallback for maps or structs—define explicit rules instead.","ref":"ord-usage-rules.html#built-in-instances"},{"type":"extras","title":"Funx.List Usage Rules","doc":"# `Funx.List` Usage Rules","ref":"list-usage-rules.html"},{"type":"extras","title":"Quick Reference - Funx.List Usage Rules","doc":"* All functions operate on Elixir lists (`[term()]`).\n* `Eq` is used for: `uniq/2`, `union/3`, `intersection/3`, `difference/3`, `symmetric_difference/3`, `subset?/3`, and `superset?/3`.\n* `Ord` is used for: `sort/2` and `strict_sort/2`.\n* `strict_sort/2` combines `Ord` (for sorting) and `Eq` (for deduplication).\n* All functions default to protocol dispatch; no wiring needed if instances exist.\n* Ad-hoc comparators can be passed using `Eq.Utils.contramap/1` or `Ord.Utils.contramap/1`.\n\n---","ref":"list-usage-rules.html#quick-reference"},{"type":"extras","title":"Overview - Funx.List Usage Rules","doc":"The `Funx.List` module provides equality- and ordering-aware utilities for working with lists.\nIt supports deduplication, sorting, and set-like behavior using `Eq` and `Ord` instances.\n\nThis allows logic like \"unique cars by VIN\" or \"sort by price, then mileage\" to be clean, composable, and domain-aware.\n\n---","ref":"list-usage-rules.html#overview"},{"type":"extras","title":"Eq-Based Operations - Funx.List Usage Rules","doc":"### `uniq/2`\n\nRemoves duplicates using `Eq`.\n\n```elixir\nFunx.List.uniq([%Car{vin: \"A\"}, %Car{vin: \"A\"}])\n# => [%Car{vin: \"A\"}]\n```\n\nWith custom comparator:\n\n```elixir\neq = Eq.Utils.contramap(& &1.make)\nFunx.List.uniq(cars, eq)\n```\n\n---\n\n### `union/3`\n\nCombines two lists, removing duplicates using `Eq`.\n\n```elixir\nFunx.List.union([1, 2], [2, 3])\n# => [1, 2, 3]\n```\n\n---\n\n### `intersection/3`\n\nReturns the elements common to both lists.\n\n```elixir\nFunx.List.intersection([1, 2, 3], [2, 3, 4])\n# => [2, 3]\n```\n\n---\n\n### `difference/3`\n\nReturns elements from the first list that are not in the second.\n\n```elixir\nFunx.List.difference([1, 2, 3], [2])\n# => [1, 3]\n```\n\n---\n\n### `symmetric_difference/3`\n\nReturns elements that appear in only one of the two lists.\n\n```elixir\nFunx.List.symmetric_difference([1, 2], [2, 3])\n# => [1, 3]\n```\n\n---\n\n### `subset?/3` and `superset?/3`\n\nChecks for inclusion using `Eq`.\n\n```elixir\nFunx.List.subset?([1, 2], [1, 2, 3])\n# => true\n\nFunx.List.superset?([1, 2, 3], [1, 2])\n# => true\n```\n\n---","ref":"list-usage-rules.html#eq-based-operations"},{"type":"extras","title":"Ord-Based Operations - Funx.List Usage Rules","doc":"### `sort/2`\n\nSorts the list using `Ord`. Defaults to protocol dispatch.\n\n```elixir\nFunx.List.sort([3, 1, 2])\n# => [1, 2, 3]\n```\n\nWith ad-hoc ordering:\n\n```elixir\nord = Ord.Utils.contramap(& &1.price)\nFunx.List.sort(cars, ord)\n```\n\n---\n\n### `strict_sort/2`\n\nSorts the list and removes duplicates. Uses `Ord` for sorting and derives `Eq` from ordering.\n\n```elixir\nFunx.List.strict_sort([3, 1, 3, 2])\n# => [1, 2, 3]\n```\n\n---","ref":"list-usage-rules.html#ord-based-operations"},{"type":"extras","title":"Concatenation - Funx.List Usage Rules","doc":"### `concat/1`\n\nConcatenates a list of lists left-to-right using the `ListConcat` monoid.\n\n```elixir\nFunx.List.concat([[1], [2, 3], [4]])\n# => [1, 2, 3, 4]\n```\n\n---","ref":"list-usage-rules.html#concatenation"},{"type":"extras","title":"Good Patterns - Funx.List Usage Rules","doc":"* Use `uniq/2`, `intersection/3`, and related functions instead of manual deduplication.\n* Use `contramap/1` to lift equality or ordering by projecting key fields.\n* Use `strict_sort/2` when you need sorted unique results.\n* Define protocol instances for domain types to remove the need for custom comparator logic.\n\n---","ref":"list-usage-rules.html#good-patterns"},{"type":"extras","title":"Anti-Patterns - Funx.List Usage Rules","doc":"* Using `==` in list operations instead of `Eq`:\n\n  ```elixir\n  # BAD\n  Enum.uniq_by(users, & &1.id)  # not composable or testable\n  ```\n\n* Sorting maps or structs without defining `Ord`:\n\n  ```elixir\n  # BAD\n  Enum.sort([%User{}])  # may raise\n  ```\n\n* Mixing raw and protocol-based comparison:\n\n  ```elixir\n  # BAD\n  if user1.id == user2.id and Eq.eq?(user1, user2), do: ...\n  ```\n\n---","ref":"list-usage-rules.html#anti-patterns"},{"type":"extras","title":"When to Use - Funx.List Usage Rules","doc":"Use `Funx.List` when:\n\n* You want list operations that follow your domain's equality or ordering rules.\n* You need composable set logic like `union` or `difference`.\n* You want deterministic, extensible sorting.\n* You're working with domain types (e.g., `User`, `Car`, `Ticket`) and want safe behavior.","ref":"list-usage-rules.html#when-to-use"},{"type":"extras","title":"Funx.Monoid Usage Rules","doc":"# `Funx.Monoid` Usage Rules","ref":"monoid-usage-rules.html"},{"type":"extras","title":"Quick Reference - Funx.Monoid Usage Rules","doc":"* A monoid = `empty/1` (identity) + `append/2` (associative).  \n* Identities must be true identities (e.g. `0` for sum, `1` for product, `[]` for concatenation).  \n* `wrap/2` and `unwrap/1` exist for infrastructure, not daily use.  \n* `m_append/3` and `m_concat/2` are low-level helpers that power higher abstractions.  \n* Application code should prefer helpers in `Math`, `Eq.Utils`, `Ord.Utils`, or `Predicate`.\n\n---","ref":"monoid-usage-rules.html#quick-reference"},{"type":"extras","title":"Overview - Funx.Monoid Usage Rules","doc":"`Funx.Monoid` defines how values combine under an associative operation with an identity.  \nEach monoid is represented by a struct (e.g. `%Sum{}`, `%Product{}`, `%Eq.All{}`, `%Ord{}`) and implements:\n\n* `empty/1` → the identity element  \n* `append/2` → associative combination  \n* `wrap/2` / `unwrap/1` → convert between raw values and monoid structs  \n\nMonoids are rarely used directly in application code. Instead, they support utilities like `Math.sum/1`, `Eq.Utils.concat_all/1`, and `Ord.Utils.concat/1`.\n\n---","ref":"monoid-usage-rules.html#overview"},{"type":"extras","title":"Protocol Rules - Funx.Monoid Usage Rules","doc":"* Provide all four functions: `empty/1`, `append/2`, `wrap/2`, `unwrap/1`.  \n* Identity: `append(empty(m), x) == x == append(x, empty(m))`.  \n* Associativity: `append(append(a, b), c) == append(a, append(b, c))`.  \n* Purity: results must be deterministic and side-effect free.  \n\n---","ref":"monoid-usage-rules.html#protocol-rules"},{"type":"extras","title":"Preferred Usage - Funx.Monoid Usage Rules","doc":"","ref":"monoid-usage-rules.html#preferred-usage"},{"type":"extras","title":"Go Through Utilities - Funx.Monoid Usage Rules","doc":"Use high-level helpers instead of wiring monoids manually:\n\n* **Numbers** → `Math.sum/1`, `Math.product/1`, `Math.max/1`, `Math.min/1`  \n* **Equality** → `Eq.Utils.concat_all/1`, `Eq.Utils.concat_any/1`  \n* **Ordering** → `Ord.Utils.concat/1`, `Ord.Utils.append/2`  \n* **Predicates** → `Predicate.p_and/2`, `Predicate.p_or/2`, `Predicate.p_all/1`, `Predicate.p_any/1`\n\nThese functions already call `m_concat/2` and `m_append/3`.  \nYou don’t need to construct `%Monoid.*{}` by hand.\n\n---","ref":"monoid-usage-rules.html#go-through-utilities"},{"type":"extras","title":"Examples - Funx.Monoid Usage Rules","doc":"#### Equality Composition\n\n```elixir\nalias Funx.Eq.Utils, as: EqU\n\nname_eq = EqU.contramap(& &1.name)\nage_eq  = EqU.contramap(& &1.age)\n\nEqU.concat_all([name_eq, age_eq])  # AND semantics\nEqU.concat_any([name_eq, age_eq])  # OR semantics\n```\n\n#### Ordering Composition\n\n```elixir\nalias Funx.Ord.Utils, as: OrdU\n\nage  = OrdU.contramap(& &1.age)\nname = OrdU.contramap(& &1.name)\n\nOrdU.concat([age, name])  # lexicographic ordering\n```\n\n#### Math Helpers\n\n```elixir\nalias Funx.Math\n\nMath.sum([1, 2, 3])     # => 6\nMath.product([2, 3, 4]) # => 24\nMath.max([7, 3, 5])     # => 7\nMath.min([7, 3, 5])     # => 3\n```\n\n---","ref":"monoid-usage-rules.html#examples"},{"type":"extras","title":"Interop - Funx.Monoid Usage Rules","doc":"* `Eq.Utils` relies on `Eq.All` and `Eq.Any` monoids for composition.\n* `Ord.Utils` uses the `Ord` monoid for lexicographic comparison.\n* `Math` uses monoids for numeric folds.\n\n**Rule of thumb:** application code never wires `%Monoid.*{}` directly—always go through the utility combinators.\n\n---","ref":"monoid-usage-rules.html#interop"},{"type":"extras","title":"Stability Contract - Funx.Monoid Usage Rules","doc":"* Identities must be stable and input-independent.\n* `append/2` must be associative for all valid values.\n* `wrap/2` and `unwrap/1` must be inverses.\n\n---","ref":"monoid-usage-rules.html#stability-contract"},{"type":"extras","title":"Anti-Patterns - Funx.Monoid Usage Rules","doc":"* Hand-wiring `%Monoid.*{}` in application code.\n* Mixing different monoid types in one `append/2`.\n* Using fake identities (`nil` instead of `0` for sum).\n* Hiding side effects inside protocol functions.\n\n---","ref":"monoid-usage-rules.html#anti-patterns"},{"type":"extras","title":"Good Patterns - Funx.Monoid Usage Rules","doc":"* Use `Math`, `Eq.Utils`, `Ord.Utils`, or `Predicate` instead of raw monoids.\n* Keep identities explicit in library code (`0`, `1`, `[]`, `Float.min_finite()` / `Float.max_finite()`).\n* Let `m_concat/2` and `m_append/3` handle the wrapping/combining logic.\n\n---","ref":"monoid-usage-rules.html#good-patterns"},{"type":"extras","title":"When to Define a New Monoid - Funx.Monoid Usage Rules","doc":"Define a monoid struct if you need associative combination + identity:\n\n* Counters, tallies, or scores\n* Config merges (e.g. left-biased / right-biased maps)\n* “Best-of” or “min-by/max-by” selections\n* Predicate or decision combination\n\nExpose it through a utility module—application code should not use it raw.\n\n---","ref":"monoid-usage-rules.html#when-to-define-a-new-monoid"},{"type":"extras","title":"Built-in Instances - Funx.Monoid Usage Rules","doc":"* `%Funx.Monoid.Sum{}` — numeric sum (`0`)\n* `%Funx.Monoid.Product{}` — numeric product (`1`)\n* `%Funx.Monoid.Max{}` — maximum (`Float.min_finite()`)\n* `%Funx.Monoid.Min{}` — minimum (`Float.max_finite()`)\n* `%Funx.Monoid.ListConcat{}` — list concatenation (`[]`)\n* `%Funx.Monoid.StringConcat{}` — string concatenation (`\"\"`)\n* `%Funx.Monoid.Eq.All{}` / `%Funx.Monoid.Eq.Any{}` — equality composition\n* `%Funx.Monoid.Ord{}` — ordering composition\n\nThese back the higher-level helpers. Use `Math`, `Eq.Utils`, `Ord.Utils`, or `Predicate` instead.","ref":"monoid-usage-rules.html#built-in-instances"},{"type":"extras","title":"Funx.Predicate Usage Rules","doc":"# `Funx.Predicate` Usage Rules","ref":"predicate-usage-rules.html"},{"type":"extras","title":"Quick Reference - Funx.Predicate Usage Rules","doc":"* A predicate is any function that returns a truthy or falsy result (arity is unrestricted).\n* Use `p_and/2` and `p_or/2` for binary composition.\n* Use `p_not/1` to negate a single predicate.\n* Use `p_all/1`, `p_any/1`, and `p_none/1` for list-based composition.\n* All combinators return new predicates and preserve short-circuiting.\n* Backed by monoids: `%Pred.All{}` (AND) and `%Pred.Any{}` (OR).\n\n---","ref":"predicate-usage-rules.html#quick-reference"},{"type":"extras","title":"Overview - Funx.Predicate Usage Rules","doc":"`Funx.Predicate` defines composable helpers for building logic from predicates—functions that return truthy or falsy results.\nPredicates may be curried, partially applied, or lifted into a context. Composition is declarative and implemented via the `Monoid` protocol, enabling identity-safe and short-circuiting behavior across flows.\n\nUse these helpers to generate reusable logic blocks, express boolean conditions in pipelines, and support functional control flow.\n\n---","ref":"predicate-usage-rules.html#overview"},{"type":"extras","title":"Composition Rules - Funx.Predicate Usage Rules","doc":"| Function   | Description                            |\n| ---------- | -------------------------------------- |\n| `p_and/2`  | Logical AND of two predicates          |\n| `p_or/2`   | Logical OR of two predicates           |\n| `p_not/1`  | Logical negation of a single predicate |\n| `p_all/1`  | AND fold over a list of predicates     |\n| `p_any/1`  | OR fold over a list of predicates      |\n| `p_none/1` | `p_not(p_any(...))`                    |\n\nAll are powered by `%Pred.All{}` and `%Pred.Any{}`, and support composition before or after lifting into context.\n\n---","ref":"predicate-usage-rules.html#composition-rules"},{"type":"extras","title":"Correct Usage Patterns - Funx.Predicate Usage Rules","doc":"","ref":"predicate-usage-rules.html#correct-usage-patterns"},{"type":"extras","title":"Combine Two Predicates - Funx.Predicate Usage Rules","doc":"```elixir\ncombined = p_and(pred1, pred2)\ncombined.(input)\n```","ref":"predicate-usage-rules.html#combine-two-predicates"},{"type":"extras","title":"Combine a List of Predicates - Funx.Predicate Usage Rules","doc":"```elixir\npred = p_all([pred1, pred2, pred3])\npred.(input)\n```\n\nEmpty lists behave predictably:\n\n* `p_all([])` → always truthy\n* `p_any([])` → always falsy\n* `p_none([])` → always truthy","ref":"predicate-usage-rules.html#combine-a-list-of-predicates"},{"type":"extras","title":"Negate a Predicate - Funx.Predicate Usage Rules","doc":"```elixir\nnegated = p_not(pred)\nnegated.(input)\n```\n\n`p_not/1` accepts exactly one predicate.\n\n---","ref":"predicate-usage-rules.html#negate-a-predicate"},{"type":"extras","title":"Compositional Guidelines - Funx.Predicate Usage Rules","doc":"LLMs should:\n\n* Prefer `p_all/1` or `p_any/1` for 3+ conditions (avoid deep `p_and/2` chains).\n* Use `p_not/1` instead of manually wrapping with `not`.\n* Use `p_none/1` to express “none of these” logic.\n* Support predicates of any arity—assume currying is allowed.\n* Compose before or after lifting into a context (e.g. `Maybe`, `Either`).\n* Treat predicates as logic components—not inline branches.\n* Avoid expanding predicate logic into full evaluation chains.\n\n---","ref":"predicate-usage-rules.html#compositional-guidelines"},{"type":"extras","title":"Stability Contract - Funx.Predicate Usage Rules","doc":"Completions must preserve:\n\n* **Purity** — predicates are referentially transparent.\n* **Short-circuiting** — return early when result is known.\n* **Logical identity**:\n\n  * `p_all([])` → always returns truthy\n  * `p_any([])` → always returns falsy\n  * `p_none([])` → always returns truthy\n\n---","ref":"predicate-usage-rules.html#stability-contract"},{"type":"extras","title":"Anti-Patterns - Funx.Predicate Usage Rules","doc":"Avoid these:\n\n* `fn x -> a.(x) and b.(x) end` — use `p_and/2`\n* `fn x -> not pred.(x) end` — use `p_not/1`\n* `Enum.any?/2` or `Enum.all?/2` for predicate folding\n* Misusing `p_not/1` as if it accepts multiple predicates\n* Assuming arity-1 (do not destructure inputs or overgeneralize)\n\n---","ref":"predicate-usage-rules.html#anti-patterns"},{"type":"extras","title":"Good Patterns - Funx.Predicate Usage Rules","doc":"Generate completions like:\n\n```elixir\n# Composable conditions\npred = p_all([pred1, p_not(pred2), pred3])\n```\n\n```elixir\n# Reusable blocks\nfilter = p_any([is_vip, has_pass])\nEnum.filter(list, filter)\n```\n\n---","ref":"predicate-usage-rules.html#good-patterns"},{"type":"extras","title":"When to Compose - Funx.Predicate Usage Rules","doc":"Use predicate combinators for:\n\n* Validation and gating logic\n* Rule pipelines and filters\n* Declarative control structures\n* Monadic guards\n* Reusable logic composition\n\nReach for these when boolean logic needs to be:\n\n* Declarative\n* Curried\n* Lifted\n* Composed\n* Short-circuited\n\n---","ref":"predicate-usage-rules.html#when-to-compose"},{"type":"extras","title":"Built-in Behavior - Funx.Predicate Usage Rules","doc":"All combinators rely on:\n\n* `%Funx.Monoid.Predicate.All{}` — implements logical AND\n* `%Funx.Monoid.Predicate.Any{}` — implements logical OR\n\nComposition uses:\n\n* `m_append/3` — binary\n* `m_concat/2` — list\n\nThese abstractions preserve identity, associativity, and short-circuit evaluation—allowing safe expansion and reliable reuse.","ref":"predicate-usage-rules.html#built-in-behavior"},{"type":"extras","title":"Funx.Monad Usage Rules","doc":"# `Funx.Monad` Usage Rules","ref":"monad-usage-rules.html"},{"type":"extras","title":"Quick Reference - Funx.Monad Usage Rules","doc":"* A monad = `pure/1` (inject into context) + `bind/2` (chain with context).\n* Use `map/2` to transform while preserving structure.\n* Use `bind/2` to sequence context-aware operations.\n* Use `ap/2` to apply functions already in context.\n* Prefer monads when control flow depends on prior results.\n* Avoid extracting intermediate values—compose instead.\n\n---","ref":"monad-usage-rules.html#quick-reference"},{"type":"extras","title":"Overview - Funx.Monad Usage Rules","doc":"`Funx.Monad` supports declarative control flow in the presence of context.\nIt lets you sequence steps without branching manually or managing state explicitly.\n\nThe `Monad` protocol defines three core operations:\n\n| Function | Purpose                                                            |\n| -------- | ------------------------------------------------------------------ |\n| `pure/1` | Injects a plain value into the monadic context.                    |\n| `map/2`  | Applies a transformation while preserving structure.               |\n| `bind/2` | Sequences context-aware steps—each step may reshape the structure. |\n| `ap/2`   | Applies a function and a value, both inside the same context.      |\n\n---","ref":"monad-usage-rules.html#overview"},{"type":"extras","title":"When to Use It - Funx.Monad Usage Rules","doc":"Use a monad when your code depends on prior steps that occur inside a context:\n\n| Context  | Use Case Example                         |\n| -------- | ---------------------------------------- |\n| `Maybe`  | A missing value cancels the rest.        |\n| `Either` | A failure short-circuits the pipeline.   |\n| `Effect` | Asynchronous steps chained in order.     |\n| `Reader` | Configuration passed implicitly.         |\n| `Writer` | Accumulate logs or context across steps. |\n\nEach step you define declares what happens next—the monad handles how and when.\n\n---","ref":"monad-usage-rules.html#when-to-use-it"},{"type":"extras","title":"Transforming with `map/2` - Funx.Monad Usage Rules","doc":"Use `map/2` to apply a function without changing the structure:\n\n```elixir\nmap(monad, fn x -> transform(x) end)\n```\n\nIf `monad` is a list, the result is a list.\nIf it's a `Maybe`, the result is still a `Maybe`.\nThe shape of the context is preserved.\n\n---","ref":"monad-usage-rules.html#transforming-with-map-2"},{"type":"extras","title":"Sequencing with `bind/2` - Funx.Monad Usage Rules","doc":"Use `bind/2` when your function returns a new monadic value and should take over the pipeline:\n\n```elixir\nbind(monad, fn x -> step(x) end)\n```\n\nEach function must return the same type of monad.\nThis kind of function is called a Kleisli function—a function from a plain value to a wrapped value.\n\nThe structure may change. The monad will flatten and continue.\nThis allows dependent steps to be composed declaratively.\n\n---","ref":"monad-usage-rules.html#sequencing-with-bind-2"},{"type":"extras","title":"Applying with `ap/2` - Funx.Monad Usage Rules","doc":"Use `ap/2` when both the value and the function are inside the context:\n\n```elixir\nap(monadic_value, monadic_function)\n```\n\nThis is especially useful when you want to apply multiple independent values to a multi-argument function:\n\n```elixir\npure(fn x, y -> x + y end)\n|> ap(m1)\n|> ap(m2)\n```\n\n---","ref":"monad-usage-rules.html#applying-with-ap-2"},{"type":"extras","title":"Composing Declarative Logic - Funx.Monad Usage Rules","doc":"Functional control flow becomes:\n\n```elixir\npure(initial)\n|> bind(step1)\n|> bind(step2)\n|> bind(step3)\n```\n\nEach step declares its own rule.\nThe monad handles branching, structure, and short-circuiting as needed.\nThis replaces `case`, `with`, and `try` chains with composable, predictable logic.\n\n---","ref":"monad-usage-rules.html#composing-declarative-logic"},{"type":"extras","title":"Design Guidance - Funx.Monad Usage Rules","doc":"* Do not unwrap intermediate values—compose using `bind/2`.\n* Do not mix monadic and non-monadic code inside pipelines.\n* Avoid early `case` or pattern matches—prefer `bind` to handle flow.","ref":"monad-usage-rules.html#design-guidance"}],"content_type":"text/markdown","producer":{"name":"ex_doc","version":[48,46,51,52,46,50]}}