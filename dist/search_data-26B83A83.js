searchData={"items":[{"type":"protocol","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fappendable%2Fappendable.livemd)\n\nA protocol for combining values in a generic, extensible way.\n\nThe `Appendable` protocol defines how two values of the same type can be combined. It is\nused throughout Funx in functions like `traverse_a/2` and `wither_a/2` to accumulate\nintermediate results without coupling logic to a specific type.\n\nThis protocol enables functions to remain flexible and composable when reducing,\naggregating, or accumulating values across a wide variety of domains.","title":"Funx.Appendable","ref":"Funx.Appendable.html"},{"type":"protocol","doc":"* `coerce/1` – Normalizes an input value into a form suitable for aggregation.\n* `append/2` – Combines two values of the same type into one.","title":"Required functions - Funx.Appendable","ref":"Funx.Appendable.html#module-required-functions"},{"type":"protocol","doc":"A fallback implementation is provided for all types that do not define a specific\n`Appendable` instance. This default uses list concatenation as a universal aggregation\nstrategy: all inputs are coerced into lists (if not already), and combined using `++`.\n\nWhen using the default aggregation strategy, values are collected in a plain list:\n\n```elixir\nvalidate_positive = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(&1 > 0), fn v -> \"Value must be positive: \" <> to_string(v) end)\nend\n\nvalidate_even = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(rem(&1, 2) == 0), fn v -> \"Value must be even: \" <> to_string(v) end)\nend\n\nFunx.Monad.Either.validate(4, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Right{right: 4}\n\nFunx.Monad.Either.validate(3, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Left{left: [\"Value must be even: 3\"]}\n\nFunx.Monad.Either.validate(-3, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Left{left: [\"Value must be positive: -3\", \"Value must be even: -3\"]}\n```","title":"Default – Flat list aggregation - Funx.Appendable","ref":"Funx.Appendable.html#module-default-flat-list-aggregation"},{"type":"protocol","doc":"You can also use a custom struct to hold errors. This example uses `ValidationError`:\n\n```elixir\nalias Funx.Errors.ValidationError\n\nvalidate_positive = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(&1 > 0), fn v -> \"Value must be positive: \" <> to_string(v) end)\n  |> Funx.Monad.Either.map_left(&ValidationError.new/1)\nend\n\nvalidate_even = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(rem(&1, 2) == 0), fn v -> \"Value must be even: \" <> to_string(v) end)\n  |> Funx.Monad.Either.map_left(&ValidationError.new/1)\nend\n\nFunx.Monad.Either.validate(-3, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Left{\n#     left: %ValidationError{\n#       errors: [\"Value must be positive: -3\", \"Value must be even: -3\"]\n#     }\n#   }\n```","title":"Structured aggregation with ValidationError - Funx.Appendable","ref":"Funx.Appendable.html#module-structured-aggregation-with-validationerror"},{"type":"type","doc":"All the types that implement this protocol.","title":"Funx.Appendable.t/0","ref":"Funx.Appendable.html#t:t/0"},{"type":"function","doc":"Combines two values into a single result.\n\nImplementations must ensure the operation is associative within their type. For types\nthat require disambiguation or structural control, define a custom implementation.","title":"Funx.Appendable.append/2","ref":"Funx.Appendable.html#append/2"},{"type":"function","doc":"Normalizes a single input value into a form suitable for accumulation.","title":"Funx.Appendable.coerce/1","ref":"Funx.Appendable.html#coerce/1"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fconfig%2Fconfig.livemd)\n\nInternal access to `:funx` application configuration.\n\nThese functions read from `Application.get_env/3` with sane defaults.\nUsed by effect modules for settings like timeouts, telemetry, and summarization.","title":"Funx.Config","ref":"Funx.Config.html"},{"type":"module","doc":"- `:timeout` — default timeout for running effects (default: `5_000` ms)\n- `:telemetry_prefix` — base prefix for telemetry events (default: `[:funx]`)\n- `:telemetry_enabled` — whether telemetry spans are emitted (default: `true`)\n- `:summarizer` — function used to summarize effect results for telemetry\n- `:default_span_name` — fallback span name for telemetry traces","title":"Supported config keys - Funx.Config","ref":"Funx.Config.html#module-supported-config-keys"},{"type":"function","doc":"","title":"Funx.Config.default_span_name/0","ref":"Funx.Config.html#default_span_name/0"},{"type":"function","doc":"","title":"Funx.Config.summarizer/0","ref":"Funx.Config.html#summarizer/0"},{"type":"function","doc":"","title":"Funx.Config.telemetry_enabled?/0","ref":"Funx.Config.html#telemetry_enabled?/0"},{"type":"function","doc":"","title":"Funx.Config.telemetry_prefix/0","ref":"Funx.Config.html#telemetry_prefix/0"},{"type":"function","doc":"","title":"Funx.Config.timeout/0","ref":"Funx.Config.html#timeout/0"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Feq%2Feq.livemd)\n\nUtilities and DSL for working with the `Funx.Eq.Protocol`.\n\nThis module provides two main capabilities:\n\n1. **Utility functions** for working with equality comparisons:\n   - `contramap/2` - Transform equality checks via projections\n   - `eq?/3`, `not_eq?/3` - Direct equality checks\n   - `append_all/2`, `append_any/2` - Combine comparators\n   - `concat_all/1`, `concat_any/1` - Combine lists of comparators\n   - `to_predicate/2` - Convert to single-argument predicates\n\n2. **Declarative DSL** for building complex equality comparators:\n   - `eq do ... end` - Build comparators with clean syntax\n   - Supports `on`, `diff_on`, `any`, and `all` directives\n   - Compiles at compile-time for efficiency\n\nThese functions assume that types passed in either support Elixir's equality operator\nor implement the `Funx.Eq.Protocol` protocol.","title":"Funx.Eq","ref":"Funx.Eq.html"},{"type":"module","doc":"use Funx.Eq\n\n    eq do\n      on :name\n      on :age\n    end","title":"DSL Usage - Funx.Eq","ref":"Funx.Eq.html#module-dsl-usage"},{"type":"module","doc":"Funx.Eq.contramap(&(&1.age))\n    Funx.Eq.eq?(value1, value2)\n\nFor detailed DSL documentation, see the `eq/1` macro below.","title":"Utility Usage - Funx.Eq","ref":"Funx.Eq.html#module-utility-usage"},{"type":"type","doc":"","title":"Funx.Eq.eq_map/0","ref":"Funx.Eq.html#t:eq_map/0"},{"type":"type","doc":"","title":"Funx.Eq.eq_t/0","ref":"Funx.Eq.html#t:eq_t/0"},{"type":"function","doc":"Combines two equality comparators using the `Eq.All` monoid.\n\nThis function merges two equality comparisons, requiring **both** to return `true`\nfor the final result to be considered equal. This enforces a **strict** equality rule,\nwhere all comparators must agree.","title":"Funx.Eq.append_all/2","ref":"Funx.Eq.html#append_all/2"},{"type":"function","doc":"iex> eq1 = Funx.Eq.contramap(& &1.name)\n    iex> eq2 = Funx.Eq.contramap(& &1.age)\n    iex> combined = Funx.Eq.append_all(eq1, eq2)\n    iex> Funx.Eq.eq?(%{name: \"Alice\", age: 30}, %{name: \"Alice\", age: 30}, combined)\n    true\n    iex> Funx.Eq.eq?(%{name: \"Alice\", age: 30}, %{name: \"Alice\", age: 25}, combined)\n    false","title":"Examples - Funx.Eq.append_all/2","ref":"Funx.Eq.html#append_all/2-examples"},{"type":"function","doc":"Combines two equality comparators using the `Eq.Any` monoid.\n\nThis function merges two equality comparisons, where **at least one**\nmust return `true` for the final result to be considered equal.","title":"Funx.Eq.append_any/2","ref":"Funx.Eq.html#append_any/2"},{"type":"function","doc":"iex> eq1 = Funx.Eq.contramap(& &1.name)\n    iex> eq2 = Funx.Eq.contramap(& &1.age)\n    iex> combined = Funx.Eq.append_any(eq1, eq2)\n    iex> Funx.Eq.eq?(%{name: \"Alice\", age: 30}, %{name: \"Alice\", age: 25}, combined)\n    true\n    iex> Funx.Eq.eq?(%{name: \"Alice\", age: 30}, %{name: \"Bob\", age: 25}, combined)\n    false","title":"Examples - Funx.Eq.append_any/2","ref":"Funx.Eq.html#append_any/2-examples"},{"type":"function","doc":"Concatenates a list of equality comparators using the `Eq.All` monoid.\n\nThe resulting comparator requires **all** comparators in the list to agree\nthat two values are equal.","title":"Funx.Eq.concat_all/1","ref":"Funx.Eq.html#concat_all/1"},{"type":"function","doc":"iex> eq1 = Funx.Eq.contramap(& &1.name)\n    iex> eq2 = Funx.Eq.contramap(& &1.age)\n    iex> combined = Funx.Eq.concat_all([eq1, eq2])\n    iex> Funx.Eq.eq?(%{name: \"Alice\", age: 30}, %{name: \"Alice\", age: 30}, combined)\n    true\n    iex> Funx.Eq.eq?(%{name: \"Alice\", age: 30}, %{name: \"Alice\", age: 25}, combined)\n    false","title":"Examples - Funx.Eq.concat_all/1","ref":"Funx.Eq.html#concat_all/1-examples"},{"type":"function","doc":"Concatenates a list of equality comparators using the `Eq.Any` monoid.\n\nThe resulting comparator allows **any** comparator in the list to determine\nequality, making it more permissive.","title":"Funx.Eq.concat_any/1","ref":"Funx.Eq.html#concat_any/1"},{"type":"function","doc":"iex> eq1 = Funx.Eq.contramap(& &1.name)\n    iex> eq2 = Funx.Eq.contramap(& &1.age)\n    iex> combined = Funx.Eq.concat_any([eq1, eq2])\n    iex> Funx.Eq.eq?(%{name: \"Alice\", age: 30}, %{name: \"Alice\", age: 25}, combined)\n    true\n    iex> Funx.Eq.eq?(%{name: \"Alice\", age: 30}, %{name: \"Bob\", age: 25}, combined)\n    false","title":"Examples - Funx.Eq.concat_any/1","ref":"Funx.Eq.html#concat_any/1-examples"},{"type":"function","doc":"Transforms an equality check by applying a projection before comparison.\n\nThe `projection` must be one of:\n\n  * a function `(a -> b)` - Applied directly to extract the comparison value\n  * a `Lens` - Uses `view!/2` to extract the focused value (raises on missing)\n  * a `Prism` - Uses `preview/2` (Nothing == Nothing)\n  * a tuple `{Prism, default}` - Uses `preview/2`, falling back to `default` on `Nothing`\n  * a `Traversal` - Uses `to_list_maybe/2`, compares all foci element-by-element (both must have all foci)\n\nThe `eq` parameter may be an `Eq` module or a custom comparator map\nwith `:eq?` and `:not_eq?` functions. The projection is applied to both\ninputs before invoking the underlying comparator.","title":"Funx.Eq.contramap/2","ref":"Funx.Eq.html#contramap/2"},{"type":"function","doc":"Using a projection function:\n\n    iex> eq = Funx.Eq.contramap(& &1.age)\n    iex> eq.eq?.(%{age: 30}, %{age: 30})\n    true\n    iex> eq.eq?.(%{age: 30}, %{age: 25})\n    false\n\nUsing a lens for single key access:\n\n    iex> eq = Funx.Eq.contramap(Funx.Optics.Lens.key(:age))\n    iex> eq.eq?.(%{age: 40}, %{age: 40})\n    true\n\nUsing a prism with a default value:\n\n    iex> prism = Funx.Optics.Prism.key(:score)\n    iex> eq = Funx.Eq.contramap({prism, 0})\n    iex> eq.eq?.(%{score: 10}, %{score: 10})\n    true\n    iex> eq.eq?.(%{}, %{score: 0})\n    true","title":"Examples - Funx.Eq.contramap/2","ref":"Funx.Eq.html#contramap/2-examples"},{"type":"macro","doc":"Creates an equality comparator from a block of projection specifications.\n\nReturns a `%Funx.Monoid.Eq.All{}` struct that can be used with `Funx.Eq`\nfunctions like `eq?/3`, `not_eq?/3`, or `to_predicate/2`.","title":"Funx.Eq.eq/1","ref":"Funx.Eq.html#eq/1"},{"type":"macro","doc":"- `on` - Field/projection must be equal\n  - `diff_on` - Field/projection must be different\n  - `any` - At least one nested check must pass (OR logic)\n  - `all` - All nested checks must pass (AND logic, implicit at top level)","title":"Directives - Funx.Eq.eq/1","ref":"Funx.Eq.html#eq/1-directives"},{"type":"macro","doc":"The DSL supports the same projection forms as Ord DSL:\n\n  - Atom - Field access via `Prism.key(atom)`\n  - Atom with or_else - Optional field via `{Prism.key(atom), or_else}`\n  - Function - Direct projection `fn x -> ... end` or `&fun/1`\n  - Lens - Explicit lens for nested access (raises on missing)\n  - Prism - Explicit prism for optional fields\n  - Prism with or_else - `{Prism.t(), or_else}` for optional with fallback\n  - Behaviour - Custom equality via `c:Funx.Eq.Dsl.Behaviour.eq/1`","title":"Projection Types - Funx.Eq.eq/1","ref":"Funx.Eq.html#eq/1-projection-types"},{"type":"macro","doc":"**Core Eq** (using only `on`, `all`, `any`) forms an equivalence relation with three properties:\n\n  - **Reflexive**: `eq?(a, a)` is always true\n  - **Symmetric**: If `eq?(a, b)` then `eq?(b, a)`\n  - **Transitive**: If `eq?(a, b)` and `eq?(b, c)` then `eq?(a, c)`\n\nThese properties guarantee that Core Eq partitions values into equivalence classes, making it\nsafe for use with Enum.uniq/2, MapSet, and grouping operations.\n\n**Extended Eq** (using `diff_on`) expresses boolean equality predicates and does not guarantee transitivity.\n\n**Important**: If you need equivalence classes (grouping, uniq, set membership), do not use `diff_on`.","title":"Equivalence Relations and diff_on - Funx.Eq.eq/1","ref":"Funx.Eq.html#eq/1-equivalence-relations-and-diff_on"},{"type":"macro","doc":"Basic multi-field equality:\n\n    use Funx.Eq\n\n    eq_person = eq do\n      on :name\n      on :age\n    end\n\nUsing diff_on to check difference:\n\n    eq_same_person = eq do\n      on :name\n      on :email\n      diff_on :id\n    end\n\nNested any blocks (OR logic):\n\n    eq_contact = eq do\n      any do\n        on :email\n        on :username\n      end\n    end\n\nMixed composition:\n\n    eq_mixed = eq do\n      on :department\n      any do\n        on :email\n        on :username\n      end\n    end\n\nWith nested field paths:\n\n    eq_nested = eq do\n      on [:user, :profile, :name]\n      on [:user, :profile, :age]\n    end","title":"Examples - Funx.Eq.eq/1","ref":"Funx.Eq.html#eq/1-examples"},{"type":"function","doc":"Returns true if two values are equal, using a specified or default `Eq`.\n\nThis function compares the values *directly*, without applying any projection.\nFor comparisons that require projecting or focusing on part of a structure,\nuse `Funx.Eq.eq_by?/4` or `Funx.Eq.contramap/2`.","title":"Funx.Eq.eq?/3","ref":"Funx.Eq.html#eq?/3"},{"type":"function","doc":"iex> Funx.Eq.eq?(42, 42)\n    true\n    iex> Funx.Eq.eq?(\"foo\", \"bar\")\n    false","title":"Examples - Funx.Eq.eq?/3","ref":"Funx.Eq.html#eq?/3-examples"},{"type":"function","doc":"Checks equality of two values by applying a projection before comparison.\n\nThe `projection` must be one of:\n\n  * a function `(a -> b)` - Applied directly to extract the comparison value\n  * a `Lens` - Uses `view!/2` to extract the focused value (raises on missing)\n  * a tuple `{Prism, default}` - Uses `preview/2`, falling back to `default` on `Nothing`\n\nThe `eq` parameter may be an `Eq` module or a custom comparator map.\nThe projection is applied to both arguments before invoking the comparator.","title":"Funx.Eq.eq_by?/4","ref":"Funx.Eq.html#eq_by?/4"},{"type":"function","doc":"Using a projection function:\n\n    iex> Funx.Eq.eq_by?(& &1.age, %{age: 30}, %{age: 30})\n    true\n    iex> Funx.Eq.eq_by?(& &1.age, %{age: 30}, %{age: 25})\n    false\n\nUsing a lens for single key access:\n\n    iex> Funx.Eq.eq_by?(Funx.Optics.Lens.key(:age), %{age: 40}, %{age: 40})\n    true\n\nUsing a prism with a default value:\n\n    iex> prism = Funx.Optics.Prism.key(:score)\n    iex> Funx.Eq.eq_by?({prism, 0}, %{score: 10}, %{score: 10})\n    true\n    iex> Funx.Eq.eq_by?({prism, 0}, %{}, %{score: 0})\n    true","title":"Examples - Funx.Eq.eq_by?/4","ref":"Funx.Eq.html#eq_by?/4-examples"},{"type":"function","doc":"Returns false if two values are not equal, using a specified or default `Eq`.\n\nThis function compares the values directly, without applying any projection.\nFor comparisons based on a projection, lens, key, or path,\nuse `Funx.Eq.eq_by?/4` or a comparator produced by `Funx.Eq.contramap/2`.","title":"Funx.Eq.not_eq?/3","ref":"Funx.Eq.html#not_eq?/3"},{"type":"function","doc":"iex> Funx.Eq.not_eq?(42, 99)\n    true\n    iex> Funx.Eq.not_eq?(\"foo\", \"foo\")\n    false","title":"Examples - Funx.Eq.not_eq?/3","ref":"Funx.Eq.html#not_eq?/3-examples"},{"type":"function","doc":"","title":"Funx.Eq.to_eq_map/1","ref":"Funx.Eq.html#to_eq_map/1"},{"type":"function","doc":"Converts an `Eq` comparator into a single-argument predicate function for use in `Enum` functions.\n\nThe resulting predicate takes a single element and returns `true` if it matches the `target`\nbased on the specified `Eq`. If no custom `Eq` is provided, it defaults to `Funx.Eq.Protocol`.","title":"Funx.Eq.to_predicate/2","ref":"Funx.Eq.html#to_predicate/2"},{"type":"function","doc":"iex> eq = Funx.Eq.contramap(& &1.name)\n    iex> predicate = Funx.Eq.to_predicate(%{name: \"Alice\"}, eq)\n    iex> Funx.Filterable.filter([%{name: \"Alice\"}, %{name: \"Bob\"}], predicate)\n    [%{name: \"Alice\"}]","title":"Examples - Funx.Eq.to_predicate/2","ref":"Funx.Eq.html#to_predicate/2-examples"},{"type":"behaviour","doc":"Behaviour for custom equality logic in the Eq DSL.\n\nImplement this behaviour to define reusable Eq comparators that can be\nused with `on` directives in the DSL without implementing the Eq protocol.\n\nThis is useful for teams that want to avoid teaching developers about protocols,\nor want struct-specific equality without global protocol implementations.","title":"Funx.Eq.Dsl.Behaviour","ref":"Funx.Eq.Dsl.Behaviour.html"},{"type":"behaviour","doc":"defmodule UserById do\n      @behaviour Funx.Eq.Dsl.Behaviour\n\n      @impl true\n      def eq(_opts) do\n        Funx.Eq.contramap(&(&1.id))\n      end\n    end\n\n    # In DSL\n    use Funx.Eq\n\n    eq do\n      on UserById  # Compares by id\n    end","title":"Basic Example - Funx.Eq.Dsl.Behaviour","ref":"Funx.Eq.Dsl.Behaviour.html#module-basic-example"},{"type":"behaviour","doc":"defmodule UserByName do\n      @behaviour Funx.Eq.Dsl.Behaviour\n\n      @impl true\n      def eq(opts) do\n        case_sensitive = Keyword.get(opts, :case_sensitive, true)\n\n        if case_sensitive do\n          Funx.Eq.contramap(&(&1.name))\n        else\n          Funx.Eq.contramap(fn u -> String.downcase(u.name) end)\n        end\n      end\n    end\n\n    # In DSL\n    eq do\n      on UserByName, case_sensitive: false\n    end","title":"With Options - Funx.Eq.Dsl.Behaviour","ref":"Funx.Eq.Dsl.Behaviour.html#module-with-options"},{"type":"behaviour","doc":"- **Simpler**: Just one function returning an Eq map\n- **No protocol knowledge required**: Easier for team onboarding\n- **Module-specific**: Override struct equality without global protocol\n- **Options support**: Built-in support for configuration\n\nThe returned Eq map typically uses `Funx.Eq.contramap/2` to build\nprojection-based equality, but can implement any custom comparison logic.","title":"Why Use This Instead of Protocols? - Funx.Eq.Dsl.Behaviour","ref":"Funx.Eq.Dsl.Behaviour.html#module-why-use-this-instead-of-protocols"},{"type":"callback","doc":"Returns an Eq map for comparison.\n\nTakes options and returns an Eq map (with `:eq?` and `:not_eq?` functions).","title":"Funx.Eq.Dsl.Behaviour.eq/1","ref":"Funx.Eq.Dsl.Behaviour.html#c:eq/1"},{"type":"callback","doc":"* `opts` - Keyword list of options passed from the DSL","title":"Arguments - Funx.Eq.Dsl.Behaviour.eq/1","ref":"Funx.Eq.Dsl.Behaviour.html#c:eq/1-arguments"},{"type":"callback","doc":"An Eq map with the structure:\n\n    %{\n      eq?: (any(), any() -> boolean()),\n      not_eq?: (any(), any() -> boolean())\n    }","title":"Return Value - Funx.Eq.Dsl.Behaviour.eq/1","ref":"Funx.Eq.Dsl.Behaviour.html#c:eq/1-return-value"},{"type":"callback","doc":"# Simple projection-based equality\n    def eq(_opts) do\n      Funx.Eq.contramap(&(&1.id))\n    end\n\n    # With options\n    def eq(opts) do\n      field = Keyword.get(opts, :field, :id)\n      Funx.Eq.contramap(&Map.get(&1, field))\n    end\n\n    # Custom comparison logic\n    def eq(_opts) do\n      %{\n        eq?: fn a, b -> normalize(a) == normalize(b) end,\n        not_eq?: fn a, b -> normalize(a) != normalize(b) end\n      }\n    end\n\nMost implementations use `Funx.Eq.contramap/2` for projection-based\nequality, which handles the Eq map creation automatically.","title":"Examples - Funx.Eq.Dsl.Behaviour.eq/1","ref":"Funx.Eq.Dsl.Behaviour.html#c:eq/1-examples"},{"type":"protocol","doc":"The `Funx.Eq.Protocol` protocol defines an equality function, `eq?/2`, for comparing two values,\nand its complement, `not_eq?/2`, for checking inequality.\n\nTypes that implement this protocol can define custom equality logic, allowing for\ndomain-specific comparisons.","title":"Funx.Eq.Protocol","ref":"Funx.Eq.Protocol.html"},{"type":"protocol","doc":"The protocol uses `@fallback_to_any true`, meaning that if a specific type does not\nimplement `Funx.Eq.Protocol`, it falls back to the default implementation for `Any`, which\nuses Elixir's built-in equality operator (`==`).","title":"Fallback - Funx.Eq.Protocol","ref":"Funx.Eq.Protocol.html#module-fallback"},{"type":"protocol","doc":"With a custom implementation for a `Funx.Monad.Maybe` type:\n\n    iex> Funx.Eq.Protocol.eq?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(3))\n    true\n\n    iex> Funx.Eq.Protocol.eq?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(5))\n    false\n\n    iex> Funx.Eq.Protocol.eq?(Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.nothing())\n    true\n\n    iex> Funx.Eq.Protocol.eq?(Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.just(5))\n    false\n\nChecking inequality with `not_eq?/2`:\n\n    iex> Funx.Eq.Protocol.not_eq?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(3))\n    false\n\n    iex> Funx.Eq.Protocol.not_eq?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(5))\n    true\n\n    iex> Funx.Eq.Protocol.not_eq?(Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.nothing())\n    false\n\n    iex> Funx.Eq.Protocol.not_eq?(Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.just(5))\n    true","title":"Examples - Funx.Eq.Protocol","ref":"Funx.Eq.Protocol.html#module-examples"},{"type":"type","doc":"All the types that implement this protocol.","title":"Funx.Eq.Protocol.t/0","ref":"Funx.Eq.Protocol.html#t:t/0"},{"type":"function","doc":"Returns `true` if `a` is equal to `b`, otherwise returns `false`.","title":"Funx.Eq.Protocol.eq?/2","ref":"Funx.Eq.Protocol.html#eq?/2"},{"type":"function","doc":"iex> Funx.Eq.Protocol.eq?(1, 1)\n    true\n\n    iex> Funx.Eq.Protocol.eq?(1, 2)\n    false","title":"Examples - Funx.Eq.Protocol.eq?/2","ref":"Funx.Eq.Protocol.html#eq?/2-examples"},{"type":"function","doc":"Returns `true` if `a` is not equal to `b`, otherwise returns `false`.","title":"Funx.Eq.Protocol.not_eq?/2","ref":"Funx.Eq.Protocol.html#not_eq?/2"},{"type":"function","doc":"iex> Funx.Eq.Protocol.not_eq?(1, 1)\n    false\n\n    iex> Funx.Eq.Protocol.not_eq?(1, 2)\n    true","title":"Examples - Funx.Eq.Protocol.not_eq?/2","ref":"Funx.Eq.Protocol.html#not_eq?/2-examples"},{"type":"protocol","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Ffilterable%2Ffilterable.livemd)\n\nThe `Funx.Filterable` protocol defines functions for conditionally retaining or discarding\nvalues within a context. It generalizes the concepts of `filter`, `filter_map`, and `guard`\nacross different data structures like `Maybe`, `List`, and others.\n\nThese functions enable conditional value retention, transformation, and short-circuiting based\non boolean conditions or predicate functions.","title":"Funx.Filterable","ref":"Funx.Filterable.html"},{"type":"type","doc":"All the types that implement this protocol.","title":"Funx.Filterable.t/0","ref":"Funx.Filterable.html#t:t/0"},{"type":"function","doc":"Retains values that satisfy the given predicate.\n\nThe `filter/2` function applies a predicate to the value(s) inside the context. If the predicate returns `true`,\nthe value is retained; otherwise, it is discarded. For collections, it filters all elements based on the predicate.","title":"Funx.Filterable.filter/2","ref":"Funx.Filterable.html#filter/2"},{"type":"function","doc":"- `structure`: The context-wrapped value or collection.\n- `predicate`: A function `(a -> boolean)` determining whether to retain each value.","title":"Parameters: - Funx.Filterable.filter/2","ref":"Funx.Filterable.html#filter/2-parameters"},{"type":"function","doc":"iex> Funx.Filterable.filter(Funx.Monad.Maybe.just(5), &(&1 > 3))\n    %Funx.Monad.Maybe.Just{value: 5}\n\n    iex> Funx.Filterable.filter(Funx.Monad.Maybe.just(2), &(&1 > 3))\n    %Funx.Monad.Maybe.Nothing{}","title":"Examples - Funx.Filterable.filter/2","ref":"Funx.Filterable.html#filter/2-examples"},{"type":"function","doc":"Applies a function that returns a `Maybe` value, combining filtering and mapping in a single pass.\n\n`filter_map/2` applies the provided function to the value(s) within the context. If the function returns `Just`,\nthe transformed value is retained; if it returns `Nothing`, the value is discarded. This avoids multiple traversals\nwhen both mapping and filtering are required.","title":"Funx.Filterable.filter_map/2","ref":"Funx.Filterable.html#filter_map/2"},{"type":"function","doc":"- `structure`: The context-wrapped value or collection.\n- `func`: A function `(a -> Maybe b)` that both transforms and conditionally retains values.","title":"Parameters: - Funx.Filterable.filter_map/2","ref":"Funx.Filterable.html#filter_map/2-parameters"},{"type":"function","doc":"iex> Funx.Filterable.filter_map(Funx.Monad.Maybe.just(5), fn x -> if x > 3, do: Funx.Monad.Maybe.just(x * 2), else: Funx.Monad.Maybe.nothing() end)\n    %Funx.Monad.Maybe.Just{value: 10}\n\n    iex> Funx.Filterable.filter_map(Funx.Monad.Maybe.just(2), fn x -> if x > 3, do: Funx.Monad.Maybe.just(x * 2), else: Funx.Monad.Maybe.nothing() end)\n    %Funx.Monad.Maybe.Nothing{}","title":"Examples - Funx.Filterable.filter_map/2","ref":"Funx.Filterable.html#filter_map/2-examples"},{"type":"function","doc":"Conditionally retains a value within the context. If the boolean is true, returns the existing value;\notherwise, returns an empty value for the context.","title":"Funx.Filterable.guard/2","ref":"Funx.Filterable.html#guard/2"},{"type":"function","doc":"- `structure`: The context-wrapped value (e.g., `Just`, list, etc.).\n- `bool`: A boolean indicating whether to retain the value.","title":"Parameters: - Funx.Filterable.guard/2","ref":"Funx.Filterable.html#guard/2-parameters"},{"type":"function","doc":"iex> Funx.Filterable.guard(Funx.Monad.Maybe.just(42), true)\n    %Funx.Monad.Maybe.Just{value: 42}\n\n    iex> Funx.Filterable.guard(Funx.Monad.Maybe.just(42), false)\n    %Funx.Monad.Maybe.Nothing{}\n\n    iex> Funx.Filterable.guard(Funx.Monad.Maybe.nothing(), true)\n    %Funx.Monad.Maybe.Nothing{}","title":"Examples - Funx.Filterable.guard/2","ref":"Funx.Filterable.html#guard/2-examples"},{"type":"protocol","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Ffoldable%2Ffoldable.livemd)\n\nThe `Funx.Foldable` protocol defines two core folding operations: `fold_l/3` (fold left) and `fold_r/3` (fold right).\n\nThese functions allow structures to be collapsed into a single value by applying functions in a specific order.\nDepending on the structure, folding can be done from the left (`fold_l/3`) or from the right (`fold_r/3`).","title":"Funx.Foldable","ref":"Funx.Foldable.html"},{"type":"type","doc":"All the types that implement this protocol.","title":"Funx.Foldable.t/0","ref":"Funx.Foldable.html#t:t/0"},{"type":"function","doc":"Folds the structure from the left, applying `func_a` if a condition is met, otherwise applying `func_b`.\n\nThis function collapses a structure by recursively applying the provided functions from the leftmost element to the rightmost.","title":"Funx.Foldable.fold_l/3","ref":"Funx.Foldable.html#fold_l/3"},{"type":"function","doc":"- `structure`: The structure to fold.\n- `func_a`: The function to apply in case of a matching condition.\n- `func_b`: The function to apply if the condition is not met.","title":"Parameters: - Funx.Foldable.fold_l/3","ref":"Funx.Foldable.html#fold_l/3-parameters"},{"type":"function","doc":"iex> Funx.Foldable.fold_l(Funx.Monad.Maybe.just(5), fn x -> x + 1 end, fn -> 0 end)\n    6\n\n    iex> Funx.Foldable.fold_l(Funx.Monad.Maybe.nothing(), fn _ -> 1 end, fn -> 0 end)\n    0","title":"Examples - Funx.Foldable.fold_l/3","ref":"Funx.Foldable.html#fold_l/3-examples"},{"type":"function","doc":"Folds the structure from the right, applying `func_a` if a condition is met, otherwise applying `func_b`.\n\nThis function collapses a structure by recursively applying the provided functions from the rightmost element to the leftmost.","title":"Funx.Foldable.fold_r/3","ref":"Funx.Foldable.html#fold_r/3"},{"type":"function","doc":"- `structure`: The structure to fold.\n- `func_a`: The function to apply in case of a matching condition.\n- `func_b`: The function to apply if the condition is not met.","title":"Parameters: - Funx.Foldable.fold_r/3","ref":"Funx.Foldable.html#fold_r/3-parameters"},{"type":"function","doc":"iex> Funx.Foldable.fold_r(Funx.Monad.Maybe.just(5), fn x -> x + 1 end, fn -> 0 end)\n    6\n\n    iex> Funx.Foldable.fold_r(Funx.Monad.Maybe.nothing(), fn _ -> 1 end, fn -> 0 end)\n    0","title":"Examples - Funx.Foldable.fold_r/3","ref":"Funx.Foldable.html#fold_r/3-examples"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Flist%2Flist.livemd)\n\nThe `Funx.List` module provides utility functions for working with lists while respecting `Eq` and `Ord` instances. This allows for set-like operations, uniqueness constraints, and sorted collections that align with functional programming principles.","title":"Funx.List","ref":"Funx.List.html"},{"type":"module","doc":"- **Equality-based Operations**: Use `Eq` instances to compare elements for uniqueness, intersection, and difference.\n- **Ordering Functions**: Leverage `Ord` instances to sort and enforce uniqueness in sorted collections.\n- **Set Operations**: Perform union, intersection, difference, and symmetric difference while preserving custom equality logic.\n- **Subset & Superset Checks**: Verify relationships between lists in terms of inclusion.\n- **Functional Constructs**: Implements `Monad` and `Foldable` protocols for lists, supporting mapping, binding, and folding.","title":"Features - Funx.List","ref":"Funx.List.html#module-features"},{"type":"module","doc":"1. **Deduplicate**: Use `uniq/1` to remove duplicates based on `Eq`.\n2. **Combine**: Use `union/2` to merge lists without duplicates.\n3. **Filter**: Use `intersection/2` or `difference/2` for set operations.\n4. **Sort**: Use `sort/2` or `strict_sort/2` with `Ord` instances.\n5. **Check Membership**: Use `subset?/2` or `superset?/2` to verify inclusion relationships.\n6. **Find Extremes**: Use `min/2`, `max/2` for safe min/max, or `min!/2`, `max!/2` to raise on empty.","title":"Usage Overview - Funx.List","ref":"Funx.List.html#module-usage-overview"},{"type":"module","doc":"- `uniq/1`: Removes duplicates using `Eq`.\n- `union/2`: Merges lists while preserving uniqueness.\n- `intersection/2`: Returns elements common to both lists.\n- `difference/2`: Returns elements from the first list not in the second.\n- `symmetric_difference/2`: Returns elements unique to each list.","title":"Equality-Based Operations - Funx.List","ref":"Funx.List.html#module-equality-based-operations"},{"type":"module","doc":"- `sort/2`: Sorts a list using `Ord`.\n- `strict_sort/2`: Sorts while ensuring uniqueness.","title":"Ordering Functions - Funx.List","ref":"Funx.List.html#module-ordering-functions"},{"type":"module","doc":"- `subset?/2`: Checks if one list is a subset of another.\n- `superset?/2`: Checks if one list is a superset of another.","title":"Set Operations - Funx.List","ref":"Funx.List.html#module-set-operations"},{"type":"module","doc":"- `min/2`: Returns the minimum element wrapped in `Maybe`.\n- `min!/2`: Returns the minimum element, raises on empty list.\n- `max/2`: Returns the maximum element wrapped in `Maybe`.\n- `max!/2`: Returns the maximum element, raises on empty list.","title":"Min/Max Operations - Funx.List","ref":"Funx.List.html#module-min-max-operations"},{"type":"module","doc":"- `map/2`: Transforms list elements.\n- `bind/2`: Applies a function returning lists and flattens the result.\n- `ap/2`: Applies functions in a list to elements in another list.","title":"Monad Implementation - Funx.List","ref":"Funx.List.html#module-monad-implementation"},{"type":"module","doc":"- `fold_l/3`: Performs left-associative folding.\n- `fold_r/3`: Performs right-associative folding.","title":"Foldable Implementation - Funx.List","ref":"Funx.List.html#module-foldable-implementation"},{"type":"function","doc":"Concatenates a list of lists from left to right.\n\nThis uses the `ListConcat` monoid, preserving the original order of elements.","title":"Funx.List.concat/1","ref":"Funx.List.html#concat/1"},{"type":"function","doc":"iex> Funx.List.concat([[1], [2, 3], [4]])\n    [1, 2, 3, 4]","title":"Examples - Funx.List.concat/1","ref":"Funx.List.html#concat/1-examples"},{"type":"function","doc":"Returns the difference of two lists.","title":"Funx.List.difference/3","ref":"Funx.List.html#difference/3"},{"type":"function","doc":"iex> Funx.List.difference([1, 2, 3, 4], [3, 4, 5])\n    [1, 2]","title":"Examples - Funx.List.difference/3","ref":"Funx.List.html#difference/3-examples"},{"type":"function","doc":"Returns true if the given value is an element of the list under the provided `Eq`.\n\nThis is the Eq-based equivalent of Haskell's `elem`.","title":"Funx.List.elem?/3","ref":"Funx.List.html#elem?/3"},{"type":"function","doc":"iex> Funx.List.elem?([1, 2, 3], 1)\n    true\n\n    iex> Funx.List.elem?([1, 3], 2)\n    false","title":"Examples - Funx.List.elem?/3","ref":"Funx.List.html#elem?/3-examples"},{"type":"function","doc":"Returns the head of a list wrapped in `Maybe.Just`, or `Maybe.Nothing` if empty.\n\nThis is a safe version of `hd/1` that returns `Maybe` instead of raising.","title":"Funx.List.head/1","ref":"Funx.List.html#head/1"},{"type":"function","doc":"iex> Funx.List.head([1, 2, 3])\n    %Funx.Monad.Maybe.Just{value: 1}\n\n    iex> Funx.List.head([])\n    %Funx.Monad.Maybe.Nothing{}\n\n    iex> Funx.List.head(\"not a list\")\n    %Funx.Monad.Maybe.Nothing{}","title":"Examples - Funx.List.head/1","ref":"Funx.List.html#head/1-examples"},{"type":"function","doc":"Returns the head of a list.\n\nRaises `ArgumentError` if the list is empty or not a list.","title":"Funx.List.head!/1","ref":"Funx.List.html#head!/1"},{"type":"function","doc":"iex> Funx.List.head!([1, 2, 3])\n    1\n\n    iex> Funx.List.head!([42])\n    42","title":"Examples - Funx.List.head!/1","ref":"Funx.List.html#head!/1-examples"},{"type":"function","doc":"Returns the intersection of two lists.","title":"Funx.List.intersection/3","ref":"Funx.List.html#intersection/3"},{"type":"function","doc":"iex> Funx.List.intersection([1, 2, 3, 4], [3, 4, 5])\n    [3, 4]","title":"Examples - Funx.List.intersection/3","ref":"Funx.List.html#intersection/3-examples"},{"type":"function","doc":"Returns the maximum element in a list according to the given ordering.\n\nReturns `Just(element)` for non-empty lists, `Nothing` for empty lists.\n\nThis is a safe version that returns `Maybe` instead of raising.\nUse `max!/2` if you want to raise on empty lists.","title":"Funx.List.max/2","ref":"Funx.List.html#max/2"},{"type":"function","doc":"iex> Funx.List.max([3, 1, 4, 1, 5])\n    %Funx.Monad.Maybe.Just{value: 5}\n\n    iex> Funx.List.max([])\n    %Funx.Monad.Maybe.Nothing{}\n\n    iex> ord = Funx.Ord.contramap(&String.length/1)\n    iex> Funx.List.max([\"cat\", \"elephant\", \"ox\"], ord)\n    %Funx.Monad.Maybe.Just{value: \"elephant\"}","title":"Examples - Funx.List.max/2","ref":"Funx.List.html#max/2-examples"},{"type":"function","doc":"Returns the maximum element in a list according to the given ordering.\n\nRaises `Enum.EmptyError` if the list is empty.","title":"Funx.List.max!/2","ref":"Funx.List.html#max!/2"},{"type":"function","doc":"iex> Funx.List.max!([3, 1, 4, 1, 5])\n    5\n\n    iex> ord = Funx.Ord.contramap(&String.length/1)\n    iex> Funx.List.max!([\"cat\", \"elephant\", \"ox\"], ord)\n    \"elephant\"","title":"Examples - Funx.List.max!/2","ref":"Funx.List.html#max!/2-examples"},{"type":"function","doc":"Returns the minimum element in a list according to the given ordering.\n\nReturns `Just(element)` for non-empty lists, `Nothing` for empty lists.\n\nThis is a safe version that returns `Maybe` instead of raising.\nUse `min!/2` if you want to raise on empty lists.","title":"Funx.List.min/2","ref":"Funx.List.html#min/2"},{"type":"function","doc":"iex> Funx.List.min([3, 1, 4, 1, 5])\n    %Funx.Monad.Maybe.Just{value: 1}\n\n    iex> Funx.List.min([])\n    %Funx.Monad.Maybe.Nothing{}\n\n    iex> ord = Funx.Ord.contramap(&String.length/1)\n    iex> Funx.List.min([\"cat\", \"elephant\", \"ox\"], ord)\n    %Funx.Monad.Maybe.Just{value: \"ox\"}","title":"Examples - Funx.List.min/2","ref":"Funx.List.html#min/2-examples"},{"type":"function","doc":"Returns the minimum element in a list according to the given ordering.\n\nRaises `Enum.EmptyError` if the list is empty.","title":"Funx.List.min!/2","ref":"Funx.List.html#min!/2"},{"type":"function","doc":"iex> Funx.List.min!([3, 1, 4, 1, 5])\n    1\n\n    iex> ord = Funx.Ord.contramap(&String.length/1)\n    iex> Funx.List.min!([\"cat\", \"elephant\", \"ox\"], ord)\n    \"ox\"","title":"Examples - Funx.List.min!/2","ref":"Funx.List.html#min!/2-examples"},{"type":"function","doc":"Sorts a list using the given ordering module.","title":"Funx.List.sort/2","ref":"Funx.List.html#sort/2"},{"type":"function","doc":"iex> Funx.List.sort([3, 1, 4, 1, 5])\n    [1, 1, 3, 4, 5]","title":"Examples - Funx.List.sort/2","ref":"Funx.List.html#sort/2-examples"},{"type":"function","doc":"Sorts a list while ensuring uniqueness.","title":"Funx.List.strict_sort/2","ref":"Funx.List.html#strict_sort/2"},{"type":"function","doc":"iex> Funx.List.strict_sort([3, 1, 4, 1, 5])\n    [1, 3, 4, 5]","title":"Examples - Funx.List.strict_sort/2","ref":"Funx.List.html#strict_sort/2-examples"},{"type":"function","doc":"Checks if the first list is a subset of the second.","title":"Funx.List.subset?/3","ref":"Funx.List.html#subset?/3"},{"type":"function","doc":"iex> Funx.List.subset?([1, 2], [1, 2, 3, 4])\n    true\n\n    iex> Funx.List.subset?([1, 5], [1, 2, 3, 4])\n    false","title":"Examples - Funx.List.subset?/3","ref":"Funx.List.html#subset?/3-examples"},{"type":"function","doc":"Checks if the first list is a superset of the second.","title":"Funx.List.superset?/3","ref":"Funx.List.html#superset?/3"},{"type":"function","doc":"iex> Funx.List.superset?([1, 2, 3, 4], [1, 2])\n    true\n\n    iex> Funx.List.superset?([1, 2, 3, 4], [1, 5])\n    false","title":"Examples - Funx.List.superset?/3","ref":"Funx.List.html#superset?/3-examples"},{"type":"function","doc":"Returns the symmetric difference of two lists.","title":"Funx.List.symmetric_difference/3","ref":"Funx.List.html#symmetric_difference/3"},{"type":"function","doc":"iex> Funx.List.symmetric_difference([1, 2, 3], [3, 4, 5])\n    [1, 2, 4, 5]","title":"Examples - Funx.List.symmetric_difference/3","ref":"Funx.List.html#symmetric_difference/3-examples"},{"type":"function","doc":"Returns the tail of a list.\n\nThe tail of an empty list is an empty list.","title":"Funx.List.tail/1","ref":"Funx.List.html#tail/1"},{"type":"function","doc":"iex> Funx.List.tail([1, 2, 3])\n    [2, 3]\n\n    iex> Funx.List.tail([1])\n    []\n\n    iex> Funx.List.tail([])\n    []","title":"Examples - Funx.List.tail/1","ref":"Funx.List.html#tail/1-examples"},{"type":"function","doc":"Returns the union of two lists, removing duplicates.","title":"Funx.List.union/3","ref":"Funx.List.html#union/3"},{"type":"function","doc":"iex> Funx.List.union([1, 2, 3], [3, 4, 5])\n    [1, 2, 3, 4, 5]","title":"Examples - Funx.List.union/3","ref":"Funx.List.html#union/3-examples"},{"type":"function","doc":"Removes duplicate elements from a list based on the given equality module.","title":"Funx.List.uniq/2","ref":"Funx.List.html#uniq/2"},{"type":"function","doc":"iex> Funx.List.uniq([1, 2, 2, 3, 1, 4, 5])\n    [1, 2, 3, 4, 5]","title":"Examples - Funx.List.uniq/2","ref":"Funx.List.html#uniq/2-examples"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmacros%2Fmacros.livemd)\n\nProvides macros for automatically implementing `Funx.Eq` and `Funx.Ord` protocols\nfor structs based on field projections.\n\nThe `Funx.Macros` module generates protocol implementations at compile time,\neliminating boilerplate while providing flexible projection options for both\nequality and ordering comparisons. The macros support simple field access,\nnested structures, optional fields, and custom projections through a unified interface.\n\nThis module is useful for:\n\n  - Implementing `Funx.Eq` protocol for structs with projection-based equality\n  - Implementing `Funx.Ord` protocol with various projection strategies\n  - Handling optional fields with safe defaults via `or_else`\n  - Accessing nested structures through Lens and Prism optics\n  - Custom comparison logic via projection functions","title":"Funx.Macros","ref":"Funx.Macros.html"},{"type":"module","doc":"- `eq_for/2` - Generate `Funx.Eq` protocol implementation (basic)\n  - `eq_for/3` - Generate `Funx.Eq` protocol with options (e.g., `or_else`, `eq`)\n  - `ord_for/2` - Generate `Funx.Ord` protocol implementation (basic)\n  - `ord_for/3` - Generate `Funx.Ord` protocol with options (e.g., `or_else`)","title":"Macros - Funx.Macros","ref":"Funx.Macros.html#module-macros"},{"type":"module","doc":"Both `eq_for` and `ord_for` macros support multiple projection types, all normalized at compile time:\n\n  - **Atom** - Converted to `Prism.key(atom)`. Safe for nil values with `Nothing   ... end` or `&fun/1`. Must return a comparable value.\n  - **Eq DSL** - A pre-built equality comparator from `eq do ... end`. Used directly by `eq_for`.\n  - **Ord DSL** - A pre-built ordering from `ord do ... end`. Used directly by `ord_for`.\n\n> Note: Atoms use Prism by default for safety. Use explicit `Lens.key(:field)` when you need\n> total access that raises on missing keys or nil intermediate values.","title":"Projection Types - Funx.Macros","ref":"Funx.Macros.html#module-projection-types"},{"type":"module","doc":"The `or_else` option provides fallback values for optional fields:\n\n  - **Valid with:** Atoms, Prisms, and helper functions returning Prisms\n  - **Invalid with:** Lens (always returns a value), Traversal (focuses on multiple elements),\n    functions (must handle own defaults), struct literals, or `{Prism, default}` tuples (redundant)\n\nWhen `or_else` is used with an incompatible projection type, a clear compile-time\nerror is raised with actionable guidance.","title":"or_else Option - Funx.Macros","ref":"Funx.Macros.html#module-or_else-option"},{"type":"module","doc":"Simple equality by field:\n\n    iex> defmodule Person do\n    ...>   defstruct [:name, :age]\n    ...>\n    ...>   require Funx.Macros\n    ...>   Funx.Macros.eq_for(Person, :age)\n    ...> end\n    iex> alias Funx.Eq\n    iex> Eq.eq?(%Person{name: \"Alice\", age: 30}, %Person{name: \"Bob\", age: 30})\n    true\n\nEquality with optional field:\n\n    iex> defmodule Item do\n    ...>   defstruct [:name, :score]\n    ...>\n    ...>   require Funx.Macros\n    ...>   Funx.Macros.eq_for(Item, :score, or_else: 0)\n    ...> end\n    iex> alias Funx.Eq\n    iex> i1 = %Item{name: \"A\", score: nil}\n    iex> i2 = %Item{name: \"B\", score: 0}\n    iex> Eq.eq?(i1, i2)  # nil becomes 0, so equal\n    true\n\nOrdering by field with Prism (safe for nil):\n\n    iex> defmodule Product do\n    ...>   defstruct [:name, :rating]\n    ...>\n    ...>   require Funx.Macros\n    ...>   Funx.Macros.ord_for(Product, :rating)\n    ...> end\n    iex> alias Funx.Ord\n    iex> p1 = %Product{name: \"Widget\", rating: 4}\n    iex> p2 = %Product{name: \"Gadget\", rating: 5}\n    iex> Ord.lt?(p1, p2)\n    true\n\nOptional field with or_else:\n\n    iex> defmodule Item do\n    ...>   defstruct [:name, :score]\n    ...>\n    ...>   require Funx.Macros\n    ...>   Funx.Macros.ord_for(Item, :score, or_else: 0)\n    ...> end\n    iex> alias Funx.Ord\n    iex> i1 = %Item{name: \"A\", score: nil}\n    iex> i2 = %Item{name: \"B\", score: 10}\n    iex> Ord.lt?(i1, i2)  # nil becomes 0, so 0 < 10\n    true\n\nNested structure access with Lens:\n\n    iex> defmodule Address, do: defstruct [:city, :state]\n    iex> defmodule Customer do\n    ...>   defstruct [:name, :address]\n    ...>\n    ...>   require Funx.Macros\n    ...>   alias Funx.Optics.Lens\n    ...>   Funx.Macros.ord_for(Customer, Lens.path([:address, :city]))\n    ...> end\n    iex> alias Funx.Ord\n    iex> c1 = %Customer{name: \"Alice\", address: %Address{city: \"Austin\", state: \"TX\"}}\n    iex> c2 = %Customer{name: \"Bob\", address: %Address{city: \"Boston\", state: \"MA\"}}\n    iex> Ord.lt?(c1, c2)  # \"Austin\" < \"Boston\"\n    true\n\nFunction projection:\n\n    iex> defmodule Article do\n    ...>   defstruct [:title, :content]\n    ...>\n    ...>   require Funx.Macros\n    ...>   Funx.Macros.ord_for(Article, &String.length(&1.title))\n    ...> end\n    iex> alias Funx.Ord\n    iex> a1 = %Article{title: \"Short\", content: \"...\"}\n    iex> a2 = %Article{title: \"Very Long Title\", content: \"...\"}\n    iex> Ord.lt?(a1, a2)  # length(\"Short\") < length(\"Very Long Title\")\n    true","title":"Examples - Funx.Macros","ref":"Funx.Macros.html#module-examples"},{"type":"module","doc":"The generated `Ord` implementations leverage the `Funx.Ord` protocol for projected values.\nAny type implementing `Ord` can be used as a projection target:\n\n    defmodule Priority do\n      defstruct [:level]\n    end\n\n    defimpl Funx.Ord, for: Priority do\n      def lt?(a, b), do: a.level   b.level\n      def ge?(a, b), do: a.level >= b.level\n    end\n\n    defmodule Task do\n      defstruct [:title, :priority]\n\n      require Funx.Macros\n      Funx.Macros.ord_for(Task, :priority)  # Uses Funx.Ord.Priority\n    end","title":"Protocol Dispatch - Funx.Macros","ref":"Funx.Macros.html#module-protocol-dispatch"},{"type":"module","doc":"All macros expand at compile time into direct protocol implementations with zero\nruntime overhead. The `ord_for` macro normalizes all projection types into one of\nfour canonical forms that `Funx.Ord.contramap/2` accepts:\n\n  1. `Lens.t()` - Bare Lens struct\n  2. `Prism.t()` - Bare Prism struct (uses `Maybe.lift_ord`)\n  3. `{Prism.t(), or_else}` - Prism with fallback value\n  4. `(a -> b)` - Projection function\n\nExample expansion:\n\n    Funx.Macros.ord_for(Product, :rating, or_else: 0)\n\nCompiles to:\n\n    defimpl Funx.Ord, for: Product do\n      defp __ord_map__ do\n        Funx.Ord.contramap({Prism.key(:rating), 0})\n      end\n\n      def lt?(a, b) when is_struct(a, Product) and is_struct(b, Product) do\n        __ord_map__().lt?.(a, b)\n      end\n      # ... other comparison functions\n    end","title":"Compile-Time Behavior - Funx.Macros","ref":"Funx.Macros.html#module-compile-time-behavior"},{"type":"module","doc":"The macros provide clear compile-time errors for invalid configurations:\n\n  - Using `or_else` with Lens (total access doesn't need fallback)\n  - Using `or_else` with functions (functions must handle own defaults)\n  - Using `or_else` with `{Prism, default}` tuple (redundant)\n  - Using `or_else` with struct literals (ambiguous semantics)\n\nAll error messages include actionable guidance and examples of correct usage.","title":"Error Handling - Funx.Macros","ref":"Funx.Macros.html#module-error-handling"},{"type":"macro","doc":"Generates an implementation of the `Funx.Eq` protocol for the given struct,\nusing the specified projection as the basis for equality comparison.","title":"Funx.Macros.eq_for/3","ref":"Funx.Macros.html#eq_for/3"},{"type":"macro","doc":"The macro supports the same projection types as `ord_for`:\n\n- **Atom** - Converted to `Prism.key(atom)`. Safe for nil values.\n- **Atom with or_else** - `eq_for(Struct, :field, or_else: default)` → `{Prism.key(:field), default}`.\n- **Lens** - Total access via `Lens.key/1` or `Lens.path/1`. Raises on missing values.\n- **Prism** - Partial access via `Prism.key/1` or `Prism.path/1`.\n- **Prism with or_else** - `eq_for(Struct, Prism.key(:field), or_else: default)` → `{prism, default}`.\n- **{Prism, default}** - Partial access with fallback value.\n- **Traversal** - Multiple foci via `Traversal.combine/1`. All foci must match.\n- **Function** - Custom projection function `(struct -> value)`.\n- **Eq DSL** - A pre-built equality comparator from `eq do ... end`. Used directly without contramap.","title":"Projection Types - Funx.Macros.eq_for/3","ref":"Funx.Macros.html#eq_for/3-projection-types"},{"type":"macro","doc":"- `:or_else` - Fallback value for optional fields. Only valid with atoms and Prisms.\n- `:eq` - Custom Eq module or map for comparison. Defaults to `Funx.Eq.Protocol`.","title":"Options - Funx.Macros.eq_for/3","ref":"Funx.Macros.html#eq_for/3-options"},{"type":"macro","doc":"# Atom (backward compatible)\n    defmodule Person do\n      defstruct [:name, :age]\n    end\n    Funx.Macros.eq_for(Person, :age)\n\n    # Atom with or_else\n    Funx.Macros.eq_for(Person, :score, or_else: 0)\n\n    # Lens - total access\n    Funx.Macros.eq_for(Customer, Lens.path([:address, :city]))\n\n    # Prism - partial access\n    Funx.Macros.eq_for(Item, Prism.key(:rating))\n\n    # Traversal - multiple foci\n    Funx.Macros.eq_for(Person, Traversal.combine([Lens.key(:name), Lens.key(:age)]))\n\n    # Function projection\n    Funx.Macros.eq_for(Article, &String.length(&1.title))\n\n    # Custom Eq module\n    Funx.Macros.eq_for(Person, :name, eq: CaseInsensitiveEq)\n\n    # Eq DSL - complex equality with multiple fields\n    use Funx.Eq\n    Funx.Macros.eq_for(Person, eq do\n      on :name\n      on :age\n    end)","title":"Examples - Funx.Macros.eq_for/3","ref":"Funx.Macros.html#eq_for/3-examples"},{"type":"macro","doc":"Generates an implementation of the `Funx.Ord` protocol for the given struct,\nusing the specified projection as the basis for ordering comparisons.","title":"Funx.Macros.ord_for/3","ref":"Funx.Macros.html#ord_for/3"},{"type":"macro","doc":"The macro supports multiple projection types:\n\n- **Atom** - Converted to `Prism.key(atom)`. Safe for nil values (Nothing   comparable)`.\n- **Ord DSL** - A pre-built ordering from `ord do ... end`. Used directly without contramap.","title":"Projection Types - Funx.Macros.ord_for/3","ref":"Funx.Macros.html#ord_for/3-projection-types"},{"type":"macro","doc":"- `:or_else` - Fallback value for optional fields. Only valid with atoms and Prisms.\n- `:ord` - Custom Ord module or map for comparison. Defaults to `Funx.Ord.Protocol`.","title":"Options - Funx.Macros.ord_for/3","ref":"Funx.Macros.html#ord_for/3-options"},{"type":"macro","doc":"# Atom - uses Prism.key (safe for nil)\n    defmodule Product do\n      defstruct [:name, :rating]\n    end\n    Funx.Macros.ord_for(Product, :rating)\n\n    # Atom with or_else - provides default for nil values\n    Funx.Macros.ord_for(Product, :rating, or_else: 0)\n\n    # Lens - total access (raises on nil)\n    defmodule Customer do\n      defstruct [:name, :address]\n    end\n    Funx.Macros.ord_for(Customer, Lens.path([:address, :city]))\n\n    # Prism - partial access\n    Funx.Macros.ord_for(Item, Prism.key(:score))\n\n    # Prism with or_else\n    Funx.Macros.ord_for(Item, Prism.key(:score), or_else: 0)\n\n    # Prism with default tuple (alternative to or_else)\n    Funx.Macros.ord_for(Task, {Prism.key(:priority), 0})\n\n    # Function projection\n    Funx.Macros.ord_for(Article, &String.length(&1.title))\n\n    # Ord DSL - complex ordering with multiple fields\n    use Funx.Ord\n    Funx.Macros.ord_for(Person, ord do\n      asc :name\n      desc :age\n    end)","title":"Examples - Funx.Macros.ord_for/3","ref":"Funx.Macros.html#ord_for/3-examples"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmath%2Fmath.livemd)\n\nProvides mathematical operations using Monoids.\n\nThis module uses the `Sum` and `Product` monoids to perform operations\nsuch as addition and multiplication over values or lists of values.","title":"Funx.Math","ref":"Funx.Math.html"},{"type":"function","doc":"Computes the deviations from the mean for a list of numbers.\n\nReturns `Nothing` if the list is empty.","title":"Funx.Math.deviation/1","ref":"Funx.Math.html#deviation/1"},{"type":"function","doc":"iex> Funx.Math.deviation([1, 2, 3, 4])\n    Funx.Monad.Maybe.pure([-1.5, -0.5, 0.5, 1.5])\n\n    iex> Funx.Math.deviation([5, 5, 5])\n    Funx.Monad.Maybe.pure([0.0, 0.0, 0.0])\n\n    iex> Funx.Math.deviation([])\n    Funx.Monad.Maybe.nothing()","title":"Examples - Funx.Math.deviation/1","ref":"Funx.Math.html#deviation/1-examples"},{"type":"function","doc":"Finds the maximum value in a list using the `Max` monoid.\n\nReturns `Float.min_finite()` if the list is empty.","title":"Funx.Math.max/1","ref":"Funx.Math.html#max/1"},{"type":"function","doc":"iex> Funx.Math.max([3, 7, 2])\n    7\n\n    iex> Funx.Math.max([])\n    Float.min_finite()","title":"Examples - Funx.Math.max/1","ref":"Funx.Math.html#max/1-examples"},{"type":"function","doc":"Returns the maximum of two numbers using the `Max` monoid.","title":"Funx.Math.max/2","ref":"Funx.Math.html#max/2"},{"type":"function","doc":"iex> Funx.Math.max(3, 7)\n    7\n\n    iex> Funx.Math.max(-1, -5)\n    -1","title":"Examples - Funx.Math.max/2","ref":"Funx.Math.html#max/2-examples"},{"type":"function","doc":"Computes the arithmetic mean of a list of numbers.\n\nReturns `Nothing` if the list is empty.","title":"Funx.Math.mean/1","ref":"Funx.Math.html#mean/1"},{"type":"function","doc":"iex> Funx.Math.mean([1, 2, 3, 4])\n    Funx.Monad.Maybe.pure(2.5)\n\n    iex> Funx.Math.mean([])\n    Funx.Monad.Maybe.nothing()","title":"Examples - Funx.Math.mean/1","ref":"Funx.Math.html#mean/1-examples"},{"type":"function","doc":"Finds the minimum value in a list using the `Min` monoid.\n\nReturns `Float.max_finite()` if the list is empty.","title":"Funx.Math.min/1","ref":"Funx.Math.html#min/1"},{"type":"function","doc":"iex> Funx.Math.min([3, 7, 2])\n    2\n\n    iex> Funx.Math.min([])\n    Float.max_finite()","title":"Examples - Funx.Math.min/1","ref":"Funx.Math.html#min/1-examples"},{"type":"function","doc":"Returns the minimum of two numbers using the `Min` monoid.","title":"Funx.Math.min/2","ref":"Funx.Math.html#min/2"},{"type":"function","doc":"iex> Funx.Math.min(3, 7)\n    3\n\n    iex> Funx.Math.min(-1, -5)\n    -5","title":"Examples - Funx.Math.min/2","ref":"Funx.Math.html#min/2-examples"},{"type":"function","doc":"Multiplies a list of numbers using the `Product` monoid.","title":"Funx.Math.product/1","ref":"Funx.Math.html#product/1"},{"type":"function","doc":"iex> Funx.Math.product([2, 3, 4])\n    24\n\n    iex> Funx.Math.product([])\n    1","title":"Examples - Funx.Math.product/1","ref":"Funx.Math.html#product/1-examples"},{"type":"function","doc":"Multiplies two numbers using the `Product` monoid.","title":"Funx.Math.product/2","ref":"Funx.Math.html#product/2"},{"type":"function","doc":"iex> Funx.Math.product(3, 4)\n    12","title":"Examples - Funx.Math.product/2","ref":"Funx.Math.html#product/2-examples"},{"type":"function","doc":"Computes the range (difference between max and min) of a list.\n\nReturns `nothing()` if the list is empty.","title":"Funx.Math.range/1","ref":"Funx.Math.html#range/1"},{"type":"function","doc":"iex> Funx.Math.range([3, 7, 2])\n    Funx.Monad.Maybe.pure(5)\n\n    iex> Funx.Math.range([])\n    Funx.Monad.Maybe.nothing()","title":"Examples - Funx.Math.range/1","ref":"Funx.Math.html#range/1-examples"},{"type":"function","doc":"Computes the square of a number.","title":"Funx.Math.square/1","ref":"Funx.Math.html#square/1"},{"type":"function","doc":"iex> Funx.Math.square(3)\n    9\n\n    iex> Funx.Math.square(-4)\n    16","title":"Examples - Funx.Math.square/1","ref":"Funx.Math.html#square/1-examples"},{"type":"function","doc":"Computes the standard deviation of a list of numbers.\n\nReturns `Nothing` if the list is empty.","title":"Funx.Math.std_dev/1","ref":"Funx.Math.html#std_dev/1"},{"type":"function","doc":"iex> Funx.Math.std_dev([1, 2, 3, 4])\n    Funx.Monad.Maybe.pure(1.118033988749895)\n\n    iex> Funx.Math.std_dev([5, 5, 5])\n    Funx.Monad.Maybe.pure(0.0)\n\n    iex> Funx.Math.std_dev([])\n    Funx.Monad.Maybe.nothing()","title":"Examples - Funx.Math.std_dev/1","ref":"Funx.Math.html#std_dev/1-examples"},{"type":"function","doc":"Sums a list of numbers using the `Sum` monoid.","title":"Funx.Math.sum/1","ref":"Funx.Math.html#sum/1"},{"type":"function","doc":"iex> Funx.Math.sum([1, 2, 3])\n    6\n\n    iex> Funx.Math.sum([])\n    0","title":"Examples - Funx.Math.sum/1","ref":"Funx.Math.html#sum/1-examples"},{"type":"function","doc":"Sums two numbers using the `Sum` monoid.","title":"Funx.Math.sum/2","ref":"Funx.Math.html#sum/2"},{"type":"function","doc":"iex> Funx.Math.sum(1, 2)\n    3","title":"Examples - Funx.Math.sum/2","ref":"Funx.Math.html#sum/2-examples"},{"type":"function","doc":"Computes the sum of squares of a list of numbers.\n\nReturns `0` if the list is empty.","title":"Funx.Math.sum_of_squares/1","ref":"Funx.Math.html#sum_of_squares/1"},{"type":"function","doc":"iex> Funx.Math.sum_of_squares([1, 2, 3])\n    14\n\n    iex> Funx.Math.sum_of_squares([-2, 5])\n    29\n\n    iex> Funx.Math.sum_of_squares([])\n    0","title":"Examples - Funx.Math.sum_of_squares/1","ref":"Funx.Math.html#sum_of_squares/1-examples"},{"type":"function","doc":"Computes the variance of a list of numbers.\n\nReturns `Nothing` if the list is empty.","title":"Funx.Math.variance/1","ref":"Funx.Math.html#variance/1"},{"type":"function","doc":"iex> Funx.Math.variance([1, 2, 3, 4])\n    Funx.Monad.Maybe.pure(1.25)\n\n    iex> Funx.Math.variance([5, 5, 5])\n    Funx.Monad.Maybe.pure(0.0)\n\n    iex> Funx.Math.variance([])\n    Funx.Monad.Maybe.nothing()","title":"Examples - Funx.Math.variance/1","ref":"Funx.Math.html#variance/1-examples"},{"type":"protocol","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonad%2Fmonad.livemd)\n\nThe `Funx.Monad` protocol defines the core monadic operations: `ap/2`, `bind/2`, and `map/2`.\n\nA monad is an abstraction that represents computations as a series of steps.\nThis protocol is designed to be implemented by types that wrap a value and allow chaining of operations while preserving the wrapped context.","title":"Funx.Monad","ref":"Funx.Monad.html"},{"type":"protocol","doc":"- `map/2`: Applies a function to the value within the monad.\n- `bind/2`: Chains operations by passing the unwrapped value into a function that returns another monad.\n- `ap/2`: Applies a monadic function to another monadic value.","title":"Functions - Funx.Monad","ref":"Funx.Monad.html#module-functions"},{"type":"type","doc":"","title":"Funx.Monad.t/0","ref":"Funx.Monad.html#t:t/0"},{"type":"function","doc":"Applies a monadic function to another monadic value.\n\nThe function `func` is expected to be wrapped in a monadic context and is applied to the value `m` within its own monadic context.\nThe result is wrapped in the same context as the original monad.","title":"Funx.Monad.ap/2","ref":"Funx.Monad.html#ap/2"},{"type":"function","doc":"iex> Funx.Monad.ap(Funx.Monad.Maybe.just(fn x -> x * 2 end), Funx.Monad.Maybe.just(3))\n    %Funx.Monad.Maybe.Just{value: 6}\n\nIn the case of `Nothing`:\n\n    iex> Funx.Monad.ap(Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.just(3))\n    %Funx.Monad.Maybe.Nothing{}","title":"Examples - Funx.Monad.ap/2","ref":"Funx.Monad.html#ap/2-examples"},{"type":"function","doc":"Chains a monadic operation.\n\nThe `bind/2` function takes a monad `m` and a function `func`. The function `func` is applied to the unwrapped value of `m`,\nand must return another monad. The result is the new monad produced by `func`.\n\nThis is the core operation that allows chaining of computations, with the value being passed from one function to the next in a sequence.","title":"Funx.Monad.bind/2","ref":"Funx.Monad.html#bind/2"},{"type":"function","doc":"iex> Funx.Monad.bind(Funx.Monad.Maybe.just(5), fn x -> Funx.Monad.Maybe.just(x * 2) end)\n    %Funx.Monad.Maybe.Just{value: 10}\n\nIn the case of `Nothing`:\n\n    iex> Funx.Monad.bind(Funx.Monad.Maybe.nothing(), fn _ -> Funx.Monad.Maybe.just(5) end)\n    %Funx.Monad.Maybe.Nothing{}","title":"Examples - Funx.Monad.bind/2","ref":"Funx.Monad.html#bind/2-examples"},{"type":"function","doc":"Maps a function over the value inside the monad.\n\nThe `map/2` function takes a monad `m` and a function `func`, applies the function to the value inside `m`, and returns a new monad\ncontaining the result. The original monadic context is preserved.","title":"Funx.Monad.map/2","ref":"Funx.Monad.html#map/2"},{"type":"function","doc":"iex> Funx.Monad.map(Funx.Monad.Maybe.just(2), fn x -> x + 3 end)\n    %Funx.Monad.Maybe.Just{value: 5}\n\nIn the case of `Nothing`:\n\n    iex> Funx.Monad.map(Funx.Monad.Maybe.nothing(), fn x -> x + 3 end)\n    %Funx.Monad.Maybe.Nothing{}","title":"Examples - Funx.Monad.map/2","ref":"Funx.Monad.html#map/2-examples"},{"type":"behaviour","doc":"Behaviour for applicative operations across monad DSLs.\n\nAp (apply) is the applicative functor operation that produces a wrapped function\nto be applied to wrapped values. This allows for function application within\na computational context.","title":"Funx.Monad.Behaviour.Ap","ref":"Funx.Monad.Behaviour.Ap.html"},{"type":"behaviour","doc":"```elixir\n@callback ap(value :: any(), opts :: keyword(), env :: keyword()) ::\n  {:ok, (any() -> any())}\n  | {:error, any()}\n  | Either.t((any() -> any()), any())\n  | Maybe.t((any() -> any()))\n```","title":"Contract - Funx.Monad.Behaviour.Ap","ref":"Funx.Monad.Behaviour.Ap.html#module-contract"},{"type":"behaviour","doc":"- `value` - The value to use for producing the function\n- `opts` - Keyword list of options (module-specific configuration)\n- `env` - Environment/context from DSL (for Reader-like dependency injection)","title":"Arguments - Funx.Monad.Behaviour.Ap","ref":"Funx.Monad.Behaviour.Ap.html#module-arguments"},{"type":"behaviour","doc":"**Monad types (preferred)**:\n- `Either.right(fn)` - Success with a function\n- `Either.left(error)` - Failure with error\n- `Maybe.just(fn)` - Success with a function\n- `Maybe.nothing()` - Failure (no function)\n\n**Tagged tuples (supported)**:\n- `{:ok, fn}` - Operation succeeded with a function\n- `{:error, reason}` - Operation failed with error\n\nThe DSL will normalize all these return values into the appropriate monad type.","title":"Return Values - Funx.Monad.Behaviour.Ap","ref":"Funx.Monad.Behaviour.Ap.html#module-return-values"},{"type":"behaviour","doc":"When an `ap` module returns a monad type different from the current DSL context,\nthe result is automatically normalized:\n\n**Maybe → Either**:\n- `Just(fn)` → `Right(fn)`\n- `Nothing` → `Left(:nothing)` (uses `:nothing` atom as error)\n\n**Either → Maybe**:\n- `Right(fn)` → `Just(fn)`\n- `Left(_error)` → `Nothing` (error information is discarded)","title":"Cross-Monad Normalization - Funx.Monad.Behaviour.Ap","ref":"Funx.Monad.Behaviour.Ap.html#module-cross-monad-normalization"},{"type":"behaviour","doc":"1. **Arguments strictly ordered**: value, opts, env\n2. **May use env** for Reader-like dependency injection (only way to access env - functions cannot)\n3. **Produces a function** - returns a wrapped function, not a wrapped value\n4. **Can fail** - use this for operations that might not produce a function","title":"Semantic Rules - Funx.Monad.Behaviour.Ap","ref":"Funx.Monad.Behaviour.Ap.html#module-semantic-rules"},{"type":"behaviour","doc":"","title":"Examples - Funx.Monad.Behaviour.Ap","ref":"Funx.Monad.Behaviour.Ap.html#module-examples"},{"type":"behaviour","doc":"```elixir\ndefmodule Multiplier do\n  @behaviour Funx.Monad.Behaviour.Ap\n  import Funx.Monad.Either\n\n  @impl true\n  def ap(factor, _opts, _env) when is_number(factor) do\n    right(fn x -> x * factor end)\n  end\n\n  def ap(_value, _opts, _env), do: left(\"Expected number for factor\")\nend\n\n# Usage in Either DSL\nuse Funx.Monad.Either\n\neither 5 do\n  ap Multiplier\nend\n# First evaluates Multiplier.ap(5, []) -> Right(fn x -> x * 5 end)\n# Then applies: fn x -> x * 5 end to 5 -> 25\n#=> %Right{right: 25}\n```","title":"Basic Applicative - Funx.Monad.Behaviour.Ap","ref":"Funx.Monad.Behaviour.Ap.html#module-basic-applicative"},{"type":"behaviour","doc":"```elixir\ndefmodule ConditionalOperator do\n  @behaviour Funx.Monad.Behaviour.Ap\n  import Funx.Monad.Either\n\n  @impl true\n  def ap(value, opts, _env) do\n    op = Keyword.get(opts, :operation, :add)\n\n    case op do\n      :add -> right(fn x -> x + value end)\n      :multiply -> right(fn x -> x * value end)\n      :subtract -> right(fn x -> x - value end)\n      _ -> left(\"Unknown operation: #{op}\")\n    end\n  end\nend\n\n# Usage\neither 10 do\n  ap {ConditionalOperator, operation: :multiply}\nend\n#=> %Right{right: 100}\n```","title":"With Options - Funx.Monad.Behaviour.Ap","ref":"Funx.Monad.Behaviour.Ap.html#module-with-options"},{"type":"behaviour","doc":"```elixir\ndefmodule ValidatedOperator do\n  @behaviour Funx.Monad.Behaviour.Ap\n  import Funx.Monad.Either\n\n  @impl true\n  def ap(value, _opts, _env) when is_number(value) and value > 0 do\n    right(fn x -> x + value end)\n  end\n\n  def ap(value, _opts, _env) when is_number(value) do\n    left(\"Factor must be positive, got: #{value}\")\n  end\n\n  def ap(_value, _opts, _env), do: left(\"Expected number\")\nend\n\n# Success\neither 5 do\n  ap ValidatedOperator\nend\n#=> %Right{right: 10}\n\n# Failure\neither -3 do\n  ap ValidatedOperator\nend\n#=> %Left{left: \"Factor must be positive, got: -3\"}\n```","title":"Failure Cases - Funx.Monad.Behaviour.Ap","ref":"Funx.Monad.Behaviour.Ap.html#module-failure-cases"},{"type":"callback","doc":"Produces a wrapped function based on the input value.\n\nArguments:\n\n  * value - The current value in the pipeline\n  * opts - Module-specific options passed in the DSL\n  * env - Environment/context from the DSL (for dependency injection)\n\nReturns a wrapped function that will be applied to the value.\n\nExamples:\n\n    # Using Either\n    import Funx.Monad.Either\n\n    def ap(multiplier, _opts, _env) when is_number(multiplier) do\n      right(fn x -> x * multiplier end)\n    end\n\n    # Using tagged tuples\n    def ap(multiplier, _opts, _env) when is_number(multiplier) do\n      {:ok, fn x -> x * multiplier end}\n    end\n\n    # With failure case\n    def ap(value, _opts, _env) do\n      if valid?(value) do\n        right(fn x -> transform(x, value) end)\n      else\n        left(\"validation failed\")\n      end\n    end\n\n    # With options\n    def ap(value, opts, _env) do\n      operation = Keyword.get(opts, :operation, :default)\n      right(create_function(operation, value))\n    end\n\n    # Using env for dependency injection\n    def ap(value, _opts, env) do\n      transformer = Keyword.get(env, :transformer)\n      right(fn x -> transformer.transform(x, value) end)\n    end","title":"Funx.Monad.Behaviour.Ap.ap/3","ref":"Funx.Monad.Behaviour.Ap.html#c:ap/3"},{"type":"behaviour","doc":"Behaviour for bind operations across monad DSLs.\n\nThis behaviour defines a generic interface for operations that can fail,\nusable with the `bind` operation in any monad DSL (Either, Maybe, etc.).","title":"Funx.Monad.Behaviour.Bind","ref":"Funx.Monad.Behaviour.Bind.html"},{"type":"behaviour","doc":"```elixir\n@callback bind(value :: any(), opts :: keyword(), env :: keyword()) ::\n  {:ok, any()}\n  | {:error, any()}\n  | Either.t()\n  | Maybe.t()\n```\n\nThe DSL will normalize all these return formats.\n\nNote: Plain values can also be returned and will be treated as success,\nbut using the explicit formats above is preferred for clarity.","title":"Contract - Funx.Monad.Behaviour.Bind","ref":"Funx.Monad.Behaviour.Bind.html#module-contract"},{"type":"behaviour","doc":"- `value` - The value to operate on\n- `opts` - Keyword list of options (module-specific configuration)\n- `env` - Environment/context from DSL (for Reader-like dependency injection)","title":"Arguments - Funx.Monad.Behaviour.Bind","ref":"Funx.Monad.Behaviour.Bind.html#module-arguments"},{"type":"behaviour","doc":"**Monad types (preferred)**:\n- `Either.right(value)` - Success with value\n- `Either.left(error)` - Failure with error\n- `Maybe.just(value)` - Success with value\n- `Maybe.nothing()` - Failure (no value)\n\n**Tagged tuples (supported)**:\n- `{:ok, value}` - Operation succeeded with new value\n- `{:error, reason}` - Operation failed with error\n\nThe DSL will normalize all these return values into the appropriate monad type.","title":"Return Values - Funx.Monad.Behaviour.Bind","ref":"Funx.Monad.Behaviour.Bind.html#module-return-values"},{"type":"behaviour","doc":"When a `bind` module returns a monad type different from the current DSL context,\nthe result is automatically normalized:\n\n**Maybe → Either**:\n- `Just(value)` → `Right(value)`\n- `Nothing` → `Left(:nothing)` (uses `:nothing` atom as error)\n\n**Either → Maybe**:\n- `Right(value)` → `Just(value)`\n- `Left(_error)` → `Nothing` (error information is discarded)\n\nThis allows `Bind` modules to be reused across different monad DSLs while\nmaintaining predictable behavior. Note that error information is lost when\nconverting `Left` to `Nothing`, as Maybe does not carry error details.","title":"Cross-Monad Normalization - Funx.Monad.Behaviour.Bind","ref":"Funx.Monad.Behaviour.Bind.html#module-cross-monad-normalization"},{"type":"behaviour","doc":"1. **Arguments strictly ordered**: value, opts, env\n2. **May use env** for Reader-like dependency injection (only way to access env - functions cannot)\n3. **Can fail** - use this for operations that might not succeed\n4. **Returns result** in tagged tuple or monad type","title":"Semantic Rules - Funx.Monad.Behaviour.Bind","ref":"Funx.Monad.Behaviour.Bind.html#module-semantic-rules"},{"type":"behaviour","doc":"","title":"Examples - Funx.Monad.Behaviour.Bind","ref":"Funx.Monad.Behaviour.Bind.html#module-examples"},{"type":"behaviour","doc":"```elixir\ndefmodule ParseInt do\n  @behaviour Funx.Monad.Behaviour.Bind\n  import Funx.Monad.Either\n\n  @impl true\n  def bind(value, _opts, _env) when is_binary(value) do\n    case Integer.parse(value) do\n      {int, \"\"} -> right(int)\n      _ -> left(\"Invalid integer\")\n    end\n  end\n\n  def bind(_value, _opts, _env), do: left(\"Expected string\")\nend\n\n# Usage in Either DSL\nuse Funx.Monad.Either\n\neither \"42\" do\n  bind ParseInt\nend\n#=> %Right{right: 42}\n\neither \"not a number\" do\n  bind ParseInt\nend\n#=> %Left{left: \"Invalid integer\"}\n```","title":"Using Either (Preferred) - Funx.Monad.Behaviour.Bind","ref":"Funx.Monad.Behaviour.Bind.html#module-using-either-preferred"},{"type":"behaviour","doc":"```elixir\ndefmodule ParseIntTuple do\n  @behaviour Funx.Monad.Behaviour.Bind\n\n  @impl true\n  def bind(value, _opts, _env) when is_binary(value) do\n    case Integer.parse(value) do\n      {int, \"\"} -> {:ok, int}\n      _ -> {:error, \"Invalid integer\"}\n    end\n  end\n\n  def bind(_value, _opts, _env), do: {:error, \"Expected string\"}\nend\n\n# Also works in Either DSL (tuples are normalized)\neither \"42\" do\n  bind ParseIntTuple\nend\n#=> %Right{right: 42}\n```","title":"Using Tagged Tuples (Supported) - Funx.Monad.Behaviour.Bind","ref":"Funx.Monad.Behaviour.Bind.html#module-using-tagged-tuples-supported"},{"type":"behaviour","doc":"```elixir\ndefmodule ParseIntEither do\n  @behaviour Funx.Monad.Behaviour.Bind\n  import Funx.Monad.Either\n\n  @impl true\n  def bind(value, _opts, _env) when is_binary(value) do\n    case Integer.parse(value) do\n      {int, \"\"} -> right(int)\n      _ -> left(\"Invalid integer\")\n    end\n  end\n\n  def bind(_value, _opts, _env), do: left(\"Expected string\")\nend\n```","title":"Using Either Types (Preferred) - Funx.Monad.Behaviour.Bind","ref":"Funx.Monad.Behaviour.Bind.html#module-using-either-types-preferred"},{"type":"behaviour","doc":"```elixir\ndefmodule ParseIntMaybe do\n  @behaviour Funx.Monad.Behaviour.Bind\n  import Funx.Monad.Maybe\n\n  @impl true\n  def bind(value, _opts, _env) when is_binary(value) do\n    case Integer.parse(value) do\n      {int, \"\"} -> just(int)\n      _ -> nothing()\n    end\n  end\n\n  def bind(_value, _opts, _env), do: nothing()\nend\n\n# Can be used in Either DSL - Nothing becomes Left(:nothing)\nuse Funx.Monad.Either\n\neither \"42\" do\n  bind ParseIntMaybe\nend\n#=> %Right{right: 42}\n\neither \"invalid\" do\n  bind ParseIntMaybe\nend\n#=> %Left{left: :nothing}\n```","title":"Using Maybe Types (Preferred) - Funx.Monad.Behaviour.Bind","ref":"Funx.Monad.Behaviour.Bind.html#module-using-maybe-types-preferred"},{"type":"behaviour","doc":"```elixir\ndefmodule ParseIntWithBase do\n  @behaviour Funx.Monad.Behaviour.Bind\n\n  @impl true\n  def bind(value, opts, _env) when is_binary(value) do\n    base = Keyword.get(opts, :base, 10)\n\n    case Integer.parse(value, base) do\n      {int, \"\"} -> {:ok, int}\n      _ -> {:error, \"Invalid integer for base #{base}\"}\n    end\n  end\n\n  def bind(_value, _opts, _env), do: {:error, \"Expected string\"}\nend\n\n# Usage\neither \"FF\" do\n  bind {ParseIntWithBase, base: 16}\nend\n#=> %Right{right: 255}\n```","title":"With Options - Funx.Monad.Behaviour.Bind","ref":"Funx.Monad.Behaviour.Bind.html#module-with-options"},{"type":"callback","doc":"Performs an operation that can fail.\n\nArguments:\n\n  * value - The current value in the pipeline\n  * opts - Module-specific options passed in the DSL\n  * env - Environment/context from the DSL (for dependency injection)\n\nReturns a result indicating success or failure.\n\nExamples:\n\n    # Using tagged tuples (generic)\n    def bind(value, _opts, _env) when is_binary(value) do\n      case Integer.parse(value) do\n        {int, \"\"} -> {:ok, int}\n        _ -> {:error, \"invalid\"}\n      end\n    end\n\n    # Using Either (monad-specific)\n    import Funx.Monad.Either\n\n    def bind(value, _opts, _env) do\n      if valid?(value) do\n        right(transform(value))\n      else\n        left(\"validation failed\")\n      end\n    end\n\n    # With options\n    def bind(value, opts, _env) do\n      threshold = Keyword.get(opts, :min, 0)\n      if value > threshold do\n        {:ok, value}\n      else\n        {:error, \"below threshold\"}\n      end\n    end\n\n    # Using env for dependency injection\n    def bind(user_id, _opts, env) do\n      database = Keyword.get(env, :database)\n      database.fetch_user(user_id)\n    end","title":"Funx.Monad.Behaviour.Bind.bind/3","ref":"Funx.Monad.Behaviour.Bind.html#c:bind/3"},{"type":"behaviour","doc":"Behaviour for map operations across monad DSLs.\n\nMap is a **universal functor operation** that works identically across all monads.\nUnlike `bind`, which handles failure, `map` simply transforms values when they exist.\n\nThe same `map` module can be used in Either DSL, Maybe DSL, List, IO, or any\nother monad - the transformation logic is completely generic.","title":"Funx.Monad.Behaviour.Map","ref":"Funx.Monad.Behaviour.Map.html"},{"type":"behaviour","doc":"```elixir\n@callback map(value :: any(), opts :: keyword(), env :: keyword()) :: any()\n```","title":"Contract - Funx.Monad.Behaviour.Map","ref":"Funx.Monad.Behaviour.Map.html#module-contract"},{"type":"behaviour","doc":"- `value` - The value to transform\n- `opts` - Keyword list of options (module-specific configuration)\n- `env` - Environment/context from DSL (for Reader-like dependency injection)","title":"Arguments - Funx.Monad.Behaviour.Map","ref":"Funx.Monad.Behaviour.Map.html#module-arguments"},{"type":"behaviour","doc":"Map should return **the transformed value directly** as a plain value.\nThe DSL handles wrapping the result in the appropriate monad type.\n\n**Important**: Unlike `Bind`, map does not return Either, Maybe, or result tuples.\nIt returns plain values because map is about transformation, not control flow.","title":"Return Values - Funx.Monad.Behaviour.Map","ref":"Funx.Monad.Behaviour.Map.html#module-return-values"},{"type":"behaviour","doc":"1. **Arguments strictly ordered**: value, opts, env\n2. **May use env** for Reader-like dependency injection (only way to access env - functions cannot)\n3. **Pure transformation** - should not fail (use Behaviour.Bind for operations that can fail)\n4. **Returns plain value** - not wrapped in monad (DSL handles wrapping)\n5. **Monad-agnostic** - same transformation works across all monad DSLs","title":"Semantic Rules - Funx.Monad.Behaviour.Map","ref":"Funx.Monad.Behaviour.Map.html#module-semantic-rules"},{"type":"behaviour","doc":"The beauty of `map` is that it works the same way in every monad:\n\n- **Either**: `Right(value)` → apply map → `Right(transformed)`; `Left` is skipped\n- **Maybe**: `Just(value)` → apply map → `Just(transformed)`; `Nothing` is skipped\n- **List**: `[a, b, c]` → apply map → `[f(a), f(b), f(c)]`\n\nThe same `map` module behaves consistently across all these contexts.","title":"Monad Universality - Funx.Monad.Behaviour.Map","ref":"Funx.Monad.Behaviour.Map.html#module-monad-universality"},{"type":"behaviour","doc":"","title":"Examples - Funx.Monad.Behaviour.Map","ref":"Funx.Monad.Behaviour.Map.html#module-examples"},{"type":"behaviour","doc":"```elixir\ndefmodule Double do\n  @behaviour Funx.Monad.Behaviour.Map\n\n  @impl true\n  def map(value, _opts, _env) when is_number(value) do\n    value * 2\n  end\nend\n\n# Works identically in Either DSL\nuse Funx.Monad.Either\n\neither 21 do\n  map Double\nend\n#=> %Right{right: 42}\n\n# Works identically in Maybe DSL\nuse Funx.Monad.Maybe\n\nmaybe 21 do\n  map Double\nend\n#=> %Just{value: 42}\n\n# Same transformation, different monad contexts\n```","title":"Basic Transformation - Funx.Monad.Behaviour.Map","ref":"Funx.Monad.Behaviour.Map.html#module-basic-transformation"},{"type":"behaviour","doc":"```elixir\ndefmodule Multiplier do\n  @behaviour Funx.Monad.Behaviour.Map\n\n  @impl true\n  def map(value, opts, _env) when is_number(value) do\n    factor = Keyword.get(opts, :factor, 1)\n    value * factor\n  end\nend\n\n# In Either DSL\neither 10 do\n  map {Multiplier, factor: 5}\nend\n#=> %Right{right: 50}\n\n# In Maybe DSL\nmaybe 10 do\n  map {Multiplier, factor: 5}\nend\n#=> %Just{value: 50}\n```","title":"With Options - Funx.Monad.Behaviour.Map","ref":"Funx.Monad.Behaviour.Map.html#module-with-options"},{"type":"behaviour","doc":"```elixir\ndefmodule ToUpperCase do\n  @behaviour Funx.Monad.Behaviour.Map\n\n  @impl true\n  def map(value, _opts, _env) when is_binary(value) do\n    String.upcase(value)\n  end\nend\n\ndefmodule AddPrefix do\n  @behaviour Funx.Monad.Behaviour.Map\n\n  @impl true\n  def map(value, opts, _env) when is_binary(value) do\n    prefix = Keyword.get(opts, :prefix, \"\")\n    prefix <> value\n  end\nend\n\n# Compose maps in Either\neither \"hello\" do\n  map ToUpperCase\n  map {AddPrefix, prefix: \">> \"}\nend\n#=> %Right{right: \">> HELLO\"}\n\n# Same composition works in Maybe\nmaybe \"hello\" do\n  map ToUpperCase\n  map {AddPrefix, prefix: \">> \"}\nend\n#=> %Just{value: \">> HELLO\"}\n```","title":"Composable Transformations - Funx.Monad.Behaviour.Map","ref":"Funx.Monad.Behaviour.Map.html#module-composable-transformations"},{"type":"callback","doc":"Transforms a value.\n\nArguments:\n\n  * value - The current value in the pipeline\n  * opts - Module-specific options passed in the DSL\n  * env - Environment/context from the DSL (for dependency injection)\n\nReturns the transformed value directly (not wrapped in a monad).\n\nExamples:\n\n    # Simple transformation\n    def map(value, _opts, _env) do\n      value * 2\n    end\n\n    # With options\n    def map(value, opts, _env) do\n      multiplier = Keyword.get(opts, :multiplier, 1)\n      value * multiplier\n    end\n\n    # Using env for dependency injection\n    def map(value, _opts, env) do\n      formatter = Keyword.get(env, :formatter)\n      formatter.format(value)\n    end","title":"Funx.Monad.Behaviour.Map.map/3","ref":"Funx.Monad.Behaviour.Map.html#c:map/3"},{"type":"behaviour","doc":"Behaviour for predicate operations across monad DSLs.\n\nPredicate is a **universal filtering operation** that works identically across all monads.\nIt evaluates a condition and returns a boolean to determine if a value should pass through.\n\nThe same `predicate` module can be used in Either DSL (filter_or_else), Maybe DSL (filter),\nor any other monad - the logic is completely generic.","title":"Funx.Monad.Behaviour.Predicate","ref":"Funx.Monad.Behaviour.Predicate.html"},{"type":"behaviour","doc":"```elixir\n@callback predicate(value :: any(), opts :: keyword(), env :: map()) :: boolean()\n```","title":"Contract - Funx.Monad.Behaviour.Predicate","ref":"Funx.Monad.Behaviour.Predicate.html#module-contract"},{"type":"behaviour","doc":"- `value` - The value to test\n- `opts` - Keyword list of options (module-specific configuration)\n- `env` - Environment/context from DSL (for Reader-like dependency injection)","title":"Arguments - Funx.Monad.Behaviour.Predicate","ref":"Funx.Monad.Behaviour.Predicate.html#module-arguments"},{"type":"behaviour","doc":"Predicate should return **a boolean** indicating whether the value passes the test.\nThe DSL handles the filtering logic based on the boolean result.","title":"Return Values - Funx.Monad.Behaviour.Predicate","ref":"Funx.Monad.Behaviour.Predicate.html#module-return-values"},{"type":"behaviour","doc":"1. **Arguments strictly ordered**: value, opts, env\n2. **May use env** for Reader-like dependency injection (same as other behaviors)\n3. **Returns boolean** - `true` to keep the value, `false` to filter it out\n4. **Monad-agnostic** - same predicate works across all monad DSLs","title":"Semantic Rules - Funx.Monad.Behaviour.Predicate","ref":"Funx.Monad.Behaviour.Predicate.html#module-semantic-rules"},{"type":"behaviour","doc":"The beauty of `predicate` is that it works the same way in every monad:\n\n- **Either**: `filter_or_else` uses predicate to keep `Right` or convert to `Left`\n- **Maybe**: `filter` uses predicate to keep `Just` or convert to `Nothing`\n- **List**: `filter` uses predicate to keep or remove elements\n\nThe same `predicate` module behaves consistently across all these contexts.","title":"Monad Universality - Funx.Monad.Behaviour.Predicate","ref":"Funx.Monad.Behaviour.Predicate.html#module-monad-universality"},{"type":"behaviour","doc":"","title":"Examples - Funx.Monad.Behaviour.Predicate","ref":"Funx.Monad.Behaviour.Predicate.html#module-examples"},{"type":"behaviour","doc":"```elixir\ndefmodule IsPositive do\n  @behaviour Funx.Monad.Behaviour.Predicate\n\n  @impl true\n  def predicate(value, _opts, _env) when is_number(value) do\n    value > 0\n  end\n\n  def predicate(_value, _opts, _env), do: false\nend\n\n# Works in Either DSL\nuse Funx.Monad.Either\n\neither 10 do\n  filter_or_else IsPositive, fn -> \"not positive\" end\nend\n#=> %Right{right: 10}\n\neither -5 do\n  filter_or_else IsPositive, fn -> \"not positive\" end\nend\n#=> %Left{left: \"not positive\"}\n\n# Works in Maybe DSL\nuse Funx.Monad.Maybe\n\nmaybe 10 do\n  filter IsPositive\nend\n#=> %Just{value: 10}\n\nmaybe -5 do\n  filter IsPositive\nend\n#=> %Nothing{}\n```","title":"Basic Predicate - Funx.Monad.Behaviour.Predicate","ref":"Funx.Monad.Behaviour.Predicate.html#module-basic-predicate"},{"type":"behaviour","doc":"```elixir\ndefmodule InRange do\n  @behaviour Funx.Monad.Behaviour.Predicate\n\n  @impl true\n  def predicate(value, opts, _env) when is_number(value) do\n    min = Keyword.get(opts, :min, 0)\n    max = Keyword.get(opts, :max, 100)\n    value >= min and value <= max\n  end\n\n  def predicate(_value, _opts, _env), do: false\nend\n\n# In Either DSL\neither 50 do\n  filter_or_else {InRange, min: 0, max: 100}, fn -> \"out of range\" end\nend\n#=> %Right{right: 50}\n\n# In Maybe DSL\nmaybe 50 do\n  filter {InRange, min: 0, max: 100}\nend\n#=> %Just{value: 50}\n```","title":"With Options - Funx.Monad.Behaviour.Predicate","ref":"Funx.Monad.Behaviour.Predicate.html#module-with-options"},{"type":"behaviour","doc":"```elixir\ndefmodule IsEven do\n  @behaviour Funx.Monad.Behaviour.Predicate\n\n  @impl true\n  def predicate(value, _opts, _env) when is_integer(value) do\n    rem(value, 2) == 0\n  end\n\n  def predicate(_value, _opts, _env), do: false\nend\n\ndefmodule IsPositive do\n  @behaviour Funx.Monad.Behaviour.Predicate\n\n  @impl true\n  def predicate(value, _opts, _env) when is_number(value) do\n    value > 0\n  end\n\n  def predicate(_value, _opts, _env), do: false\nend\n\n# Compose predicates in Either\neither 10 do\n  filter_or_else IsPositive, fn -> \"not positive\" end\n  filter_or_else IsEven, fn -> \"not even\" end\nend\n#=> %Right{right: 10}\n\neither 11 do\n  filter_or_else IsPositive, fn -> \"not positive\" end\n  filter_or_else IsEven, fn -> \"not even\" end\nend\n#=> %Left{left: \"not even\"}\n\n# Same composition works in Maybe\nmaybe 10 do\n  filter IsPositive\n  filter IsEven\nend\n#=> %Just{value: 10}\n```","title":"Composable Predicates - Funx.Monad.Behaviour.Predicate","ref":"Funx.Monad.Behaviour.Predicate.html#module-composable-predicates"},{"type":"behaviour","doc":"Predicates support the `env` parameter for Reader-like dependency injection, maintaining\nconsistency with other monad behaviors. While most predicates are pure boolean tests that\nonly need the value and options, the `env` parameter allows for stateful or context-dependent\npredicates when needed (e.g., checking against a dynamic threshold from a database).","title":"Environment Support - Funx.Monad.Behaviour.Predicate","ref":"Funx.Monad.Behaviour.Predicate.html#module-environment-support"},{"type":"callback","doc":"Tests whether a value satisfies a condition.\n\nArguments:\n\n  * value - The current value in the pipeline\n  * opts - Module-specific options passed in the DSL\n  * env - Environment/context from the DSL (for Reader-like dependency injection)\n\nReturns a boolean indicating whether the value passes the test.\n\nExamples:\n\n    # Simple predicate\n    def predicate(value, _opts, _env) do\n      value > 0\n    end\n\n    # With options\n    def predicate(value, opts, _env) do\n      threshold = Keyword.get(opts, :threshold, 0)\n      value > threshold\n    end\n\n    # Using env for context-dependent predicates\n    def predicate(value, _opts, env) do\n      max_allowed = Map.get(env, :max_threshold, 100)\n      value <= max_allowed\n    end\n\n    # Type-specific predicates\n    def predicate(value, _opts, _env) when is_number(value) do\n      value > 0\n    end\n\n    def predicate(_value, _opts, _env), do: false","title":"Funx.Monad.Behaviour.Predicate.predicate/3","ref":"Funx.Monad.Behaviour.Predicate.html#c:predicate/3"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonad%2Feffect%2Feffect.livemd)\n\nThe `Funx.Monad.Effect` module provides an implementation of the `Effect` monad, which represents deferred asynchronous computations that may succeed or fail.\n\nAn `Effect` represents one of two possibilities:\n\n  - `Right(value)`: a successful asynchronous computation\n  - `Left(error)`: a failed asynchronous computation\n\nEffects are lazy—execution is deferred until `run/2` is explicitly called. This makes `Effect` ideal for structuring asynchronous workflows with built-in observability via telemetry and tracing.\n\nAll effects carry an `Effect.Context`, which propagates trace IDs and span names through the computation graph, enabling distributed tracing and performance monitoring in concurrent Elixir systems.","title":"Funx.Monad.Effect","ref":"Funx.Monad.Effect.html"},{"type":"module","doc":"- `right/2`: Wraps a value in a successful `Right` effect with optional context.\n  - `left/2`: Wraps an error in a failing `Left` effect with optional context.\n  - `pure/2`: Alias for `right/2`.","title":"Constructors - Funx.Monad.Effect","ref":"Funx.Monad.Effect.html#module-constructors"},{"type":"module","doc":"- `run/2`: Executes the deferred effect and returns an `Either` result.\n\nYou may pass `:task_supervisor` in the options to run the effect under a specific `Task.Supervisor`. This supervises only the top-level task; any internal tasks spawned within the effect function are not supervised.","title":"Execution - Funx.Monad.Effect","ref":"Funx.Monad.Effect.html#module-execution"},{"type":"module","doc":"- `map_left/2`: Transforms a `Left` using a function, leaving `Right` values unchanged.\n  - `flip_either/1`: Inverts the success and failure branches of an `Effect`.","title":"Error Handling - Funx.Monad.Effect","ref":"Funx.Monad.Effect.html#module-error-handling"},{"type":"module","doc":"- `sequence/1`: Runs a list of effects, stopping at the first `Left`.\n  - `traverse/2`: Applies a function returning an `Effect` to each element in a list and sequences the results.\n  - `sequence_a/1`: Like `sequence/1`, but accumulates all errors from `Left` values.\n  - `traverse_a/2`: Like `traverse/2`, but accumulates all `Left` values instead of short-circuiting.","title":"List Operations - Funx.Monad.Effect","ref":"Funx.Monad.Effect.html#module-list-operations"},{"type":"module","doc":"- `validate/2`: Validates a value using one or more effectful validators, collecting all errors.","title":"Validation - Funx.Monad.Effect","ref":"Funx.Monad.Effect.html#module-validation"},{"type":"module","doc":"- `lift_func/2`: Lifts a thunk into an `Effect`, capturing exceptions as `Left(EffectError)`.\n  - `lift_either/2`: Lifts a thunk returning an `Either` into an `Effect`, deferring evaluation.\n  - `lift_maybe/3`: Converts a `Maybe` to an `Effect` using a fallback error for `Nothing`.\n  - `lift_predicate/3`: Turns a predicate into an `Effect`, returning `Right` on `true` and `Left` on `false`.","title":"Lifting - Funx.Monad.Effect","ref":"Funx.Monad.Effect.html#module-lifting"},{"type":"module","doc":"- `ask/0`: Returns the environment passed to `run/2` as a `Right`.\n  - `asks/1`: Applies a function to the environment passed to `run/2`, wrapping the result in `Right`.\n  - `fail/0`: Returns the environment passed to `run/2` as a `Left`.\n  - `fails/1`: Applies a function to the environment passed to `run/2`, wrapping the result in `Left`.","title":"Reader Operations - Funx.Monad.Effect","ref":"Funx.Monad.Effect.html#module-reader-operations"},{"type":"module","doc":"- `from_result/2`: Converts `{:ok, val}` or `{:error, err}` into an `Effect`.\n  - `to_result/1`: Converts an `Effect` into a result tuple.\n  - `from_try/2`: Runs a function and returns `Right` on success or `Left(EffectError)` on exception.\n  - `to_try!/1`: Unwraps a `Right`, or raises an error from a `Left`.","title":"Elixir Interoperability - Funx.Monad.Effect","ref":"Funx.Monad.Effect.html#module-elixir-interoperability"},{"type":"module","doc":"The `Left` and `Right` structs implement the following protocols, making the `Effect` abstraction composable and extensible:\n\n  - `Funx.Monad`: Provides `map/2`, `ap/2`, and `bind/2` for monadic composition.\n  - `Funx.Tappable`: Executes side effects on `Right` values via `Funx.Tappable.tap/2`, leaving `Left` values unchanged.\n\nAlthough these implementations are defined on each constructor (`Left` and `Right`), the behavior is consistent across the `Effect` abstraction.\n\nThis module enables structured concurrency, error handling, and observability in asynchronous workflows.","title":"Protocols - Funx.Monad.Effect","ref":"Funx.Monad.Effect.html#module-protocols"},{"type":"module","doc":"The `run/2` function emits telemetry using `:telemetry.span/3`.","title":"Telemetry - Funx.Monad.Effect","ref":"Funx.Monad.Effect.html#module-telemetry"},{"type":"module","doc":"* `[:funx, :effect, :run, :start]`\n  * `[:funx, :effect, :run, :stop]`","title":"Events - Funx.Monad.Effect","ref":"Funx.Monad.Effect.html#module-events"},{"type":"module","doc":"* `:monotonic_time` – included in both `:start` and `:stop` events.\n  * `:system_time` – included only in the `:start` event.\n  * `:duration` – included only in the `:stop` event.","title":"Measurements - Funx.Monad.Effect","ref":"Funx.Monad.Effect.html#module-measurements"},{"type":"module","doc":"* `:timeout` – the timeout in milliseconds passed to `run/2`.\n  * `:result` – a summarized version of the result using `Funx.Summarizable`.\n  * `:effect_type` – `:right` or `:left`, depending on the effect being run.\n  * `:status` – `:ok` if the result is a `Right`, or `:error` if it's a `Left`.\n  * `:trace_id` – optional value used to correlate traces across boundaries.\n  * `:span_name` – optional name for the span (defaults to `\"funx.effect.run\"`).\n  * `:telemetry_span_context` – reference to correlate `:start` and `:stop` events.","title":"Metadata - Funx.Monad.Effect","ref":"Funx.Monad.Effect.html#module-metadata"},{"type":"module","doc":":telemetry.attach(\n      \"effect-run-handler\",\n      [:funx, :effect, :run, :stop],\n      fn event, measurements, metadata, _config ->\n        IO.inspect({event, measurements, metadata}, label: \"Effect telemetry\")\n      end,\n      nil\n    )","title":"Example - Funx.Monad.Effect","ref":"Funx.Monad.Effect.html#module-example"},{"type":"type","doc":"Represents a deferred computation in the `Effect` monad that may either succeed (`Right`) or fail (`Left`).\n\nThis type unifies `Effect.Right.t/1` and `Effect.Left.t/1` under a common interface, allowing code to\noperate over asynchronous effects regardless of success or failure outcome.\n\nEach variant carries a `context` for telemetry and a deferred `effect` function that takes an environment.","title":"Funx.Monad.Effect.t/2","ref":"Funx.Monad.Effect.html#t:t/2"},{"type":"function","doc":"Returns a `Funx.Monad.Effect.Right` that yields the environment passed to `Funx.Monad.Effect.run/2`.\n\nThis is the Reader-style `ask`, used to access the full environment inside an effectful computation.","title":"Funx.Monad.Effect.ask/0","ref":"Funx.Monad.Effect.html#ask/0"},{"type":"function","doc":"iex> Funx.Monad.Effect.ask()\n    ...> |> Funx.Monad.map(& &1[:region])\n    ...> |> Funx.Monad.Effect.run(%{region: \"us-west\"})\n    %Funx.Monad.Either.Right{right: \"us-west\"}","title":"Example - Funx.Monad.Effect.ask/0","ref":"Funx.Monad.Effect.html#ask/0-example"},{"type":"function","doc":"Returns a `Funx.Monad.Effect.Right` that applies the given function to the environment passed to `Funx.Monad.Effect.run/2`.\n\nThis allows extracting a value from the environment and using it in an effectful computation,\nfollowing the Reader pattern.","title":"Funx.Monad.Effect.asks/1","ref":"Funx.Monad.Effect.html#asks/1"},{"type":"function","doc":"iex> Funx.Monad.Effect.asks(fn env -> env[:user] end)\n    ...> |> Funx.Monad.bind(fn user -> Funx.Monad.Effect.right(user) end)\n    ...> |> Funx.Monad.Effect.run(%{user: \"alice\"})\n    %Funx.Monad.Either.Right{right: \"alice\"}","title":"Example - Funx.Monad.Effect.asks/1","ref":"Funx.Monad.Effect.html#asks/1-example"},{"type":"function","doc":"","title":"Funx.Monad.Effect.await/2","ref":"Funx.Monad.Effect.html#await/2"},{"type":"function","doc":"Returns a `Funx.Monad.Effect.Left` that fails with the entire environment passed to `Funx.Monad.Effect.run/2`.\n\nThis is the Reader-style equivalent of `ask/0`, but marks the environment as a failure.\nUseful when the presence of certain runtime data should short-circuit execution.","title":"Funx.Monad.Effect.fail/0","ref":"Funx.Monad.Effect.html#fail/0"},{"type":"function","doc":"iex> Funx.Monad.Effect.fail()\n    ...> |> Funx.Monad.Effect.run(%{error: :invalid_token})\n    %Funx.Monad.Either.Left{left: %{error: :invalid_token}}","title":"Example - Funx.Monad.Effect.fail/0","ref":"Funx.Monad.Effect.html#fail/0-example"},{"type":"function","doc":"Returns a `Funx.Monad.Effect.Left` that applies the given function to the environment passed to `Funx.Monad.Effect.run/2`.\n\nThis is the failure-side equivalent of `asks/1`, used to produce an error effect based on runtime context.","title":"Funx.Monad.Effect.fails/1","ref":"Funx.Monad.Effect.html#fails/1"},{"type":"function","doc":"iex> Funx.Monad.Effect.fails(fn env -> {:missing_key, env} end)\n    ...> |> Funx.Monad.Effect.run(%{input: nil})\n    %Funx.Monad.Either.Left{left: {:missing_key, %{input: nil}}}","title":"Example - Funx.Monad.Effect.fails/1","ref":"Funx.Monad.Effect.html#fails/1-example"},{"type":"function","doc":"Inverts the success and failure branches of an `Effect`.\n\nFor a `Right`, this reverses the result: a successful value becomes a failure, and\na failure becomes a success. For a `Left`, only failure is expected; if the `Left`\nproduces a success, it is ignored.\n\nThis is useful when you want to reverse the semantics of a computation—treating\nan expected error as success, or vice versa.","title":"Funx.Monad.Effect.flip_either/1","ref":"Funx.Monad.Effect.html#flip_either/1"},{"type":"function","doc":"iex> effect = Funx.Monad.Effect.pure(42)\n    iex> flipped = Funx.Monad.Effect.flip_either(effect)\n    iex> Funx.Monad.Effect.run(flipped)\n    %Funx.Monad.Either.Left{left: 42}\n    iex> effect = Funx.Monad.Effect.left(\"fail\")\n    iex> flipped = Funx.Monad.Effect.flip_either(effect)\n    iex> Funx.Monad.Effect.run(flipped)\n    %Funx.Monad.Either.Right{right: \"fail\"}","title":"Examples - Funx.Monad.Effect.flip_either/1","ref":"Funx.Monad.Effect.html#flip_either/1-examples"},{"type":"function","doc":"Converts an Elixir `{:ok, value}` or `{:error, reason}` tuple into an `Effect`.\n\nAccepts an optional context context which includes telemetry tracking.","title":"Funx.Monad.Effect.from_result/2","ref":"Funx.Monad.Effect.html#from_result/2"},{"type":"function","doc":"iex> result = Funx.Monad.Effect.from_result({:ok, 42})\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}\n\n    iex> result = Funx.Monad.Effect.from_result({:error, \"error\"})\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: \"error\"}","title":"Examples - Funx.Monad.Effect.from_result/2","ref":"Funx.Monad.Effect.html#from_result/2-examples"},{"type":"function","doc":"Lifts a potentially exception-raising function into a Kleisli function for the `Effect` monad.\n\nThis returns a function of type (`input -> Effect`) that applies the given function to a value.\nIf the function raises, the error is captured and returned in a `Left`. You can optionally\nprovide a context (or opts) for tracing and telemetry.","title":"Funx.Monad.Effect.from_try/2","ref":"Funx.Monad.Effect.html#from_try/2"},{"type":"function","doc":"iex> safe_div = Funx.Monad.Effect.from_try(fn x -> 10 / x end)\n    iex> effect = Funx.Monad.Effect.pure(2) |> Funx.Monad.bind(safe_div)\n    iex> Funx.Monad.Effect.run(effect)\n    %Funx.Monad.Either.Right{right: 5.0}\n    iex> bad_div = Funx.Monad.Effect.pure(0) |> Funx.Monad.bind(safe_div)\n    iex> Funx.Monad.Effect.run(bad_div)\n    %Funx.Monad.Either.Left{left: %ArithmeticError{}}","title":"Examples - Funx.Monad.Effect.from_try/2","ref":"Funx.Monad.Effect.html#from_try/2-examples"},{"type":"function","doc":"Wraps a value in the `Left` variant of the `Effect` monad, representing a failed asynchronous computation.\n\nAccepts either a keyword list of context options or a `Effect.Context` struct.","title":"Funx.Monad.Effect.left/2","ref":"Funx.Monad.Effect.html#left/2"},{"type":"function","doc":"iex> result = Funx.Monad.Effect.left(\"error\")\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: \"error\"}\n\n    iex> context = Funx.Monad.Effect.Context.new(trace_id: \"err-id\", span_name: \"failure\")\n    iex> result = Funx.Monad.Effect.left(\"error\", context)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: \"error\"}","title":"Examples - Funx.Monad.Effect.left/2","ref":"Funx.Monad.Effect.html#left/2-examples"},{"type":"function","doc":"Lifts a thunk that returns an `Either` into the `Effect` monad.\n\nInstead of passing an `Either` value directly, you provide a zero-arity function (`thunk`) that returns one.\nThis defers execution until the effect is run, allowing integration with tracing and composable pipelines.\n\nYou may also pass a context or options (`opts`) to configure telemetry or span metadata.\n\nIf the thunk raises an exception, it is caught and returned as a `Left` containing an `EffectError` tagged with `:lift`.","title":"Funx.Monad.Effect.lift_either/2","ref":"Funx.Monad.Effect.html#lift_either/2"},{"type":"function","doc":"iex> result = Funx.Monad.Effect.lift_either(fn -> %Funx.Monad.Either.Right{right: 42} end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}\n\n    iex> result = Funx.Monad.Effect.lift_either(fn -> %Funx.Monad.Either.Left{left: \"error\"} end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: \"error\"}","title":"Examples - Funx.Monad.Effect.lift_either/2","ref":"Funx.Monad.Effect.html#lift_either/2-examples"},{"type":"function","doc":"Lifts a thunk into the `Effect` monad, wrapping its result in a `Right`.\n\nThis function defers execution of the given zero-arity function (`thunk`) until the effect is run.\nThe result is automatically wrapped as `Either.Right`.\n\nYou may also pass a context or options (`opts`) to configure telemetry or span metadata.\n\nIf the thunk raises an exception, it is caught and returned as a `Left` containing an `EffectError` tagged with `:lift`.","title":"Funx.Monad.Effect.lift_func/2","ref":"Funx.Monad.Effect.html#lift_func/2"},{"type":"function","doc":"iex> result = Funx.Monad.Effect.lift_func(fn -> 42 end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}\n\n    iex> result = Funx.Monad.Effect.lift_func(fn -> raise \"boom\" end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{\n      left: %Funx.Errors.EffectError{stage: :lift_func, reason: %RuntimeError{message: \"boom\"}}\n    }","title":"Examples - Funx.Monad.Effect.lift_func/2","ref":"Funx.Monad.Effect.html#lift_func/2-examples"},{"type":"function","doc":"Converts a `Maybe` value into the `Effect` monad.\nIf the `Maybe` is `Just`, the value is wrapped in `Right`.\nIf it is `Nothing`, the result of `on_none` is wrapped in `Left`.\n\nYou can optionally provide context metadata via `opts`.","title":"Funx.Monad.Effect.lift_maybe/3","ref":"Funx.Monad.Effect.html#lift_maybe/3"},{"type":"function","doc":"iex> maybe = Funx.Monad.Maybe.just(42)\n    iex> result = Funx.Monad.Effect.lift_maybe(maybe, fn -> \"No value\" end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}\n\n    iex> maybe = Funx.Monad.Maybe.nothing()\n    iex> result = Funx.Monad.Effect.lift_maybe(maybe, fn -> \"No value\" end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: \"No value\"}","title":"Examples - Funx.Monad.Effect.lift_maybe/3","ref":"Funx.Monad.Effect.html#lift_maybe/3-examples"},{"type":"function","doc":"Lifts a value into the `Effect` monad based on a predicate.\nIf the predicate returns true, the value is wrapped in `Right`.\nOtherwise, the result of calling `on_false` with the value is wrapped in `Left`.\n\nOptional context metadata (e.g. `:span_name`, `:trace_id`) can be passed via `opts`.","title":"Funx.Monad.Effect.lift_predicate/4","ref":"Funx.Monad.Effect.html#lift_predicate/4"},{"type":"function","doc":"iex> result = Funx.Monad.Effect.lift_predicate(10, &(&1 > 5), fn x -> \"#{x} is too small\" end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 10}\n\n    iex> result = Funx.Monad.Effect.lift_predicate(3, &(&1 > 5), fn x -> \"#{x} is too small\" end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: \"3 is too small\"}","title":"Examples - Funx.Monad.Effect.lift_predicate/4","ref":"Funx.Monad.Effect.html#lift_predicate/4-examples"},{"type":"function","doc":"Transforms the `Left` branch of an `Effect`.\n\nIf the `Effect` resolves to a `Left`, the provided function is applied to the error.\nIf the `Effect` resolves to a `Right`, the value is returned unchanged.\n\nThis function is useful when you want to rewrite or wrap errors without affecting successful computations.","title":"Funx.Monad.Effect.map_left/2","ref":"Funx.Monad.Effect.html#map_left/2"},{"type":"function","doc":"iex> effect = Funx.Monad.Effect.left(\"error\")\n    iex> transformed = Funx.Monad.Effect.map_left(effect, fn e -> \"wrapped: \" <> e end)\n    iex> Funx.Monad.Effect.run(transformed)\n    %Funx.Monad.Either.Left{left: \"wrapped: error\"}\n\n    iex> effect = Funx.Monad.Effect.pure(42)\n    iex> transformed = Funx.Monad.Effect.map_left(effect, fn _ -> \"should not be called\" end)\n    iex> Funx.Monad.Effect.run(transformed)\n    %Funx.Monad.Either.Right{right: 42}","title":"Examples - Funx.Monad.Effect.map_left/2","ref":"Funx.Monad.Effect.html#map_left/2-examples"},{"type":"function","doc":"Alias for `right/2`.\n\nWraps a value in the `Right` variant of the `Effect` monad, representing a successful asynchronous computation.\n\nAccepts either a keyword list of context options or a `Effect.Context` struct.","title":"Funx.Monad.Effect.pure/2","ref":"Funx.Monad.Effect.html#pure/2"},{"type":"function","doc":"iex> result = Funx.Monad.Effect.pure(42)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}\n\n    iex> context = Funx.Monad.Effect.Context.new(trace_id: \"custom-id\", span_name: \"pure example\")\n    iex> result = Funx.Monad.Effect.pure(42, context)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}","title":"Examples - Funx.Monad.Effect.pure/2","ref":"Funx.Monad.Effect.html#pure/2-examples"},{"type":"function","doc":"Wraps a value in the `Right` variant of the `Effect` monad, representing a successful asynchronous computation.\n\nThis is an alias for `pure/2`. You may optionally provide execution context, either as a keyword list or\na `%Funx.Monad.Effect.Context{}` struct. The context is attached to the effect and propagated during execution.","title":"Funx.Monad.Effect.right/2","ref":"Funx.Monad.Effect.html#right/2"},{"type":"function","doc":"iex> result = Funx.Monad.Effect.right(42)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}\n\n    iex> context = Funx.Monad.Effect.Context.new(trace_id: \"custom-id\", span_name: \"from right\")\n    iex> result = Funx.Monad.Effect.right(42, context)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}","title":"Examples - Funx.Monad.Effect.right/2","ref":"Funx.Monad.Effect.html#right/2-examples"},{"type":"function","doc":"Runs the `Effect` and returns the result, awaiting the task if necessary.\n\nYou may provide optional telemetry metadata using `opts`, such as `:span_name`\nto promote the current context with a new label.","title":"Funx.Monad.Effect.run/1","ref":"Funx.Monad.Effect.html#run/1"},{"type":"function","doc":"* `:span_name` – (optional) promotes the trace to a new span with the given name.","title":"Options - Funx.Monad.Effect.run/1","ref":"Funx.Monad.Effect.html#run/1-options"},{"type":"function","doc":"iex> result = Funx.Monad.Effect.right(42)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}\n\n    iex> result = Funx.Monad.Effect.right(42, span_name: \"initial\")\n    iex> Funx.Monad.Effect.run(result, span_name: \"promoted\")\n    %Funx.Monad.Either.Right{right: 42}","title":"Examples - Funx.Monad.Effect.run/1","ref":"Funx.Monad.Effect.html#run/1-examples"},{"type":"function","doc":"","title":"Funx.Monad.Effect.run/2","ref":"Funx.Monad.Effect.html#run/2"},{"type":"function","doc":"","title":"Funx.Monad.Effect.run/3","ref":"Funx.Monad.Effect.html#run/3"},{"type":"function","doc":"Sequences a list of `Effect` computations, running each in order.\n\nIf all effects resolve to `Right`, the result is a `Right` containing a list of values.\nIf any effect resolves to `Left`, the sequencing stops early and that `Left` is returned.\n\nEach effect is executed with its own context context, and telemetry spans are emitted for observability.","title":"Funx.Monad.Effect.sequence/2","ref":"Funx.Monad.Effect.html#sequence/2"},{"type":"function","doc":"iex> effects = [Funx.Monad.Effect.right(1), Funx.Monad.Effect.right(2)]\n    iex> result = Funx.Monad.Effect.sequence(effects)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: [1, 2]}\n\n    iex> effects = [Funx.Monad.Effect.right(1), Funx.Monad.Effect.left(\"error\")]\n    iex> result = Funx.Monad.Effect.sequence(effects)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: \"error\"}","title":"Examples - Funx.Monad.Effect.sequence/2","ref":"Funx.Monad.Effect.html#sequence/2-examples"},{"type":"function","doc":"Sequences a list of `Effect` computations, collecting all `Right` results\nor accumulating all `Left` errors if present.\n\nUnlike `sequence/1`, which stops at the first `Left`, this version continues processing\nall effects, returning a list of errors if any failures occur.\n\nEach effect emits its own telemetry span, and error contexts are preserved through tracing.","title":"Funx.Monad.Effect.sequence_a/2","ref":"Funx.Monad.Effect.html#sequence_a/2"},{"type":"function","doc":"iex> effects = [\n    ...>   Funx.Monad.Effect.right(1),\n    ...>   Funx.Monad.Effect.left(\"Error 1\"),\n    ...>   Funx.Monad.Effect.left(\"Error 2\")\n    ...> ]\n    iex> result = Funx.Monad.Effect.sequence_a(effects)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: [\"Error 1\", \"Error 2\"]}","title":"Examples - Funx.Monad.Effect.sequence_a/2","ref":"Funx.Monad.Effect.html#sequence_a/2-examples"},{"type":"function","doc":"Converts an `Effect` into an Elixir `{:ok, _}` or `{:error, _}` tuple by running the effect.\n\nIf the effect completes successfully (`Right`), the result is wrapped in `{:ok, value}`.\nIf the effect fails (`Left`), the error is returned as `{:error, reason}`.\n\nThis function also emits telemetry via `run/2` and supports optional context metadata through keyword options.","title":"Funx.Monad.Effect.to_result/2","ref":"Funx.Monad.Effect.html#to_result/2"},{"type":"function","doc":"* `:span_name` – sets a custom span name for tracing and telemetry.","title":"Options - Funx.Monad.Effect.to_result/2","ref":"Funx.Monad.Effect.html#to_result/2-options"},{"type":"function","doc":"iex> effect = Funx.Monad.Effect.right(42, span_name: \"convert-ok\")\n    iex> Funx.Monad.Effect.to_result(effect, span_name: \"to_result\")\n    {:ok, 42}\n\n    iex> error = Funx.Monad.Effect.left(\"fail\", span_name: \"convert-error\")\n    iex> Funx.Monad.Effect.to_result(error, span_name: \"to_result\")\n    {:error, \"fail\"}\n\nTelemetry will include the promoted span name (`\"to_result -> convert-ok\"`) and context metadata.","title":"Examples - Funx.Monad.Effect.to_result/2","ref":"Funx.Monad.Effect.html#to_result/2-examples"},{"type":"function","doc":"Executes an `Effect` and returns the result if it is a `Right`. If the result is a `Left`,\nthis function raises the contained error.\n\nThis is useful when you want to interoperate with code that expects regular exceptions,\nsuch as within test assertions or imperative pipelines.\n\nRuns the effect with full telemetry tracing.","title":"Funx.Monad.Effect.to_try!/2","ref":"Funx.Monad.Effect.html#to_try!/2"},{"type":"function","doc":"iex> effect = Funx.Monad.Effect.right(42, span_name: \"return\")\n    iex> Funx.Monad.Effect.to_try!(effect)\n    42\n\n    iex> error = Funx.Monad.Effect.left(%RuntimeError{message: \"failure\"}, span_name: \"error\")\n    iex> Funx.Monad.Effect.to_try!(error)\n    ** (RuntimeError) failure\n\nTelemetry will emit a `:stop` event with `:status` set to `:ok` or `:error`, depending on the outcome.","title":"Examples - Funx.Monad.Effect.to_try!/2","ref":"Funx.Monad.Effect.html#to_try!/2-examples"},{"type":"function","doc":"Traverses a list with a function that returns `Effect` computations,\nrunning each in sequence and collecting the `Right` results.\n\nIf all effects resolve to `Right`, returns a single `Effect` with a list of results.\nIf any effect resolves to `Left`, the traversal stops early and returns that `Left`.\n\nEach step preserves context context and emits telemetry spans, including nested spans when bound.","title":"Funx.Monad.Effect.traverse/2","ref":"Funx.Monad.Effect.html#traverse/2"},{"type":"function","doc":"iex> is_positive = fn num ->\n    ...>   Funx.Monad.Effect.lift_predicate(num, fn x -> x > 0 end, fn x -> Integer.to_string(x) <> \" is not positive\" end)\n    ...> end\n    iex> result = Funx.Monad.Effect.traverse([1, 2, 3], fn num -> is_positive.(num) end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: [1, 2, 3]}\n    iex> result = Funx.Monad.Effect.traverse([1, -2, 3], fn num -> is_positive.(num) end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: \"-2 is not positive\"}","title":"Examples - Funx.Monad.Effect.traverse/2","ref":"Funx.Monad.Effect.html#traverse/2-examples"},{"type":"function","doc":"","title":"Funx.Monad.Effect.traverse/3","ref":"Funx.Monad.Effect.html#traverse/3"},{"type":"function","doc":"Traverses a list with a function that returns `Effect` values, combining results\ninto a single `Effect`. Unlike `traverse/2`, this version accumulates all errors\nrather than stopping at the first `Left`.\n\nEach successful computation contributes to the final list of results.\nIf any computations fail, all errors are collected and returned as a single `Left`.\n\nThis function also manages telemetry trace context across all nested effects,\nensuring that span relationships and trace IDs are preserved through the traversal.","title":"Funx.Monad.Effect.traverse_a/2","ref":"Funx.Monad.Effect.html#traverse_a/2"},{"type":"function","doc":"iex> validate = fn n ->\n    ...>   Funx.Monad.Effect.lift_predicate(n, fn x -> x > 0 end, fn x -> Integer.to_string(x) <> \" is not positive\" end)\n    ...> end\n    iex> result = Funx.Monad.Effect.traverse_a([1, -2, 3], validate)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: [\"-2 is not positive\"]}\n    iex> result = Funx.Monad.Effect.traverse_a([1, 2, 3], validate)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: [1, 2, 3]}","title":"Examples - Funx.Monad.Effect.traverse_a/2","ref":"Funx.Monad.Effect.html#traverse_a/2-examples"},{"type":"function","doc":"","title":"Funx.Monad.Effect.traverse_a/3","ref":"Funx.Monad.Effect.html#traverse_a/3"},{"type":"function","doc":"Validates a value using one or more validator functions, each returning an `Effect`.\n\nIf all validators succeed (`Right`), the original value is returned in a `Right`.\nIf any validator fails (`Left`), all errors are accumulated and returned as a single `Left`.\n\nThis function also manages telemetry trace context across all nested validations,\nensuring that span relationships and trace IDs are preserved throughout.\n\nSupports optional `opts` for span metadata (e.g. `:span_name`).","title":"Funx.Monad.Effect.validate/3","ref":"Funx.Monad.Effect.html#validate/3"},{"type":"function","doc":"iex> validate_positive = fn x ->\n    ...>   Funx.Monad.Effect.lift_predicate(x, fn n -> n > 0 end, fn n -> \"Value \" <> Integer.to_string(n) <> \" must be positive\" end)\n    ...> end\n    iex> validate_even = fn x ->\n    ...>   Funx.Monad.Effect.lift_predicate(x, fn n -> rem(n, 2) == 0 end, fn n -> \"Value \" <> Integer.to_string(n) <> \" must be even\" end)\n    ...> end\n    iex> validators = [validate_positive, validate_even]\n    iex> result = Funx.Monad.Effect.validate(4, validators)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 4}\n    iex> result = Funx.Monad.Effect.validate(3, validators)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: [\"Value 3 must be even\"]}\n    iex> result = Funx.Monad.Effect.validate(-3, validators)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: [\"Value -3 must be positive\", \"Value -3 must be even\"]}","title":"Examples - Funx.Monad.Effect.validate/3","ref":"Funx.Monad.Effect.html#validate/3-examples"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonad%2Feffect%2Fcontext.livemd)\n\nRepresents the execution context attached to an effect.\n\nThis struct carries contextual information such as `trace_id`, `span_name`,\ntimeouts, and arbitrary metadata (`baggage` and `metadata`). It supports\ntelemetry integration, span linking, and timeout control, and is propagated\nautomatically across composed effects.\n\nDevelopers can set fields like `timeout`, `trace_id`, or `span_name` when\nconstructing `Left` and `Right` effects. The context is merged or promoted\nas needed when chaining effects to preserve trace continuity and execution scope.\n\nThis context is not injected at runtime via `run/2`—it is bound to the effect\nwhen created.","title":"Funx.Monad.Effect.Context","ref":"Funx.Monad.Effect.Context.html"},{"type":"type","doc":"Represents input for constructing an `Effect.Context`.\n\nAccepts either a keyword list of options (`trace_id`, `span_name`, etc.) or an existing `Context` struct.\nUsed throughout the `Effect` system for flexible context propagation.","title":"Funx.Monad.Effect.Context.opts_or_context/0","ref":"Funx.Monad.Effect.Context.html#t:opts_or_context/0"},{"type":"type","doc":"Represents the contextual metadata associated with an `Effect`.\n\nThe context carries telemetry and tracing information such as `trace_id`, `span_name`, and `timeout`,\nas well as arbitrary metadata and user-defined `baggage`. It is passed through all effectful computations\nand can be promoted to represent nested spans.","title":"Funx.Monad.Effect.Context.t/0","ref":"Funx.Monad.Effect.Context.html#t:t/0"},{"type":"function","doc":"","title":"Funx.Monad.Effect.Context.default_span_name?/1","ref":"Funx.Monad.Effect.Context.html#default_span_name?/1"},{"type":"function","doc":"","title":"Funx.Monad.Effect.Context.default_span_name_if_empty/2","ref":"Funx.Monad.Effect.Context.html#default_span_name_if_empty/2"},{"type":"function","doc":"","title":"Funx.Monad.Effect.Context.empty_or_default_span_name?/1","ref":"Funx.Monad.Effect.Context.html#empty_or_default_span_name?/1"},{"type":"function","doc":"Generates a random lowercase hexadecimal trace ID.\n\nThis function is used internally to ensure each trace is uniquely identifiable.","title":"Funx.Monad.Effect.Context.generate_trace_id/0","ref":"Funx.Monad.Effect.Context.html#generate_trace_id/0"},{"type":"function","doc":"iex> id = Funx.Monad.Effect.Context.generate_trace_id()\n    iex> String.length(id)\n    32\n    iex> id =~ ~r/^[a-f0-9]+$/\n    true","title":"Examples - Funx.Monad.Effect.Context.generate_trace_id/0","ref":"Funx.Monad.Effect.Context.html#generate_trace_id/0-examples"},{"type":"function","doc":"Merges two `%Funx.Monad.Effect.Context{}` structs into one, preferring non-nil values from the first context.\n\nThis is used to preserve trace continuity and propagate context across composed effects.\n\n- Non-nil fields from the first context take precedence.\n- `baggage` and `metadata` maps are deeply merged.\n- This operation is idempotent and safe for reuse across nested effect chains.","title":"Funx.Monad.Effect.Context.merge/2","ref":"Funx.Monad.Effect.Context.html#merge/2"},{"type":"function","doc":"iex> c1 = Funx.Monad.Effect.Context.new(trace_id: \"a\", baggage: %{user: 1})\n    iex> c2 = Funx.Monad.Effect.Context.new(trace_id: \"b\", baggage: %{region: \"us-west\"})\n    iex> Funx.Monad.Effect.Context.merge(c1, c2).baggage\n    %{user: 1, region: \"us-west\"}","title":"Examples - Funx.Monad.Effect.Context.merge/2","ref":"Funx.Monad.Effect.Context.html#merge/2-examples"},{"type":"function","doc":"Creates a new `Funx.Monad.Effect.Context` struct for use with effectful computations.\n\nIf no `:trace_id` is provided, a unique one is generated automatically.\nYou may also set optional fields such as `:span_name`, `:timeout`, `:baggage`, and `:metadata`.\n\nThe returned context is intended to be passed into `Left` and `Right` effects,\nwhere it will be propagated and updated across chained computations.","title":"Funx.Monad.Effect.Context.new/0","ref":"Funx.Monad.Effect.Context.html#new/0"},{"type":"function","doc":"iex> ctx = Funx.Monad.Effect.Context.new(span_name: \"load-data\", timeout: 2000)\n    iex> ctx.span_name\n    \"load-data\"\n\n    iex> ctx = Funx.Monad.Effect.Context.new(trace_id: \"abc123\")\n    iex> ctx.trace_id\n    \"abc123\"","title":"Examples - Funx.Monad.Effect.Context.new/0","ref":"Funx.Monad.Effect.Context.html#new/0-examples"},{"type":"function","doc":"","title":"Funx.Monad.Effect.Context.new/1","ref":"Funx.Monad.Effect.Context.html#new/1"},{"type":"function","doc":"Returns a new `%Funx.Monad.Effect.Context{}` with fields overridden by values from the given keyword list.\n\n- Direct fields like `:trace_id`, `:parent_trace_id`, `:span_name`, and `:timeout` are replaced if present.\n- Nested maps `:baggage` and `:metadata` are deeply merged, with the keyword list taking precedence.\n\nThis is useful for refining or extending an existing context in a specific part of an effect chain.","title":"Funx.Monad.Effect.Context.override/2","ref":"Funx.Monad.Effect.Context.html#override/2"},{"type":"function","doc":"iex> ctx = Funx.Monad.Effect.Context.new(trace_id: \"abc\", baggage: %{x: 1}, metadata: %{debug: false})\n    iex> updated = Funx.Monad.Effect.Context.override(ctx, span_name: \"child\", baggage: %{x: 2}, metadata: %{debug: true})\n    iex> updated.span_name\n    \"child\"\n    iex> updated.baggage\n    %{x: 2}\n    iex> updated.metadata\n    %{debug: true}","title":"Examples - Funx.Monad.Effect.Context.override/2","ref":"Funx.Monad.Effect.Context.html#override/2-examples"},{"type":"function","doc":"Promotes the current context into a child trace by generating a new `trace_id` and linking to the original.\n\n- The current `trace_id` is moved to `parent_trace_id`.\n- A new `trace_id` is generated for the child context.\n- The given `label` is prepended to the existing `span_name` as `\"label -> span\"`.\n\nThis is typically used to represent a nested span or sub-operation within a larger effect chain,\npreserving trace lineage across composed effects.","title":"Funx.Monad.Effect.Context.promote_trace/2","ref":"Funx.Monad.Effect.Context.html#promote_trace/2"},{"type":"function","doc":"iex> parent = Funx.Monad.Effect.Context.new(trace_id: \"abc123\", span_name: \"load\")\n    iex> child = Funx.Monad.Effect.Context.promote_trace(parent, \"decode\")\n    iex> child.parent_trace_id\n    \"abc123\"\n    iex> child.trace_id != \"abc123\"\n    true\n    iex> child.span_name\n    \"decode -> load\"","title":"Examples - Funx.Monad.Effect.Context.promote_trace/2","ref":"Funx.Monad.Effect.Context.html#promote_trace/2-examples"},{"type":"function","doc":"","title":"Funx.Monad.Effect.Context.span_name?/1","ref":"Funx.Monad.Effect.Context.html#span_name?/1"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonad%2Feffect%2Fleft.livemd)\n\nRepresents the `Left` variant of the `Effect` monad, used to model a failure or error in an asynchronous context.\n\nThis module implements the following protocols:\n  - `Funx.Monad`: Implements `bind/2`, `map/2`, and `ap/2` for monadic sequencing in a lazy, effectful context.\n  - `String.Chars`: Provides a string representation of the effect for debugging and inspection.\n\nA `Left` effect propagates its failure value without invoking further computations, preserving short-circuit behavior.","title":"Funx.Monad.Effect.Left","ref":"Funx.Monad.Effect.Left.html"},{"type":"module","doc":"* `ask/1` – Returns the environment passed to `run/2` as a `Left`.\n  * `asks/2` – Applies a function to the environment passed to `run/2`, wrapping the result in a `Left`.","title":"Reader Operations - Funx.Monad.Effect.Left","ref":"Funx.Monad.Effect.Left.html#module-reader-operations"},{"type":"type","doc":"","title":"Funx.Monad.Effect.Left.t/0","ref":"Funx.Monad.Effect.Left.html#t:t/0"},{"type":"type","doc":"Represents an asynchronous computation that produces a `Left` value.\n\nThe `effect` function is typically a deferred task that takes an environment and returns a `Task`.\nSince Elixir does not support parameterized `Task.t()` types, the return type is written as a union:\neither a `Task.t()` or a plain `Either.Left.t(left)` to support testing and internal optimizations.\n\nThe `context` carries telemetry, trace metadata, and environment configuration for error flows.","title":"Funx.Monad.Effect.Left.t/1","ref":"Funx.Monad.Effect.Left.html#t:t/1"},{"type":"function","doc":"Returns a `Funx.Monad.Effect.Left` that yields the environment passed to `Funx.Monad.Effect.run/2`.\n\nThis is the Reader-style `ask`, used to construct a failure from the full injected environment.\nIt can be useful for debugging, instrumentation, or propagating request-scoped failure information.","title":"Funx.Monad.Effect.Left.ask/1","ref":"Funx.Monad.Effect.Left.html#ask/1"},{"type":"function","doc":"iex> Funx.Monad.Effect.Left.ask()\n    ...> |> Funx.Monad.Effect.run(%{error: :unauthorized})\n    %Funx.Monad.Either.Left{left: %{error: :unauthorized}}","title":"Example - Funx.Monad.Effect.Left.ask/1","ref":"Funx.Monad.Effect.Left.html#ask/1-example"},{"type":"function","doc":"Returns a `Funx.Monad.Effect.Left` that applies the given function to the environment passed to `Funx.Monad.Effect.run/2`.\n\nThis allows constructing a failure (`Left`) based on runtime input. It complements `Right.asks/2`,\nbut marks the result as a failure rather than a success.","title":"Funx.Monad.Effect.Left.asks/2","ref":"Funx.Monad.Effect.Left.html#asks/2"},{"type":"function","doc":"iex> Funx.Monad.Effect.Left.asks(fn env -> {:error, env[:reason]} end)\n    ...> |> Funx.Monad.Effect.run(%{reason: :invalid})\n    %Funx.Monad.Either.Left{left: {:error, :invalid}}","title":"Example - Funx.Monad.Effect.Left.asks/2","ref":"Funx.Monad.Effect.Left.html#asks/2-example"},{"type":"function","doc":"Creates a new `Left` effect.\n\nWraps a failure value in an asynchronous effect. You may provide context either as a keyword list or\nan `Effect.Context` struct.","title":"Funx.Monad.Effect.Left.pure/2","ref":"Funx.Monad.Effect.Left.html#pure/2"},{"type":"function","doc":"iex> effect = Funx.Monad.Effect.Left.pure(\"error\")\n    iex> Funx.Monad.Effect.run(effect)\n    %Funx.Monad.Either.Left{left: \"error\"}","title":"Examples - Funx.Monad.Effect.Left.pure/2","ref":"Funx.Monad.Effect.Left.html#pure/2-examples"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonad%2Feffect%2Fright.livemd)\n\nRepresents the `Right` variant of the `Effect` monad, used to model a successful computation in an asynchronous context.\n\nThis module implements the following protocols:\n  - `Funx.Monad`: Implements the `bind/2`, `map/2`, and `ap/2` functions to handle monadic operations within an effectful, lazy execution context.\n  - `String.Chars`: Provides a `to_string/1` function to represent `Right` values as strings.\n\nThe `Right` effect allows the computation to proceed with successful values, supporting lazy, asynchronous tasks\nand capturing execution context through the `Effect.Context` struct.","title":"Funx.Monad.Effect.Right","ref":"Funx.Monad.Effect.Right.html"},{"type":"module","doc":"* `ask/1` – Returns the environment passed to `run/2` as a `Right`.\n  * `asks/2` – Applies a function to the environment passed to `run/2`, wrapping the result in a `Right`.","title":"Reader Operations - Funx.Monad.Effect.Right","ref":"Funx.Monad.Effect.Right.html#module-reader-operations"},{"type":"type","doc":"","title":"Funx.Monad.Effect.Right.t/0","ref":"Funx.Monad.Effect.Right.html#t:t/0"},{"type":"type","doc":"Represents an asynchronous computation that produces a `Right` value.\n\nThe `effect` function is typically a deferred task that takes an environment and returns a `Task`.\nSince Elixir does not support parameterized `Task.t()` types, the return type is described as a union:\neither a `Task.t()` or a plain `Either.Right.t(right)` for testability and flexibility.\n\nThe `context` carries telemetry and trace information used during execution.","title":"Funx.Monad.Effect.Right.t/1","ref":"Funx.Monad.Effect.Right.html#t:t/1"},{"type":"function","doc":"Returns a `Funx.Monad.Effect.Right` that yields the environment passed to `Funx.Monad.Effect.run/2`.\n\nThis is the Reader monad's equivalent of `ask`, giving access to the entire injected environment\nfor further computation.","title":"Funx.Monad.Effect.Right.ask/1","ref":"Funx.Monad.Effect.Right.html#ask/1"},{"type":"function","doc":"iex> Funx.Monad.Effect.Right.ask()\n    ...> |> Funx.Monad.map(& &1[:user])\n    ...> |> Funx.Monad.Effect.run(%{user: \"alice\"})\n    %Funx.Monad.Either.Right{right: \"alice\"}","title":"Example - Funx.Monad.Effect.Right.ask/1","ref":"Funx.Monad.Effect.Right.html#ask/1-example"},{"type":"function","doc":"Returns a `Funx.Monad.Effect.Right` that applies the given function to the environment passed to `Funx.Monad.Effect.run/2`.\n\nThis allows extracting a value from the environment and using it in an effectful computation,\nfollowing the Reader pattern.","title":"Funx.Monad.Effect.Right.asks/2","ref":"Funx.Monad.Effect.Right.html#asks/2"},{"type":"function","doc":"iex> Funx.Monad.Effect.Right.asks(fn env -> env[:user] end)\n    ...> |> Funx.Monad.bind(fn user -> Funx.Monad.Effect.right(user) end)\n    ...> |> Funx.Monad.Effect.run(%{user: \"alice\"})\n    %Funx.Monad.Either.Right{right: \"alice\"}","title":"Example - Funx.Monad.Effect.Right.asks/2","ref":"Funx.Monad.Effect.Right.html#asks/2-example"},{"type":"function","doc":"Creates a new `Right` effect.\n\nThe `pure/2` function wraps a value in the `Right` effect monad, representing an asynchronous success.","title":"Funx.Monad.Effect.Right.pure/2","ref":"Funx.Monad.Effect.Right.html#pure/2"},{"type":"function","doc":"iex> effect = Funx.Monad.Effect.Right.pure(\"success\")\n    iex> Funx.Monad.Effect.run(effect)\n    %Funx.Monad.Either.Right{right: \"success\"}","title":"Examples - Funx.Monad.Effect.Right.pure/2","ref":"Funx.Monad.Effect.Right.html#pure/2-examples"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonad%2Feither%2Feither.livemd)\n\nThe `Funx.Monad.Either` module provides an implementation of the `Either` monad, a functional abstraction used to model computations that may fail.\n\nAn `Either` represents one of two possibilities:\n\n  - `Right(value)`: a successful result\n  - `Left(error)`: a failure or error\n\nThis pattern is commonly used in place of exceptions to handle errors explicitly and safely in functional pipelines.","title":"Funx.Monad.Either","ref":"Funx.Monad.Either.html"},{"type":"module","doc":"- `right/1`: Wraps a value in the `Right` branch.\n  - `left/1`: Wraps a value in the `Left` branch.\n  - `pure/1`: Alias for `right/1`.","title":"Constructors - Funx.Monad.Either","ref":"Funx.Monad.Either.html#module-constructors"},{"type":"module","doc":"- `right?/1`: Returns `true` if the value is a `Right`.\n  - `left?/1`: Returns `true` if the value is a `Left`.","title":"Refinement - Funx.Monad.Either","ref":"Funx.Monad.Either.html#module-refinement"},{"type":"module","doc":"- `get_or_else/2`: Returns the value from a `Right`, or a default if `Left`.\n  - `or_else/2`: Returns the original `Right`, or invokes a fallback function if `Left`.\n  - `map_left/2`: Transforms a `Left` using a function, leaving `Right` values unchanged.\n  - `flip_iso/0`: Returns the isomorphism that swaps `Left` and `Right` branches.\n  - `flip/1`: Swaps `Left` and `Right`, turning errors into successes and vice versa (via `flip_iso`).\n  - `filter_or_else/3`: Applies a predicate to the `Right` value; if false, returns a fallback `Left`.","title":"Fallback and Extraction - Funx.Monad.Either","ref":"Funx.Monad.Either.html#module-fallback-and-extraction"},{"type":"module","doc":"- `concat/1`: Removes all `Left` values and unwraps the `Right` values from a list.\n  - `concat_map/2`: Applies a function and collects only `Right` results.\n  - `sequence/1`: Converts a list of `Either` values into a single `Either` of list.\n  - `traverse/2`: Applies a function to each element in a list and sequences the results.\n  - `sequence_a/1`: Like `sequence/1`, but accumulates all errors from `Left` values.\n  - `traverse_a/2`: Like `traverse/2`, but accumulates all `Left` values instead of short-circuiting.\n  - `wither_a/2`: Like `traverse_a/2`, but filters out `Nothing` results and collects only `Just` values.","title":"List Operations - Funx.Monad.Either","ref":"Funx.Monad.Either.html#module-list-operations"},{"type":"module","doc":"- `validate/2`: Applies multiple validators to a single input, collecting all errors.","title":"Validation - Funx.Monad.Either","ref":"Funx.Monad.Either.html#module-validation"},{"type":"module","doc":"- `lift_predicate/3`: Turns a predicate into an `Either`, returning `Right` on `true` and `Left` on `false`.\n  - `lift_maybe/2`: Converts a `Maybe` to an `Either` using a fallback value.\n  - `lift_eq/1`: Lifts an equality function into the `Either` context.\n  - `lift_ord/1`: Lifts an ordering function into the `Either` context.","title":"Lifting - Funx.Monad.Either","ref":"Funx.Monad.Either.html#module-lifting"},{"type":"module","doc":"- `map_left/2` – Transforms the error inside a `Left`, leaving `Right` values untouched.","title":"Transformation - Funx.Monad.Either","ref":"Funx.Monad.Either.html#module-transformation"},{"type":"module","doc":"- `result_iso/0`: Returns the isomorphism between `Either` and result tuples.\n  - `from_result/1`: Converts `{:ok, val}` or `{:error, err}` into an `Either` (via `result_iso`).\n  - `to_result/1`: Converts an `Either` into a result tuple (via `result_iso`).\n  - `from_try/1`: Runs a function and returns `Right` on success or `Left` on exception.\n  - `to_try!/1`: Unwraps a `Right`, or raises an error from a `Left`.","title":"Elixir Interoperability - Funx.Monad.Either","ref":"Funx.Monad.Either.html#module-elixir-interoperability"},{"type":"module","doc":"The `Left` and `Right` structs implement the following protocols, making the `Either` abstraction composable and extensible:\n\n  - `Funx.Eq`: Enables equality comparisons between `Either` values.\n  - `Funx.Foldable`: Implements `fold_l/3` and `fold_r/3` for reducing over contained values.\n  - `Funx.Monad`: Provides `map/2`, `ap/2`, and `bind/2` for monadic composition.\n  - `Funx.Ord`: Defines ordering behavior for comparing `Left` and `Right` values.\n  - `Funx.Tappable`: Executes side effects on `Right` values via `Funx.Tappable.tap/2`, leaving `Left` values unchanged.\n\nAlthough these implementations are defined on each constructor (`Left` and `Right`), the behavior is consistent across the `Either` abstraction.\n\nThis module helps you model failure explicitly, compose error-aware logic, and integrate cleanly with Elixir's functional idioms.","title":"Protocols - Funx.Monad.Either","ref":"Funx.Monad.Either.html#module-protocols"},{"type":"module","doc":"You can use the Either DSL for clean Kleisli composition:\n\n    use Funx.Monad.Either\n\n    either input do\n      ParseInt\n      bind PositiveNumber\n      Double\n    end","title":"DSL Usage - Funx.Monad.Either","ref":"Funx.Monad.Either.html#module-dsl-usage"},{"type":"type","doc":"","title":"Funx.Monad.Either.t/2","ref":"Funx.Monad.Either.html#t:t/2"},{"type":"function","doc":"Removes `Left` values from a list of `Either` and returns a list of unwrapped `Right` values.\n\nUseful for discarding failed computations while keeping successful results.","title":"Funx.Monad.Either.concat/1","ref":"Funx.Monad.Either.html#concat/1"},{"type":"function","doc":"iex> Funx.Monad.Either.concat([Funx.Monad.Either.right(1), Funx.Monad.Either.left(:error), Funx.Monad.Either.right(2)])\n    [1, 2]\n\n    iex> Funx.Monad.Either.concat([Funx.Monad.Either.left(:a), Funx.Monad.Either.left(:b)])\n    []\n\n    iex> Funx.Monad.Either.concat([Funx.Monad.Either.right(\"a\"), Funx.Monad.Either.right(\"b\"), Funx.Monad.Either.right(\"c\")])\n    [\"a\", \"b\", \"c\"]","title":"Examples - Funx.Monad.Either.concat/1","ref":"Funx.Monad.Either.html#concat/1-examples"},{"type":"function","doc":"Applies the given function to each element in the list and collects the `Right` results, discarding any `Left`.\n\nThis is useful when mapping a function that may fail and you only want the successful results.","title":"Funx.Monad.Either.concat_map/2","ref":"Funx.Monad.Either.html#concat_map/2"},{"type":"function","doc":"iex> Funx.Monad.Either.concat_map([1, 2, 3], fn x -> if rem(x, 2) == 1, do: Funx.Monad.Either.right(x), else: Funx.Monad.Either.left(:even) end)\n    [1, 3]\n\n    iex> Funx.Monad.Either.concat_map([2, 4], fn x -> if x > 3, do: Funx.Monad.Either.right(x), else: Funx.Monad.Either.left(:too_small) end)\n    [4]\n\n    iex> Funx.Monad.Either.concat_map([], fn _ -> Funx.Monad.Either.left(:none) end)\n    []","title":"Examples - Funx.Monad.Either.concat_map/2","ref":"Funx.Monad.Either.html#concat_map/2-examples"},{"type":"function","doc":"Filters the value inside a `Right` using the given `predicate`. If the predicate returns `false`,\na `Left` is returned using the `left_func`.","title":"Funx.Monad.Either.filter_or_else/3","ref":"Funx.Monad.Either.html#filter_or_else/3"},{"type":"function","doc":"iex> Funx.Monad.Either.filter_or_else(Funx.Monad.Either.right(5), fn x -> x > 3 end, fn -> \"error\" end)\n    %Funx.Monad.Either.Right{right: 5}\n\n    iex> Funx.Monad.Either.filter_or_else(Funx.Monad.Either.right(2), fn x -> x > 3 end, fn -> \"error\" end)\n    %Funx.Monad.Either.Left{left: \"error\"}","title":"Examples - Funx.Monad.Either.filter_or_else/3","ref":"Funx.Monad.Either.html#filter_or_else/3-examples"},{"type":"function","doc":"Swaps the `Left` and `Right` branches of the `Either`.\n\nTurns a `Left` into a `Right` and vice versa, preserving the contained term.\n\nImplemented via the `flip_iso` involution.","title":"Funx.Monad.Either.flip/1","ref":"Funx.Monad.Either.html#flip/1"},{"type":"function","doc":"iex> Funx.Monad.Either.flip(Funx.Monad.Either.left(:error))\n    %Funx.Monad.Either.Right{right: :error}\n\n    iex> Funx.Monad.Either.flip(Funx.Monad.Either.right(42))\n    %Funx.Monad.Either.Left{left: 42}","title":"Examples - Funx.Monad.Either.flip/1","ref":"Funx.Monad.Either.html#flip/1-examples"},{"type":"function","doc":"Returns the isomorphism that swaps Left and Right branches.\n\nThis is an involution - applying it twice returns the original value.\nBoth directions of the iso perform the same swap operation.","title":"Funx.Monad.Either.flip_iso/0","ref":"Funx.Monad.Either.html#flip_iso/0"},{"type":"function","doc":"iex> iso = Funx.Monad.Either.flip_iso()\n    iex> Funx.Optics.Iso.view(%Funx.Monad.Either.Left{left: :error}, iso)\n    %Funx.Monad.Either.Right{right: :error}\n    iex> Funx.Optics.Iso.review(%Funx.Monad.Either.Right{right: 42}, iso)\n    %Funx.Monad.Either.Left{left: 42}","title":"Examples - Funx.Monad.Either.flip_iso/0","ref":"Funx.Monad.Either.html#flip_iso/0-examples"},{"type":"function","doc":"Converts a result (`{:ok, _}` or `{:error, _}`) to an `Either`.\n\nImplemented via the `Either <-> result tuple` isomorphism.","title":"Funx.Monad.Either.from_result/1","ref":"Funx.Monad.Either.html#from_result/1"},{"type":"function","doc":"iex> Funx.Monad.Either.from_result({:ok, 5})\n    %Funx.Monad.Either.Right{right: 5}\n\n    iex> Funx.Monad.Either.from_result({:error, \"error\"})\n    %Funx.Monad.Either.Left{left: \"error\"}","title":"Examples - Funx.Monad.Either.from_result/1","ref":"Funx.Monad.Either.html#from_result/1-examples"},{"type":"function","doc":"Wraps a value in an `Either`, catching any exceptions. If an exception occurs, a `Left` is returned with the exception.","title":"Funx.Monad.Either.from_try/1","ref":"Funx.Monad.Either.html#from_try/1"},{"type":"function","doc":"iex> Funx.Monad.Either.from_try(fn -> 5 end)\n    %Funx.Monad.Either.Right{right: 5}\n\n    iex> Funx.Monad.Either.from_try(fn -> raise \"error\" end)\n    %Funx.Monad.Either.Left{left: %RuntimeError{message: \"error\"}}","title":"Examples - Funx.Monad.Either.from_try/1","ref":"Funx.Monad.Either.html#from_try/1-examples"},{"type":"function","doc":"Retrieves the value from a `Right`, returning the `default` value if `Left`.","title":"Funx.Monad.Either.get_or_else/2","ref":"Funx.Monad.Either.html#get_or_else/2"},{"type":"function","doc":"iex> Funx.Monad.Either.get_or_else(Funx.Monad.Either.right(5), 0)\n    5\n\n    iex> Funx.Monad.Either.get_or_else(Funx.Monad.Either.left(\"error\"), 0)\n    0","title":"Examples - Funx.Monad.Either.get_or_else/2","ref":"Funx.Monad.Either.html#get_or_else/2-examples"},{"type":"function","doc":"Wraps a value in the `Left` monad.","title":"Funx.Monad.Either.left/1","ref":"Funx.Monad.Either.html#left/1"},{"type":"function","doc":"iex> Funx.Monad.Either.left(\"error\")\n    %Funx.Monad.Either.Left{left: \"error\"}","title":"Examples - Funx.Monad.Either.left/1","ref":"Funx.Monad.Either.html#left/1-examples"},{"type":"function","doc":"Returns `true` if the `Either` is a `Left` value.","title":"Funx.Monad.Either.left?/1","ref":"Funx.Monad.Either.html#left?/1"},{"type":"function","doc":"iex> Funx.Monad.Either.left?(Funx.Monad.Either.left(\"error\"))\n    true\n\n    iex> Funx.Monad.Either.left?(Funx.Monad.Either.right(5))\n    false","title":"Examples - Funx.Monad.Either.left?/1","ref":"Funx.Monad.Either.html#left?/1-examples"},{"type":"function","doc":"Lifts an equality function to compare `Either` values:\n  - `Right` vs `Right`: Uses the custom equality function.\n  - `Left` vs `Left`: Uses the custom equality function.\n  - `Left` vs `Right` or vice versa: Always `false`.","title":"Funx.Monad.Either.lift_eq/1","ref":"Funx.Monad.Either.html#lift_eq/1"},{"type":"function","doc":"iex> eq = Funx.Monad.Either.lift_eq(%{\n    ...>   eq?: fn x, y -> x == y end,\n    ...>   not_eq?: fn x, y -> x != y end\n    ...> })\n    iex> eq.eq?.(Funx.Monad.Either.right(5), Funx.Monad.Either.right(5))\n    true\n    iex> eq.eq?.(Funx.Monad.Either.right(5), Funx.Monad.Either.right(10))\n    false\n    iex> eq.eq?.(Funx.Monad.Either.left(:a), Funx.Monad.Either.left(:a))\n    true\n    iex> eq.eq?.(Funx.Monad.Either.left(:a), Funx.Monad.Either.left(:b))\n    false\n    iex> eq.eq?.(Funx.Monad.Either.right(5), Funx.Monad.Either.left(:a))\n    false","title":"Examples - Funx.Monad.Either.lift_eq/1","ref":"Funx.Monad.Either.html#lift_eq/1-examples"},{"type":"function","doc":"Converts a `Maybe` value to an `Either`. If the `Maybe` is `Nothing`, a `Left` is returned using `on_none`.","title":"Funx.Monad.Either.lift_maybe/2","ref":"Funx.Monad.Either.html#lift_maybe/2"},{"type":"function","doc":"iex> Funx.Monad.Either.lift_maybe(Funx.Monad.Maybe.just(5), fn -> \"error\" end)\n    %Funx.Monad.Either.Right{right: 5}\n\n    iex> Funx.Monad.Either.lift_maybe(Funx.Monad.Maybe.nothing(), fn -> \"error\" end)\n    %Funx.Monad.Either.Left{left: \"error\"}","title":"Examples - Funx.Monad.Either.lift_maybe/2","ref":"Funx.Monad.Either.html#lift_maybe/2-examples"},{"type":"function","doc":"Creates a custom ordering function for `Either` values using the provided `custom_ord`.\n\nThe `custom_ord` must be a map with `:lt?`, `:le?`, `:gt?`, and `:ge?` functions. These are used to compare the internal `left` or `right` values.","title":"Funx.Monad.Either.lift_ord/1","ref":"Funx.Monad.Either.html#lift_ord/1"},{"type":"function","doc":"iex> ord = Funx.Monad.Either.lift_ord(%{\n    ...>   lt?: fn x, y -> x     le?: fn x, y -> x <= y end,\n    ...>   gt?: fn x, y -> x > y end,\n    ...>   ge?: fn x, y -> x >= y end\n    ...> })\n    iex> ord.lt?.(Funx.Monad.Either.right(3), Funx.Monad.Either.right(5))\n    true\n    iex> ord.lt?.(Funx.Monad.Either.left(3), Funx.Monad.Either.right(5))\n    true\n    iex> ord.lt?.(Funx.Monad.Either.right(3), Funx.Monad.Either.left(5))\n    false\n    iex> ord.lt?.(Funx.Monad.Either.left(3), Funx.Monad.Either.left(5))\n    true","title":"Examples - Funx.Monad.Either.lift_ord/1","ref":"Funx.Monad.Either.html#lift_ord/1-examples"},{"type":"function","doc":"Lifts a value into an `Either` based on the result of a predicate.\n\nReturns `Right(value)` if the predicate returns `true`, or `Left(on_false.(value))` if it returns `false`.\n\nThis allows you to wrap a conditional check in a functional context with a custom error message.","title":"Funx.Monad.Either.lift_predicate/3","ref":"Funx.Monad.Either.html#lift_predicate/3"},{"type":"function","doc":"iex> Funx.Monad.Either.lift_predicate(5, fn x -> x > 3 end, fn x -> \"#{x} is too small\" end)\n    %Funx.Monad.Either.Right{right: 5}\n\n    iex> Funx.Monad.Either.lift_predicate(2, fn x -> x > 3 end, fn x -> \"#{x} is too small\" end)\n    %Funx.Monad.Either.Left{left: \"2 is too small\"}","title":"Examples - Funx.Monad.Either.lift_predicate/3","ref":"Funx.Monad.Either.html#lift_predicate/3-examples"},{"type":"function","doc":"Transforms the `Left` value using the given function if the `Either` is a `Left`.\nIf the value is `Right`, it is returned unchanged.","title":"Funx.Monad.Either.map_left/2","ref":"Funx.Monad.Either.html#map_left/2"},{"type":"function","doc":"iex> Funx.Monad.Either.map_left(Funx.Monad.Either.left(\"error\"), fn e -> \"wrapped: \" <> e end)\n    %Funx.Monad.Either.Left{left: \"wrapped: error\"}\n\n    iex> Funx.Monad.Either.map_left(Funx.Monad.Either.right(42), fn _ -> \"ignored\" end)\n    %Funx.Monad.Either.Right{right: 42}","title":"Examples - Funx.Monad.Either.map_left/2","ref":"Funx.Monad.Either.html#map_left/2-examples"},{"type":"function","doc":"Returns the current `Right` value or invokes the `fallback_fun` if `Left`.\n\nUseful for recovering from a failure by providing an alternate computation.","title":"Funx.Monad.Either.or_else/2","ref":"Funx.Monad.Either.html#or_else/2"},{"type":"function","doc":"iex> Funx.Monad.Either.or_else(Funx.Monad.Either.left(\"error\"), fn -> Funx.Monad.Either.right(42) end)\n    %Funx.Monad.Either.Right{right: 42}\n\n    iex> Funx.Monad.Either.or_else(Funx.Monad.Either.right(10), fn -> Funx.Monad.Either.right(42) end)\n    %Funx.Monad.Either.Right{right: 10}","title":"Examples - Funx.Monad.Either.or_else/2","ref":"Funx.Monad.Either.html#or_else/2-examples"},{"type":"function","doc":"Alias for `right/1`.","title":"Funx.Monad.Either.pure/1","ref":"Funx.Monad.Either.html#pure/1"},{"type":"function","doc":"iex> Funx.Monad.Either.pure(2)\n    %Funx.Monad.Either.Right{right: 2}","title":"Examples - Funx.Monad.Either.pure/1","ref":"Funx.Monad.Either.html#pure/1-examples"},{"type":"function","doc":"Returns the isomorphism between Either and Elixir result tuples.\n\nThis iso witnesses that `Either` and `{:ok, _} | {:error, _}` are equivalent representations.","title":"Funx.Monad.Either.result_iso/0","ref":"Funx.Monad.Either.html#result_iso/0"},{"type":"function","doc":"iex> iso = Funx.Monad.Either.result_iso()\n    iex> Funx.Optics.Iso.view({:ok, 42}, iso)\n    %Funx.Monad.Either.Right{right: 42}\n    iex> Funx.Optics.Iso.review(%Funx.Monad.Either.Left{left: \"err\"}, iso)\n    {:error, \"err\"}","title":"Examples - Funx.Monad.Either.result_iso/0","ref":"Funx.Monad.Either.html#result_iso/0-examples"},{"type":"function","doc":"Wraps a value in the `Right` monad.","title":"Funx.Monad.Either.right/1","ref":"Funx.Monad.Either.html#right/1"},{"type":"function","doc":"iex> Funx.Monad.Either.right(5)\n    %Funx.Monad.Either.Right{right: 5}","title":"Examples - Funx.Monad.Either.right/1","ref":"Funx.Monad.Either.html#right/1-examples"},{"type":"function","doc":"Returns `true` if the `Either` is a `Right` value.","title":"Funx.Monad.Either.right?/1","ref":"Funx.Monad.Either.html#right?/1"},{"type":"function","doc":"iex> Funx.Monad.Either.right?(Funx.Monad.Either.right(5))\n    true\n\n    iex> Funx.Monad.Either.right?(Funx.Monad.Either.left(\"error\"))\n    false","title":"Examples - Funx.Monad.Either.right?/1","ref":"Funx.Monad.Either.html#right?/1-examples"},{"type":"function","doc":"Sequences a list of `Either` values into an `Either` of a list.","title":"Funx.Monad.Either.sequence/1","ref":"Funx.Monad.Either.html#sequence/1"},{"type":"function","doc":"iex> Funx.Monad.Either.sequence([Funx.Monad.Either.right(1), Funx.Monad.Either.right(2)])\n    %Funx.Monad.Either.Right{right: [1, 2]}\n\n    iex> Funx.Monad.Either.sequence([Funx.Monad.Either.right(1), Funx.Monad.Either.left(\"error\")])\n    %Funx.Monad.Either.Left{left: \"error\"}","title":"Examples - Funx.Monad.Either.sequence/1","ref":"Funx.Monad.Either.html#sequence/1-examples"},{"type":"function","doc":"Sequences a list of `Either` values, collecting all errors from `Left` values, rather than short-circuiting.","title":"Funx.Monad.Either.sequence_a/1","ref":"Funx.Monad.Either.html#sequence_a/1"},{"type":"function","doc":"iex> Funx.Monad.Either.sequence_a([Funx.Monad.Either.right(1), Funx.Monad.Either.left(\"error\"), Funx.Monad.Either.left(\"another error\")])\n    %Funx.Monad.Either.Left{left: [\"error\", \"another error\"]}","title":"Examples - Funx.Monad.Either.sequence_a/1","ref":"Funx.Monad.Either.html#sequence_a/1-examples"},{"type":"function","doc":"Converts an `Either` to a result (`{:ok, value}` or `{:error, reason}`).\n\nImplemented via the `Either <-> result tuple` isomorphism.","title":"Funx.Monad.Either.to_result/1","ref":"Funx.Monad.Either.html#to_result/1"},{"type":"function","doc":"iex> Funx.Monad.Either.to_result(Funx.Monad.Either.right(5))\n    {:ok, 5}\n\n    iex> Funx.Monad.Either.to_result(Funx.Monad.Either.left(\"error\"))\n    {:error, \"error\"}","title":"Examples - Funx.Monad.Either.to_result/1","ref":"Funx.Monad.Either.html#to_result/1-examples"},{"type":"function","doc":"Converts an `Either` to its inner value, raising an exception if it is `Left`.\n\nIf the `Left` holds an exception struct, it is raised directly. If it holds a string or list of errors, they are converted into a `RuntimeError`. Unexpected types are inspected and raised as a `RuntimeError`.","title":"Funx.Monad.Either.to_try!/1","ref":"Funx.Monad.Either.html#to_try!/1"},{"type":"function","doc":"iex> Funx.Monad.Either.to_try!(Funx.Monad.Either.right(5))\n    5\n\n    iex> Funx.Monad.Either.to_try!(Funx.Monad.Either.left(\"error\"))\n    ** (RuntimeError) error\n\n    iex> Funx.Monad.Either.to_try!(Funx.Monad.Either.left([\"error 1\", \"error 2\"]))\n    ** (RuntimeError) error 1, error 2\n\n    iex> Funx.Monad.Either.to_try!(Funx.Monad.Either.left(%ArgumentError{message: \"bad argument\"}))\n    ** (ArgumentError) bad argument","title":"Examples - Funx.Monad.Either.to_try!/1","ref":"Funx.Monad.Either.html#to_try!/1-examples"},{"type":"function","doc":"Traverses a list, applying the given function to each element and collecting the results in a single `Right`, or short-circuiting with the first `Left`.\n\nThis is useful for validating or transforming a list of values where each step may fail.","title":"Funx.Monad.Either.traverse/2","ref":"Funx.Monad.Either.html#traverse/2"},{"type":"function","doc":"iex> Funx.Monad.Either.traverse([1, 2, 3], &Funx.Monad.Either.right/1)\n    %Funx.Monad.Either.Right{right: [1, 2, 3]}\n\n    iex> Funx.Monad.Either.traverse([1, -2, 3], fn x -> if x > 0, do: Funx.Monad.Either.right(x), else: Funx.Monad.Either.left(\"error\") end)\n    %Funx.Monad.Either.Left{left: \"error\"}","title":"Examples - Funx.Monad.Either.traverse/2","ref":"Funx.Monad.Either.html#traverse/2-examples"},{"type":"function","doc":"Traverses a list, applying the given function to each element and collecting the results in a single `Right`.\n\nUnlike `traverse/2`, this version accumulates all `Left` values rather than stopping at the first failure.\nIt is useful for validations where you want to gather all errors at once.","title":"Funx.Monad.Either.traverse_a/2","ref":"Funx.Monad.Either.html#traverse_a/2"},{"type":"function","doc":"iex> validate = fn x -> Funx.Monad.Either.lift_predicate(x, &(&1 > 0), fn v -> \"must be positive: #{v}\" end) end\n    iex> Funx.Monad.Either.traverse_a([1, 2, 3], validate)\n    %Funx.Monad.Either.Right{right: [1, 2, 3]}\n    iex> Funx.Monad.Either.traverse_a([1, -2, -3], validate)\n    %Funx.Monad.Either.Left{left: [\"must be positive: -2\", \"must be positive: -3\"]}","title":"Examples - Funx.Monad.Either.traverse_a/2","ref":"Funx.Monad.Either.html#traverse_a/2-examples"},{"type":"function","doc":"Validates a value using a list of validator functions. Each validator returns an `Either.Right` if\nthe check passes, or an `Either.Left` with an error message if it fails. If any validation fails,\nall errors are aggregated and returned in a single `Left`.","title":"Funx.Monad.Either.validate/2","ref":"Funx.Monad.Either.html#validate/2"},{"type":"function","doc":"When using the default aggregation strategy, errors are collected in a plain list:\n\n```elixir\nvalidate_positive = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(&1 > 0), fn v -> \"Value must be positive: \" <> to_string(v) end)\nend\n\nvalidate_even = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(rem(&1, 2) == 0), fn v -> \"Value must be even: \" <> to_string(v) end)\nend\n\nFunx.Monad.Either.validate(4, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Right{right: 4}\n\nFunx.Monad.Either.validate(3, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Left{left: [\"Value must be even: 3\"]}\n\nFunx.Monad.Either.validate(-3, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Left{left: [\"Value must be positive: -3\", \"Value must be even: -3\"]}\n```","title":"Flat list aggregation - Funx.Monad.Either.validate/2","ref":"Funx.Monad.Either.html#validate/2-flat-list-aggregation"},{"type":"function","doc":"You can also use a custom struct to hold errors. This example uses `ValidationError` and a corresponding\n`Funx.Semigroup` implementation to accumulate errors into a single structure:\n\n```elixir\nalias Funx.Errors.ValidationError\n\nvalidate_positive = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(&1 > 0), fn v -> \"Value must be positive: \" <> to_string(v) end)\n  |> Funx.Monad.Either.map_left(&ValidationError.new/1)\nend\n\nvalidate_even = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(rem(&1, 2) == 0), fn v -> \"Value must be even: \" <> to_string(v) end)\n  |> Funx.Monad.Either.map_left(&ValidationError.new/1)\nend\n\nFunx.Monad.Either.validate(-3, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Left{\n#     left: %ValidationError{\n#       errors: [\"Value must be positive: -3\", \"Value must be even: -3\"]\n#     }\n#   }\n```","title":"Structured aggregation with ValidationError - Funx.Monad.Either.validate/2","ref":"Funx.Monad.Either.html#validate/2-structured-aggregation-with-validationerror"},{"type":"function","doc":"Validates a value using validators that accept options and environment.\n\nSupports validators with arity 3: `(value, opts, env) -> Either.t()`.\nAlso supports arity 1 and 2 for backwards compatibility.","title":"Funx.Monad.Either.validate/3","ref":"Funx.Monad.Either.html#validate/3"},{"type":"function","doc":"Either.validate(%{name: \"Alice\"}, validator, env: %{db: conn})","title":"Examples - Funx.Monad.Either.validate/3","ref":"Funx.Monad.Either.html#validate/3-examples"},{"type":"function","doc":"Traverses a list, applying the given function to each element, and collects the successful `Just` results into a single `Right`.\n\nThe given function must return an `Either` of `Maybe`. `Right(Just x)` values are kept; `Right(Nothing)` values are filtered out.\nIf any application returns `Left`, all `Left` values are accumulated.\n\nThis is useful for effectful filtering, where you want to validate or transform elements and conditionally keep them, while still reporting all errors.","title":"Funx.Monad.Either.wither_a/2","ref":"Funx.Monad.Either.html#wither_a/2"},{"type":"function","doc":"iex> filter_positive = fn x ->\n    ...>   Funx.Monad.Either.lift_predicate(x, &is_integer/1, fn v -> \"not an integer: #{inspect(v)}\" end)\n    ...>   |> Funx.Monad.map(fn x -> if x > 0, do: Funx.Monad.Maybe.just(x), else: Funx.Monad.Maybe.nothing() end)\n    ...> end\n    iex> Funx.Monad.Either.wither_a([1, -2, 3], filter_positive)\n    %Funx.Monad.Either.Right{right: [1, 3]}\n    iex> Funx.Monad.Either.wither_a([\"oops\", -2], filter_positive)\n    %Funx.Monad.Either.Left{left: [\"not an integer: \\\"oops\\\"\"]}","title":"Examples - Funx.Monad.Either.wither_a/2","ref":"Funx.Monad.Either.html#wither_a/2-examples"},{"type":"module","doc":"Provides the `either/2` macro for writing declarative pipelines in the Either context.\n\nThe DSL lets you express a sequence of operations that may fail without manually\nthreading values through `bind`, `map`, or `map_left`. Input is lifted into Either\nautomatically, each step runs in order, and the pipeline stops on the first error.","title":"Funx.Monad.Either.Dsl","ref":"Funx.Monad.Either.Dsl.html"},{"type":"module","doc":"- `bind` - for operations that return Either or result tuples\n- `map` - for transformations that return plain values\n- `ap` - for applying a function in an Either to a value in an Either\n- Either functions: `filter_or_else`, `or_else`, `map_left`, `flip`\n- Protocol functions: `tap` (via Funx.Tappable)\n- Validation: `validate` for accumulating multiple errors\n\nThe result format is controlled by the `:as` option (`:either`, `:tuple`, or `:raise`).","title":"Supported Operations - Funx.Monad.Either.Dsl","ref":"Funx.Monad.Either.Dsl.html#module-supported-operations"},{"type":"module","doc":"**Short-Circuit Behavior:** The DSL uses fail-fast semantics. When any step returns\na `Left` value or `{:error, reason}` tuple, the pipeline **stops immediately** and\nreturns that error. Subsequent steps are never executed.\n\nExample:\n\n    iex> defmodule GetUser do\n    ...>   use Funx.Monad.Either\n    ...>   alias Funx.Monad.Either\n    ...>   @behaviour Funx.Monad.Behaviour.Bind\n    ...>   def bind(_value, _opts, _env), do: Either.left(\"not found\")\n    ...> end\n    iex> defmodule CheckPermissions do\n    ...>   use Funx.Monad.Either\n    ...>   alias Funx.Monad.Either\n    ...>   @behaviour Funx.Monad.Behaviour.Bind\n    ...>   def bind(value, _opts, _env), do: Either.right(value)\n    ...> end\n    iex> defmodule FormatUser do\n    ...>   @behaviour Funx.Monad.Behaviour.Map\n    ...>   def map(value, _opts, _env), do: \"formatted: #{value}\"\n    ...> end\n    iex> use Funx.Monad.Either\n    iex> either 123 do\n    ...>   bind GetUser           # Returns Left(\"not found\")\n    ...>   bind CheckPermissions  # Never runs\n    ...>   map FormatUser         # Never runs\n    ...> end\n    %Funx.Monad.Either.Left{left: \"not found\"}\n\n**Exception:** The `validate` operation uses applicative semantics and accumulates\n**all** validation errors before returning:\n\nExample:\n\n    iex> use Funx.Monad.Either\n    iex> positive? = fn x -> if x > 0, do: Funx.Monad.Either.right(x), else: Funx.Monad.Either.left(\"not positive\") end\n    iex> even? = fn x -> if rem(x, 2) == 0, do: Funx.Monad.Either.right(x), else: Funx.Monad.Either.left(\"not even\") end\n    iex> less_than_100? = fn x -> if x < 100, do: Funx.Monad.Either.right(x), else: Funx.Monad.Either.left(\"too large\") end\n    iex> either -5 do\n    ...>   validate [positive?, even?, less_than_100?]\n    ...> end\n    %Funx.Monad.Either.Left{left: [\"not positive\", \"not even\"]}","title":"Error Handling Strategy - Funx.Monad.Either.Dsl","ref":"Funx.Monad.Either.Dsl.html#module-error-handling-strategy"},{"type":"module","doc":"The DSL compiles to direct function calls at **compile time**. There is no runtime\noverhead for the DSL itself - it expands into the same code you would write manually\nwith `bind`, `map`, etc.\n\nExample showing compile-time expansion:\n\n    iex> defmodule ParseInt do\n    ...>   use Funx.Monad.Either\n    ...>   alias Funx.Monad.Either\n    ...>   @behaviour Funx.Monad.Behaviour.Bind\n    ...>   def bind(value, _opts, _env) when is_binary(value) do\n    ...>     case Integer.parse(value) do\n    ...>       {int, \"\"} -> Either.right(int)\n    ...>       _ -> Either.left(\"invalid integer\")\n    ...>     end\n    ...>   end\n    ...> end\n    iex> defmodule Double do\n    ...>   @behaviour Funx.Monad.Behaviour.Map\n    ...>   def map(value, _opts, _env), do: value * 2\n    ...> end\n    iex> use Funx.Monad.Either\n    iex> either \"42\" do\n    ...>   bind ParseInt\n    ...>   map Double\n    ...> end\n    %Funx.Monad.Either.Right{right: 84}\n\nAuto-lifting creates anonymous functions, but these are created at compile time,\nnot runtime. For performance-critical hot paths, you may prefer direct combinator\ncalls, but the difference is typically negligible.","title":"Performance - Funx.Monad.Either.Dsl","ref":"Funx.Monad.Either.Dsl.html#module-performance"},{"type":"module","doc":"Transformers allow post-parse optimization and validation of pipelines:\n\n    either user_id, transformers: [MyCustomTransformer] do\n      bind GetUser\n      map Transform\n    end\n\nTransformers run at compile time and create compile-time dependencies.","title":"Transformers - Funx.Monad.Either.Dsl","ref":"Funx.Monad.Either.Dsl.html#module-transformers"},{"type":"module","doc":"either user_id, as: :tuple do\n      bind Accounts.get_user()\n      bind Policies.ensure_active()\n      map fn user -> %{user: user} end\n    end","title":"Example - Funx.Monad.Either.Dsl","ref":"Funx.Monad.Either.Dsl.html#module-example"},{"type":"module","doc":"The DSL automatically lifts certain function call patterns for convenience:\n\n- `Module.fun()` becomes `&Module.fun/1` (zero-arity qualified calls)\n- `Module.fun(arg)` becomes `fn x -> Module.fun(x, arg) end` (partial application)\n\nThis is particularly useful in validator lists:\n\n    validate [Validator.positive?(), Validator.even?()]\n    # Becomes: validate [&Validator.positive?/1, &Validator.even?/1]\n\nThis module defines the public DSL entry point. The macro expansion details and\ninternal rewrite rules are not part of the public API.","title":"Auto-Lifting of Function Calls - Funx.Monad.Either.Dsl","ref":"Funx.Monad.Either.Dsl.html#module-auto-lifting-of-function-calls"},{"type":"macro","doc":"","title":"Funx.Monad.Either.Dsl.either/2","ref":"Funx.Monad.Either.Dsl.html#either/2"},{"type":"macro","doc":"","title":"Funx.Monad.Either.Dsl.either/3","ref":"Funx.Monad.Either.Dsl.html#either/3"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonad%2Feither%2Fleft.livemd)\n\nRepresents the `Left` variant of the `Either` monad, used to model an error or failure.\n\nThis module implements the following protocols:\n  - `Funx.Eq`: Defines equality checks between `Left` and other `Either` values.\n  - `Funx.Foldable`: Provides `fold_l/3` and `fold_r/3` to handle folding for `Left` values.\n  - `Funx.Monad`: Implements the `bind/2`, `map/2`, and `ap/2` functions for monadic operations.\n  - `Funx.Ord`: Defines ordering logic for `Left` and `Right` values.\n\nThe `Left` monad propagates the wrapped error through operations without executing the success logic.","title":"Funx.Monad.Either.Left","ref":"Funx.Monad.Either.Left.html"},{"type":"type","doc":"","title":"Funx.Monad.Either.Left.t/1","ref":"Funx.Monad.Either.Left.html#t:t/1"},{"type":"function","doc":"Creates a new `Left` value.\n\nThe `pure/1` function wraps a value in the `Left` monad, representing an error or failure.","title":"Funx.Monad.Either.Left.pure/1","ref":"Funx.Monad.Either.Left.html#pure/1"},{"type":"function","doc":"iex> Funx.Monad.Either.Left.pure(\"error\")\n    %Funx.Monad.Either.Left{left: \"error\"}","title":"Examples - Funx.Monad.Either.Left.pure/1","ref":"Funx.Monad.Either.Left.html#pure/1-examples"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonad%2Feither%2Fright.livemd)\n\nRepresents the `Right` variant of the `Either` monad, used to model a success or valid result.\n\nThis module implements the following protocols:\n  - `Funx.Eq`: Defines equality checks between `Right` and other `Either` values.\n  - `Funx.Foldable`: Provides `fold_l/3` and `fold_r/3` to handle folding for `Right` values.\n  - `Funx.Monad`: Implements the `bind/2`, `map/2`, and `ap/2` functions for monadic operations.\n  - `Funx.Ord`: Defines ordering logic for `Right` and `Left` values.\n  - `Funx.Tappable`: Executes side effects on the contained value without modifying it.\n\nThe `Right` monad represents a valid result, and the contained value is propagated through operations.","title":"Funx.Monad.Either.Right","ref":"Funx.Monad.Either.Right.html"},{"type":"type","doc":"","title":"Funx.Monad.Either.Right.t/1","ref":"Funx.Monad.Either.Right.html#t:t/1"},{"type":"function","doc":"Creates a new `Right` value.\n\nThe `pure/1` function wraps a value in the `Right` monad, representing a valid result.","title":"Funx.Monad.Either.Right.pure/1","ref":"Funx.Monad.Either.Right.html#pure/1"},{"type":"function","doc":"iex> Funx.Monad.Either.Right.pure(5)\n    %Funx.Monad.Either.Right{right: 5}","title":"Examples - Funx.Monad.Either.Right.pure/1","ref":"Funx.Monad.Either.Right.html#pure/1-examples"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonad%2Fidentity%2Fidentity.livemd)\n\nThe `Funx.Monad.Identity` module represents the identity monad, where values are simply wrapped in a structure\nand operations are applied directly to those values.","title":"Funx.Monad.Identity","ref":"Funx.Monad.Identity.html"},{"type":"module","doc":"- `pure/1`: Wraps a value in the `Identity` monad.\n  - `extract/1`: Extracts the wrapped value from an `Identity`.","title":"Functions - Funx.Monad.Identity","ref":"Funx.Monad.Identity.html#module-functions"},{"type":"module","doc":"This module implements the following protocols:\n  - `Funx.Monad`: Implements the `bind/2`, `map/2`, and `ap/2` functions for monadic operations.\n  - `Funx.Eq`: Defines equality checks for `Identity` values.\n  - `Funx.Ord`: Defines ordering logic for `Identity` values.\n  - `Funx.Tappable`: Executes side effects on the wrapped value via `Funx.Tappable.tap/2`.\n  - `String.Chars`: Converts an `Identity` value into a string representation.","title":"Protocols - Funx.Monad.Identity","ref":"Funx.Monad.Identity.html#module-protocols"},{"type":"type","doc":"","title":"Funx.Monad.Identity.t/1","ref":"Funx.Monad.Identity.html#t:t/1"},{"type":"function","doc":"Extracts the value from an `Identity`.","title":"Funx.Monad.Identity.extract/1","ref":"Funx.Monad.Identity.html#extract/1"},{"type":"function","doc":"iex> Funx.Monad.Identity.extract(Funx.Monad.Identity.pure(5))\n    5","title":"Examples - Funx.Monad.Identity.extract/1","ref":"Funx.Monad.Identity.html#extract/1-examples"},{"type":"function","doc":"","title":"Funx.Monad.Identity.lift_eq/1","ref":"Funx.Monad.Identity.html#lift_eq/1"},{"type":"function","doc":"","title":"Funx.Monad.Identity.lift_ord/1","ref":"Funx.Monad.Identity.html#lift_ord/1"},{"type":"function","doc":"Creates a new `Identity` value by wrapping a given value.","title":"Funx.Monad.Identity.pure/1","ref":"Funx.Monad.Identity.html#pure/1"},{"type":"function","doc":"iex> Funx.Monad.Identity.pure(5)\n    %Funx.Monad.Identity{value: 5}","title":"Examples - Funx.Monad.Identity.pure/1","ref":"Funx.Monad.Identity.html#pure/1-examples"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonad%2Fmaybe%2Fmaybe.livemd)\n\nThe `Funx.Monad.Maybe` module provides an implementation of the `Maybe` monad, a functional abstraction used to represent optional values in Elixir.\n\nA `Maybe` represents one of two possibilities:\n\n  - `Just(value)`: the presence of a value\n  - `Nothing`: the absence of a value\n\nThis pattern is useful for eliminating `nil` checks and handling missing data explicitly and safely in functional pipelines.","title":"Funx.Monad.Maybe","ref":"Funx.Monad.Maybe.html"},{"type":"module","doc":"- `just/1`: Wraps a value in the `Just` variant.\n  - `nothing/0`: Returns a `Nothing` value.\n  - `pure/1`: Alias for `just/1`.","title":"Constructors - Funx.Monad.Maybe","ref":"Funx.Monad.Maybe.html#module-constructors"},{"type":"module","doc":"- `just?/1`: Returns `true` if the value is a `Just`.\n  - `nothing?/1`: Returns `true` if the value is a `Nothing`.","title":"Refinement - Funx.Monad.Maybe","ref":"Funx.Monad.Maybe.html#module-refinement"},{"type":"module","doc":"- `get_or_else/2`: Returns the value from a `Just`, or a default if `Nothing`.\n  - `or_else/2`: Returns the original `Just`, or invokes a fallback function if `Nothing`.","title":"Fallback and Extraction - Funx.Monad.Maybe","ref":"Funx.Monad.Maybe.html#module-fallback-and-extraction"},{"type":"module","doc":"- `concat/1`: Removes all `Nothing` values and unwraps the `Just` values from a list.\n  - `concat_map/2`: Applies a function and collects only `Just` results.\n  - `sequence/1`: Converts a list of `Maybe` values into a single `Maybe` of list.\n  - `traverse/2`: Applies a function to each element in a list and sequences the results.","title":"List Operations - Funx.Monad.Maybe","ref":"Funx.Monad.Maybe.html#module-list-operations"},{"type":"module","doc":"- `lift_predicate/2`: Converts a value to `Just` if it meets a predicate, otherwise `Nothing`.\n  - `lift_identity/1`: Converts an `Identity` to a `Maybe`.\n  - `lift_either/1`: Converts an `Either` to a `Maybe`.\n  - `lift_eq/1`: Lifts an equality function for use in the `Maybe` context.\n  - `lift_ord/1`: Lifts an ordering function for use in the `Maybe` context.","title":"Lifting - Funx.Monad.Maybe","ref":"Funx.Monad.Maybe.html#module-lifting"},{"type":"module","doc":"- `nil_iso/0`: Returns the isomorphism between `Maybe` and nil values.\n  - `from_nil/1`: Converts `nil` to `Nothing`, otherwise wraps the value in `Just` (via `nil_iso`).\n  - `to_nil/1`: Returns the underlying value or `nil` (via `nil_iso`).\n  - `result_iso/0`: Returns the isomorphism between `Maybe` and result tuples.\n  - `from_result/1`: Converts `{:ok, val}` or `{:error, _}` into a `Maybe` (via `result_iso`).\n  - `to_result/1`: Converts a `Maybe` to a result tuple (via `result_iso`).\n  - `from_try/1`: Runs a function and returns `Just` on success, or `Nothing` if an exception is raised.\n  - `to_try!/2`: Unwraps a `Just`, or raises an error if `Nothing`.","title":"Elixir Interoperability - Funx.Monad.Maybe","ref":"Funx.Monad.Maybe.html#module-elixir-interoperability"},{"type":"module","doc":"The `Just` and `Nothing` structs implement the following protocols, making the `Maybe` abstraction composable and extensible:\n\n  - `Funx.Eq`: Enables equality comparisons between `Maybe` values.\n  - `Funx.Foldable`: Implements `fold_l/3` and `fold_r/3` for reducing over the value or fallback.\n  - `Funx.Filterable`: Supports conditional retention with `filter/2`, `guard/2`, and `filter_map/2`.\n  - `Funx.Monad`: Provides `map/2`, `ap/2`, and `bind/2` for monadic composition.\n  - `Funx.Ord`: Defines ordering behavior between `Just` and `Nothing` values.\n  - `Funx.Tappable`: Executes side effects on `Just` values via `Funx.Tappable.tap/2`, leaving `Nothing` unchanged.\n\nAlthough these implementations are defined per constructor (`Just` and `Nothing`), the behavior is consistent across the `Maybe` abstraction.\n\nThis module helps you represent optional data explicitly, structure conditional logic safely, and eliminate reliance on `nil` in functional pipelines.","title":"Protocols - Funx.Monad.Maybe","ref":"Funx.Monad.Maybe.html#module-protocols"},{"type":"module","doc":"You can use the Maybe DSL for clean monadic composition:\n\n    use Funx.Monad.Maybe\n\n    maybe input do\n      bind ParseInt\n      bind PositiveNumber\n      map Double\n    end","title":"DSL Usage - Funx.Monad.Maybe","ref":"Funx.Monad.Maybe.html#module-dsl-usage"},{"type":"type","doc":"","title":"Funx.Monad.Maybe.t/1","ref":"Funx.Monad.Maybe.html#t:t/1"},{"type":"function","doc":"Removes `Nothing` values from a list of `Maybe` and returns a list of unwrapped `Just` values.","title":"Funx.Monad.Maybe.concat/1","ref":"Funx.Monad.Maybe.html#concat/1"},{"type":"function","doc":"iex> Funx.Monad.Maybe.concat([Funx.Monad.Maybe.pure(1), Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.pure(2)])\n    [1, 2]\n\n    iex> Funx.Monad.Maybe.concat([Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.nothing()])\n    []\n\n    iex> Funx.Monad.Maybe.concat([Funx.Monad.Maybe.pure(\"a\"), Funx.Monad.Maybe.pure(\"b\"), Funx.Monad.Maybe.pure(\"c\")])\n    [\"a\", \"b\", \"c\"]","title":"Examples - Funx.Monad.Maybe.concat/1","ref":"Funx.Monad.Maybe.html#concat/1-examples"},{"type":"function","doc":"Maps a function over a list, collecting unwrapped `Just` values and ignoring `Nothing` in a single pass.","title":"Funx.Monad.Maybe.concat_map/2","ref":"Funx.Monad.Maybe.html#concat_map/2"},{"type":"function","doc":"iex> Funx.Monad.Maybe.concat_map([1, 2, 3, 4], fn x ->\n    ...>   if rem(x, 2) == 0, do: Funx.Monad.Maybe.pure(x), else: Funx.Monad.Maybe.nothing()\n    ...> end)\n    [2, 4]\n\n    iex> Funx.Monad.Maybe.concat_map([1, nil, 3], fn\n    ...>   nil -> Funx.Monad.Maybe.nothing()\n    ...>   x -> Funx.Monad.Maybe.pure(x * 2)\n    ...> end)\n    [2, 6]\n\n    iex> Funx.Monad.Maybe.concat_map([1, 2, 3], fn x -> Funx.Monad.Maybe.pure(x + 1) end)\n    [2, 3, 4]\n\n    iex> Funx.Monad.Maybe.concat_map([], fn x -> Funx.Monad.Maybe.pure(x) end)\n    []","title":"Examples - Funx.Monad.Maybe.concat_map/2","ref":"Funx.Monad.Maybe.html#concat_map/2-examples"},{"type":"function","doc":"Converts `nil` to `Nothing`; any other value becomes `Just`.\n\nImplemented via the `Maybe <-> nil` isomorphism.","title":"Funx.Monad.Maybe.from_nil/1","ref":"Funx.Monad.Maybe.html#from_nil/1"},{"type":"function","doc":"iex> Funx.Monad.Maybe.from_nil(nil)\n    %Funx.Monad.Maybe.Nothing{}\n\n    iex> Funx.Monad.Maybe.from_nil(5)\n    %Funx.Monad.Maybe.Just{value: 5}","title":"Examples - Funx.Monad.Maybe.from_nil/1","ref":"Funx.Monad.Maybe.html#from_nil/1-examples"},{"type":"function","doc":"Converts a result tuple to a `Maybe`. `{:ok, value}` becomes `Just(value)`, while `{:error, _}` becomes `Nothing`.\n\nImplemented via the `Maybe <-> result tuple` isomorphism.","title":"Funx.Monad.Maybe.from_result/1","ref":"Funx.Monad.Maybe.html#from_result/1"},{"type":"function","doc":"iex> Funx.Monad.Maybe.from_result({:ok, 5})\n    %Funx.Monad.Maybe.Just{value: 5}\n\n    iex> Funx.Monad.Maybe.from_result({:error, :something})\n    %Funx.Monad.Maybe.Nothing{}","title":"Examples - Funx.Monad.Maybe.from_result/1","ref":"Funx.Monad.Maybe.html#from_result/1-examples"},{"type":"function","doc":"Executes a function within a `Maybe` context, returning `Nothing` if an exception occurs.","title":"Funx.Monad.Maybe.from_try/1","ref":"Funx.Monad.Maybe.html#from_try/1"},{"type":"function","doc":"iex> Funx.Monad.Maybe.from_try(fn -> 5 end)\n    %Funx.Monad.Maybe.Just{value: 5}\n\n    iex> Funx.Monad.Maybe.from_try(fn -> raise \"error\" end)\n    %Funx.Monad.Maybe.Nothing{}","title":"Examples - Funx.Monad.Maybe.from_try/1","ref":"Funx.Monad.Maybe.html#from_try/1-examples"},{"type":"function","doc":"Retrieves the value from a `Maybe`, returning `default` if `Nothing`.","title":"Funx.Monad.Maybe.get_or_else/2","ref":"Funx.Monad.Maybe.html#get_or_else/2"},{"type":"function","doc":"iex> Funx.Monad.Maybe.get_or_else(Funx.Monad.Maybe.just(5), 0)\n    5\n\n    iex> Funx.Monad.Maybe.get_or_else(Funx.Monad.Maybe.nothing(), 0)\n    0","title":"Examples - Funx.Monad.Maybe.get_or_else/2","ref":"Funx.Monad.Maybe.html#get_or_else/2-examples"},{"type":"function","doc":"Wraps a value in `Just`.","title":"Funx.Monad.Maybe.just/1","ref":"Funx.Monad.Maybe.html#just/1"},{"type":"function","doc":"iex> Funx.Monad.Maybe.just(2)\n    %Funx.Monad.Maybe.Just{value: 2}","title":"Examples - Funx.Monad.Maybe.just/1","ref":"Funx.Monad.Maybe.html#just/1-examples"},{"type":"function","doc":"Returns `true` if the `Maybe` is `Just`, otherwise `false`.","title":"Funx.Monad.Maybe.just?/1","ref":"Funx.Monad.Maybe.html#just?/1"},{"type":"function","doc":"iex> Funx.Monad.Maybe.just?(Funx.Monad.Maybe.just(5))\n    true\n\n    iex> Funx.Monad.Maybe.just?(Funx.Monad.Maybe.nothing())\n    false","title":"Examples - Funx.Monad.Maybe.just?/1","ref":"Funx.Monad.Maybe.html#just?/1-examples"},{"type":"function","doc":"Converts an `Either` to a `Maybe`. `Right` becomes `Just`, and `Left` becomes `Nothing`.","title":"Funx.Monad.Maybe.lift_either/1","ref":"Funx.Monad.Maybe.html#lift_either/1"},{"type":"function","doc":"iex> Funx.Monad.Maybe.lift_either(Funx.Monad.Either.right(5))\n    %Funx.Monad.Maybe.Just{value: 5}\n\n    iex> Funx.Monad.Maybe.lift_either(Funx.Monad.Either.left(\"Error\"))\n    %Funx.Monad.Maybe.Nothing{}","title":"Examples - Funx.Monad.Maybe.lift_either/1","ref":"Funx.Monad.Maybe.html#lift_either/1-examples"},{"type":"function","doc":"Lifts an equality function to compare `Maybe` values:\n  - `Just` vs `Just`: Uses the custom equality function.\n  - `Nothing` vs `Nothing`: Always `true`.\n  - `Just` vs `Nothing` or vice versa: Always `false`.","title":"Funx.Monad.Maybe.lift_eq/1","ref":"Funx.Monad.Maybe.html#lift_eq/1"},{"type":"function","doc":"iex> eq = Funx.Monad.Maybe.lift_eq(%{\n    ...>   eq?: fn x, y -> x == y end,\n    ...>   not_eq?: fn x, y -> x != y end\n    ...> })\n    iex> eq.eq?.(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.just(5))\n    true\n    iex> eq.eq?.(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.just(10))\n    false\n    iex> eq.eq?.(Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.nothing())\n    true\n    iex> eq.eq?.(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.nothing())\n    false","title":"Examples - Funx.Monad.Maybe.lift_eq/1","ref":"Funx.Monad.Maybe.html#lift_eq/1-examples"},{"type":"function","doc":"Converts an `Identity` value into a `Maybe`. If the value is `nil`, returns `Nothing`; otherwise `Just`.","title":"Funx.Monad.Maybe.lift_identity/1","ref":"Funx.Monad.Maybe.html#lift_identity/1"},{"type":"function","doc":"iex> Funx.Monad.Maybe.lift_identity(Funx.Monad.Identity.pure(5))\n    %Funx.Monad.Maybe.Just{value: 5}\n\n    iex> Funx.Monad.Maybe.lift_identity(Funx.Monad.Identity.pure(nil))\n    %Funx.Monad.Maybe.Nothing{}","title":"Examples - Funx.Monad.Maybe.lift_identity/1","ref":"Funx.Monad.Maybe.html#lift_identity/1-examples"},{"type":"function","doc":"Adapts an ordering function to compare `Maybe` values:\n  - `Nothing` is considered less than any `Just`.\n  - Two `Just` values are compared by the provided function.","title":"Funx.Monad.Maybe.lift_ord/1","ref":"Funx.Monad.Maybe.html#lift_ord/1"},{"type":"function","doc":"iex> ord = Funx.Monad.Maybe.lift_ord(%{\n    ...>   lt?: &</2,\n    ...>   le?: &<=/2,\n    ...>   gt?: &>/2,\n    ...>   ge?: &>=/2\n    ...> })\n    iex> ord.lt?.(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(5))\n    true\n    iex> ord.lt?.(Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.just(5))\n    true","title":"Examples - Funx.Monad.Maybe.lift_ord/1","ref":"Funx.Monad.Maybe.html#lift_ord/1-examples"},{"type":"function","doc":"Lifts a value into `Maybe` based on a predicate. If `predicate.(value)` is `true`, returns `Just(value)`; otherwise `Nothing`.","title":"Funx.Monad.Maybe.lift_predicate/2","ref":"Funx.Monad.Maybe.html#lift_predicate/2"},{"type":"function","doc":"iex> Funx.Monad.Maybe.lift_predicate(5, fn x -> x > 3 end)\n    %Funx.Monad.Maybe.Just{value: 5}\n\n    iex> Funx.Monad.Maybe.lift_predicate(2, fn x -> x > 3 end)\n    %Funx.Monad.Maybe.Nothing{}","title":"Examples - Funx.Monad.Maybe.lift_predicate/2","ref":"Funx.Monad.Maybe.html#lift_predicate/2-examples"},{"type":"function","doc":"Returns the isomorphism between Maybe and nil values.\n\nThis iso witnesses that `Maybe` and `nil | value` are equivalent representations.","title":"Funx.Monad.Maybe.nil_iso/0","ref":"Funx.Monad.Maybe.html#nil_iso/0"},{"type":"function","doc":"iex> iso = Funx.Monad.Maybe.nil_iso()\n    iex> Funx.Optics.Iso.view(nil, iso)\n    %Funx.Monad.Maybe.Nothing{}\n    iex> Funx.Optics.Iso.view(42, iso)\n    %Funx.Monad.Maybe.Just{value: 42}\n    iex> Funx.Optics.Iso.review(%Funx.Monad.Maybe.Just{value: 42}, iso)\n    42\n    iex> Funx.Optics.Iso.review(%Funx.Monad.Maybe.Nothing{}, iso)\n    nil","title":"Examples - Funx.Monad.Maybe.nil_iso/0","ref":"Funx.Monad.Maybe.html#nil_iso/0-examples"},{"type":"function","doc":"Returns a `Nothing` value.","title":"Funx.Monad.Maybe.nothing/0","ref":"Funx.Monad.Maybe.html#nothing/0"},{"type":"function","doc":"iex> Funx.Monad.Maybe.nothing()\n    %Funx.Monad.Maybe.Nothing{}","title":"Examples - Funx.Monad.Maybe.nothing/0","ref":"Funx.Monad.Maybe.html#nothing/0-examples"},{"type":"function","doc":"Returns `true` if the `Maybe` is `Nothing`, otherwise `false`.","title":"Funx.Monad.Maybe.nothing?/1","ref":"Funx.Monad.Maybe.html#nothing?/1"},{"type":"function","doc":"iex> Funx.Monad.Maybe.nothing?(Funx.Monad.Maybe.nothing())\n    true\n\n    iex> Funx.Monad.Maybe.nothing?(Funx.Monad.Maybe.just(5))\n    false","title":"Examples - Funx.Monad.Maybe.nothing?/1","ref":"Funx.Monad.Maybe.html#nothing?/1-examples"},{"type":"function","doc":"Returns the current `Just` value or invokes the `fallback_fun` if `Nothing`.","title":"Funx.Monad.Maybe.or_else/2","ref":"Funx.Monad.Maybe.html#or_else/2"},{"type":"function","doc":"iex> Funx.Monad.Maybe.or_else(Funx.Monad.Maybe.nothing(), fn -> Funx.Monad.Maybe.just(42) end)\n    %Funx.Monad.Maybe.Just{value: 42}\n\n    iex> Funx.Monad.Maybe.or_else(Funx.Monad.Maybe.just(10), fn -> Funx.Monad.Maybe.just(42) end)\n    %Funx.Monad.Maybe.Just{value: 10}","title":"Examples - Funx.Monad.Maybe.or_else/2","ref":"Funx.Monad.Maybe.html#or_else/2-examples"},{"type":"function","doc":"Alias for `just/1`.","title":"Funx.Monad.Maybe.pure/1","ref":"Funx.Monad.Maybe.html#pure/1"},{"type":"function","doc":"iex> Funx.Monad.Maybe.pure(5)\n    %Funx.Monad.Maybe.Just{value: 5}","title":"Examples - Funx.Monad.Maybe.pure/1","ref":"Funx.Monad.Maybe.html#pure/1-examples"},{"type":"function","doc":"Returns the isomorphism between Maybe and Elixir result tuples.\n\nThis iso witnesses that `Maybe` and `{:ok, _} | {:error, :nothing}` are equivalent representations.","title":"Funx.Monad.Maybe.result_iso/0","ref":"Funx.Monad.Maybe.html#result_iso/0"},{"type":"function","doc":"iex> iso = Funx.Monad.Maybe.result_iso()\n    iex> Funx.Optics.Iso.view({:ok, 42}, iso)\n    %Funx.Monad.Maybe.Just{value: 42}\n    iex> Funx.Optics.Iso.view({:error, :nothing}, iso)\n    %Funx.Monad.Maybe.Nothing{}\n    iex> Funx.Optics.Iso.review(%Funx.Monad.Maybe.Just{value: 42}, iso)\n    {:ok, 42}\n    iex> Funx.Optics.Iso.review(%Funx.Monad.Maybe.Nothing{}, iso)\n    {:error, :nothing}","title":"Examples - Funx.Monad.Maybe.result_iso/0","ref":"Funx.Monad.Maybe.html#result_iso/0-examples"},{"type":"function","doc":"Converts a list of `Maybe` values into a `Maybe` containing a list. If any element is `Nothing`, the entire result is `Nothing`.","title":"Funx.Monad.Maybe.sequence/1","ref":"Funx.Monad.Maybe.html#sequence/1"},{"type":"function","doc":"iex> Funx.Monad.Maybe.sequence([Funx.Monad.Maybe.just(1), Funx.Monad.Maybe.just(2)])\n    %Funx.Monad.Maybe.Just{value: [1, 2]}\n\n    iex> Funx.Monad.Maybe.sequence([Funx.Monad.Maybe.just(1), Funx.Monad.Maybe.nothing()])\n    %Funx.Monad.Maybe.Nothing{}","title":"Examples - Funx.Monad.Maybe.sequence/1","ref":"Funx.Monad.Maybe.html#sequence/1-examples"},{"type":"function","doc":"Converts a `Maybe` to its wrapped value or `nil`.\n\nImplemented via the `Maybe <-> nil` isomorphism.","title":"Funx.Monad.Maybe.to_nil/1","ref":"Funx.Monad.Maybe.html#to_nil/1"},{"type":"function","doc":"iex> Funx.Monad.Maybe.to_nil(Funx.Monad.Maybe.just(5))\n    5\n\n    iex> Funx.Monad.Maybe.to_nil(Funx.Monad.Maybe.nothing())\n    nil","title":"Examples - Funx.Monad.Maybe.to_nil/1","ref":"Funx.Monad.Maybe.html#to_nil/1-examples"},{"type":"function","doc":"Returns `true` if the given `Maybe` is a `Just`, or `false` if it is `Nothing`.\n\nThis provides a simple way to treat a `Maybe` as a boolean condition, useful when filtering or making branching decisions based on presence.","title":"Funx.Monad.Maybe.to_predicate/1","ref":"Funx.Monad.Maybe.html#to_predicate/1"},{"type":"function","doc":"iex> Funx.Monad.Maybe.to_predicate(Funx.Monad.Maybe.just(42))\n    true\n\n    iex> Funx.Monad.Maybe.to_predicate(Funx.Monad.Maybe.nothing())\n    false\n\nRaises an error if the input is not a `Just` or `Nothing`.","title":"Examples - Funx.Monad.Maybe.to_predicate/1","ref":"Funx.Monad.Maybe.html#to_predicate/1-examples"},{"type":"function","doc":"Converts a `Maybe` to a result tuple. `Just(value)` becomes `{:ok, value}`, while `Nothing` becomes `{:error, :nothing}`.\n\nImplemented via the `Maybe <-> result tuple` isomorphism.","title":"Funx.Monad.Maybe.to_result/1","ref":"Funx.Monad.Maybe.html#to_result/1"},{"type":"function","doc":"iex> Funx.Monad.Maybe.to_result(Funx.Monad.Maybe.just(5))\n    {:ok, 5}\n\n    iex> Funx.Monad.Maybe.to_result(Funx.Monad.Maybe.nothing())\n    {:error, :nothing}","title":"Examples - Funx.Monad.Maybe.to_result/1","ref":"Funx.Monad.Maybe.html#to_result/1-examples"},{"type":"function","doc":"Extracts a value from a `Maybe`, raising an exception if `Nothing`.\n\nThe second parameter can be:\n- A string message (raises `RuntimeError`)\n- An exception module (e.g., `Enum.EmptyError`)\n- An exception struct (e.g., `%ArgumentError{message: \"custom\"}`)","title":"Funx.Monad.Maybe.to_try!/2","ref":"Funx.Monad.Maybe.html#to_try!/2"},{"type":"function","doc":"iex> Funx.Monad.Maybe.to_try!(Funx.Monad.Maybe.just(5))\n    5\n\n    iex> Funx.Monad.Maybe.to_try!(Funx.Monad.Maybe.nothing(), \"No value found\")\n    ** (RuntimeError) No value found\n\n    iex> Funx.Monad.Maybe.to_try!(Funx.Monad.Maybe.nothing(), Enum.EmptyError)\n    ** (Enum.EmptyError) empty error\n\n    iex> Funx.Monad.Maybe.to_try!(Funx.Monad.Maybe.nothing(), %ArgumentError{message: \"missing value\"})\n    ** (ArgumentError) missing value","title":"Examples - Funx.Monad.Maybe.to_try!/2","ref":"Funx.Monad.Maybe.html#to_try!/2-examples"},{"type":"function","doc":"Applies a function to each element of a list, collecting results into a single `Maybe`. If any call returns `Nothing`, the operation halts and returns `Nothing`.","title":"Funx.Monad.Maybe.traverse/2","ref":"Funx.Monad.Maybe.html#traverse/2"},{"type":"function","doc":"iex> Funx.Monad.Maybe.traverse([1, 2], fn x -> Funx.Monad.Maybe.just(x * 2) end)\n    %Funx.Monad.Maybe.Just{value: [2, 4]}\n\n    iex> Funx.Monad.Maybe.traverse([1, nil, 3], fn\n    ...>   nil -> Funx.Monad.Maybe.nothing()\n    ...>   x -> Funx.Monad.Maybe.just(x * 2)\n    ...> end)\n    %Funx.Monad.Maybe.Nothing{}","title":"Examples - Funx.Monad.Maybe.traverse/2","ref":"Funx.Monad.Maybe.html#traverse/2-examples"},{"type":"module","doc":"Provides the `maybe/2` macro for writing declarative pipelines in the Maybe context.\n\nThe DSL lets you express a sequence of operations that may return nothing without manually\nthreading values through `bind`, `map`, or `filter`. Input is lifted into Maybe\nautomatically, each step runs in order, and the pipeline stops on the first Nothing.","title":"Funx.Monad.Maybe.Dsl","ref":"Funx.Monad.Maybe.Dsl.html"},{"type":"module","doc":"- `bind` - for operations that return Maybe, Either, result tuples, or nil\n- `map` - for transformations that return plain values\n- `ap` - for applying a function in a Maybe to a value in a Maybe\n- Maybe functions: `or_else`\n- Protocol functions: `tap` (via Funx.Tappable), `filter`, `filter_map`, `guard` (via Funx.Filterable)\n\nThe result format is controlled by the `:as` option (`:maybe`, `:raise`, or `:nil`).","title":"Supported Operations - Funx.Monad.Maybe.Dsl","ref":"Funx.Monad.Maybe.Dsl.html#module-supported-operations"},{"type":"module","doc":"The DSL uses fail-fast semantics. When any step returns a `Nothing` value, `Either.Left`, `{:error, _}` tuple, or `nil`,\nthe pipeline **stops immediately** and returns `Nothing`. Subsequent steps are never executed.\n\nExample:\n\n    iex> defmodule GetUser do\n    ...>   use Funx.Monad.Maybe\n    ...>   @behaviour Funx.Monad.Behaviour.Bind\n    ...>   def bind(_value, _opts, _env), do: nothing()\n    ...> end\n    iex> defmodule CheckPermissions do\n    ...>   use Funx.Monad.Maybe\n    ...>   @behaviour Funx.Monad.Behaviour.Bind\n    ...>   def bind(value, _opts, _env), do: just(value)\n    ...> end\n    iex> defmodule FormatUser do\n    ...>   @behaviour Funx.Monad.Behaviour.Map\n    ...>   def map(value, _opts, _env), do: \"formatted: #{value}\"\n    ...> end\n    iex> use Funx.Monad.Maybe\n    iex> maybe 123 do\n    ...>   bind GetUser           # Returns Nothing\n    ...>   bind CheckPermissions  # Never runs\n    ...>   map FormatUser         # Never runs\n    ...> end\n    %Funx.Monad.Maybe.Nothing{}","title":"Short-Circuit Behavior - Funx.Monad.Maybe.Dsl","ref":"Funx.Monad.Maybe.Dsl.html#module-short-circuit-behavior"},{"type":"module","doc":"The DSL compiles to direct function calls at **compile time**. There is no runtime\noverhead for the DSL itself - it expands into the same code you would write manually\nwith `bind`, `map`, etc.\n\nExample showing compile-time expansion:\n\n    iex> defmodule ParseInt do\n    ...>   use Funx.Monad.Maybe\n    ...>   @behaviour Funx.Monad.Behaviour.Bind\n    ...>   def bind(value, _opts, _env) when is_binary(value) do\n    ...>     case Integer.parse(value) do\n    ...>       {int, \"\"} -> just(int)\n    ...>       _ -> nothing()\n    ...>     end\n    ...>   end\n    ...> end\n    iex> defmodule Double do\n    ...>   @behaviour Funx.Monad.Behaviour.Map\n    ...>   def map(value, _opts, _env), do: value * 2\n    ...> end\n    iex> use Funx.Monad.Maybe\n    iex> maybe \"42\" do\n    ...>   bind ParseInt\n    ...>   map Double\n    ...> end\n    %Funx.Monad.Maybe.Just{value: 84}\n\nAuto-lifting creates anonymous functions, but these are created at compile time,\nnot runtime. For performance-critical hot paths, you may prefer direct combinator\ncalls, but the difference is typically negligible.","title":"Performance - Funx.Monad.Maybe.Dsl","ref":"Funx.Monad.Maybe.Dsl.html#module-performance"},{"type":"module","doc":"Transformers allow post-parse optimization and validation of pipelines:\n\n    maybe user_id, transformers: [MyCustomTransformer] do\n      bind GetUser\n      map Transform\n    end\n\nTransformers run at compile time and create compile-time dependencies.","title":"Transformers - Funx.Monad.Maybe.Dsl","ref":"Funx.Monad.Maybe.Dsl.html#module-transformers"},{"type":"module","doc":"maybe user_id, as: :nil do\n      bind Accounts.get_user()\n      bind Policies.ensure_active()\n      map fn user -> %{user: user} end\n    end","title":"Example - Funx.Monad.Maybe.Dsl","ref":"Funx.Monad.Maybe.Dsl.html#module-example"},{"type":"module","doc":"The DSL automatically lifts certain function call patterns for convenience:\n\n- `Module.fun()` becomes `&Module.fun/1` (zero-arity qualified calls)\n- `Module.fun(arg)` becomes `fn x -> Module.fun(x, arg) end` (partial application)\n\nThis is particularly useful in filter operations:\n\n    filter &Validator.positive?/1\n\nThis module defines the public DSL entry point. The macro expansion details and\ninternal rewrite rules are not part of the public API.","title":"Auto-Lifting of Function Calls - Funx.Monad.Maybe.Dsl","ref":"Funx.Monad.Maybe.Dsl.html#module-auto-lifting-of-function-calls"},{"type":"macro","doc":"","title":"Funx.Monad.Maybe.Dsl.maybe/2","ref":"Funx.Monad.Maybe.Dsl.html#maybe/2"},{"type":"macro","doc":"","title":"Funx.Monad.Maybe.Dsl.maybe/3","ref":"Funx.Monad.Maybe.Dsl.html#maybe/3"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonad%2Fmaybe%2Fjust.livemd)\n\nRepresents the `Just` variant of the `Maybe` monad, used to model the presence of a value.\n\nA `Just` wraps a single value and participates in functional composition by propagating the contained value through monadic operations.\n\nThis module implements the following protocols:\n\n  - `Funx.Monad`: Implements `bind/2`, `map/2`, and `ap/2` for monadic composition.\n  - `Funx.Foldable`: Provides `fold_l/3` and `fold_r/3` to fold over the wrapped value.\n  - `Funx.Filterable`: Supports filtering with `filter/2`, `filter_map/2`, and `guard/2`.\n  - `Funx.Eq`: Enables equality checks between `Just` and other `Maybe` values.\n  - `Funx.Ord`: Defines ordering behavior between `Just` and `Nothing`.\n  - `Funx.Tappable`: Executes side effects on the wrapped value via `Funx.Tappable.tap/2`.\n\nThese protocol implementations allow `Just` to participate in structured computation, validation, filtering, and comparison within the `Maybe` context.","title":"Funx.Monad.Maybe.Just","ref":"Funx.Monad.Maybe.Just.html"},{"type":"type","doc":"","title":"Funx.Monad.Maybe.Just.t/1","ref":"Funx.Monad.Maybe.Just.html#t:t/1"},{"type":"function","doc":"Creates a new `Just` value.\n\nThe `pure/1` function wraps a value in the `Just` monad, representing the presence of the value.","title":"Funx.Monad.Maybe.Just.pure/1","ref":"Funx.Monad.Maybe.Just.html#pure/1"},{"type":"function","doc":"iex> Funx.Monad.Maybe.Just.pure(5)\n    %Funx.Monad.Maybe.Just{value: 5}","title":"Examples - Funx.Monad.Maybe.Just.pure/1","ref":"Funx.Monad.Maybe.Just.html#pure/1-examples"},{"type":"function","doc":"- `ArgumentError` if `nil` is provided.\n\n    iex> Funx.Monad.Maybe.Just.pure(nil)\n    ** (ArgumentError) Cannot wrap nil in a Just","title":"Raises - Funx.Monad.Maybe.Just.pure/1","ref":"Funx.Monad.Maybe.Just.html#pure/1-raises"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonad%2Fmaybe%2Fnothing.livemd)\n\nRepresents the `Nothing` variant of the `Maybe` monad, used to model the absence of a value.\n\nA `Nothing` indicates that no value is present. All operations in the monad context simply propagate the absence, making `Nothing` an identity for failure or emptiness.\n\nThis module implements the following protocols:\n\n  - `Funx.Monad`: Implements `bind/2`, `map/2`, and `ap/2`, all of which return `Nothing`.\n  - `Funx.Foldable`: Provides `fold_l/3` and `fold_r/3`, invoking the fallback function when folding.\n  - `Funx.Filterable`: Supports filtering operations, which always return `Nothing`.\n  - `Funx.Eq`: Enables equality checks between `Nothing` and other `Maybe` values.\n  - `Funx.Ord`: Defines ordering behavior between `Nothing` and `Just`.\n  - `Funx.Tappable`: Returns `Nothing` unchanged without executing the tap function.\n\nThese implementations ensure that `Nothing` behaves consistently in functional composition, filtering, and comparison, treating absence as a stable and composable case.","title":"Funx.Monad.Maybe.Nothing","ref":"Funx.Monad.Maybe.Nothing.html"},{"type":"type","doc":"","title":"Funx.Monad.Maybe.Nothing.t/0","ref":"Funx.Monad.Maybe.Nothing.html#t:t/0"},{"type":"function","doc":"Creates a new `Nothing` value.","title":"Funx.Monad.Maybe.Nothing.pure/0","ref":"Funx.Monad.Maybe.Nothing.html#pure/0"},{"type":"function","doc":"iex> Funx.Monad.Maybe.Nothing.pure()\n    %Funx.Monad.Maybe.Nothing{}","title":"Examples - Funx.Monad.Maybe.Nothing.pure/0","ref":"Funx.Monad.Maybe.Nothing.html#pure/0-examples"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonad%2Freader%2Freader.livemd)\n\nThe `Funx.Monad.Reader` module represents the Reader monad, which allows computations to access\nshared, read-only environment values.\n\nThis module defines core Reader functions:\n\n  * `pure/1` – Lifts a value into the Reader context.\n  * `run/2` – Executes the Reader with a given environment.\n  * `asks/1` – Extracts and transforms a value from the environment.\n  * `ask/0` – Extracts the full environment.\n\nThis module implements the following protocols:\n\n  * `Funx.Monad`: Implements `bind/2`, `map/2`, and `ap/2` for monadic composition.\n  * `Funx.Tappable`: Executes side effects on the computed value via `Funx.Tappable.tap/2`.\n\nNote: The Reader monad does not implement `Eq` or `Ord`, since Readers are lazy— they do not actually contain a value until they are run. We only can compare the results of a Reader, not the Reader itself.","title":"Funx.Monad.Reader","ref":"Funx.Monad.Reader.html"},{"type":"type","doc":"","title":"Funx.Monad.Reader.t/2","ref":"Funx.Monad.Reader.html#t:t/2"},{"type":"function","doc":"Extracts the value contained in the environment, making it available within the Reader context.","title":"Funx.Monad.Reader.ask/0","ref":"Funx.Monad.Reader.html#ask/0"},{"type":"function","doc":"iex> reader = Funx.Monad.Reader.ask()\n    iex> Funx.Monad.Reader.run(reader, %{foo: \"bar\"})\n    %{foo: \"bar\"}","title":"Examples - Funx.Monad.Reader.ask/0","ref":"Funx.Monad.Reader.html#ask/0-examples"},{"type":"function","doc":"Extracts and transforms the value contained in the environment, making it available within the Reader context.","title":"Funx.Monad.Reader.asks/1","ref":"Funx.Monad.Reader.html#asks/1"},{"type":"function","doc":"iex> reader = Funx.Monad.Reader.asks(fn env -> Map.get(env, :foo) end)\n    iex> Funx.Monad.Reader.run(reader, %{foo: \"bar\"})\n    \"bar\"","title":"Examples - Funx.Monad.Reader.asks/1","ref":"Funx.Monad.Reader.html#asks/1-examples"},{"type":"function","doc":"Lifts a value into the `Reader` context.","title":"Funx.Monad.Reader.pure/1","ref":"Funx.Monad.Reader.html#pure/1"},{"type":"function","doc":"iex> reader = Funx.Monad.Reader.pure(42)\n    iex> Funx.Monad.Reader.run(reader, %{})\n    42","title":"Examples - Funx.Monad.Reader.pure/1","ref":"Funx.Monad.Reader.html#pure/1-examples"},{"type":"function","doc":"Runs the `Reader` with the provided environment, returning the computed value.","title":"Funx.Monad.Reader.run/2","ref":"Funx.Monad.Reader.html#run/2"},{"type":"function","doc":"iex> reader = Funx.Monad.Reader.pure(42)\n    iex> Funx.Monad.Reader.run(reader, %{})\n    42","title":"Examples - Funx.Monad.Reader.run/2","ref":"Funx.Monad.Reader.html#run/2-examples"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonad%2Fwriter%2Fwriter.livemd)\n\nThe `Funx.Monad.Writer` module defines the Writer monad, which threads a log alongside a computed result.\n\nLogs are accumulated using a `Monoid` implementation, injected lazily at runtime. This makes the Writer monad flexible and monoid-polymorphic—supporting lists, strings, or any user-defined monoid.","title":"Funx.Monad.Writer","ref":"Funx.Monad.Writer.html"},{"type":"module","doc":"* `pure/1` – Wraps a result with an empty log.\n  * `writer/1` – Wraps a result and an explicit log.\n  * `tell/1` – Emits a log with no result.\n  * `listen/1` – Returns both result and log as a pair.\n  * `censor/2` – Applies a function to transform the final log.\n  * `pass/1` – Uses a log-transforming function returned from within the computation.\n  * `run/2` – Executes the Writer and returns a `%Writer.Result{}` with result and log.\n  * `eval/2` – Executes and returns only the result.\n  * `exec/2` – Executes and returns only the log.\n\nBy default, the `ListConcat` monoid is used unless a different monoid is passed to `run`, `eval`, or `exec`.\n\nThis module implements the following protocols:\n\n  * `Funx.Monad`: Implements `bind/2`, `map/2`, and `ap/2` for monadic composition.\n  * `Funx.Tappable`: Executes side effects on the computed value via `Funx.Tappable.tap/2`.","title":"Core functions - Funx.Monad.Writer","ref":"Funx.Monad.Writer.html#module-core-functions"},{"type":"type","doc":"Represents a computation that produces a result along with a log,\naccumulated using a monoid.\n\nThe internal `writer` function takes an initial monoid and returns\na `{value, monoid}` tuple, where the monoid contains the accumulated log.","title":"Funx.Monad.Writer.t/1","ref":"Funx.Monad.Writer.html#t:t/1"},{"type":"function","doc":"Transforms the final log by applying a function to it.\n\nThe result remains unchanged—only the log is modified.","title":"Funx.Monad.Writer.censor/2","ref":"Funx.Monad.Writer.html#censor/2"},{"type":"function","doc":"iex> writer = Funx.Monad.Writer.writer({\"ok\", [:a, :b]})\n    iex> censored = Funx.Monad.Writer.censor(writer, fn log -> Enum.reverse(log) end)\n    iex> result = Funx.Monad.Writer.run(censored)\n    iex> result.value\n    \"ok\"\n    iex> result.log\n    [:b, :a]","title":"Example - Funx.Monad.Writer.censor/2","ref":"Funx.Monad.Writer.html#censor/2-example"},{"type":"function","doc":"Executes the Writer and returns only the final result value.\n\nUses `ListConcat` by default.","title":"Funx.Monad.Writer.eval/2","ref":"Funx.Monad.Writer.html#eval/2"},{"type":"function","doc":"iex> writer =\n    ...>   Funx.Monad.Writer.writer({10, [:init]})\n    ...>   |> Funx.Monad.bind(fn x ->\n    ...>     Funx.Monad.Writer.tell([:logged])\n    ...>     |> Funx.Monad.bind(fn _ -> Funx.Monad.Writer.pure(x * 2) end)\n    ...>   end)\n    iex> Funx.Monad.Writer.eval(writer)\n    20","title":"Example - Funx.Monad.Writer.eval/2","ref":"Funx.Monad.Writer.html#eval/2-example"},{"type":"function","doc":"Executes the Writer and returns only the final accumulated log.\n\nUses `ListConcat` by default.","title":"Funx.Monad.Writer.exec/2","ref":"Funx.Monad.Writer.html#exec/2"},{"type":"function","doc":"iex> writer =\n    ...>   Funx.Monad.Writer.writer({:ok, [:step1]})\n    ...>   |> Funx.Monad.bind(fn _ -> Funx.Monad.Writer.tell([:step2]) end)\n    iex> Funx.Monad.Writer.exec(writer)\n    [:step1, :step2]","title":"Example - Funx.Monad.Writer.exec/2","ref":"Funx.Monad.Writer.html#exec/2-example"},{"type":"function","doc":"Captures the current log and returns it alongside the result.\n\nThe log remains unchanged—only the result is modified to include it.","title":"Funx.Monad.Writer.listen/1","ref":"Funx.Monad.Writer.html#listen/1"},{"type":"function","doc":"iex> writer = Funx.Monad.Writer.writer({\"done\", [:start, :finish]})\n    iex> listened = Funx.Monad.Writer.listen(writer)\n    iex> result = Funx.Monad.Writer.run(listened)\n    iex> result.value\n    {\"done\", [:start, :finish]}\n    iex> result.log\n    [:start, :finish]","title":"Example - Funx.Monad.Writer.listen/1","ref":"Funx.Monad.Writer.html#listen/1-example"},{"type":"function","doc":"Applies a log-transforming function that is returned from within the computation.\n\nThis allows the result of a computation to include not only a value, but also\na function that modifies the final accumulated log.\n\nThe input to `pass/1` must be a Writer containing a tuple `{result, f}`, where\n`f` is a function from log to log. This function will be applied to the final log\njust before it's returned.","title":"Funx.Monad.Writer.pass/1","ref":"Funx.Monad.Writer.html#pass/1"},{"type":"function","doc":"iex> result =\n    ...>   Funx.Monad.Writer.pure({\"done\", fn log -> log ++ [:transformed] end})\n    ...>   |> Funx.Monad.Writer.pass()\n    ...>   |> Funx.Monad.Writer.run()\n    iex> result.value\n    \"done\"\n    iex> result.log\n    [:transformed]","title":"Example - Funx.Monad.Writer.pass/1","ref":"Funx.Monad.Writer.html#pass/1-example"},{"type":"function","doc":"Wraps a value with no log.","title":"Funx.Monad.Writer.pure/1","ref":"Funx.Monad.Writer.html#pure/1"},{"type":"function","doc":"iex> writer = Funx.Monad.Writer.pure(42)\n    iex> result = Funx.Monad.Writer.run(writer)\n    iex> result.value\n    42\n    iex> result.log\n    []","title":"Example - Funx.Monad.Writer.pure/1","ref":"Funx.Monad.Writer.html#pure/1-example"},{"type":"function","doc":"Executes the Writer and returns both the result and the final accumulated log.\n\nBy default, it uses `ListConcat` unless a monoid is explicitly passed.","title":"Funx.Monad.Writer.run/2","ref":"Funx.Monad.Writer.html#run/2"},{"type":"function","doc":"iex> writer = Funx.Monad.Writer.writer({\"ok\", [:a, :b]})\n    iex> result = Funx.Monad.Writer.run(writer)\n    iex> result.value\n    \"ok\"\n    iex> result.log\n    [:a, :b]","title":"Example - Funx.Monad.Writer.run/2","ref":"Funx.Monad.Writer.html#run/2-example"},{"type":"function","doc":"Appends a log value using the monoid, returning `:ok` as the result.","title":"Funx.Monad.Writer.tell/1","ref":"Funx.Monad.Writer.html#tell/1"},{"type":"function","doc":"iex> writer = Funx.Monad.Writer.tell([:event])\n    iex> result = Funx.Monad.Writer.run(writer)\n    iex> result.value\n    :ok\n    iex> result.log\n    [:event]","title":"Example - Funx.Monad.Writer.tell/1","ref":"Funx.Monad.Writer.html#tell/1-example"},{"type":"function","doc":"Wraps both a value and a raw log into the Writer context.","title":"Funx.Monad.Writer.writer/1","ref":"Funx.Monad.Writer.html#writer/1"},{"type":"function","doc":"iex> writer = Funx.Monad.Writer.writer({:ok, [:step1, :step2]})\n    iex> result = Funx.Monad.Writer.run(writer)\n    iex> result.value\n    :ok\n    iex> result.log\n    [:step1, :step2]","title":"Example - Funx.Monad.Writer.writer/1","ref":"Funx.Monad.Writer.html#writer/1-example"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonad%2Fwriter%2Fresult.livemd)\n\nRepresents the result of running a Writer computation:\nthe final value and the accumulated monoid.","title":"Funx.Monad.Writer.Result","ref":"Funx.Monad.Writer.Result.html"},{"type":"type","doc":"","title":"Funx.Monad.Writer.Result.t/2","ref":"Funx.Monad.Writer.Result.html#t:t/2"},{"type":"protocol","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonoid%2Fmonoid.livemd)\n\nA protocol defining the Monoid algebraic structure, which consists of\nan identity element and an associative binary operation for combining values.\n\nThis protocol provides four key functions:\n\n- `empty/1`: Returns the identity element for the given monoid.\n- `append/2`: Combines two monoid structs.\n- `wrap/2`: Wraps a value into the monoid struct.\n- `unwrap/1`: Extracts the underlying value from the monoid struct.","title":"Funx.Monoid","ref":"Funx.Monoid.html"},{"type":"type","doc":"All the types that implement this protocol.","title":"Funx.Monoid.t/0","ref":"Funx.Monoid.html#t:t/0"},{"type":"function","doc":"Combines two monoid structs.\n\nThe operation must satisfy associativity:\n\n    append(append(a, b), c) == append(a, append(b, c))","title":"Funx.Monoid.append/2","ref":"Funx.Monoid.html#append/2"},{"type":"function","doc":"iex> Funx.Monoid.append(%Funx.Monoid.Sum{value: 1}, %Funx.Monoid.Sum{value: 2})\n    %Funx.Monoid.Sum{value: 3}","title":"Examples - Funx.Monoid.append/2","ref":"Funx.Monoid.html#append/2-examples"},{"type":"function","doc":"Returns the identity element for the given monoid struct.\n\nThe identity element is a special value that satisfies the property:\n\n    append(empty(monoid_struct), x) == x\n    append(x, empty(monoid_struct)) == x","title":"Funx.Monoid.empty/1","ref":"Funx.Monoid.html#empty/1"},{"type":"function","doc":"iex> Funx.Monoid.empty(%Funx.Monoid.Sum{})\n    %Funx.Monoid.Sum{value: 0}","title":"Examples - Funx.Monoid.empty/1","ref":"Funx.Monoid.html#empty/1-examples"},{"type":"function","doc":"Extracts the underlying value from the monoid struct.","title":"Funx.Monoid.unwrap/1","ref":"Funx.Monoid.html#unwrap/1"},{"type":"function","doc":"iex> Funx.Monoid.unwrap(%Funx.Monoid.Sum{value: 10})\n    10","title":"Examples - Funx.Monoid.unwrap/1","ref":"Funx.Monoid.html#unwrap/1-examples"},{"type":"function","doc":"Wraps a value into the given monoid struct.","title":"Funx.Monoid.wrap/2","ref":"Funx.Monoid.html#wrap/2"},{"type":"function","doc":"iex> Funx.Monoid.wrap(%Funx.Monoid.Sum{}, 10)\n    %Funx.Monoid.Sum{value: 10}","title":"Examples - Funx.Monoid.wrap/2","ref":"Funx.Monoid.html#wrap/2-examples"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonoid%2Feq_all.livemd)\n\nA Monoid implementation for equality checks for All.","title":"Funx.Monoid.Eq.All","ref":"Funx.Monoid.Eq.All.html"},{"type":"type","doc":"","title":"Funx.Monoid.Eq.All.t/0","ref":"Funx.Monoid.Eq.All.html#t:t/0"},{"type":"function","doc":"","title":"Funx.Monoid.Eq.All.default_eq?/2","ref":"Funx.Monoid.Eq.All.html#default_eq?/2"},{"type":"function","doc":"","title":"Funx.Monoid.Eq.All.default_not_eq?/2","ref":"Funx.Monoid.Eq.All.html#default_not_eq?/2"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonoid%2Feq_any.livemd)\n\nA Monoid implementation for equality checks for Any.","title":"Funx.Monoid.Eq.Any","ref":"Funx.Monoid.Eq.Any.html"},{"type":"type","doc":"","title":"Funx.Monoid.Eq.Any.t/0","ref":"Funx.Monoid.Eq.Any.html#t:t/0"},{"type":"function","doc":"","title":"Funx.Monoid.Eq.Any.default_eq?/2","ref":"Funx.Monoid.Eq.Any.html#default_eq?/2"},{"type":"function","doc":"","title":"Funx.Monoid.Eq.Any.default_not_eq?/2","ref":"Funx.Monoid.Eq.Any.html#default_not_eq?/2"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonoid%2Flist_concat.livemd)\n\nA Monoid implementation for concatenating lists.\n\nThis monoid uses list concatenation as its associative operation\nand `[]` as the identity element.","title":"Funx.Monoid.ListConcat","ref":"Funx.Monoid.ListConcat.html"},{"type":"type","doc":"","title":"Funx.Monoid.ListConcat.t/0","ref":"Funx.Monoid.ListConcat.html#t:t/0"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonoid%2Fmax.livemd)\n\nA Monoid implementation for maximum values.","title":"Funx.Monoid.Max","ref":"Funx.Monoid.Max.html"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonoid%2Fmin.livemd)\n\nA Monoid implementation for minimum values.","title":"Funx.Monoid.Min","ref":"Funx.Monoid.Min.html"},{"type":"module","doc":"The `Funx.Monoid.Optics.IsoCompose` module provides a monoid wrapper for sequential iso composition.\n\nThis wrapper allows isos to be used with generic monoid operations like `m_concat/2` and `m_append/3`,\nenabling functional composition of multiple isos into a single bidirectional transformation.","title":"Funx.Monoid.Optics.IsoCompose","ref":"Funx.Monoid.Optics.IsoCompose.html"},{"type":"module","doc":"- `new/1`: Wraps an iso in an `IsoCompose` monoid.\n  - `unwrap/1`: Extracts the iso from an `IsoCompose` wrapper.","title":"Wrapping and Unwrapping - Funx.Monoid.Optics.IsoCompose","ref":"Funx.Monoid.Optics.IsoCompose.html#module-wrapping-and-unwrapping"},{"type":"module","doc":"- `empty/1`: Returns the identity iso (both directions are identity).\n  - `append/2`: Composes two isos sequentially.\n  - `wrap/2`: Wraps an iso value into the monoid.","title":"Monoid Operations (via protocol) - Funx.Monoid.Optics.IsoCompose","ref":"Funx.Monoid.Optics.IsoCompose.html#module-monoid-operations-via-protocol"},{"type":"module","doc":"iex> alias Funx.Monoid.Optics.IsoCompose\n    iex> alias Funx.Optics.Iso\n    iex> isos = [\n    ...>   Iso.make(\n    ...>     fn s -> String.to_integer(s) end,\n    ...>     fn i -> Integer.to_string(i) end\n    ...>   ),\n    ...>   Iso.make(\n    ...>     fn i -> i * 2 end,\n    ...>     fn i -> div(i, 2) end\n    ...>   )\n    ...> ]\n    iex> composed = Funx.Monoid.Utils.m_concat(%IsoCompose{}, isos)\n    iex> Iso.view(\"21\", composed)\n    42","title":"Examples - Funx.Monoid.Optics.IsoCompose","ref":"Funx.Monoid.Optics.IsoCompose.html#module-examples"},{"type":"type","doc":"","title":"Funx.Monoid.Optics.IsoCompose.t/0","ref":"Funx.Monoid.Optics.IsoCompose.html#t:t/0"},{"type":"function","doc":"Wraps an iso in an IsoCompose monoid.","title":"Funx.Monoid.Optics.IsoCompose.new/1","ref":"Funx.Monoid.Optics.IsoCompose.html#new/1"},{"type":"function","doc":"Extracts the iso from an IsoCompose wrapper.","title":"Funx.Monoid.Optics.IsoCompose.unwrap/1","ref":"Funx.Monoid.Optics.IsoCompose.html#unwrap/1"},{"type":"module","doc":"The `Funx.Monoid.Optics.LensCompose` module provides a monoid wrapper for sequential lens composition.\n\nThis wrapper allows lenses to be used with generic monoid operations like `m_concat/2` and `m_append/3`,\nenabling functional composition of multiple lenses into a single focusing operation.","title":"Funx.Monoid.Optics.LensCompose","ref":"Funx.Monoid.Optics.LensCompose.html"},{"type":"module","doc":"- `new/1`: Wraps a lens in a `LensCompose` monoid.\n  - `unwrap/1`: Extracts the lens from a `LensCompose` wrapper.","title":"Wrapping and Unwrapping - Funx.Monoid.Optics.LensCompose","ref":"Funx.Monoid.Optics.LensCompose.html#module-wrapping-and-unwrapping"},{"type":"module","doc":"- `empty/1`: Returns the identity lens (leaves structure unchanged).\n  - `append/2`: Composes two lenses sequentially (outer then inner).\n  - `wrap/2`: Wraps a lens value into the monoid.","title":"Monoid Operations (via protocol) - Funx.Monoid.Optics.LensCompose","ref":"Funx.Monoid.Optics.LensCompose.html#module-monoid-operations-via-protocol"},{"type":"module","doc":"iex> alias Funx.Monoid.Optics.LensCompose\n    iex> alias Funx.Optics.Lens\n    iex> lenses = [\n    ...>   Lens.key(:profile),\n    ...>   Lens.key(:score)\n    ...> ]\n    iex> wrapped = Enum.map(lenses, &LensCompose.new/1)\n    iex> composed = Funx.Monoid.Utils.m_concat(%LensCompose{}, lenses)\n    iex> %{profile: %{score: 42}} |> Lens.view!(composed)\n    42","title":"Examples - Funx.Monoid.Optics.LensCompose","ref":"Funx.Monoid.Optics.LensCompose.html#module-examples"},{"type":"type","doc":"","title":"Funx.Monoid.Optics.LensCompose.t/0","ref":"Funx.Monoid.Optics.LensCompose.html#t:t/0"},{"type":"function","doc":"Wraps a lens in a LensCompose monoid.","title":"Funx.Monoid.Optics.LensCompose.new/1","ref":"Funx.Monoid.Optics.LensCompose.html#new/1"},{"type":"function","doc":"Extracts the lens from a LensCompose wrapper.","title":"Funx.Monoid.Optics.LensCompose.unwrap/1","ref":"Funx.Monoid.Optics.LensCompose.html#unwrap/1"},{"type":"module","doc":"The `Funx.Monoid.Optics.PrismCompose` module provides a monoid wrapper for sequential prism composition.\n\nThis wrapper allows prisms to be used with generic monoid operations like `m_concat/2` and `m_append/3`,\nenabling functional composition of multiple prisms into a single partial focusing operation.","title":"Funx.Monoid.Optics.PrismCompose","ref":"Funx.Monoid.Optics.PrismCompose.html"},{"type":"module","doc":"- `new/1`: Wraps a prism in a `PrismCompose` monoid.\n  - `unwrap/1`: Extracts the prism from a `PrismCompose` wrapper.","title":"Wrapping and Unwrapping - Funx.Monoid.Optics.PrismCompose","ref":"Funx.Monoid.Optics.PrismCompose.html#module-wrapping-and-unwrapping"},{"type":"module","doc":"- `empty/1`: Returns the identity prism (accepts all values).\n  - `append/2`: Composes two prisms sequentially (outer then inner).\n  - `wrap/2`: Wraps a prism value into the monoid.","title":"Monoid Operations (via protocol) - Funx.Monoid.Optics.PrismCompose","ref":"Funx.Monoid.Optics.PrismCompose.html#module-monoid-operations-via-protocol"},{"type":"module","doc":"iex> alias Funx.Monoid.Optics.PrismCompose\n    iex> alias Funx.Optics.Prism\n    iex> prisms = [\n    ...>   Prism.key(:account),\n    ...>   Prism.key(:name)\n    ...> ]\n    iex> wrapped = Enum.map(prisms, &PrismCompose.new/1)\n    iex> composed = Funx.Monoid.Utils.m_concat(%PrismCompose{}, prisms)\n    iex> Prism.preview(%{account: %{name: \"Alice\"}}, composed)\n    %Funx.Monad.Maybe.Just{value: \"Alice\"}","title":"Examples - Funx.Monoid.Optics.PrismCompose","ref":"Funx.Monoid.Optics.PrismCompose.html#module-examples"},{"type":"type","doc":"","title":"Funx.Monoid.Optics.PrismCompose.t/0","ref":"Funx.Monoid.Optics.PrismCompose.html#t:t/0"},{"type":"function","doc":"Wraps a prism in a PrismCompose monoid.","title":"Funx.Monoid.Optics.PrismCompose.new/1","ref":"Funx.Monoid.Optics.PrismCompose.html#new/1"},{"type":"function","doc":"Extracts the prism from a PrismCompose wrapper.","title":"Funx.Monoid.Optics.PrismCompose.unwrap/1","ref":"Funx.Monoid.Optics.PrismCompose.html#unwrap/1"},{"type":"module","doc":"The `Funx.Monoid.Optics.TraversalCombine` module provides a monoid wrapper for parallel traversal combination.\n\nThis wrapper allows traversals to be used with generic monoid operations like `m_concat/2`,\nenabling functional aggregation of multiple optics into a single multi-focus traversal.","title":"Funx.Monoid.Optics.TraversalCombine","ref":"Funx.Monoid.Optics.TraversalCombine.html"},{"type":"module","doc":"- `new/1`: Wraps a traversal in a `TraversalCombine` monoid.\n  - `unwrap/1`: Extracts the traversal from a `TraversalCombine` wrapper.","title":"Wrapping and Unwrapping - Funx.Monoid.Optics.TraversalCombine","ref":"Funx.Monoid.Optics.TraversalCombine.html#module-wrapping-and-unwrapping"},{"type":"module","doc":"- `empty/1`: Returns the identity traversal (no foci).\n  - `append/2`: Combines two traversals by concatenating their foci.\n  - `wrap/2`: Wraps an optic into a single-focus traversal.","title":"Monoid Operations (via protocol) - Funx.Monoid.Optics.TraversalCombine","ref":"Funx.Monoid.Optics.TraversalCombine.html#module-monoid-operations-via-protocol"},{"type":"module","doc":"iex> alias Funx.Monoid.Optics.TraversalCombine\n    iex> alias Funx.Optics.{Lens, Traversal}\n    iex> optics = [Lens.key(:name), Lens.key(:age)]\n    iex> t = Funx.Monoid.Utils.m_concat(%TraversalCombine{}, optics)\n    iex> Traversal.to_list(%{name: \"Alice\", age: 30}, t)\n    [\"Alice\", 30]","title":"Examples - Funx.Monoid.Optics.TraversalCombine","ref":"Funx.Monoid.Optics.TraversalCombine.html#module-examples"},{"type":"type","doc":"","title":"Funx.Monoid.Optics.TraversalCombine.t/0","ref":"Funx.Monoid.Optics.TraversalCombine.html#t:t/0"},{"type":"function","doc":"Wraps a traversal in a TraversalCombine monoid.","title":"Funx.Monoid.Optics.TraversalCombine.new/1","ref":"Funx.Monoid.Optics.TraversalCombine.html#new/1"},{"type":"function","doc":"Extracts the traversal from a TraversalCombine wrapper.","title":"Funx.Monoid.Optics.TraversalCombine.unwrap/1","ref":"Funx.Monoid.Optics.TraversalCombine.html#unwrap/1"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonoid%2Ford.livemd)\n\nA monoid implementation for ordering logic (Ord).\nProvides default comparison functions and supports combining multiple\n`Ord` comparators into a single composite comparator.","title":"Funx.Monoid.Ord","ref":"Funx.Monoid.Ord.html"},{"type":"type","doc":"","title":"Funx.Monoid.Ord.t/0","ref":"Funx.Monoid.Ord.html#t:t/0"},{"type":"function","doc":"","title":"Funx.Monoid.Ord.default?/2","ref":"Funx.Monoid.Ord.html#default?/2"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonoid%2Fpred_all.livemd)\n\nA Monoid implementation for combining predicates using logical AND.","title":"Funx.Monoid.Predicate.All","ref":"Funx.Monoid.Predicate.All.html"},{"type":"function","doc":"","title":"Funx.Monoid.Predicate.All.default_pred?/1","ref":"Funx.Monoid.Predicate.All.html#default_pred?/1"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonoid%2Fpred_any.livemd)\n\nA Monoid implementation for combining predicates using logical OR.","title":"Funx.Monoid.Predicate.Any","ref":"Funx.Monoid.Predicate.Any.html"},{"type":"function","doc":"","title":"Funx.Monoid.Predicate.Any.default_pred?/1","ref":"Funx.Monoid.Predicate.Any.html#default_pred?/1"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonoid%2Fproduct.livemd)\n\nA Monoid implementation for products.\n\nThis monoid uses multiplication as its associative operation\nand `1` as the identity element.","title":"Funx.Monoid.Product","ref":"Funx.Monoid.Product.html"},{"type":"type","doc":"","title":"Funx.Monoid.Product.t/0","ref":"Funx.Monoid.Product.html#t:t/0"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonoid%2Fstring_concat.livemd)\n\nA Monoid implementation for concatenating strings.\n\nThis monoid uses binary string concatenation (`<>`) as its associative operation\nand `\"\"` (empty string) as the identity element.","title":"Funx.Monoid.StringConcat","ref":"Funx.Monoid.StringConcat.html"},{"type":"type","doc":"","title":"Funx.Monoid.StringConcat.t/0","ref":"Funx.Monoid.StringConcat.html#t:t/0"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonoid%2Fsum.livemd)\n\nA Monoid implementation for sums.\n\nThis monoid uses addition as its associative operation\nand `0` as the identity element.","title":"Funx.Monoid.Sum","ref":"Funx.Monoid.Sum.html"},{"type":"type","doc":"","title":"Funx.Monoid.Sum.t/0","ref":"Funx.Monoid.Sum.html#t:t/0"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fmonoid%2Futils.livemd)\n\nUtility functions for working with Monoids.\n\nThis module provides functions to combine monoidal values using\n`m_append/3` and `m_concat/2`.","title":"Funx.Monoid.Utils","ref":"Funx.Monoid.Utils.html"},{"type":"function","doc":"Appends two values within a given monoid.\n\nThis function wraps the input values using the provided `monoid`, applies\nthe `append/2` operation, and then unwraps the result.","title":"Funx.Monoid.Utils.m_append/3","ref":"Funx.Monoid.Utils.html#m_append/3"},{"type":"function","doc":"- `monoid` – A monoid struct defining how values should be combined.\n  - `a` – The first raw value.\n  - `b` – The second raw value.","title":"Parameters - Funx.Monoid.Utils.m_append/3","ref":"Funx.Monoid.Utils.html#m_append/3-parameters"},{"type":"function","doc":"iex> alias Funx.Monoid.Sum\n    iex> Funx.Monoid.Utils.m_append(%Sum{}, 3, 5)\n    8","title":"Examples - Funx.Monoid.Utils.m_append/3","ref":"Funx.Monoid.Utils.html#m_append/3-examples"},{"type":"function","doc":"Concatenates a list of values using the given monoid.\n\nThis function wraps each value using the provided `monoid`, folds the list\nusing the monoid's identity and append operation, and then unwraps the result.","title":"Funx.Monoid.Utils.m_concat/2","ref":"Funx.Monoid.Utils.html#m_concat/2"},{"type":"function","doc":"- `monoid` – A monoid struct defining how values should be combined.\n  - `values` – A list of raw values.","title":"Parameters - Funx.Monoid.Utils.m_concat/2","ref":"Funx.Monoid.Utils.html#m_concat/2-parameters"},{"type":"function","doc":"iex> alias Funx.Monoid.Sum\n    iex> Funx.Monoid.Utils.m_concat(%Sum{}, [1, 2, 3])\n    6","title":"Examples - Funx.Monoid.Utils.m_concat/2","ref":"Funx.Monoid.Utils.html#m_concat/2-examples"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Foptics%2Fiso.livemd)\n\nThe `Funx.Optics.Iso` module provides a lawful isomorphism optic for bidirectional, lossless transformations.\n\nAn isomorphism (iso) represents a reversible transformation between two types. It consists of\ntwo inverse functions that satisfy the round-trip laws:\n\n- `review(view(s, iso), iso) == s` - Round-trip forward then back returns the original\n- `view(review(a, iso), iso) == a` - Round-trip back then forward returns the original\n\nIsos are total optics with no partiality. If the transformation can fail, you do not have an iso.\nContract violations crash immediately - there are no bang variants or safe alternatives.","title":"Funx.Optics.Iso","ref":"Funx.Optics.Iso.html"},{"type":"module","doc":"- `make/2`: Creates a custom iso from two inverse functions.\n  - `identity/0`: The identity iso (both directions are identity).","title":"Constructors - Funx.Optics.Iso","ref":"Funx.Optics.Iso.html#module-constructors"},{"type":"module","doc":"- `view/2`: Apply the forward transformation (s -> a).\n  - `review/2`: Apply the backward transformation (a -> s).\n  - `over/3`: Modify the viewed side (view, apply function, review).\n  - `under/3`: Modify the reviewed side (review, apply function, view).","title":"Core Operations - Funx.Optics.Iso","ref":"Funx.Optics.Iso.html#module-core-operations"},{"type":"module","doc":"- `from/1`: Reverse the iso's direction.","title":"Direction - Funx.Optics.Iso","ref":"Funx.Optics.Iso.html#module-direction"},{"type":"module","doc":"- `compose/2`: Composes two isos sequentially (outer then inner).\n  - `compose/1`: Composes a list of isos into a single iso.","title":"Composition - Funx.Optics.Iso","ref":"Funx.Optics.Iso.html#module-composition"},{"type":"module","doc":"- `as_lens/1`: Converts an iso to a lens.\n  - `as_prism/1`: Converts an iso to a prism.\n\nAn iso is more powerful than both lens and prism. Every iso can be used as a lens\n(viewing and setting always succeed) or as a prism (preview always returns `Just`).\n\nIsos compose naturally. Composing two isos yields a new iso where:\n- Forward (`view`) applies the outer iso first, then the inner iso\n- Backward (`review`) applies the inner iso first, then the outer iso","title":"Interoperability - Funx.Optics.Iso","ref":"Funx.Optics.Iso.html#module-interoperability"},{"type":"module","doc":"Isos form a monoid under composition.\n\nThe monoid structure is provided via `Funx.Monoid.Optics.IsoCompose`, which wraps isos\nfor use with generic monoid operations:\n\n  - **Identity**: `identity/0` - the identity iso\n  - **Operation**: `compose/2` - sequential composition\n\nComposing an empty list returns the identity iso.","title":"Monoid Structure - Funx.Optics.Iso","ref":"Funx.Optics.Iso.html#module-monoid-structure"},{"type":"module","doc":"Simple encoding/decoding:\n\n    iex> alias Funx.Optics.Iso\n    iex> # Iso between string and integer (string representation)\n    iex> string_int = Iso.make(\n    ...>   fn s -> String.to_integer(s) end,\n    ...>   fn i -> Integer.to_string(i) end\n    ...> )\n    iex> Iso.view(\"42\", string_int)\n    42\n    iex> Iso.review(42, string_int)\n    \"42\"\n\nComposing isos:\n\n    iex> alias Funx.Optics.Iso\n    iex> # Iso: string <-> integer\n    iex> string_int = Iso.make(\n    ...>   fn s -> String.to_integer(s) end,\n    ...>   fn i -> Integer.to_string(i) end\n    ...> )\n    iex> # Iso: integer <-> doubled integer\n    iex> double = Iso.make(\n    ...>   fn i -> i * 2 end,\n    ...>   fn i -> div(i, 2) end\n    ...> )\n    iex> # Composed: string <-> doubled integer\n    iex> composed = Iso.compose(string_int, double)\n    iex> Iso.view(\"21\", composed)\n    42\n    iex> Iso.review(42, composed)\n    \"21\"\n\nUsing `over` and `under`:\n\n    iex> alias Funx.Optics.Iso\n    iex> string_int = Iso.make(\n    ...>   fn s -> String.to_integer(s) end,\n    ...>   fn i -> Integer.to_string(i) end\n    ...> )\n    iex> Iso.over(\"10\", string_int, fn i -> i * 5 end)\n    \"50\"\n    iex> Iso.under(100, string_int, fn s -> s <> \"0\" end)\n    1000","title":"Examples - Funx.Optics.Iso","ref":"Funx.Optics.Iso.html#module-examples"},{"type":"type","doc":"","title":"Funx.Optics.Iso.backward/2","ref":"Funx.Optics.Iso.html#t:backward/2"},{"type":"type","doc":"","title":"Funx.Optics.Iso.forward/2","ref":"Funx.Optics.Iso.html#t:forward/2"},{"type":"type","doc":"","title":"Funx.Optics.Iso.t/0","ref":"Funx.Optics.Iso.html#t:t/0"},{"type":"type","doc":"","title":"Funx.Optics.Iso.t/2","ref":"Funx.Optics.Iso.html#t:t/2"},{"type":"function","doc":"Converts an iso to a lens.\n\nAn iso is more powerful than a lens: it provides bidirectional transformation,\nwhile a lens only provides viewing and updating. Every iso can be used as a lens.\n\nThe resulting lens:\n- `view` uses the iso's forward transformation\n- `update` ignores the old value and uses the iso's backward transformation\n\nThis is safe because an iso is total - the transformation always succeeds.","title":"Funx.Optics.Iso.as_lens/1","ref":"Funx.Optics.Iso.html#as_lens/1"},{"type":"function","doc":"iex> alias Funx.Optics.{Iso, Lens}\n    iex> string_int = Iso.make(\n    ...>   fn s -> String.to_integer(s) end,\n    ...>   fn i -> Integer.to_string(i) end\n    ...> )\n    iex> lens = Iso.as_lens(string_int)\n    iex> Lens.view!(\"42\", lens)\n    42\n    iex> Lens.set!(\"10\", lens, 99)\n    \"99\"","title":"Examples - Funx.Optics.Iso.as_lens/1","ref":"Funx.Optics.Iso.html#as_lens/1-examples"},{"type":"function","doc":"Converts an iso to a prism.\n\nAn iso is more powerful than a prism: it never fails to extract a value,\nwhile a prism models optional extraction. Every iso can be used as a prism.\n\nThe resulting prism:\n- `preview` always succeeds (returns `Just`), using the iso's forward transformation\n- `review` uses the iso's backward transformation\n\nThis is safe because an iso is total - the transformation always succeeds.","title":"Funx.Optics.Iso.as_prism/1","ref":"Funx.Optics.Iso.html#as_prism/1"},{"type":"function","doc":"iex> alias Funx.Optics.{Iso, Prism}\n    iex> alias Funx.Monad.Maybe.Just\n    iex> string_int = Iso.make(\n    ...>   fn s -> String.to_integer(s) end,\n    ...>   fn i -> Integer.to_string(i) end\n    ...> )\n    iex> prism = Iso.as_prism(string_int)\n    iex> Prism.preview(\"42\", prism)\n    %Just{value: 42}\n    iex> Prism.review(42, prism)\n    \"42\"","title":"Examples - Funx.Optics.Iso.as_prism/1","ref":"Funx.Optics.Iso.html#as_prism/1-examples"},{"type":"function","doc":"","title":"Funx.Optics.Iso.compose/1","ref":"Funx.Optics.Iso.html#compose/1"},{"type":"function","doc":"Composes isos into a single iso using sequential composition.\n\nThis delegates to the monoid append operation, which contains the\ncanonical composition logic.","title":"Funx.Optics.Iso.compose/2","ref":"Funx.Optics.Iso.html#compose/2"},{"type":"function","doc":"Composes two isos. The outer iso transforms first, then the inner iso\ntransforms the result.\n\nThis is left-to-right composition: the first parameter is applied first.\nThis differs from mathematical function composition (f ∘ g applies g first).\n\n**Sequential semantics:**\n- On `view`: Applies outer's forward transformation first, then inner's forward transformation\n- On `review`: Applies inner's backward transformation first, then outer's backward transformation\n\nThis is sequential transformation through composed isos.\n\n    iex> alias Funx.Optics.Iso\n    iex> # string <-> int\n    iex> string_int = Iso.make(\n    ...>   fn s -> String.to_integer(s) end,\n    ...>   fn i -> Integer.to_string(i) end\n    ...> )\n    iex> # int <-> doubled int\n    iex> double = Iso.make(\n    ...>   fn i -> i * 2 end,\n    ...>   fn i -> div(i, 2) end\n    ...> )\n    iex> composed = Iso.compose(string_int, double)\n    iex> Iso.view(\"21\", composed)\n    42\n    iex> Iso.review(42, composed)\n    \"21\"","title":"Binary composition - Funx.Optics.Iso.compose/2","ref":"Funx.Optics.Iso.html#compose/2-binary-composition"},{"type":"function","doc":"Composes a list of isos into a single iso using sequential composition.\n\n**Sequential semantics:**\n- On `view`: Applies transformations in list order (left-to-right)\n- On `review`: Applies transformations in reverse list order (right-to-left)\n\nThis is sequential transformation through composed isos.\n\n    iex> isos = [\n    ...>   Funx.Optics.Iso.make(\n    ...>     fn s -> String.to_integer(s) end,\n    ...>     fn i -> Integer.to_string(i) end\n    ...>   ),\n    ...>   Funx.Optics.Iso.make(\n    ...>     fn i -> i * 2 end,\n    ...>     fn i -> div(i, 2) end\n    ...>   )\n    ...> ]\n    iex> composed = Funx.Optics.Iso.compose(isos)\n    iex> Funx.Optics.Iso.view(\"21\", composed)\n    42","title":"List composition - Funx.Optics.Iso.compose/2","ref":"Funx.Optics.Iso.html#compose/2-list-composition"},{"type":"function","doc":"Reverses the direction of an iso.\n\nSwaps the view and review functions.\n\nThis is the established optic operation for reversing direction, following Haskell's\n`Control.Lens.Iso.from`.","title":"Funx.Optics.Iso.from/1","ref":"Funx.Optics.Iso.html#from/1"},{"type":"function","doc":"iex> string_int = Funx.Optics.Iso.make(\n    ...>   fn s -> String.to_integer(s) end,\n    ...>   fn i -> Integer.to_string(i) end\n    ...> )\n    iex> int_string = Funx.Optics.Iso.from(string_int)\n    iex> Funx.Optics.Iso.view(42, int_string)\n    \"42\"\n    iex> Funx.Optics.Iso.review(\"42\", int_string)\n    42","title":"Examples - Funx.Optics.Iso.from/1","ref":"Funx.Optics.Iso.html#from/1-examples"},{"type":"function","doc":"The identity iso that leaves values unchanged in both directions.","title":"Funx.Optics.Iso.identity/0","ref":"Funx.Optics.Iso.html#identity/0"},{"type":"function","doc":"iex> iso = Funx.Optics.Iso.identity()\n    iex> Funx.Optics.Iso.view(42, iso)\n    42\n    iex> Funx.Optics.Iso.review(42, iso)\n    42","title":"Examples - Funx.Optics.Iso.identity/0","ref":"Funx.Optics.Iso.html#identity/0-examples"},{"type":"function","doc":"Creates a custom iso from two inverse functions.\n\nThe viewer function transforms from the source type to the target type.\nThe reviewer function transforms from the target type back to the source type.\n\nBoth functions must be inverses for the iso to be lawful:\n- `review(view(s, iso), iso) == s`\n- `view(review(a, iso), iso) == a`\n\nIf these functions are not true inverses, the iso contract is violated and\nthe program is incorrect. There are no runtime checks - the contract is enforced\nby design.","title":"Funx.Optics.Iso.make/2","ref":"Funx.Optics.Iso.html#make/2"},{"type":"function","doc":"iex> # Celsius <-> Fahrenheit\n    iex> temp_iso = Funx.Optics.Iso.make(\n    ...>   fn c -> c * 9 / 5 + 32 end,\n    ...>   fn f -> (f - 32) * 5 / 9 end\n    ...> )\n    iex> Funx.Optics.Iso.view(0, temp_iso)\n    32.0\n    iex> Funx.Optics.Iso.review(32, temp_iso)\n    0.0","title":"Examples - Funx.Optics.Iso.make/2","ref":"Funx.Optics.Iso.html#make/2-examples"},{"type":"function","doc":"Modify the viewed side of the iso.\n\nApplies a function through the iso: view, apply function, review.\n\nThis is the standard optic modifier, consistent with Lens and Prism.","title":"Funx.Optics.Iso.over/3","ref":"Funx.Optics.Iso.html#over/3"},{"type":"function","doc":"iex> string_int = Funx.Optics.Iso.make(\n    ...>   fn s -> String.to_integer(s) end,\n    ...>   fn i -> Integer.to_string(i) end\n    ...> )\n    iex> Funx.Optics.Iso.over(\"10\", string_int, fn i -> i * 5 end)\n    \"50\"","title":"Examples - Funx.Optics.Iso.over/3","ref":"Funx.Optics.Iso.html#over/3-examples"},{"type":"function","doc":"Apply the backward transformation of the iso.\n\nTransforms from the target type back to the source type.\n\nThis operation is total. If it crashes, the iso contract is violated.","title":"Funx.Optics.Iso.review/2","ref":"Funx.Optics.Iso.html#review/2"},{"type":"function","doc":"iex> string_int = Funx.Optics.Iso.make(\n    ...>   fn s -> String.to_integer(s) end,\n    ...>   fn i -> Integer.to_string(i) end\n    ...> )\n    iex> Funx.Optics.Iso.review(42, string_int)\n    \"42\"","title":"Examples - Funx.Optics.Iso.review/2","ref":"Funx.Optics.Iso.html#review/2-examples"},{"type":"function","doc":"Modify the reviewed side of the iso.\n\nApplies a function in reverse through the iso: review, apply function, view.\n\nThis operation is unique to Iso due to its bidirectional symmetry.\nLens and Prism cannot offer this.","title":"Funx.Optics.Iso.under/3","ref":"Funx.Optics.Iso.html#under/3"},{"type":"function","doc":"iex> string_int = Funx.Optics.Iso.make(\n    ...>   fn s -> String.to_integer(s) end,\n    ...>   fn i -> Integer.to_string(i) end\n    ...> )\n    iex> Funx.Optics.Iso.under(100, string_int, fn s -> s <> \"0\" end)\n    1000","title":"Examples - Funx.Optics.Iso.under/3","ref":"Funx.Optics.Iso.html#under/3-examples"},{"type":"function","doc":"Apply the forward transformation of the iso.\n\nTransforms from the source type to the target type.\n\nThis operation is total. If it crashes, the iso contract is violated.","title":"Funx.Optics.Iso.view/2","ref":"Funx.Optics.Iso.html#view/2"},{"type":"function","doc":"iex> string_int = Funx.Optics.Iso.make(\n    ...>   fn s -> String.to_integer(s) end,\n    ...>   fn i -> Integer.to_string(i) end\n    ...> )\n    iex> Funx.Optics.Iso.view(\"42\", string_int)\n    42","title":"Examples - Funx.Optics.Iso.view/2","ref":"Funx.Optics.Iso.html#view/2-examples"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Foptics%2Flens.livemd)\n\nThe `Funx.Optics.Lens` module provides a lawful total optic for focusing on a part of a data structure.\n\nA lens is **total**: it assumes the focus always exists within the valid domain. This is a contract\nenforced at runtime by raising `KeyError` when violated. If the focus might not exist, use a prism instead.\n\nBoth `view!` and `set!` enforce totality symmetrically for all data types (maps, structs, etc.). If either\noperation can succeed when the focus is missing, you no longer have a lens.","title":"Funx.Optics.Lens","ref":"Funx.Optics.Lens.html"},{"type":"module","doc":"- `key/1`: Focuses on a single key in a map or struct.\n  - `path/1`: Focuses on nested keys by composing `key/1` lenses.\n  - `make/2`: Creates a custom lens from viewer and updater functions.","title":"Constructors - Funx.Optics.Lens","ref":"Funx.Optics.Lens.html#module-constructors"},{"type":"module","doc":"- `view!/2`: Extracts the focused part (raises `KeyError` if missing).\n  - `set!/3`: Updates the focused part (raises `KeyError` if missing).\n  - `over!/3`: Applies a function to the focused part (raises `KeyError` if missing).","title":"Core Operations - Funx.Optics.Lens","ref":"Funx.Optics.Lens.html#module-core-operations"},{"type":"module","doc":"- `view/3`: Safe version of `view!/2` (returns `Either` or tuple).\n  - `set/4`: Safe version of `set!/3` (returns `Either` or tuple).\n  - `over/4`: Safe version of `over!/3` (returns `Either` or tuple).\n\n**Error handling modes:**\n\nSafe operations accept an optional `:as` parameter:\n\n  - `:either` (default): Returns `Right(value)` or `Left(exception)`.\n  - `:tuple`: Returns `{:ok, value}` or `{:error, exception}`.\n  - `:raise`: Behaves like the `!` version, raising exceptions directly.\n\nSafe operations use `Either.from_try/1` internally, which catches **all exceptions**,\nnot just `KeyError`.","title":"Safe Operations - Funx.Optics.Lens","ref":"Funx.Optics.Lens.html#module-safe-operations"},{"type":"module","doc":"- `compose/2`: Composes two lenses sequentially (outer then inner).\n  - `compose/1`: Composes a list of lenses into a single lens.\n\nLenses compose naturally. Composing two lenses yields a new lens that focuses through\nboth layers sequentially.","title":"Composition - Funx.Optics.Lens","ref":"Funx.Optics.Lens.html#module-composition"},{"type":"module","doc":"Lenses form a monoid under composition **for a fixed outer type `s`**.\n\nThe monoid structure is provided via `Funx.Monoid.Optics.LensCompose`, which wraps lenses\nfor use with generic monoid operations:\n\n  - **Identity**: `make(fn s -> s end, fn _s, a -> a end)` - the identity lens\n  - **Operation**: `compose/2` - sequential composition\n\nYou can use `compose/1` to compose multiple lenses sequentially, or work directly\nwith `Funx.Monoid.Optics.LensCompose` for more control.","title":"Monoid Structure - Funx.Optics.Lens","ref":"Funx.Optics.Lens.html#module-monoid-structure"},{"type":"module","doc":"iex> alias Funx.Optics.Lens\n    iex> lens = Lens.key(:age)\n    iex> %{age: 40} |> Lens.view!(lens)\n    40\n    iex> %{age: 40} |> Lens.set!(lens, 50)\n    %{age: 50}\n\nComposing lenses for nested access:\n\n    iex> alias Funx.Optics.Lens\n    iex> outer = Lens.key(:profile)\n    iex> inner = Lens.key(:score)\n    iex> lens = Lens.compose(outer, inner)\n    iex> %{profile: %{score: 12}} |> Lens.view!(lens)\n    12\n    iex> %{profile: %{score: 12}} |> Lens.set!(lens, 99)\n    %{profile: %{score: 99}}\n\nDeeply nested composition with `compose/1`:\n\n    iex> alias Funx.Optics.Lens\n    iex> lens = Lens.compose([Lens.key(:stats), Lens.key(:wins)])\n    iex> %{stats: %{wins: 7}} |> Lens.view!(lens)\n    7\n    iex> %{stats: %{wins: 7}} |> Lens.set!(lens, 8)\n    %{stats: %{wins: 8}}","title":"Examples - Funx.Optics.Lens","ref":"Funx.Optics.Lens.html#module-examples"},{"type":"type","doc":"","title":"Funx.Optics.Lens.t/0","ref":"Funx.Optics.Lens.html#t:t/0"},{"type":"type","doc":"","title":"Funx.Optics.Lens.t/2","ref":"Funx.Optics.Lens.html#t:t/2"},{"type":"type","doc":"","title":"Funx.Optics.Lens.updater/2","ref":"Funx.Optics.Lens.html#t:updater/2"},{"type":"type","doc":"","title":"Funx.Optics.Lens.viewer/2","ref":"Funx.Optics.Lens.html#t:viewer/2"},{"type":"function","doc":"","title":"Funx.Optics.Lens.compose/1","ref":"Funx.Optics.Lens.html#compose/1"},{"type":"function","doc":"Composes lenses into a single lens using sequential composition.\n\nThis delegates to the monoid append operation, which contains the\ncanonical composition logic.","title":"Funx.Optics.Lens.compose/2","ref":"Funx.Optics.Lens.html#compose/2"},{"type":"function","doc":"Composes two lenses. The outer lens focuses first, then the inner lens\nfocuses within the result.\n\nThis is left-to-right composition: the first parameter is applied first.\nThis differs from mathematical function composition (f ∘ g applies g first).\n\n**Sequential semantics:**\n- On `view!`: Applies outer's viewer first, then inner's viewer\n- On `set!`: Updates through both lenses, maintaining nested structure\n\nThis is sequential focusing through nested structures.\n\n    iex> alias Funx.Optics.Lens\n    iex> outer = Lens.key(:profile)\n    iex> inner = Lens.key(:age)\n    iex> lens = Lens.compose(outer, inner)\n    iex> %{profile: %{age: 30}} |> Lens.view!(lens)\n    30","title":"Binary composition - Funx.Optics.Lens.compose/2","ref":"Funx.Optics.Lens.html#compose/2-binary-composition"},{"type":"function","doc":"Composes a list of lenses into a single lens using sequential composition.\n\n**Sequential semantics:**\n- On `view!`: Applies viewers in list order (left-to-right)\n- On `set!`: Updates through each lens in reverse order to maintain structure\n\nThis is sequential focusing through nested structures.\n\n    iex> lenses = [\n    ...>   Funx.Optics.Lens.key(:user),\n    ...>   Funx.Optics.Lens.key(:profile),\n    ...>   Funx.Optics.Lens.key(:age)\n    ...> ]\n    iex> lens = Funx.Optics.Lens.compose(lenses)\n    iex> %{user: %{profile: %{age: 25}}} |> Funx.Optics.Lens.view!(lens)\n    25","title":"List composition - Funx.Optics.Lens.compose/2","ref":"Funx.Optics.Lens.html#compose/2-list-composition"},{"type":"function","doc":"Builds a lawful lens focusing on a single key in a map or struct.","title":"Funx.Optics.Lens.key/1","ref":"Funx.Optics.Lens.html#key/1"},{"type":"function","doc":"The key **must exist** in the structure. When used with `view!` and `set!`,\nthis lens uses `Map.fetch!/2` and `Map.replace!/3`, raising `KeyError` if\nthe key is missing. This symmetric enforcement ensures all three lens laws hold.\n\n**If the key might not exist, use a prism instead.**","title":"Contract - Funx.Optics.Lens.key/1","ref":"Funx.Optics.Lens.html#key/1-contract"},{"type":"function","doc":"The return type `t(map(), term())` uses Elixir's `map()` type, which includes\nboth plain maps and structs (since structs are maps with a `__struct__` key).","title":"Type Note - Funx.Optics.Lens.key/1","ref":"Funx.Optics.Lens.html#key/1-type-note"},{"type":"function","doc":"iex> lens = Funx.Optics.Lens.key(:name)\n    iex> %{name: \"Alice\"} |> Funx.Optics.Lens.view!(lens)\n    \"Alice\"\n    iex> %{name: \"Alice\"} |> Funx.Optics.Lens.set!(lens, \"Bob\")\n    %{name: \"Bob\"}\n\nWorks with string keys:\n\n    iex> lens = Funx.Optics.Lens.key(\"count\")\n    iex> %{\"count\" => 5} |> Funx.Optics.Lens.view!(lens)\n    5\n\nWith structs (preserves type):\n\n    defmodule User, do: defstruct [:name, :age]\n    lens = Funx.Optics.Lens.key(:name)\n    user = %User{name: \"Alice\", age: 30}\n    Funx.Optics.Lens.view!(user, lens) #=> \"Alice\"\n    Funx.Optics.Lens.set!(user, lens, \"Bob\") #=> %User{name: \"Bob\", age: 30}","title":"Examples - Funx.Optics.Lens.key/1","ref":"Funx.Optics.Lens.html#key/1-examples"},{"type":"function","doc":"Creates a custom lens from viewer and updater functions.\n\nThe viewer extracts the focused part from the structure. The updater\ntakes the structure and a new value, returning an updated structure.\n\nBoth functions must maintain the lens laws for the result to be lawful.","title":"Funx.Optics.Lens.make/2","ref":"Funx.Optics.Lens.html#make/2"},{"type":"function","doc":"iex> # A lens that views and updates the length of a string\n    iex> lens = Funx.Optics.Lens.make(\n    ...>   fn s -> String.length(s) end,\n    ...>   fn s, len -> String.duplicate(s, div(len, String.length(s))) end\n    ...> )\n    iex> Funx.Optics.Lens.view!(\"hello\", lens)\n    5","title":"Examples - Funx.Optics.Lens.make/2","ref":"Funx.Optics.Lens.html#make/2-examples"},{"type":"function","doc":"Safe version of `over!/3` that returns an `Either` or tuple instead of raising.\n\nSee the \"Safe Operations\" section in the module documentation for details\nabout error handling modes and what exceptions are caught.","title":"Funx.Optics.Lens.over/4","ref":"Funx.Optics.Lens.html#over/4"},{"type":"function","doc":"iex> lens = Funx.Optics.Lens.key(:age)\n    iex> Funx.Optics.Lens.over(%{age: 30}, lens, fn a -> a + 1 end)\n    %Funx.Monad.Either.Right{right: %{age: 31}}\n\n    iex> lens = Funx.Optics.Lens.key(:age)\n    iex> Funx.Optics.Lens.over(%{}, lens, fn a -> a + 1 end)\n    %Funx.Monad.Either.Left{left: %KeyError{key: :age, term: %{}}}\n\n    iex> lens = Funx.Optics.Lens.key(:score)\n    iex> Funx.Optics.Lens.over(%{score: 10}, lens, fn s -> s * 2 end, as: :tuple)\n    {:ok, %{score: 20}}\n\n    iex> lens = Funx.Optics.Lens.key(:value)\n    iex> Funx.Optics.Lens.over(%{value: 5}, lens, fn v -> v + 1 end, as: :raise)\n    %{value: 6}","title":"Examples - Funx.Optics.Lens.over/4","ref":"Funx.Optics.Lens.html#over/4-examples"},{"type":"function","doc":"Updates the focused part of a structure by applying a function to it.\n\nThis is the derived transformation operation for a lens. It is implemented\nas:\n\n- `view!/2` to extract the focused part\n- Application of the given function\n- `set!/3` to write the result back\n\nBecause lenses are **total**, `over!/3` is also total. If the focus does not\nexist, a `KeyError` is raised by `view!/2` or `set!/3`.\n\nOnly the focused part is changed. All other structure and data is preserved.","title":"Funx.Optics.Lens.over!/3","ref":"Funx.Optics.Lens.html#over!/3"},{"type":"function","doc":"iex> lens = Funx.Optics.Lens.key(:age)\n    iex> data = %{age: 40}\n    iex> Funx.Optics.Lens.over!(data, lens, fn a -> a + 1 end)\n    %{age: 41}\n\nWorks through composed lenses:\n\n    iex> outer = Funx.Optics.Lens.key(:profile)\n    iex> inner = Funx.Optics.Lens.key(:score)\n    iex> lens = Funx.Optics.Lens.compose(outer, inner)\n    iex> data = %{profile: %{score: 10}}\n    iex> Funx.Optics.Lens.over!(data, lens, fn s -> s * 2 end)\n    %{profile: %{score: 20}}\n\nWorks through `path/1`:\n\n    iex> lens = Funx.Optics.Lens.path([:stats, :wins])\n    iex> data = %{stats: %{wins: 3}}\n    iex> Funx.Optics.Lens.over!(data, lens, fn n -> n + 5 end)\n    %{stats: %{wins: 8}}","title":"Examples - Funx.Optics.Lens.over!/3","ref":"Funx.Optics.Lens.html#over!/3-examples"},{"type":"function","doc":"Builds a lawful lens for nested map access by composing `key/1` lenses.\n\nThis is equivalent to `compose(Enum.map(keys, &key/1))` and enforces totality\nat every level - raising `KeyError` when used with `view!` or `set!` if any\nintermediate key is missing.","title":"Funx.Optics.Lens.path/1","ref":"Funx.Optics.Lens.html#path/1"},{"type":"function","doc":"The return type `t(map(), term())` uses Elixir's `map()` type, which includes\nboth plain maps and structs (since structs are maps with a `__struct__` key).","title":"Type Note - Funx.Optics.Lens.path/1","ref":"Funx.Optics.Lens.html#path/1-type-note"},{"type":"function","doc":"iex> lens = Funx.Optics.Lens.path([:user, :profile, :name])\n    iex> data = %{user: %{profile: %{name: \"Alice\"}}}\n    iex> Funx.Optics.Lens.view!(data, lens)\n    \"Alice\"\n    iex> Funx.Optics.Lens.set!(data, lens, \"Bob\")\n    %{user: %{profile: %{name: \"Bob\"}}}\n\nRaises on missing keys when accessed:\n\n    iex> lens = Funx.Optics.Lens.path([:user, :name])\n    iex> Funx.Optics.Lens.view!(%{}, lens)\n    ** (KeyError) key :user not found in: %{}","title":"Examples - Funx.Optics.Lens.path/1","ref":"Funx.Optics.Lens.html#path/1-examples"},{"type":"function","doc":"Safe version of `set!/3` that returns an `Either` or tuple instead of raising.\n\nSee the \"Safe Operations\" section in the module documentation for details\nabout error handling modes and what exceptions are caught.","title":"Funx.Optics.Lens.set/4","ref":"Funx.Optics.Lens.html#set/4"},{"type":"function","doc":"iex> lens = Funx.Optics.Lens.key(:age)\n    iex> Funx.Optics.Lens.set(%{age: 30}, lens, 31)\n    %Funx.Monad.Either.Right{right: %{age: 31}}\n\n    iex> lens = Funx.Optics.Lens.key(:age)\n    iex> Funx.Optics.Lens.set(%{}, lens, 31)\n    %Funx.Monad.Either.Left{left: %KeyError{key: :age, term: %{}}}\n\n    iex> lens = Funx.Optics.Lens.key(:count)\n    iex> Funx.Optics.Lens.set(%{count: 5}, lens, 10, as: :tuple)\n    {:ok, %{count: 10}}\n\n    iex> lens = Funx.Optics.Lens.key(:name)\n    iex> Funx.Optics.Lens.set(%{name: \"Alice\"}, lens, \"Bob\", as: :raise)\n    %{name: \"Bob\"}","title":"Examples - Funx.Optics.Lens.set/4","ref":"Funx.Optics.Lens.html#set/4-examples"},{"type":"function","doc":"Updates the focused part of a structure by setting it to a new value.\n\nRaises `KeyError` if the focus does not exist. The entire structure is\nreturned with only the focused part changed. All other fields and nested\nstructures are preserved. Struct types are maintained.\n\nFor non-raising behavior, use `set/4` instead.","title":"Funx.Optics.Lens.set!/3","ref":"Funx.Optics.Lens.html#set!/3"},{"type":"function","doc":"iex> lens = Funx.Optics.Lens.key(:age)\n    iex> Funx.Optics.Lens.set!(%{age: 30, name: \"Alice\"}, lens, 31)\n    %{age: 31, name: \"Alice\"}\n\n    iex> lens = Funx.Optics.Lens.key(:age)\n    iex> Funx.Optics.Lens.set!(%{name: \"Alice\"}, lens, 31)\n    ** (KeyError) key :age not found in: %{name: \"Alice\"}","title":"Examples - Funx.Optics.Lens.set!/3","ref":"Funx.Optics.Lens.html#set!/3-examples"},{"type":"function","doc":"Safe version of `view!/2` that returns an `Either` or tuple instead of raising.\n\nSee the \"Safe Operations\" section in the module documentation for details\nabout error handling modes and what exceptions are caught.","title":"Funx.Optics.Lens.view/3","ref":"Funx.Optics.Lens.html#view/3"},{"type":"function","doc":"iex> lens = Funx.Optics.Lens.key(:name)\n    iex> Funx.Optics.Lens.view(%{name: \"Alice\"}, lens)\n    %Funx.Monad.Either.Right{right: \"Alice\"}\n\n    iex> lens = Funx.Optics.Lens.key(:name)\n    iex> Funx.Optics.Lens.view(%{}, lens)\n    %Funx.Monad.Either.Left{left: %KeyError{key: :name, term: %{}}}\n\n    iex> lens = Funx.Optics.Lens.key(:age)\n    iex> Funx.Optics.Lens.view(%{age: 30}, lens, as: :tuple)\n    {:ok, 30}\n\n    iex> lens = Funx.Optics.Lens.key(:age)\n    iex> Funx.Optics.Lens.view(%{age: 30}, lens, as: :raise)\n    30","title":"Examples - Funx.Optics.Lens.view/3","ref":"Funx.Optics.Lens.html#view/3-examples"},{"type":"function","doc":"Extracts the focused part of a structure using a lens.\n\nRaises `KeyError` if the focus does not exist (e.g., missing map key).\nFor non-raising behavior, use `view/3` instead.","title":"Funx.Optics.Lens.view!/2","ref":"Funx.Optics.Lens.html#view!/2"},{"type":"function","doc":"iex> lens = Funx.Optics.Lens.key(:name)\n    iex> Funx.Optics.Lens.view!(%{name: \"Alice\"}, lens)\n    \"Alice\"\n\n    iex> lens = Funx.Optics.Lens.key(:name)\n    iex> Funx.Optics.Lens.view!(%{}, lens)\n    ** (KeyError) key :name not found in: %{}","title":"Examples - Funx.Optics.Lens.view!/2","ref":"Funx.Optics.Lens.html#view!/2-examples"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Foptics%2Fprism.livemd)\n\nThe `Funx.Optics.Prism` module provides a lawful partial optic for focusing on a branch of a data structure.\n\nA prism is **partial**: the focus may or may not be present. This makes prisms ideal for working with\noptional values, variants, and sum types. Unlike lenses, prisms never raise—they return `Maybe` instead.\n\n**When to use prisms vs lenses:**\n\n  - **Prisms** (partial): Use for optional values, variants, sum types, missing map keys.\n  - **Lenses** (total): Use for record fields, map keys that always exist.","title":"Funx.Optics.Prism","ref":"Funx.Optics.Prism.html"},{"type":"module","doc":"- `key/1`: Focuses on an optional key in a map.\n  - `struct/1`: Focuses on a specific struct type (for sum types).\n  - `path/1`: Focuses on nested paths through maps and structs.\n  - `make/2`: Creates a custom prism from preview and review functions.","title":"Constructors - Funx.Optics.Prism","ref":"Funx.Optics.Prism.html#module-constructors"},{"type":"module","doc":"- `preview/2`: Attempts to extract the focus, returning `Just(value)` or `Nothing`.\n  - `review/2`: Reconstructs the whole structure from the focused value.\n\n**Important:** `review` constructs a fresh structure from the focused value alone—it does not merge\nor preserve other fields. This is lawful prism behavior. If you need to update while preserving other\nfields, use a lens instead.","title":"Core Operations - Funx.Optics.Prism","ref":"Funx.Optics.Prism.html#module-core-operations"},{"type":"module","doc":"- `compose/2`: Composes two prisms sequentially (outer then inner).\n  - `compose/1`: Composes a list of prisms into a single prism.\n\nPrisms compose naturally. Composing two prisms yields a new prism that attempts both matches in sequence,\nstopping at the first `Nothing`.","title":"Composition - Funx.Optics.Prism","ref":"Funx.Optics.Prism.html#module-composition"},{"type":"module","doc":"Prisms form a monoid under composition **for a fixed outer type `s`**.\n\nThe monoid structure is provided via `Funx.Monoid.Optics.PrismCompose`, which wraps prisms\nfor use with generic monoid operations:\n\n  - **Identity**: `make(fn x -> Maybe.from_nil(x) end, fn x -> x end)` - the identity prism\n  - **Operation**: `compose/2` - sequential composition\n\nYou can use `compose/1` to compose multiple prisms sequentially, or work directly\nwith `Funx.Monoid.Optics.PrismCompose` for more control.","title":"Monoid Structure - Funx.Optics.Prism","ref":"Funx.Optics.Prism.html#module-monoid-structure"},{"type":"module","doc":"Working with optional map keys:\n\n    iex> name_prism = Funx.Optics.Prism.key(:name)\n    iex> Funx.Optics.Prism.preview(%{name: \"Alice\"}, name_prism)\n    %Funx.Monad.Maybe.Just{value: \"Alice\"}\n    iex> Funx.Optics.Prism.preview(%{age: 30}, name_prism)\n    %Funx.Monad.Maybe.Nothing{}\n\nComposing prisms for nested access:\n\n    iex> outer = Funx.Optics.Prism.key(:person)\n    iex> inner = Funx.Optics.Prism.key(:name)\n    iex> composed = Funx.Optics.Prism.compose(outer, inner)\n    iex> Funx.Optics.Prism.preview(%{person: %{name: \"Alice\"}}, composed)\n    %Funx.Monad.Maybe.Just{value: \"Alice\"}\n    iex> Funx.Optics.Prism.preview(%{person: %{age: 30}}, composed)\n    %Funx.Monad.Maybe.Nothing{}\n\nUsing `path/1` for convenient nested access:\n\n    iex> person_name = Funx.Optics.Prism.path([:person, :name])\n    iex> Funx.Optics.Prism.preview(%{person: %{name: \"Alice\"}}, person_name)\n    %Funx.Monad.Maybe.Just{value: \"Alice\"}","title":"Examples - Funx.Optics.Prism","ref":"Funx.Optics.Prism.html#module-examples"},{"type":"type","doc":"","title":"Funx.Optics.Prism.previewer/2","ref":"Funx.Optics.Prism.html#t:previewer/2"},{"type":"type","doc":"","title":"Funx.Optics.Prism.reviewer/2","ref":"Funx.Optics.Prism.html#t:reviewer/2"},{"type":"type","doc":"","title":"Funx.Optics.Prism.t/0","ref":"Funx.Optics.Prism.html#t:t/0"},{"type":"type","doc":"","title":"Funx.Optics.Prism.t/2","ref":"Funx.Optics.Prism.html#t:t/2"},{"type":"function","doc":"","title":"Funx.Optics.Prism.compose/1","ref":"Funx.Optics.Prism.html#compose/1"},{"type":"function","doc":"Composes prisms into a single prism using sequential composition.\n\nThis delegates to the monoid append operation, which contains the\ncanonical composition logic.","title":"Funx.Optics.Prism.compose/2","ref":"Funx.Optics.Prism.html#compose/2"},{"type":"function","doc":"Composes two prisms. The outer prism runs first; if it succeeds,\nthe inner prism runs next.\n\nThis is left-to-right composition: the first parameter is applied first.\nThis differs from mathematical function composition (f ∘ g applies g first).\n\n**Sequential semantics:**\n- On `preview`: Applies outer's matcher first, then inner's matcher (short-circuits on `Nothing`)\n- On `review`: Applies inner's builder first, then outer's builder\n\nThis is sequential matching through nested structures.\n\n    iex> outer = Funx.Optics.Prism.key(:account)\n    iex> inner = Funx.Optics.Prism.key(:name)\n    iex> p = Funx.Optics.Prism.compose(outer, inner)\n    iex> Funx.Optics.Prism.preview(%{account: %{name: \"Alice\"}}, p)\n    %Funx.Monad.Maybe.Just{value: \"Alice\"}","title":"Binary composition - Funx.Optics.Prism.compose/2","ref":"Funx.Optics.Prism.html#compose/2-binary-composition"},{"type":"function","doc":"Composes a list of prisms into a single prism using sequential composition.\n\n**Sequential semantics:**\n- On `preview`: Applies matchers in list order (left-to-right), stopping at first `Nothing`\n- On `review`: Applies builders in reverse list order (right-to-left)\n\nThis is **not** a union or choice operator. It does not \"try all branches.\"\nIt is strict sequential matching and construction.\n\n    iex> prisms = [\n    ...>   Funx.Optics.Prism.key(:account),\n    ...>   Funx.Optics.Prism.key(:name)\n    ...> ]\n    iex> p = Funx.Optics.Prism.compose(prisms)\n    iex> Funx.Optics.Prism.preview(%{account: %{name: \"Alice\"}}, p)\n    %Funx.Monad.Maybe.Just{value: \"Alice\"}\n    iex> Funx.Optics.Prism.preview(%{other: %{name: \"Bob\"}}, p)\n    %Funx.Monad.Maybe.Nothing{}","title":"List composition - Funx.Optics.Prism.compose/2","ref":"Funx.Optics.Prism.html#compose/2-list-composition"},{"type":"function","doc":"Builds a prism that focuses on a single key inside a map.","title":"Funx.Optics.Prism.key/1","ref":"Funx.Optics.Prism.html#key/1"},{"type":"function","doc":"iex> p = Funx.Optics.Prism.key(:name)\n    iex> Funx.Optics.Prism.preview(%{name: \"Alice\"}, p)\n    %Funx.Monad.Maybe.Just{value: \"Alice\"}\n    iex> Funx.Optics.Prism.preview(%{age: 30}, p)\n    %Funx.Monad.Maybe.Nothing{}","title":"Examples - Funx.Optics.Prism.key/1","ref":"Funx.Optics.Prism.html#key/1-examples"},{"type":"function","doc":"Creates a custom prism from previewer and reviewer functions.\n\nThe previewer attempts to extract the focused part, returning a `Maybe`.\nThe reviewer reconstructs the whole structure from the focused part.\n\nBoth functions must maintain the prism laws for the result to be lawful.","title":"Funx.Optics.Prism.make/2","ref":"Funx.Optics.Prism.html#make/2"},{"type":"function","doc":"iex> p =\n    ...>   Funx.Optics.Prism.make(\n    ...>     fn x -> Funx.Monad.Maybe.just(x) end,\n    ...>     fn x -> x end\n    ...>   )\n    iex> Funx.Optics.Prism.preview(5, p)\n    %Funx.Monad.Maybe.Just{value: 5}","title":"Examples - Funx.Optics.Prism.make/2","ref":"Funx.Optics.Prism.html#make/2-examples"},{"type":"function","doc":"Builds a prism that focuses on a nested path through maps and structs.\n\nEach element in the path can be:\n- `:atom` - A plain key access (works with maps and structs)\n- `Module` - A naked struct verification (checks type, no key access)\n- `{Module, :atom}` - A struct-typed key access (verifies struct type and accesses key)\n\nThe syntax expands as follows:\n- `:key` → `key(:key)` - plain key access\n- `Module` → `struct(Module)` - struct type verification\n- `{Module, :key}` → `compose(struct(Module), key(:key))` - typed field access\n\nModules are distinguished from plain keys using `function_exported?(atom, :__struct__, 0)`.","title":"Funx.Optics.Prism.path/1","ref":"Funx.Optics.Prism.html#path/1"},{"type":"function","doc":"# Plain map path\n    p1 = Prism.path([:person, :bio, :age])\n    Prism.review(30, p1)\n    #=> %{person: %{bio: %{age: 30}}}\n\n    # Given struct modules:\n    defmodule Bio do\n      defstruct [:age, :location]\n    end\n\n    defmodule Person do\n      defstruct [:name, :bio]\n    end\n\n    # Struct-typed path using {Module, :key} syntax\n    p2 = Prism.path([{Person, :bio}, {Bio, :age}])\n    Prism.review(30, p2)\n    #=> %Person{bio: %Bio{age: 30, location: nil}, name: nil}\n\n    # Naked struct at end verifies final type\n    p3 = Prism.path([:profile, Bio])\n    Prism.preview(%{profile: %Bio{age: 30}}, p3)\n    #=> Just(%Bio{age: 30, location: nil})\n\n    # Naked struct at beginning verifies root type\n    p4 = Prism.path([Person, :name])\n    Prism.review(\"Alice\", p4)\n    #=> %Person{name: \"Alice\", bio: nil}\n\n    # Mix naked structs with typed field syntax\n    p5 = Prism.path([{Person, :bio}, Bio, :age])\n    Prism.review(25, p5)\n    #=> %Person{bio: %Bio{age: 25, location: nil}, name: nil}\n\n    # Naked struct only (just type verification)\n    p6 = Prism.path([Person])\n    Prism.preview(%Person{name: \"Bob\"}, p6)\n    #=> Just(%Person{name: \"Bob\", bio: nil})","title":"Examples - Funx.Optics.Prism.path/1","ref":"Funx.Optics.Prism.html#path/1-examples"},{"type":"function","doc":"The `path/1` function composes prisms using `compose/1`:\n- `:key` → `[key(:key)]`\n- `Module` → `[struct(Module)]`\n- `{Mod, :key}` → `[struct(Mod), key(:key)]`\n\nThis means `path` is just syntactic sugar for prism composition.","title":"Implementation - Funx.Optics.Prism.path/1","ref":"Funx.Optics.Prism.html#path/1-implementation"},{"type":"function","doc":"- When using `{Module, :field}`, ensure `:field` exists in `Module`\n- Using non-existent fields may violate prism laws (Kernel.struct/2 silently drops invalid keys)\n- The tuple form `{Module, :key}` requires `Module` to be a struct module (raises otherwise)\n- Plain lowercase atoms like `:user` are always treated as keys, not struct modules","title":"Important - Funx.Optics.Prism.path/1","ref":"Funx.Optics.Prism.html#path/1-important"},{"type":"function","doc":"Attempts to extract the focus from a structure using the prism.\n\nReturns a `Funx.Monad.Maybe.Just` on success or `Funx.Monad.Maybe.Nothing`\nif the branch does not match.","title":"Funx.Optics.Prism.preview/2","ref":"Funx.Optics.Prism.html#preview/2"},{"type":"function","doc":"iex> p = Funx.Optics.Prism.key(:name)\n    iex> Funx.Optics.Prism.preview(%{name: \"Alice\"}, p)\n    %Funx.Monad.Maybe.Just{value: \"Alice\"}\n    iex> Funx.Optics.Prism.preview(%{age: 30}, p)\n    %Funx.Monad.Maybe.Nothing{}","title":"Examples - Funx.Optics.Prism.preview/2","ref":"Funx.Optics.Prism.html#preview/2-examples"},{"type":"function","doc":"Reconstructs the whole structure from the focused part.\n\nReview reverses the prism, injecting the focused value back into the outer\nstructure. **Important**: `review` constructs a fresh structure from the\nfocused value alone - it does not merge with or patch an existing structure.\nThis is the lawful behaviour of prisms.\n\nIf you need to update a field while preserving other fields, you need a lens,\nnot a prism.\n\n**Note**: Cannot review with `nil` as it would violate prism laws (since\n`Just(nil)` is invalid).","title":"Funx.Optics.Prism.review/2","ref":"Funx.Optics.Prism.html#review/2"},{"type":"function","doc":"iex> p = Funx.Optics.Prism.key(:name)\n    iex> Funx.Optics.Prism.review(\"Alice\", p)\n    %{name: \"Alice\"}","title":"Examples - Funx.Optics.Prism.review/2","ref":"Funx.Optics.Prism.html#review/2-examples"},{"type":"function","doc":"Builds a prism that focuses on a specific struct constructor.\n\nThis prism succeeds only when the input value is a struct of the given module.\nIt models a *sum-type constructor*: selecting one structural variant from a\nset of possible variants.\n\nOn `review`, this prism can promote a plain map to the specified struct type,\nfilling in defaults for missing fields.","title":"Funx.Optics.Prism.struct/1","ref":"Funx.Optics.Prism.html#struct/1"},{"type":"function","doc":"# Given a struct module:\n    defmodule Account do\n      defstruct [:name, :email]\n    end\n\n    # Create a prism for that struct type\n    p = Prism.struct(Account)\n\n    # Preview succeeds for matching struct\n    Prism.preview(%Account{name: \"Alice\"}, p)\n    #=> %Just{value: %Account{name: \"Alice\", email: nil}}\n\n    # Preview fails for non-matching types\n    Prism.preview(%{name: \"Bob\"}, p)\n    #=> %Nothing{}\n\n    # Review promotes a map to the struct type\n    Prism.review(%{name: \"Charlie\"}, p)\n    #=> %Account{name: \"Charlie\", email: nil}","title":"Examples - Funx.Optics.Prism.struct/1","ref":"Funx.Optics.Prism.html#struct/1-examples"},{"type":"function","doc":"The `struct/1` prism is commonly composed with `key/1` to focus on struct fields:\n\n    user_name = Prism.compose(Prism.struct(Account), Prism.key(:name))\n    Prism.review(\"Alice\", user_name)\n    #=> %Account{name: \"Alice\", email: nil}","title":"Composition - Funx.Optics.Prism.struct/1","ref":"Funx.Optics.Prism.html#struct/1-composition"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Foptics%2Ftraversal.livemd)\n\nThe `Funx.Optics.Traversal` module provides a multi-focus optic for targeting multiple locations in a data structure.\n\nA traversal is built using `combine`, which takes multiple optics (Lens or Prism) and creates a single\noptic that can focus on all of them as a single optic.","title":"Funx.Optics.Traversal","ref":"Funx.Optics.Traversal.html"},{"type":"module","doc":"- `combine/1`: Takes a list of optics and creates a multi-focus traversal.","title":"Building Traversals - Funx.Optics.Traversal","ref":"Funx.Optics.Traversal.html#module-building-traversals"},{"type":"module","doc":"- `to_list/2`: Extracts values from lens foci and any prism foci that match.\n  - `to_list_maybe/2`: Extracts values from all foci (all-or-nothing).\n  - `preview/2`: Returns the first matching focus.\n  - `has/2`: Returns true if at least one focus matches.","title":"Read Operations - Funx.Optics.Traversal","ref":"Funx.Optics.Traversal.html#module-read-operations"},{"type":"module","doc":"- **Order preservation**: Foci are traversed in the order they were combined.\n- **Lens behavior**: Lens foci require presence and raise on violation.\n- **Prism behavior**: Prism foci contribute if they match, otherwise are skipped.\n- **combine is a monoid**: Declares multiplicity, not iteration.","title":"Key Properties - Funx.Optics.Traversal","ref":"Funx.Optics.Traversal.html#module-key-properties"},{"type":"module","doc":"iex> alias Funx.Optics.{Lens, Prism, Traversal}\n    iex> t = Traversal.combine([Lens.key(:name), Lens.key(:age)])\n    iex> Traversal.to_list(%{name: \"Alice\", age: 30}, t)\n    [\"Alice\", 30]\n\nWith Prisms (optional foci):\n\n    iex> alias Funx.Optics.{Lens, Prism, Traversal}\n    iex> t = Traversal.combine([Lens.key(:name), Prism.key(:email)])\n    iex> Traversal.to_list(%{name: \"Alice\"}, t)\n    [\"Alice\"]\n    iex> Traversal.to_list(%{name: \"Alice\", email: \"alice@example.com\"}, t)\n    [\"Alice\", \"alice@example.com\"]","title":"Examples - Funx.Optics.Traversal","ref":"Funx.Optics.Traversal.html#module-examples"},{"type":"type","doc":"","title":"Funx.Optics.Traversal.t/0","ref":"Funx.Optics.Traversal.html#t:t/0"},{"type":"function","doc":"Combines multiple optics into a single multi-focus traversal.\n\nThis is parallel composition. It widens the focus to include all provided optics.\nThe resulting traversal targets all foci simultaneously.","title":"Funx.Optics.Traversal.combine/1","ref":"Funx.Optics.Traversal.html#combine/1"},{"type":"function","doc":"iex> alias Funx.Optics.{Lens, Traversal}\n    iex> t = Traversal.combine([Lens.key(:name), Lens.key(:age)])\n    iex> Traversal.to_list(%{name: \"Alice\", age: 30}, t)\n    [\"Alice\", 30]\n\nWith composed paths:\n\n    iex> alias Funx.Optics.{Lens, Traversal}\n    iex> path = Lens.compose([Lens.key(:user), Lens.key(:name)])\n    iex> t = Traversal.combine([path, Lens.key(:score)])\n    iex> Traversal.to_list(%{user: %{name: \"Bob\"}, score: 100}, t)\n    [\"Bob\", 100]\n\nEmpty traversal (identity):\n\n    iex> alias Funx.Optics.Traversal\n    iex> t = Traversal.combine([])\n    iex> Traversal.to_list(%{name: \"Alice\"}, t)\n    []","title":"Examples - Funx.Optics.Traversal.combine/1","ref":"Funx.Optics.Traversal.html#combine/1-examples"},{"type":"function","doc":"Returns true if at least one focus matches.\n\nThis is a boolean query derived from `preview/2`:\n- Returns `true` if any focus matches\n- Returns `false` if all foci fail (Nothing)\n- Lens throws on contract violation","title":"Funx.Optics.Traversal.has/2","ref":"Funx.Optics.Traversal.html#has/2"},{"type":"function","doc":"iex> alias Funx.Optics.{Prism, Traversal}\n    iex> t = Traversal.combine([Prism.key(:name)])\n    iex> Traversal.has(%{name: \"Alice\"}, t)\n    true\n\nNo match:\n\n    iex> alias Funx.Optics.{Prism, Traversal}\n    iex> t = Traversal.combine([Prism.key(:email)])\n    iex> Traversal.has(%{name: \"Alice\"}, t)\n    false\n\nEmpty traversal:\n\n    iex> alias Funx.Optics.Traversal\n    iex> t = Traversal.combine([])\n    iex> Traversal.has(%{name: \"Alice\"}, t)\n    false","title":"Examples - Funx.Optics.Traversal.has/2","ref":"Funx.Optics.Traversal.html#has/2-examples"},{"type":"function","doc":"Returns the first successful focus from a traversal.\n\nCollapses multiple foci to at most one value using first-success semantics:\n- Returns the first `Just` and ignores later matches\n- Prism `Nothing` is skipped\n- Lens throws on contract violation\n- Traversal order determines priority","title":"Funx.Optics.Traversal.preview/2","ref":"Funx.Optics.Traversal.html#preview/2"},{"type":"function","doc":"iex> alias Funx.Optics.{Lens, Prism, Traversal}\n    iex> alias Funx.Monad.Maybe\n    iex> t = Traversal.combine([Prism.key(:email), Prism.key(:name)])\n    iex> Traversal.preview(%{name: \"Alice\"}, t)\n    %Maybe.Just{value: \"Alice\"}\n\nFirst success wins:\n\n    iex> alias Funx.Optics.{Prism, Traversal}\n    iex> alias Funx.Monad.Maybe\n    iex> t = Traversal.combine([Prism.key(:name), Prism.key(:email)])\n    iex> Traversal.preview(%{name: \"Alice\", email: \"alice@example.com\"}, t)\n    %Maybe.Just{value: \"Alice\"}\n\nNothing when no foci match:\n\n    iex> alias Funx.Optics.{Prism, Traversal}\n    iex> alias Funx.Monad.Maybe\n    iex> t = Traversal.combine([Prism.key(:email), Prism.key(:phone)])\n    iex> Traversal.preview(%{name: \"Alice\"}, t)\n    %Maybe.Nothing{}\n\nLens throws on violation:\n\n    iex> alias Funx.Optics.{Lens, Traversal}\n    iex> t = Traversal.combine([Lens.key(:email)])\n    iex> Traversal.preview(%{name: \"Alice\"}, t)\n    ** (KeyError) key :email not found in: %{name: \"Alice\"}","title":"Examples - Funx.Optics.Traversal.preview/2","ref":"Funx.Optics.Traversal.html#preview/2-examples"},{"type":"function","doc":"Extracts values from all foci into a list.\n\nFor each focus in the traversal:\n- **Lens**: Uses `view!`, contributes one value or throws on contract violation\n- **Prism**: Uses `preview`, contributes one value if matches, otherwise skips (Nothing)\n\nThe order of values matches the combine order.","title":"Funx.Optics.Traversal.to_list/2","ref":"Funx.Optics.Traversal.html#to_list/2"},{"type":"function","doc":"iex> alias Funx.Optics.{Lens, Traversal}\n    iex> t = Traversal.combine([Lens.key(:name), Lens.key(:age)])\n    iex> Traversal.to_list(%{name: \"Alice\", age: 30}, t)\n    [\"Alice\", 30]\n\nWith Prisms (skips Nothing):\n\n    iex> alias Funx.Optics.{Prism, Traversal}\n    iex> t = Traversal.combine([Prism.key(:name), Prism.key(:email)])\n    iex> Traversal.to_list(%{name: \"Alice\"}, t)\n    [\"Alice\"]\n\nOrder is preserved:\n\n    iex> alias Funx.Optics.{Lens, Traversal}\n    iex> t = Traversal.combine([Lens.key(:age), Lens.key(:name)])\n    iex> Traversal.to_list(%{name: \"Alice\", age: 30}, t)\n    [30, \"Alice\"]\n\nLens contract violation throws:\n\n    iex> alias Funx.Optics.{Lens, Traversal}\n    iex> t = Traversal.combine([Lens.key(:name)])\n    iex> Traversal.to_list(%{age: 30}, t)\n    ** (KeyError) key :name not found in: %{age: 30}","title":"Examples - Funx.Optics.Traversal.to_list/2","ref":"Funx.Optics.Traversal.html#to_list/2-examples"},{"type":"function","doc":"Extracts values from all foci into a Maybe list (all-or-nothing).\n\nThis is the all-or-nothing version of `to_list/2`. Unlike `to_list/2` which skips\nprism foci that don't match, this operation returns Nothing if any prism focus doesn't match.\n\nFor each focus in the traversal:\n- **Lens**: Uses `view!`, contributes one value or throws on contract violation\n- **Prism**: Uses `preview`, contributes one value if matches, otherwise returns Nothing for the entire operation\n\nReturns `Just(list)` only when every focus succeeds.\n\nThis is useful for enforcing co-presence: \"this structure exists in ALL these contexts.\"","title":"Funx.Optics.Traversal.to_list_maybe/2","ref":"Funx.Optics.Traversal.html#to_list_maybe/2"},{"type":"function","doc":"iex> alias Funx.Optics.{Lens, Prism, Traversal}\n    iex> alias Funx.Monad.Maybe\n    iex> t = Traversal.combine([Prism.key(:name), Prism.key(:email)])\n    iex> Traversal.to_list_maybe(%{name: \"Alice\", email: \"alice@example.com\"}, t)\n    %Maybe.Just{value: [\"Alice\", \"alice@example.com\"]}\n\nReturns Nothing if any Prism doesn't match:\n\n    iex> alias Funx.Optics.{Prism, Traversal}\n    iex> alias Funx.Monad.Maybe\n    iex> t = Traversal.combine([Prism.key(:name), Prism.key(:email)])\n    iex> Traversal.to_list_maybe(%{name: \"Alice\"}, t)\n    %Maybe.Nothing{}\n\nLens contract violation throws:\n\n    iex> alias Funx.Optics.{Lens, Traversal}\n    iex> t = Traversal.combine([Lens.key(:name)])\n    iex> Traversal.to_list_maybe(%{age: 30}, t)\n    ** (KeyError) key :name not found in: %{age: 30}","title":"Examples - Funx.Optics.Traversal.to_list_maybe/2","ref":"Funx.Optics.Traversal.html#to_list_maybe/2-examples"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Ford%2Ford.livemd)\n\nProvides utilities and DSL for working with the `Funx.Ord.Protocol`.\n\nThis module combines:\n- Utility functions for ordering and comparison\n- A declarative DSL for building complex orderings","title":"Funx.Ord","ref":"Funx.Ord.html"},{"type":"module","doc":"These functions work with types that support Elixir's comparison operators\nor implement the `Funx.Ord.Protocol`:\n\n- `contramap/2` - Transform ordering by applying a projection\n- `compare/3` - Compare two values, returns `:lt`, `:eq`, or `:gt`\n- `max/3`, `min/3` - Find maximum or minimum of two values\n- `clamp/4`, `between/4` - Range operations\n- `reverse/1` - Reverse ordering logic\n- `comparator/1` - Convert to Elixir comparator for `Enum.sort/2`\n- `to_eq/1` - Convert to equality comparator\n- `append/2`, `concat/1` - Combine multiple orderings","title":"Utility Functions - Funx.Ord","ref":"Funx.Ord.html#module-utility-functions"},{"type":"module","doc":"The DSL provides a declarative syntax for building total orderings over complex data structures.\n\nUse `use Funx.Ord` to import both utilities and DSL:\n\n    use Funx.Ord\n\n    ord do\n      asc :name\n      desc :age\n    end\n\nThe DSL compiles at compile time into efficient compositions using `contramap`, `reverse`, and `concat`,\neliminating the need to manually compose ordering functions.","title":"DSL - Funx.Ord","ref":"Funx.Ord.html#module-dsl"},{"type":"module","doc":"- `:asc` - Ascending order (smallest to largest)\n  - `:desc` - Descending order (largest to smallest)","title":"Directions - Funx.Ord","ref":"Funx.Ord.html#module-directions"},{"type":"module","doc":"- Atom - Field access via `Prism.key(atom)`. Safe for nil values.\n  - Atom with or_else - Optional field with fallback value\n  - Function - Direct projection `fn x -> ... end` or `&fun/1`\n  - Lens - Explicit lens for nested access\n  - Prism - Explicit prism for optional fields\n  - Prism with or_else - Optional with fallback\n  - Behaviour - Custom ordering via `Funx.Ord.Dsl.Behaviour`\n  - Ord variable - Existing ord map to compose\n\nSee `Funx.Ord.Dsl.Behaviour` for implementing custom ordering logic.","title":"Projection Types - Funx.Ord","ref":"Funx.Ord.html#module-projection-types"},{"type":"type","doc":"","title":"Funx.Ord.ord_map/0","ref":"Funx.Ord.html#t:ord_map/0"},{"type":"type","doc":"","title":"Funx.Ord.ord_t/0","ref":"Funx.Ord.html#t:ord_t/0"},{"type":"function","doc":"Appends two `Ord` instances, combining their comparison logic.\n\nIf the first `Ord` comparator determines an order, that result is used.\nIf not, the second comparator is used as a fallback.","title":"Funx.Ord.append/2","ref":"Funx.Ord.html#append/2"},{"type":"function","doc":"iex> ord1 = Funx.Ord.contramap(& &1.age, Funx.Ord.Protocol.Any)\n    iex> ord2 = Funx.Ord.contramap(& &1.name, Funx.Ord.Protocol.Any)\n    iex> combined = Funx.Ord.append(ord1, ord2)\n    iex> combined.lt?.(%{age: 30, name: \"Alice\"}, %{age: 30, name: \"Bob\"})\n    true","title":"Examples - Funx.Ord.append/2","ref":"Funx.Ord.html#append/2-examples"},{"type":"function","doc":"Checks if `value` is between `min` and `max`, inclusive, with an optional custom `Ord`.","title":"Funx.Ord.between/4","ref":"Funx.Ord.html#between/4"},{"type":"function","doc":"iex> Funx.Ord.between(5, 1, 10)\n    true\n\n    iex> Funx.Ord.between(0, 1, 10)\n    false\n\n    iex> Funx.Ord.between(11, 1, 10)\n    false","title":"Examples - Funx.Ord.between/4","ref":"Funx.Ord.html#between/4-examples"},{"type":"function","doc":"Clamps a value between `min` and `max`, with an optional custom `Ord`.","title":"Funx.Ord.clamp/4","ref":"Funx.Ord.html#clamp/4"},{"type":"function","doc":"iex> Funx.Ord.clamp(5, 1, 10)\n    5\n\n    iex> Funx.Ord.clamp(0, 1, 10)\n    1\n\n    iex> Funx.Ord.clamp(15, 1, 10)\n    10","title":"Examples - Funx.Ord.clamp/4","ref":"Funx.Ord.html#clamp/4-examples"},{"type":"function","doc":"Creates a comparator function from the given `Ord` module, returning `true`\nif `a` is less than or equal to `b` according to the module's ordering.\n\nUseful for sorting with `Enum.sort/2` or similar functions.","title":"Funx.Ord.comparator/1","ref":"Funx.Ord.html#comparator/1"},{"type":"function","doc":"iex> comparator = Funx.Ord.comparator(Funx.Ord.Protocol.Any)\n    iex> Enum.sort([3, 1, 2], comparator)\n    [1, 2, 3]","title":"Examples - Funx.Ord.comparator/1","ref":"Funx.Ord.html#comparator/1-examples"},{"type":"function","doc":"Compares two values and returns `:lt`, `:eq`, or `:gt`, with an optional custom `Ord`.","title":"Funx.Ord.compare/3","ref":"Funx.Ord.html#compare/3"},{"type":"function","doc":"iex> Funx.Ord.compare(3, 5)\n    :lt\n\n    iex> Funx.Ord.compare(7, 7)\n    :eq\n\n    iex> Funx.Ord.compare(9, 4)\n    :gt","title":"Examples - Funx.Ord.compare/3","ref":"Funx.Ord.html#compare/3-examples"},{"type":"function","doc":"Concatenates a list of `Ord` instances into a single composite comparator.\n\nThis function reduces a list of `Ord` comparators into a single `Ord`,\napplying them in sequence until an order is determined.","title":"Funx.Ord.concat/1","ref":"Funx.Ord.html#concat/1"},{"type":"function","doc":"iex> ord_list = [\n    ...>   Funx.Ord.contramap(& &1.age, Funx.Ord.Protocol.Any),\n    ...>   Funx.Ord.contramap(& &1.name, Funx.Ord.Protocol.Any)\n    ...> ]\n    iex> combined = Funx.Ord.concat(ord_list)\n    iex> combined.gt?.(%{age: 25, name: \"Charlie\"}, %{age: 25, name: \"Bob\"})\n    true","title":"Examples - Funx.Ord.concat/1","ref":"Funx.Ord.html#concat/1-examples"},{"type":"function","doc":"Transforms an ordering by applying a projection before comparison.","title":"Funx.Ord.contramap/2","ref":"Funx.Ord.html#contramap/2"},{"type":"function","doc":"This function defines the **single normalization point** for all projections\nin the Ord DSL. Every projection type resolves to one of these four forms:\n\n  * `Lens.t()` - Uses `view!/2` to extract the focused value (raises on missing)\n  * `Prism.t()` - Uses `preview/2`, returns `Maybe`, with `Nothing   b)` - Projection function applied directly\n\nAll DSL syntax sugar (atoms, helpers, etc.) normalizes to these types in the parser.\nThis function is the **only place** that converts optics to executable functions.\n\nThe `ord` parameter may be an `Ord` module or a custom comparator map\nwith `:lt?`, `:le?`, `:gt?`, and `:ge?` functions. The projection is applied\nto both inputs before invoking the underlying comparator.","title":"Canonical Normalization Layer - Funx.Ord.contramap/2","ref":"Funx.Ord.html#contramap/2-canonical-normalization-layer"},{"type":"function","doc":"Using a projection function:\n\n    iex> ord = Funx.Ord.contramap(&String.length/1)\n    iex> ord.lt?.(\"cat\", \"zebra\")\n    true\n    iex> ord.gt?.(\"zebra\", \"cat\")\n    true\n\nUsing a lens for single key access:\n\n    iex> ord = Funx.Ord.contramap(Funx.Optics.Lens.key(:age))\n    iex> ord.gt?.(%{age: 40}, %{age: 30})\n    true\n    iex> ord.lt?.(%{age: 30}, %{age: 40})\n    true\n\nUsing a bare prism (Nothing   prism = Funx.Optics.Prism.key(:score)\n    iex> ord = Funx.Ord.contramap(prism)\n    iex> ord.lt?.(%{}, %{score: 20})\n    true\n    iex> ord.gt?.(%{score: 30}, %{})\n    true\n\nUsing a prism with an or_else value:\n\n    iex> prism = Funx.Optics.Prism.key(:score)\n    iex> ord = Funx.Ord.contramap({prism, 0})\n    iex> ord.lt?.(%{score: 10}, %{score: 20})\n    true\n    iex> ord.lt?.(%{}, %{score: 20})\n    true\n    iex> ord.gt?.(%{score: 30}, %{})\n    true","title":"Examples - Funx.Ord.contramap/2","ref":"Funx.Ord.html#contramap/2-examples"},{"type":"function","doc":"Returns the maximum of two values, with an optional custom `Ord`.","title":"Funx.Ord.max/3","ref":"Funx.Ord.html#max/3"},{"type":"function","doc":"iex> Funx.Ord.max(3, 5)\n    5\n\n    iex> ord = Funx.Ord.contramap(&String.length/1, Funx.Ord.Protocol.Any)\n    iex> Funx.Ord.max(\"cat\", \"zebra\", ord)\n    \"zebra\"","title":"Examples - Funx.Ord.max/3","ref":"Funx.Ord.html#max/3-examples"},{"type":"function","doc":"Returns the minimum of two values, with an optional custom `Ord`.","title":"Funx.Ord.min/3","ref":"Funx.Ord.html#min/3"},{"type":"function","doc":"iex> Funx.Ord.min(10, 7)\n    7\n\n    iex> ord = Funx.Ord.contramap(&String.length/1, Funx.Ord.Protocol.Any)\n    iex> Funx.Ord.min(\"apple\", \"kiwi\", ord)\n    \"kiwi\"","title":"Examples - Funx.Ord.min/3","ref":"Funx.Ord.html#min/3-examples"},{"type":"macro","doc":"Creates an ordering from a block of projection specifications.\n\nReturns a `%Funx.Monoid.Ord{}` struct that can be used with `Funx.Ord`\nfunctions like `compare/3`, `max/3`, `min/3`, or `comparator/1`.","title":"Funx.Ord.ord/1","ref":"Funx.Ord.html#ord/1"},{"type":"macro","doc":"ord do\n      asc :name\n      desc :age\n    end\n\n    ord do\n      asc :score, or_else: 0\n      desc &String.length(&1.bio)\n    end\n\n    # With nested field paths\n    ord do\n      asc [:user, :profile, :created_at]\n      desc [:user, :stats, :score]\n    end","title":"Examples - Funx.Ord.ord/1","ref":"Funx.Ord.html#ord/1-examples"},{"type":"function","doc":"Reverses the ordering logic.","title":"Funx.Ord.reverse/1","ref":"Funx.Ord.html#reverse/1"},{"type":"function","doc":"iex> ord = Funx.Ord.reverse(Funx.Ord.Protocol.Any)\n    iex> ord.lt?.(10, 5)\n    true","title":"Examples - Funx.Ord.reverse/1","ref":"Funx.Ord.html#reverse/1-examples"},{"type":"function","doc":"Converts an `Ord` instance into an equality comparator.\n\nThis function creates a map containing two functions:\n  - `eq?/2`: Returns `true` if `a` and `b` are considered equal by the given `Ord`.\n  - `not_eq?/2`: Returns `true` if `a` and `b` are not considered equal by the given `Ord`.","title":"Funx.Ord.to_eq/1","ref":"Funx.Ord.html#to_eq/1"},{"type":"function","doc":"iex> eq = Funx.Ord.to_eq(Funx.Ord.Protocol.Any)\n    iex> eq.eq?.(5, 5)\n    true","title":"Examples - Funx.Ord.to_eq/1","ref":"Funx.Ord.html#to_eq/1-examples"},{"type":"function","doc":"","title":"Funx.Ord.to_ord_map/1","ref":"Funx.Ord.html#to_ord_map/1"},{"type":"module","doc":"Provides default ordering functions using the `Funx.Ord.Protocol`.\n\nThis module delegates to the protocol implementation for the given type,\nfalling back to Elixir's built-in comparison operators when no protocol\nimplementation exists.","title":"Funx.Ord.Any","ref":"Funx.Ord.Any.html"},{"type":"function","doc":"Returns `true` if `a` is greater than or equal to `b`.","title":"Funx.Ord.Any.ge?/2","ref":"Funx.Ord.Any.html#ge?/2"},{"type":"function","doc":"iex> Funx.Ord.Any.ge?(2, 1)\n    true\n\n    iex> Funx.Ord.Any.ge?(2, 2)\n    true","title":"Examples - Funx.Ord.Any.ge?/2","ref":"Funx.Ord.Any.html#ge?/2-examples"},{"type":"function","doc":"Returns `true` if `a` is greater than `b`.","title":"Funx.Ord.Any.gt?/2","ref":"Funx.Ord.Any.html#gt?/2"},{"type":"function","doc":"iex> Funx.Ord.Any.gt?(2, 1)\n    true\n\n    iex> Funx.Ord.Any.gt?(1, 2)\n    false","title":"Examples - Funx.Ord.Any.gt?/2","ref":"Funx.Ord.Any.html#gt?/2-examples"},{"type":"function","doc":"Returns `true` if `a` is less than or equal to `b`.","title":"Funx.Ord.Any.le?/2","ref":"Funx.Ord.Any.html#le?/2"},{"type":"function","doc":"iex> Funx.Ord.Any.le?(1, 2)\n    true\n\n    iex> Funx.Ord.Any.le?(2, 2)\n    true","title":"Examples - Funx.Ord.Any.le?/2","ref":"Funx.Ord.Any.html#le?/2-examples"},{"type":"function","doc":"Returns `true` if `a` is less than `b` according to their `Ord.Protocol` implementation.","title":"Funx.Ord.Any.lt?/2","ref":"Funx.Ord.Any.html#lt?/2"},{"type":"function","doc":"iex> Funx.Ord.Any.lt?(1, 2)\n    true\n\n    iex> Funx.Ord.Any.lt?(2, 1)\n    false","title":"Examples - Funx.Ord.Any.lt?/2","ref":"Funx.Ord.Any.html#lt?/2-examples"},{"type":"behaviour","doc":"Behaviour for custom ordering logic in the Ord DSL.\n\nImplement this behaviour to define reusable Ord comparators that can be\nused with `asc` and `desc` directives in the DSL without implementing the Ord protocol.\n\nThis is useful for teams that want to avoid teaching developers about protocols,\nor want struct-specific ordering without global protocol implementations.","title":"Funx.Ord.Dsl.Behaviour","ref":"Funx.Ord.Dsl.Behaviour.html"},{"type":"behaviour","doc":"defmodule UserById do\n      @behaviour Funx.Ord.Dsl.Behaviour\n\n      @impl true\n      def ord(_opts) do\n        Funx.Ord.contramap(&(&1.id))\n      end\n    end\n\n    # In DSL\n    use Funx.Ord.Dsl\n\n    ord do\n      asc: UserById  # Orders by id ascending\n    end","title":"Basic Example - Funx.Ord.Dsl.Behaviour","ref":"Funx.Ord.Dsl.Behaviour.html#module-basic-example"},{"type":"behaviour","doc":"defmodule UserByField do\n      @behaviour Funx.Ord.Dsl.Behaviour\n\n      @impl true\n      def ord(opts) do\n        field = Keyword.get(opts, :field, :id)\n        Funx.Ord.contramap(&Map.get(&1, field))\n      end\n    end\n\n    # In DSL\n    ord do\n      asc: UserByField, field: :name\n    end","title":"With Options - Funx.Ord.Dsl.Behaviour","ref":"Funx.Ord.Dsl.Behaviour.html#module-with-options"},{"type":"behaviour","doc":"- **Simpler**: Just one function returning an Ord map\n- **No protocol knowledge required**: Easier for team onboarding\n- **Module-specific**: Override struct ordering without global protocol\n- **Options support**: Built-in support for configuration\n\nThe returned Ord map typically uses `Funx.Ord.contramap/2` to build\nprojection-based ordering, but can implement any custom comparison logic.","title":"Why Use This Instead of Protocols? - Funx.Ord.Dsl.Behaviour","ref":"Funx.Ord.Dsl.Behaviour.html#module-why-use-this-instead-of-protocols"},{"type":"callback","doc":"Returns an Ord map for comparison.\n\nTakes options and returns an Ord map (with `:compare` function).","title":"Funx.Ord.Dsl.Behaviour.ord/1","ref":"Funx.Ord.Dsl.Behaviour.html#c:ord/1"},{"type":"callback","doc":"* `opts` - Keyword list of options passed from the DSL","title":"Arguments - Funx.Ord.Dsl.Behaviour.ord/1","ref":"Funx.Ord.Dsl.Behaviour.html#c:ord/1-arguments"},{"type":"callback","doc":"An Ord map with the structure:\n\n    %{\n      compare: (any(), any() -> :lt | :eq | :gt)\n    }","title":"Return Value - Funx.Ord.Dsl.Behaviour.ord/1","ref":"Funx.Ord.Dsl.Behaviour.html#c:ord/1-return-value"},{"type":"callback","doc":"# Simple projection-based ordering\n    def ord(_opts) do\n      Funx.Ord.contramap(&(&1.id))\n    end\n\n    # With options\n    def ord(opts) do\n      field = Keyword.get(opts, :field, :id)\n      Funx.Ord.contramap(&Map.get(&1, field))\n    end\n\n    # Custom comparison logic\n    def ord(_opts) do\n      %{\n        compare: fn a, b ->\n          cond do\n            normalize(a)   :lt\n            normalize(a) > normalize(b) -> :gt\n            true -> :eq\n          end\n        end\n      }\n    end\n\nMost implementations use `Funx.Ord.contramap/2` for projection-based\nordering, which handles the Ord map creation automatically.","title":"Examples - Funx.Ord.Dsl.Behaviour.ord/1","ref":"Funx.Ord.Dsl.Behaviour.html#c:ord/1-examples"},{"type":"protocol","doc":"The `Funx.Ord.Protocol` defines a set of comparison functions: `lt?/2`, `le?/2`, `gt?/2`, and `ge?/2`.\n\nThis protocol is intended for types that can be ordered, allowing values to be compared for their relative positions in a total order.\n\nBy implementing this protocol, you can provide custom logic for how values of a certain type are compared.","title":"Funx.Ord.Protocol","ref":"Funx.Ord.Protocol.html"},{"type":"protocol","doc":"The protocol uses `@fallback_to_any true`, which means if a specific type does not implement `Funx.Ord.Protocol`,\nthe default implementation for `Any` will be used, which relies on Elixir's built-in comparison operators.","title":"Fallback - Funx.Ord.Protocol","ref":"Funx.Ord.Protocol.html#module-fallback"},{"type":"type","doc":"All the types that implement this protocol.","title":"Funx.Ord.Protocol.t/0","ref":"Funx.Ord.Protocol.html#t:t/0"},{"type":"function","doc":"Returns `true` if `a` is greater than or equal to `b`, otherwise returns `false`.","title":"Funx.Ord.Protocol.ge?/2","ref":"Funx.Ord.Protocol.html#ge?/2"},{"type":"function","doc":"iex> Funx.Ord.Protocol.ge?(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.just(3))\n    true\n\n    iex> Funx.Ord.Protocol.ge?(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.just(5))\n    true\n\n    iex> Funx.Ord.Protocol.ge?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(5))\n    false","title":"Examples - Funx.Ord.Protocol.ge?/2","ref":"Funx.Ord.Protocol.html#ge?/2-examples"},{"type":"function","doc":"Returns `true` if `a` is greater than `b`, otherwise returns `false`.","title":"Funx.Ord.Protocol.gt?/2","ref":"Funx.Ord.Protocol.html#gt?/2"},{"type":"function","doc":"iex> Funx.Ord.Protocol.gt?(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.just(3))\n    true\n\n    iex> Funx.Ord.Protocol.gt?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(5))\n    false\n\n    iex> Funx.Ord.Protocol.gt?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.nothing())\n    true","title":"Examples - Funx.Ord.Protocol.gt?/2","ref":"Funx.Ord.Protocol.html#gt?/2-examples"},{"type":"function","doc":"Returns `true` if `a` is less than or equal to `b`, otherwise returns `false`.","title":"Funx.Ord.Protocol.le?/2","ref":"Funx.Ord.Protocol.html#le?/2"},{"type":"function","doc":"iex> Funx.Ord.Protocol.le?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(5))\n    true\n\n    iex> Funx.Ord.Protocol.le?(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.just(5))\n    true\n\n    iex> Funx.Ord.Protocol.le?(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.just(3))\n    false","title":"Examples - Funx.Ord.Protocol.le?/2","ref":"Funx.Ord.Protocol.html#le?/2-examples"},{"type":"function","doc":"Returns `true` if `a` is less than `b`, otherwise returns `false`.","title":"Funx.Ord.Protocol.lt?/2","ref":"Funx.Ord.Protocol.html#lt?/2"},{"type":"function","doc":"iex> Funx.Ord.Protocol.lt?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(5))\n    true\n\n    iex> Funx.Ord.Protocol.lt?(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.just(3))\n    false\n\n    iex> Funx.Ord.Protocol.lt?(Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.just(3))\n    true","title":"Examples - Funx.Ord.Protocol.lt?/2","ref":"Funx.Ord.Protocol.html#lt?/2-examples"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Fpredicate%2Fpredicate.livemd)\n\nProvides utility functions for working with predicates—functions that return `true` or `false`.\n\nThis module enables combining predicates in a declarative way using logical operations.","title":"Funx.Predicate","ref":"Funx.Predicate.html"},{"type":"module","doc":"The predicate algebra is built on three primitives:\n\n- `p_all/1`: Combines predicates with AND logic (structural primitive)\n- `p_any/1`: Combines predicates with OR logic (structural primitive)\n- `p_not/1`: Negates a predicate\n\nBinary convenience functions are thin wrappers over the primitives:\n\n- `p_and/2`: Binary AND, equivalent to `p_all([pred1, pred2])`\n- `p_or/2`: Binary OR, equivalent to `p_any([pred1, pred2])`\n- `p_none/1`: Negated OR, equivalent to `p_not(p_any(predicates))`\n\nThe Predicate DSL compiles exclusively to `p_all`, `p_any`, and `p_not`, treating them\nas the canonical forms.","title":"Combinator Hierarchy - Funx.Predicate","ref":"Funx.Predicate.html#module-combinator-hierarchy"},{"type":"module","doc":"The algebra allows empty lists and returns logical identity values:\n\n- `p_all([])` returns a predicate that always returns `true` (AND identity)\n- `p_any([])` returns a predicate that always returns `false` (OR identity)\n- `p_none([])` returns a predicate that always returns `true` (negated OR identity)\n\nThe Predicate DSL also supports empty blocks, returning the same identity values:\n\n- `all do end` returns `fn _ -> true end` (AND identity)\n- `any do end` returns `fn _ -> false end` (OR identity)\n- `negate_all do end` returns `fn _ -> false end` (NOT true)\n- `negate_any do end` returns `fn _ -> true end` (NOT false)","title":"Empty List Semantics - Funx.Predicate","ref":"Funx.Predicate.html#module-empty-list-semantics"},{"type":"module","doc":"","title":"Examples - Funx.Predicate","ref":"Funx.Predicate.html#module-examples"},{"type":"module","doc":"iex> is_adult = fn person -> person.age >= 18 end\n    iex> has_ticket = fn person -> person.tickets > 0 end\n    iex> can_enter = Funx.Predicate.p_and(is_adult, has_ticket)\n    iex> can_enter.(%{age: 20, tickets: 1})\n    true\n    iex> can_enter.(%{age: 16, tickets: 1})\n    false","title":"Combining predicates with p_and/2: - Funx.Predicate","ref":"Funx.Predicate.html#module-combining-predicates-with-p_and-2"},{"type":"module","doc":"iex> is_vip = fn person -> person.vip end\n    iex> is_sponsor = fn person -> person.sponsor end\n    iex> can_access_vip_area = Funx.Predicate.p_or(is_vip, is_sponsor)\n    iex> can_access_vip_area.(%{vip: true, sponsor: false})\n    true\n    iex> can_access_vip_area.(%{vip: false, sponsor: false})\n    false","title":"Using p_or/2 for alternative conditions: - Funx.Predicate","ref":"Funx.Predicate.html#module-using-p_or-2-for-alternative-conditions"},{"type":"module","doc":"iex> is_minor = fn person -> person.age < 18 end\n    iex> is_adult = Funx.Predicate.p_not(is_minor)\n    iex> is_adult.(%{age: 20})\n    true\n    iex> is_adult.(%{age: 16})\n    false","title":"Negating predicates with p_not/1: - Funx.Predicate","ref":"Funx.Predicate.html#module-negating-predicates-with-p_not-1"},{"type":"module","doc":"iex> is_adult = fn person -> person.age >= 18 end\n    iex> has_ticket = fn person -> person.tickets > 0 end\n    iex> conditions = [is_adult, has_ticket]\n    iex> must_meet_all = Funx.Predicate.p_all(conditions)\n    iex> must_meet_any = Funx.Predicate.p_any(conditions)\n    iex> must_meet_all.(%{age: 20, tickets: 1})\n    true\n    iex> must_meet_all.(%{age: 20, tickets: 0})\n    false\n    iex> must_meet_any.(%{age: 20, tickets: 0})\n    true\n    iex> must_meet_any.(%{age: 16, tickets: 0})\n    false","title":"Using p_all/1 and p_any/1 for predicate lists: - Funx.Predicate","ref":"Funx.Predicate.html#module-using-p_all-1-and-p_any-1-for-predicate-lists"},{"type":"module","doc":"iex> is_adult = fn person -> person.age >= 18 end\n    iex> is_vip = fn person -> person.vip end\n    iex> cannot_enter = Funx.Predicate.p_none([is_adult, is_vip])\n    iex> cannot_enter.(%{age: 20, vip: true})\n    false\n    iex> cannot_enter.(%{age: 16, vip: false})\n    true","title":"Using p_none/1 to reject multiple conditions: - Funx.Predicate","ref":"Funx.Predicate.html#module-using-p_none-1-to-reject-multiple-conditions"},{"type":"type","doc":"","title":"Funx.Predicate.t/0","ref":"Funx.Predicate.html#t:t/0"},{"type":"function","doc":"Composes a projection (optic or function) with a predicate.\n\nThis allows checking predicates on projected values (focused parts of data).","title":"Funx.Predicate.compose_projection/2","ref":"Funx.Predicate.html#compose_projection/2"},{"type":"function","doc":"","title":"Projection Types and Semantics - Funx.Predicate.compose_projection/2","ref":"Funx.Predicate.html#compose_projection/2-projection-types-and-semantics"},{"type":"function","doc":"- **Semantics**: Always focuses on a single value\n- **Success**: Applies predicate to the focused value\n- **Failure**: Raises if field is missing (total projection contract)\n- **Note**: The raising behavior is enforced by the Lens implementation (`lens.view/1`),\n  not by this composition function. This function delegates to the Lens contract.","title":"Lens (Total Projection) - Funx.Predicate.compose_projection/2","ref":"Funx.Predicate.html#compose_projection/2-lens-total-projection"},{"type":"function","doc":"- **Semantics**: May focus on a value (returns Maybe monad)\n- **Success**: When focus succeeds (Just), applies predicate to unwrapped value\n- **Failure**: When focus fails (Nothing), returns `false` without applying predicate\n- **Contract**: Missing or nil values return `false`, not an error","title":"Prism (Partial Projection) - Funx.Predicate.compose_projection/2","ref":"Funx.Predicate.html#compose_projection/2-prism-partial-projection"},{"type":"function","doc":"- **Semantics**: Focuses on zero or more values (returns list of foci)\n- **Success**: Returns `true` if **at least one** focused value passes the predicate (existential)\n- **Failure**: Returns `false` if **all** focused values fail or if no foci exist\n- **Contract**: Uses existential quantification (∃), not universal (∀)","title":"Traversal (Multi-Focus Projection) - Funx.Predicate.compose_projection/2","ref":"Funx.Predicate.html#compose_projection/2-traversal-multi-focus-projection"},{"type":"function","doc":"- **Semantics**: Projects value using the provided function\n- **Success**: Applies predicate to the function result\n- **Failure**: No built-in failure mode; function must handle edge cases","title":"Function (Custom Projection) - Funx.Predicate.compose_projection/2","ref":"Funx.Predicate.html#compose_projection/2-function-custom-projection"},{"type":"function","doc":"When a projection fails to focus on a value:\n- **Prism**: Returns `false` (graceful degradation)\n- **Traversal** (empty foci): Returns `false`\n- **Lens**: Raises error (total projection contract violation)\n- **Function**: Depends on function implementation","title":"Projection Failure Behavior - Funx.Predicate.compose_projection/2","ref":"Funx.Predicate.html#compose_projection/2-projection-failure-behavior"},{"type":"function","doc":"iex> alias Funx.Optics.Prism\n    iex> is_adult = fn age -> age >= 18 end\n    iex> check = Funx.Predicate.compose_projection(Prism.key(:age), is_adult)\n    iex> check.(%{age: 20})\n    true\n    iex> check.(%{age: 16})\n    false\n    iex> check.(%{})  # Missing key returns false\n    false\n\n    iex> alias Funx.Optics.Lens\n    iex> is_long = fn s -> String.length(s) > 5 end\n    iex> check = Funx.Predicate.compose_projection(Lens.key(:name), is_long)\n    iex> check.(%{name: \"Alexander\"})\n    true\n    iex> check.(%{name: \"Joe\"})\n    false\n\n    iex> alias Funx.Optics.Traversal\n    iex> # Traversal: predicate receives list of foci to relate them\n    iex> has_high_score = fn scores -> Enum.any?(scores, fn score -> score > 90 end) end\n    iex> check = Funx.Predicate.compose_projection(\n    ...>   Traversal.combine([Lens.key(:score1), Lens.key(:score2)]),\n    ...>   has_high_score\n    ...> )\n    iex> check.(%{score1: 95, score2: 80})  # At least one score > 90\n    true\n    iex> check.(%{score1: 80, score2: 85})  # No scores > 90\n    false","title":"Examples - Funx.Predicate.compose_projection/2","ref":"Funx.Predicate.html#compose_projection/2-examples"},{"type":"function","doc":"Combines a list of predicates (`p_list`) using logical AND.\nReturns `true` only if all predicates return `true`. An empty list returns `true`.","title":"Funx.Predicate.p_all/1","ref":"Funx.Predicate.html#p_all/1"},{"type":"function","doc":"iex> is_adult = fn person -> person.age >= 18 end\n    iex> has_ticket = fn person -> person.tickets > 0 end\n    iex> can_enter = Funx.Predicate.p_all([is_adult, has_ticket])\n    iex> can_enter.(%{age: 20, tickets: 1})\n    true\n    iex> can_enter.(%{age: 16, tickets: 1})\n    false","title":"Examples - Funx.Predicate.p_all/1","ref":"Funx.Predicate.html#p_all/1-examples"},{"type":"function","doc":"Combines two predicates (`pred1` and `pred2`) using logical AND.\nReturns a predicate that evaluates to `true` only if both `pred1` and `pred2` return `true`.","title":"Funx.Predicate.p_and/2","ref":"Funx.Predicate.html#p_and/2"},{"type":"function","doc":"iex> is_adult = fn person -> person.age >= 18 end\n    iex> has_ticket = fn person -> person.tickets > 0 end\n    iex> can_enter = Funx.Predicate.p_and(is_adult, has_ticket)\n    iex> can_enter.(%{age: 20, tickets: 1})\n    true\n    iex> can_enter.(%{age: 16, tickets: 1})\n    false","title":"Examples - Funx.Predicate.p_and/2","ref":"Funx.Predicate.html#p_and/2-examples"},{"type":"function","doc":"Combines a list of predicates (`p_list`) using logical OR.\nReturns `true` if at least one predicate returns `true`. An empty list returns `false`.","title":"Funx.Predicate.p_any/1","ref":"Funx.Predicate.html#p_any/1"},{"type":"function","doc":"iex> is_vip = fn person -> person.vip end\n    iex> is_sponsor = fn person -> person.sponsor end\n    iex> can_access_vip_area = Funx.Predicate.p_any([is_vip, is_sponsor])\n    iex> can_access_vip_area.(%{vip: true, sponsor: false})\n    true\n    iex> can_access_vip_area.(%{vip: false, sponsor: false})\n    false","title":"Examples - Funx.Predicate.p_any/1","ref":"Funx.Predicate.html#p_any/1-examples"},{"type":"function","doc":"Combines a list of predicates (`p_list`) using logical NOR (negated OR).\nReturns `true` only if **none** of the predicates return `true`. An empty list returns `true`.","title":"Funx.Predicate.p_none/1","ref":"Funx.Predicate.html#p_none/1"},{"type":"function","doc":"iex> is_adult = fn person -> person.age >= 18 end\n    iex> is_vip = fn person -> person.vip end\n    iex> cannot_enter = Funx.Predicate.p_none([is_adult, is_vip])\n    iex> cannot_enter.(%{age: 20, vip: true})\n    false\n    iex> cannot_enter.(%{age: 16, vip: false})\n    true","title":"Examples - Funx.Predicate.p_none/1","ref":"Funx.Predicate.html#p_none/1-examples"},{"type":"function","doc":"Negates a predicate (`pred`).\nReturns a predicate that evaluates to `true` when `pred` returns `false`, and vice versa.","title":"Funx.Predicate.p_not/1","ref":"Funx.Predicate.html#p_not/1"},{"type":"function","doc":"iex> is_minor = fn person -> person.age < 18 end\n    iex> is_adult = Funx.Predicate.p_not(is_minor)\n    iex> is_adult.(%{age: 20})\n    true\n    iex> is_adult.(%{age: 16})\n    false","title":"Examples - Funx.Predicate.p_not/1","ref":"Funx.Predicate.html#p_not/1-examples"},{"type":"function","doc":"Combines two predicates (`pred1` and `pred2`) using logical OR.\nReturns a predicate that evaluates to `true` if either `pred1` or `pred2` return `true`.","title":"Funx.Predicate.p_or/2","ref":"Funx.Predicate.html#p_or/2"},{"type":"function","doc":"iex> is_vip = fn person -> person.vip end\n    iex> is_sponsor = fn person -> person.sponsor end\n    iex> can_access_vip_area = Funx.Predicate.p_or(is_vip, is_sponsor)\n    iex> can_access_vip_area.(%{vip: true, sponsor: false})\n    true\n    iex> can_access_vip_area.(%{vip: false, sponsor: false})\n    false","title":"Examples - Funx.Predicate.p_or/2","ref":"Funx.Predicate.html#p_or/2-examples"},{"type":"macro","doc":"Creates a predicate from a block of predicate compositions.\n\nReturns a function `(any() -> boolean())` that can be used with `Enum.filter`,\n`Enum.find`, and other functions that accept predicates.","title":"Funx.Predicate.pred/1","ref":"Funx.Predicate.html#pred/1"},{"type":"macro","doc":"- Bare predicate - Include predicate in composition\n  - `negate` - Negate the predicate\n  - `check` - Compose projection with predicate (check projected value)\n  - `any` - At least one nested predicate must pass (OR logic)\n  - `all` - All nested predicates must pass (AND logic, implicit at top level)","title":"Directives - Funx.Predicate.pred/1","ref":"Funx.Predicate.html#pred/1-directives"},{"type":"macro","doc":"The DSL accepts predicates in multiple forms:","title":"Predicate Forms - Funx.Predicate.pred/1","ref":"Funx.Predicate.html#pred/1-predicate-forms"},{"type":"macro","doc":"When a predicate is bound to a variable, reference it directly:\n\n    is_adult = fn user -> user.age >= 18 end\n\n    pred do\n      is_adult  # Variable reference - no () needed\n    end","title":"Variables (no parentheses needed) - Funx.Predicate.pred/1","ref":"Funx.Predicate.html#pred/1-variables-no-parentheses-needed"},{"type":"macro","doc":"When using 0-arity functions that return predicates, call them with `()`:\n\n    defmodule Helpers do\n      def adult?, do: fn user -> user.age >= 18 end\n    end\n\n    pred do\n      Helpers.adult?()  # Must call with () to get the predicate\n    end\n\n**Why `()` is required**: The DSL cannot distinguish at compile time between\na function reference and a function call. Using `()` makes the intent explicit\nand ensures the predicate function is retrieved.","title":"Helper Functions (parentheses required) - Funx.Predicate.pred/1","ref":"Funx.Predicate.html#pred/1-helper-functions-parentheses-required"},{"type":"macro","doc":"Define predicates inline using `fn`:\n\n    pred do\n      fn user -> user.age >= 18 end\n    end","title":"Anonymous Functions (inline) - Funx.Predicate.pred/1","ref":"Funx.Predicate.html#pred/1-anonymous-functions-inline"},{"type":"macro","doc":"Use the capture operator `&` for named functions:\n\n    pred do\n      &adult?/1\n    end","title":"Captured Functions - Funx.Predicate.pred/1","ref":"Funx.Predicate.html#pred/1-captured-functions"},{"type":"macro","doc":"For reusable validation logic, implement `Funx.Predicate.Dsl.Behaviour`:\n\n    defmodule IsActive do\n      @behaviour Funx.Predicate.Dsl.Behaviour\n\n      def pred(_opts), do: fn user -> user.active end\n    end\n\n    pred do\n      IsActive              # Bare module reference\n      {HasMinimumAge, minimum: 21}  # With options\n    end","title":"Behaviour Modules - Funx.Predicate.pred/1","ref":"Funx.Predicate.html#pred/1-behaviour-modules"},{"type":"macro","doc":"use Funx.Predicate\n\n    # Simple composition (implicit AND)\n    pred do\n      is_adult\n      has_ticket\n    end\n\n    # With any block (OR logic)\n    pred do\n      is_admin\n\n      any do\n        is_vip\n        is_sponsor\n      end\n    end\n\n    # With negation\n    pred do\n      is_verified\n      negate is_banned\n    end\n\n    # With projection (check directive)\n    pred do\n      is_adult\n      check :email, fn email -> String.contains?(email, \"@\") end\n    end\n\n    # With nested field projection (list paths)\n    pred do\n      check [:user, :profile, :age], fn age -> age >= 18 end\n      check [:user, :settings, :notifications], fn n -> n == true end\n    end\n\n    # With negated projection\n    pred do\n      is_adult\n      negate check :banned, fn b -> b == true end\n    end\n\n    # Complex nesting\n    pred do\n      any do\n        all do\n          is_admin\n          is_verified\n        end\n\n        all do\n          is_moderator\n          has_permission\n        end\n      end\n\n      negate is_suspended\n    end","title":"Examples - Funx.Predicate.pred/1","ref":"Funx.Predicate.html#pred/1-examples"},{"type":"behaviour","doc":"Behaviour for custom predicate logic in the Predicate DSL.\n\nImplement this behaviour to define reusable predicates that can be\nused with `on` directives in the DSL.\n\nThis is useful for teams that want to create reusable, configurable\npredicates without repeating logic across the codebase.","title":"Funx.Predicate.Dsl.Behaviour","ref":"Funx.Predicate.Dsl.Behaviour.html"},{"type":"behaviour","doc":"defmodule IsActive do\n      @behaviour Funx.Predicate.Dsl.Behaviour\n\n      @impl true\n      def pred(_opts) do\n        fn user -> user.active end\n      end\n    end\n\n    # In DSL\n    use Funx.Predicate\n\n    pred do\n      on IsActive  # Checks if active\n    end","title":"Basic Example - Funx.Predicate.Dsl.Behaviour","ref":"Funx.Predicate.Dsl.Behaviour.html#module-basic-example"},{"type":"behaviour","doc":"defmodule HasMinimumAge do\n      @behaviour Funx.Predicate.Dsl.Behaviour\n\n      @impl true\n      def pred(opts) do\n        minimum_age = Keyword.get(opts, :minimum, 18)\n\n        fn user -> user.age >= minimum_age end\n      end\n    end\n\n    # In DSL\n    pred do\n      on HasMinimumAge, minimum: 21\n    end","title":"With Options - Funx.Predicate.Dsl.Behaviour","ref":"Funx.Predicate.Dsl.Behaviour.html#module-with-options"},{"type":"behaviour","doc":"- **Reusable**: Define predicates once, use everywhere\n- **Configurable**: Built-in support for options\n- **Testable**: Predicates can be unit tested independently\n- **Discoverable**: All predicates in one module namespace\n\nThe returned predicate is a function `(any() -> boolean())` that will be\ncomposed with other predicates using the DSL's combinator logic.","title":"Why Use This? - Funx.Predicate.Dsl.Behaviour","ref":"Funx.Predicate.Dsl.Behaviour.html#module-why-use-this"},{"type":"callback","doc":"Returns a predicate function.\n\nTakes options and returns a predicate function `(any() -> boolean())`.","title":"Funx.Predicate.Dsl.Behaviour.pred/1","ref":"Funx.Predicate.Dsl.Behaviour.html#c:pred/1"},{"type":"callback","doc":"* `opts` - Keyword list of options passed from the DSL","title":"Arguments - Funx.Predicate.Dsl.Behaviour.pred/1","ref":"Funx.Predicate.Dsl.Behaviour.html#c:pred/1-arguments"},{"type":"callback","doc":"A predicate function with the signature:\n\n    (any() -> boolean())","title":"Return Value - Funx.Predicate.Dsl.Behaviour.pred/1","ref":"Funx.Predicate.Dsl.Behaviour.html#c:pred/1-return-value"},{"type":"callback","doc":"# Simple predicate\n    def pred(_opts) do\n      fn user -> user.active end\n    end\n\n    # With options\n    def pred(opts) do\n      field = Keyword.get(opts, :field, :active)\n      fn item -> Map.get(item, field) end\n    end\n\n    # Complex logic\n    def pred(opts) do\n      min_age = Keyword.get(opts, :min_age, 18)\n      max_age = Keyword.get(opts, :max_age, 65)\n\n      fn user ->\n        user.age >= min_age and user.age <= max_age\n      end\n    end\n\nMost implementations return simple predicate functions that check\nspecific conditions on the input value.","title":"Examples - Funx.Predicate.Dsl.Behaviour.pred/1","ref":"Funx.Predicate.Dsl.Behaviour.html#c:pred/1-examples"},{"type":"protocol","doc":"","title":"Funx.Summarizable","ref":"Funx.Summarizable.html"},{"type":"type","doc":"All the types that implement this protocol.","title":"Funx.Summarizable.t/0","ref":"Funx.Summarizable.html#t:t/0"},{"type":"function","doc":"Summarizes a value in a telemetry-safe, compact format.","title":"Funx.Summarizable.summarize/1","ref":"Funx.Summarizable.html#summarize/1"},{"type":"protocol","doc":"","title":"Funx.Tappable","ref":"Funx.Tappable.html"},{"type":"type","doc":"All the types that implement this protocol.","title":"Funx.Tappable.t/0","ref":"Funx.Tappable.html#t:t/0"},{"type":"function","doc":"","title":"Funx.Tappable.tap/2","ref":"Funx.Tappable.html#tap/2"},{"type":"module","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Futilities%2Futils.livemd)\n\nA collection of higher-order functions for functional programming in Elixir.\n\nThis module provides utilities for working with functions in a functional\nprogramming style. It includes:\n\n- `curry/1`: Transforms a multi-argument function into a curried version.\n- `curry_r/1`: Transforms a multi-argument function into a curried version, but from right to left.\n- `flip/1`: Reverses the argument order of a two-argument function.","title":"Funx.Utils","ref":"Funx.Utils.html"},{"type":"function","doc":"Transforms a function of arity `n` into a curried version,\nallowing it to be applied one argument at a time.","title":"Funx.Utils.curry/1","ref":"Funx.Utils.html#curry/1"},{"type":"function","doc":"iex> add = fn a, b -> a + b end\n    iex> curried_add = FunPark.Utils.curry(add)\n    iex> add_three = curried_add.(3)\n    iex> add_three.(2)\n    5","title":"Example - Funx.Utils.curry/1","ref":"Funx.Utils.html#curry/1-example"},{"type":"function","doc":"Alias for `curry/1`, explicitly denoting left-to-right argument application.","title":"Funx.Utils.curry_l/1","ref":"Funx.Utils.html#curry_l/1"},{"type":"function","doc":"iex> subtract = fn a, b -> a - b end\n    iex> curried_subtract = FunPark.Utils.curry_l(subtract)\n    iex> subtract_five = curried_subtract.(5)\n    iex> subtract_five.(3)\n    2","title":"Example - Funx.Utils.curry_l/1","ref":"Funx.Utils.html#curry_l/1-example"},{"type":"function","doc":"Transforms a function of arity `n` into a right-curried version,\napplying arguments from right to left.","title":"Funx.Utils.curry_r/1","ref":"Funx.Utils.html#curry_r/1"},{"type":"function","doc":"iex> divide = fn a, b -> a / b end\n    iex> curried_divide = FunPark.Utils.curry_r(divide)\n    iex> divide_by_two = curried_divide.(2)\n    iex> divide_by_two.(10)\n    5.0","title":"Example - Funx.Utils.curry_r/1","ref":"Funx.Utils.html#curry_r/1-example"},{"type":"function","doc":"Reverses the argument order of a two-argument function.\n\nThe `flip/1` function takes a function of arity 2 and returns a new function\nwhere the first and second arguments are swapped.","title":"Funx.Utils.flip/1","ref":"Funx.Utils.html#flip/1"},{"type":"function","doc":"iex> divide = fn a, b -> a / b end\n    iex> flipped_divide = Utils.flip(divide)\n    iex> flipped_divide.(2, 10)\n    5.0","title":"Examples - Funx.Utils.flip/1","ref":"Funx.Utils.html#flip/1-examples"},{"type":"function","doc":"","title":"Funx.Utils.summarize_string/2","ref":"Funx.Utils.html#summarize_string/2"},{"type":"module","doc":"Declarative validation DSL using optics and applicative error accumulation.","title":"Funx.Validate","ref":"Funx.Validate.html"},{"type":"module","doc":"The Validation DSL provides:\n- Declarative syntax for validating nested structures\n- Projection to fields using optics (Lens, Prism, Traversal)\n- Applicative error accumulation (all validators run, all errors collected)\n- Structure preservation (returns original value on success)","title":"Overview - Funx.Validate","ref":"Funx.Validate.html#module-overview"},{"type":"module","doc":"use Funx.Validate\n\n    user_validation =\n      validate do\n        at :name, [Required, {MinLength, min: 3}]\n        at :email, [Required, Email]\n      end\n\n    Either.validate(%{name: \"Alice\", email: \"alice@example.com\"}, user_validation)\n    #=> %Right{right: %{name: \"Alice\", email: \"alice@example.com\"}}","title":"Usage - Funx.Validate","ref":"Funx.Validate.html#module-usage"},{"type":"module","doc":"1. **Identity**: `validate do end` returns `Right(value)`\n2. **Structure Preservation**: Successful validation returns original structure\n3. **Applicative**: All validators run; all errors accumulate","title":"Laws - Funx.Validate","ref":"Funx.Validate.html#module-laws"},{"type":"module","doc":"The DSL compiles in two phases:\n1. **Parser** - Converts DSL syntax into Step nodes\n2. **Executor** - Converts Step nodes into executable validator function","title":"Architecture - Funx.Validate","ref":"Funx.Validate.html#module-architecture"},{"type":"type","doc":"","title":"Funx.Validate.t/0","ref":"Funx.Validate.html#t:t/0"},{"type":"macro","doc":"Defines a validation using the DSL.\n\nReturns a validator function compatible with `Either.validate/2,3`.","title":"Funx.Validate.validate/2","ref":"Funx.Validate.html#validate/2"},{"type":"macro","doc":"","title":"Syntax - Funx.Validate.validate/2","ref":"Funx.Validate.html#validate/2-syntax"},{"type":"macro","doc":"validate do\n      HasContactMethod\n      ValidTimezone\n    end","title":"Root Validators - Funx.Validate.validate/2","ref":"Funx.Validate.html#validate/2-root-validators"},{"type":"macro","doc":"validate do\n      at :name, Required\n      at :email, Email\n    end\n\nBy default, `at :key` uses `Prism.key(:key)` (optional field).","title":"Field Validation with at - Funx.Validate.validate/2","ref":"Funx.Validate.html#validate/2-field-validation-with-at"},{"type":"macro","doc":"validate do\n      at [:user, :profile, :name], Required\n      at [:user, :profile, :age], Positive\n    end\n\nList paths support struct modules for type-safe nested access:\n\n    validate do\n      at [User, :profile, Profile, :age], Positive\n    end","title":"Nested Field Validation (List Paths) - Funx.Validate.validate/2","ref":"Funx.Validate.html#validate/2-nested-field-validation-list-paths"},{"type":"macro","doc":"validate do\n      # Prism: optional field\n      at Prism.key(:email), Email\n\n      # Lens: required field (raises KeyError if missing)\n      at Lens.key(:name), Required\n    end","title":"Explicit Optics - Funx.Validate.validate/2","ref":"Funx.Validate.html#validate/2-explicit-optics"},{"type":"macro","doc":"validate do\n      at :name, {MinLength, min: 3}\n    end","title":"Validator Options - Funx.Validate.validate/2","ref":"Funx.Validate.html#validate/2-validator-options"},{"type":"macro","doc":"validate do\n      at :name, [Required, {MinLength, min: 3}]\n    end\n\nValidators run sequentially left-to-right.","title":"Multiple Validators per Field - Funx.Validate.validate/2","ref":"Funx.Validate.html#validate/2-multiple-validators-per-field"},{"type":"macro","doc":"# Sequential mode (default): fail-fast, short-circuits on first error\n    validate mode: :sequential do\n      at :name, Required\n      at :email, Email\n    end\n\n    # Parallel mode: runs all validations, accumulates all errors\n    validate mode: :parallel do\n      at :name, Required\n      at :email, Email\n    end","title":"Validation Modes - Funx.Validate.validate/2","ref":"Funx.Validate.html#validate/2-validation-modes"},{"type":"macro","doc":"validate do\n      at :name, Required\n      at :email, [Required, Email]\n      at :age, Positive\n    end","title":"Examples - Funx.Validate.validate/2","ref":"Funx.Validate.html#validate/2-examples"},{"type":"behaviour","doc":"Behaviour for validation functions.\n\nAll validators follow a consistent arity-3 signature, matching other DSL behaviours in Funx.","title":"Funx.Validate.Behaviour","ref":"Funx.Validate.Behaviour.html"},{"type":"behaviour","doc":"```elixir\n@callback validate(value :: any(), opts :: keyword(), env :: map()) ::\n  Funx.Monad.Either.t(any(), Funx.Errors.ValidationError.t())\n  | :ok\n  | {:ok, any()}\n  | {:error, Funx.Errors.ValidationError.t()}\n```","title":"Contract - Funx.Validate.Behaviour","ref":"Funx.Validate.Behaviour.html#module-contract"},{"type":"behaviour","doc":"- `value` - The value to validate (may be transformed by previous validators)\n- `opts` - Keyword list of options (validator-specific configuration)\n- `env` - Environment map (runtime context like database connections, session data)","title":"Arguments - Funx.Validate.Behaviour","ref":"Funx.Validate.Behaviour.html#module-arguments"},{"type":"behaviour","doc":"**Canonical (preferred)**:\n- `Either.right(value)` - Validation passed, return original or transformed value\n- `Either.left(ValidationError.t())` - Validation failed with error\n\n**Legacy (supported via normalization)**:\n- `:ok` - Validation passed, return original value\n- `{:ok, value}` - Validation passed with transformation\n- `{:error, ValidationError.t()}` - Validation failed","title":"Return Values - Funx.Validate.Behaviour","ref":"Funx.Validate.Behaviour.html#module-return-values"},{"type":"behaviour","doc":"1. **Arguments strictly ordered**: value, opts, env\n2. **Either is canonical** (tagged tuples normalized by DSL)\n3. **Value transformation allowed** (sequential within focus)\n4. **Never raise for validation failure** (use Left/error tuple)\n5. **Return ValidationError** for errors (not raw strings)\n6. **Concurrency-safe** by contract","title":"Semantic Rules - Funx.Validate.Behaviour","ref":"Funx.Validate.Behaviour.html#module-semantic-rules"},{"type":"behaviour","doc":"All validators should support a `:message` option for custom error messages:\n\n- **String**: `[message: \"custom error\"]`\n- **Function**: `[message: fn value -> \"got #{inspect(value)}\" end]`\n\nWhen a function is provided, it receives the current value being validated.","title":"Message Option - Funx.Validate.Behaviour","ref":"Funx.Validate.Behaviour.html#module-message-option"},{"type":"behaviour","doc":"```elixir\ndefmodule MyValidator do\n  @behaviour Funx.Validate.Behaviour\n  alias Funx.Monad.Either\n  alias Funx.Errors.ValidationError\n\n  @impl true\n  def validate(value, opts, _env) do\n    if valid?(value) do\n      Either.right(value)\n    else\n      message = get_message(opts, value, \"default error message\")\n      Either.left(ValidationError.new(message))\n    end\n  end\n\n  defp get_message(opts, value, default) do\n    case Keyword.get(opts, :message) do\n      nil -> default\n      msg when is_binary(msg) -> msg\n      msg_fn when is_function(msg_fn, 1) -> msg_fn.(value)\n    end\n  end\nend\n```","title":"Example - Funx.Validate.Behaviour","ref":"Funx.Validate.Behaviour.html#module-example"},{"type":"callback","doc":"","title":"Funx.Validate.Behaviour.validate/3","ref":"Funx.Validate.Behaviour.html#c:validate/3"},{"type":"behaviour","doc":"Macro for building custom validators with minimal boilerplate.\n\nUsers creating custom validators (e.g., database checks, API validations) can use\nthis macro to avoid reimplementing the standard validator pattern. The macro\ngenerates all the boilerplate including arity overloads, Maybe handling, message\nbuilding, and Either wrapping.","title":"Funx.Validator","ref":"Funx.Validator.html"},{"type":"behaviour","doc":"This module defines two separate behaviours:\n\n1. **`Funx.Validate.Behaviour`** - The public contract for all validators.\n   Defines `validate/3` which returns `Either.t(value, ValidationError.t())`.\n   This is what the validation DSL and consumers interact with.\n\n2. **`Funx.Validator`** - The callback contract for users of this macro.\n   Defines `validate_value/3` (returns boolean) and `default_message/1` (returns string).\n   This is the simplified API for implementing custom validation logic.\n\nThe macro generates the `Funx.Validate.Behaviour` implementation from your\n`Funx.Validator` callbacks.","title":"Two Behaviours - Funx.Validator","ref":"Funx.Validator.html#module-two-behaviours"},{"type":"behaviour","doc":"Users implement one required callback (and optionally a second):\n\n- `valid?/3` - Predicate function that returns `true` or `false` (required)\n- `default_message/2` - Returns a plain string error message (optional)\n\nIf `default_message/2` is not implemented, a generic \"is invalid\" message is used.\n\nNo need to know about `Either`, `ValidationError`, or `Maybe` - the macro\nhandles all functional programming complexity.","title":"User API - Funx.Validator","ref":"Funx.Validator.html#module-user-api"},{"type":"behaviour","doc":"# Minimal - just implement valid?/3\n    defmodule MyApp.Validators.UniqueEmail do\n      use Funx.Validator\n\n      @impl Funx.Validator\n      def valid?(email, _opts, _env) do\n        not MyApp.Repo.exists?(User, email: email)\n      end\n      # Uses default \"is invalid\" message\n    end\n\n    # With custom message\n    defmodule MyApp.Validators.UniqueEmailWithMessage do\n      use Funx.Validator\n\n      @impl Funx.Validator\n      def valid?(email, _opts, _env) do\n        not MyApp.Repo.exists?(User, email: email)\n      end\n\n      @impl Funx.Validator\n      def default_message(_value, _opts) do\n        \"email is already taken\"\n      end\n    end\n\n    # With custom type checking (if needed)\n    defmodule MyApp.Validators.CustomNumber do\n      use Funx.Validator\n\n      @impl Funx.Validator\n      def valid?(num, _opts, _env) when is_number(num) do\n        custom_number_check(num)\n      end\n\n      def valid?(_non_number, _opts, _env), do: false\n\n      @impl Funx.Validator\n      def default_message(_value), do: \"must be a valid number\"\n    end","title":"Examples - Funx.Validator","ref":"Funx.Validator.html#module-examples"},{"type":"behaviour","doc":"The macro generates:\n- `@behaviour Funx.Validate.Behaviour` implementation\n- Convenience helpers `validate/1`, `validate/2` (delegate to `validate/3`)\n- Maybe handling at the validation boundary (see Maybe Semantics below)\n- Message handling via `build_message/3` (supports `:message` option)\n- Either wrapping using `Either.lift_predicate`","title":"Generated Code - Funx.Validator","ref":"Funx.Validator.html#module-generated-code"},{"type":"behaviour","doc":"**Critical design rule**: `Nothing` always passes through unchanged.\n\n- `Nothing` → `Either.right(Nothing)` (validation skipped)\n- `Just(value)` → unwraps to `value`, calls your `validate_value/3`, re-wraps result\n- Raw value → calls your `validate_value/3` directly\n\n**Why `Nothing` passes**: In Funx's validation model, absence is handled by Prism\noptics. `Nothing` represents \"value not present\" (e.g., optional field missing).\nOnly `Funx.Validator.Required` fails on absence - all other validators assume presence.\n\n**What you validate**: Your `validate_value/3` callback receives the **unwrapped value**,\nnever `Nothing` or `Just`. The macro handles the Maybe boundary for you.","title":"Maybe Semantics - Funx.Validator","ref":"Funx.Validator.html#module-maybe-semantics"},{"type":"behaviour","doc":"All generated validators support the `:message` option to override the default error:\n\n    MyValidator.validate(value, message: fn v -> \"custom error for #{v}\" end)\n\nThe `:message` option accepts a **function** `(value -> String.t())` that receives\nthe invalid value and returns an error message string. The macro wraps this in\n`ValidationError.new/1` automatically.\n\n**Note**: Only function callbacks are supported (not raw strings), consistent with\nall built-in Funx validators.","title":"Message Customization - Funx.Validator","ref":"Funx.Validator.html#module-message-customization"},{"type":"behaviour","doc":"Users of your validator can override the default message using the `:message` option:\n\n    MyApp.Validators.UniqueEmail.validate(\n      \"test@example.com\",\n      message: fn email -> \"#{email} is already registered\" end\n    )","title":"Custom Message Override - Funx.Validator","ref":"Funx.Validator.html#module-custom-message-override"},{"type":"behaviour","doc":"Funx provides built-in validators for common scenarios:","title":"Built-in Validators - Funx.Validator","ref":"Funx.Validator.html#module-built-in-validators"},{"type":"behaviour","doc":"- `Funx.Validator.Required` – Validates presence (not `nil`, not empty, not `Nothing`)\n- `Funx.Validator.Confirmation` – Validates that a value matches another field using `Eq`","title":"Presence and Structure - Funx.Validator","ref":"Funx.Validator.html#module-presence-and-structure"},{"type":"behaviour","doc":"- `Funx.Validator.Email` – Validates basic email format\n- `Funx.Validator.MinLength` – Validates minimum string length\n- `Funx.Validator.MaxLength` – Validates maximum string length\n- `Funx.Validator.Pattern` – Validates against a regular expression","title":"String Validators - Funx.Validator","ref":"Funx.Validator.html#module-string-validators"},{"type":"behaviour","doc":"- `Funx.Validator.Integer` – Validates that the value is an integer\n- `Funx.Validator.Negative` – Validates number < 0\n- `Funx.Validator.Positive` – Validates number > 0\n- `Funx.Validator.Range` – Validates number within inclusive bounds","title":"Numeric Validators - Funx.Validator","ref":"Funx.Validator.html#module-numeric-validators"},{"type":"behaviour","doc":"- `Funx.Validator.Equal` – Validates that a value equals an expected value using `Eq`\n- `Funx.Validator.NotEqual` – Validates that a value does not equal an expected value using `Eq`\n- `Funx.Validator.AllEqual` – Validates that all elements in a collection are equal using `Eq`","title":"Equality (Eq based) - Funx.Validator","ref":"Funx.Validator.html#module-equality-eq-based"},{"type":"behaviour","doc":"- `Funx.Validator.GreaterThan` – Validates value > threshold\n- `Funx.Validator.GreaterThanOrEqual` – Validates value ≥ threshold\n- `Funx.Validator.LessThan` – Validates value < threshold\n- `Funx.Validator.LessThanOrEqual` – Validates value ≤ threshold","title":"Ordering (Ord based) - Funx.Validator","ref":"Funx.Validator.html#module-ordering-ord-based"},{"type":"behaviour","doc":"- `Funx.Validator.In` – Validates membership in a set of allowed values using `Eq`\n- `Funx.Validator.NotIn` – Validates non-membership in a set of disallowed values using `Eq`","title":"Membership (Eq based) - Funx.Validator","ref":"Funx.Validator.html#module-membership-eq-based"},{"type":"behaviour","doc":"- `Funx.Validator.Any` – Validates that at least one of several validators succeeds (OR logic)\n- `Funx.Validator.Not` – Negates the result of another validator","title":"Combinators - Funx.Validator","ref":"Funx.Validator.html#module-combinators"},{"type":"behaviour","doc":"- `Funx.Validator.LiftPredicate` – Lifts a predicate function into a validator","title":"Predicate Lifting - Funx.Validator","ref":"Funx.Validator.html#module-predicate-lifting"},{"type":"behaviour","doc":"When implementing a validator with this macro, you must follow this contract:","title":"Validator Contract - Funx.Validator","ref":"Funx.Validator.html#module-validator-contract"},{"type":"behaviour","doc":"- Your `valid?/3` receives the **unwrapped value** (never `Nothing` or `Just`)\n- `Nothing` is handled by the macro (always passes through)\n- You only validate **present values**\n- You can pattern match on type, structure, etc. in `valid?/3` clauses","title":"Input Handling - Funx.Validator","ref":"Funx.Validator.html#module-input-handling"},{"type":"behaviour","doc":"- Return `true` if validation passes\n- Return `false` if validation fails (triggers `default_message/1`)\n- The macro wraps your boolean in `Either` and `ValidationError` automatically","title":"Return Values - Funx.Validator","ref":"Funx.Validator.html#module-return-values"},{"type":"behaviour","doc":"- `opts` - Configuration for your validator (e.g., `[threshold: 100]`)\n- `env` - Runtime context (database, session, etc.) - currently unused by convention\n- If you need `opts` or `env`, pattern match them; otherwise use `_opts`, `_env`","title":"Options and Environment - Funx.Validator","ref":"Funx.Validator.html#module-options-and-environment"},{"type":"behaviour","doc":"- Implement `default_message/1` to return a plain string\n- You can pattern match on value to customize the message\n- Users can override with `:message` option (function callback)","title":"Error Messages - Funx.Validator","ref":"Funx.Validator.html#module-error-messages"},{"type":"type","doc":"","title":"Funx.Validator.t/0","ref":"Funx.Validator.html#t:t/0"},{"type":"callback","doc":"Callback for default error message.\n\nReturns a plain string that will be wrapped in `ValidationError.new/1`.\n\n**This callback is optional.** If not implemented, a generic \"is invalid\" message is used.","title":"Funx.Validator.default_message/2","ref":"Funx.Validator.html#c:default_message/2"},{"type":"callback","doc":"- `value` - The value that failed validation\n- `opts` - Keyword list of options (for accessing configuration in error messages)","title":"Arguments - Funx.Validator.default_message/2","ref":"Funx.Validator.html#c:default_message/2-arguments"},{"type":"callback","doc":"A plain string error message (will be wrapped in `ValidationError.new/1`)","title":"Returns - Funx.Validator.default_message/2","ref":"Funx.Validator.html#c:default_message/2-returns"},{"type":"callback","doc":"@impl Funx.Validator\n    def default_message(value, opts) when is_binary(value) do\n      min = Keyword.get(opts, :min, 0)\n      \"must be at least #{min} characters\"\n    end\n\n    def default_message(_value, _opts) do\n      \"must be a string\"\n    end","title":"Example - Funx.Validator.default_message/2","ref":"Funx.Validator.html#c:default_message/2-example"},{"type":"callback","doc":"Callback for custom validation predicate.\n\nYour implementation receives the **unwrapped value** (never `Nothing` or `Just`).","title":"Funx.Validator.valid?/3","ref":"Funx.Validator.html#c:valid?/3"},{"type":"callback","doc":"- `value` - The value to validate (unwrapped from Just if applicable)\n- `opts` - Keyword list of options passed to the validator\n- `env` - Environment map (runtime context like database connections, session data)","title":"Arguments - Funx.Validator.valid?/3","ref":"Funx.Validator.html#c:valid?/3-arguments"},{"type":"callback","doc":"- `true` - Validation passed\n- `false` - Validation failed (will use default_message/1)","title":"Returns - Funx.Validator.valid?/3","ref":"Funx.Validator.html#c:valid?/3-returns"},{"type":"callback","doc":"@impl Funx.Validator\n    def valid?(num, opts, _env) when is_number(num) do\n      threshold = Keyword.get(opts, :min, 0)\n      num >= threshold\n    end\n\n    def valid?(_non_number, _opts, _env), do: false","title":"Example - Funx.Validator.valid?/3","ref":"Funx.Validator.html#c:valid?/3-example"},{"type":"function","doc":"Helper function to build error messages with :message option support.\n\nThis can be used by validators that don't use the macro but want consistent\nmessage handling.","title":"Funx.Validator.build_message/3","ref":"Funx.Validator.html#build_message/3"},{"type":"function","doc":"- `opts` - Keyword list that may contain a `:message` callback\n- `value` - The value that failed validation\n- `default` - The default message to use if no `:message` option provided","title":"Arguments - Funx.Validator.build_message/3","ref":"Funx.Validator.html#build_message/3-arguments"},{"type":"function","doc":"A string message - either from the `:message` callback or the default","title":"Returns - Funx.Validator.build_message/3","ref":"Funx.Validator.html#build_message/3-returns"},{"type":"function","doc":"defp validate_something(value, opts) do\n      if valid?(value) do\n        Either.right(value)\n      else\n        message = Funx.Validator.build_message(opts, value, \"default error\")\n        Either.left(ValidationError.new(message))\n      end\n    end","title":"Example - Funx.Validator.build_message/3","ref":"Funx.Validator.html#build_message/3-example"},{"type":"function","doc":"Helper function to build a ValidationError with message option support.\n\nCombines `build_message/3` and `ValidationError.new/1` into a single call.\nThis is the most common pattern for validators.","title":"Funx.Validator.validation_error/3","ref":"Funx.Validator.html#validation_error/3"},{"type":"function","doc":"- `opts` - Keyword list that may contain a `:message` callback\n- `value` - The value that failed validation\n- `default` - The default message to use if no `:message` option provided","title":"Arguments - Funx.Validator.validation_error/3","ref":"Funx.Validator.html#validation_error/3-arguments"},{"type":"function","doc":"A `ValidationError` struct","title":"Returns - Funx.Validator.validation_error/3","ref":"Funx.Validator.html#validation_error/3-returns"},{"type":"function","doc":"defp validate_something(value, opts) do\n      if valid?(value) do\n        Either.right(value)\n      else\n        error = Funx.Validator.validation_error(opts, value, \"default error\")\n        Either.left(error)\n      end\n    end","title":"Example - Funx.Validator.validation_error/3","ref":"Funx.Validator.html#validation_error/3-example"},{"type":"module","doc":"Validates that all elements in a list are equal to each other.","title":"Funx.Validator.AllEqual","ref":"Funx.Validator.AllEqual.html"},{"type":"module","doc":"This validator supports `Maybe` types from Prism projections:\n- `Nothing` - Passes validation (optional fields without values)\n- `Just(list)` - Validates the list inside the Just\n\nThis makes the validator compatible with optional fields in the validation DSL.","title":"Maybe Support - Funx.Validator.AllEqual","ref":"Funx.Validator.AllEqual.html#module-maybe-support"},{"type":"module","doc":"- `:message` - Custom error message callback `(value -> String.t())`\n- `:eq` - Custom equality comparator (defaults to `Funx.Eq.Protocol`)","title":"Optional Options - Funx.Validator.AllEqual","ref":"Funx.Validator.AllEqual.html#module-optional-options"},{"type":"module","doc":"iex> Funx.Validator.AllEqual.validate([1, 1, 1], [])\n    %Funx.Monad.Either.Right{right: [1, 1, 1]}\n\n    iex> Funx.Validator.AllEqual.validate([1, 2, 3], [])\n    %Funx.Monad.Either.Left{left: %Funx.Errors.ValidationError{errors: [\"must be all matching\"]}}\n\n    iex> Funx.Validator.AllEqual.validate(\"not a list\", [])\n    %Funx.Monad.Either.Left{left: %Funx.Errors.ValidationError{errors: [\"must be a list\"]}}\n\n    iex> Funx.Validator.AllEqual.validate([1, 2], [message: fn _ -> \"all items must match\" end])\n    %Funx.Monad.Either.Left{left: %Funx.Errors.ValidationError{errors: [\"all items must match\"]}}","title":"Examples - Funx.Validator.AllEqual","ref":"Funx.Validator.AllEqual.html#module-examples"},{"type":"module","doc":"You can provide a custom equality comparator via the `:eq` option:\n\n    iex> case_insensitive = %{\n    ...>   eq?: fn a, b -> String.downcase(a) == String.downcase(b) end,\n    ...>   not_eq?: fn a, b -> String.downcase(a) != String.downcase(b) end\n    ...> }\n    iex> Funx.Validator.AllEqual.validate([\"HELLO\", \"hello\", \"HeLLo\"], [eq: case_insensitive])\n    %Funx.Monad.Either.Right{right: [\"HELLO\", \"hello\", \"HeLLo\"]}","title":"Using Custom Equality - Funx.Validator.AllEqual","ref":"Funx.Validator.AllEqual.html#module-using-custom-equality"},{"type":"module","doc":"iex> Funx.Validator.AllEqual.validate(%Funx.Monad.Maybe.Nothing{}, [])\n    %Funx.Monad.Either.Right{right: %Funx.Monad.Maybe.Nothing{}}\n\n    iex> Funx.Validator.AllEqual.validate(%Funx.Monad.Maybe.Just{value: [1, 1, 1]}, [])\n    %Funx.Monad.Either.Right{right: [1, 1, 1]}\n\n    iex> Funx.Validator.AllEqual.validate(%Funx.Monad.Maybe.Just{value: [1, 2]}, [])\n    %Funx.Monad.Either.Left{left: %Funx.Errors.ValidationError{errors: [\"must be all matching\"]}}","title":"Maybe Examples - Funx.Validator.AllEqual","ref":"Funx.Validator.AllEqual.html#module-maybe-examples"},{"type":"function","doc":"","title":"Funx.Validator.AllEqual.validate/1","ref":"Funx.Validator.AllEqual.html#validate/1"},{"type":"function","doc":"","title":"Funx.Validator.AllEqual.validate/2","ref":"Funx.Validator.AllEqual.html#validate/2"},{"type":"module","doc":"Validates that at least one of several alternative validators succeeds.\n\n`Any` provides disjunctive validation semantics. Unlike the default validation\npipeline, which is conjunctive (all validators must succeed), `Any` succeeds\nas soon as a single validator passes. If all validators fail, validation fails\nwith a single aggregated `ValidationError`.\n\nThis validator is useful for expressing alternatives such as:\n\"value must satisfy rule A or rule B\".\n\nOptions\n\n- `:validators` (required)\n  A non-empty list of validators. Each entry may be:\n  - a validator module implementing `Funx.Validate.Behaviour`\n  - a `{Validator, opts}` tuple for optioned validators\n  - a validator function with arity 1, 2, or 3 (e.g., result of `validate do...end`)\n  - a `{validator_function, opts}` tuple for optioned function validators\n\n- `:message` (optional)\n  A zero-arity callback `(() -> String.t())` used to override the default error\n  message when all alternatives fail.\n\nSemantics\n\n- Validators are evaluated left-to-right.\n- Evaluation short-circuits on the first successful validation.\n- If any validator returns `Right`, the value is returned unchanged.\n- If all validators return `Left`, a single `ValidationError` is returned.\n- `Nothing` values succeed if any validator accepts them.\n- `Just` values are unwrapped before validation.\n\nExamples\n\n    iex> Funx.Validator.Any.validate(10,\n    ...>   validators: [Funx.Validator.Positive, Funx.Validator.Negative]\n    ...> )\n    %Funx.Monad.Either.Right{right: 10}\n\n    iex> Funx.Validator.Any.validate(0,\n    ...>   validators: [Funx.Validator.Positive, Funx.Validator.Negative]\n    ...> )\n    %Funx.Monad.Either.Left{\n      left: %Funx.Errors.ValidationError{\n        errors: [\"value must satisfy at least one alternative\"]\n      }\n    }\n\n    iex> Funx.Validator.Any.validate(0,\n    ...>   validators: [Funx.Validator.Positive, Funx.Validator.Negative],\n    ...>   message: fn -> \"must be positive or negative\" end\n    ...> )\n    %Funx.Monad.Either.Left{\n      left: %Funx.Errors.ValidationError{\n        errors: [\"must be positive or negative\"]\n      }\n    }","title":"Funx.Validator.Any","ref":"Funx.Validator.Any.html"},{"type":"function","doc":"","title":"Funx.Validator.Any.validate/1","ref":"Funx.Validator.Any.html#validate/1"},{"type":"function","doc":"","title":"Funx.Validator.Any.validate/2","ref":"Funx.Validator.Any.html#validate/2"},{"type":"module","doc":"Validates that a value matches another field in the data structure.\n\nUseful for password confirmation, email confirmation, etc.","title":"Funx.Validator.Confirmation","ref":"Funx.Validator.Confirmation.html"},{"type":"module","doc":"- `:field` – The field name to compare against (atom)\n- `:data` – The full data structure containing both fields","title":"Required Options - Funx.Validator.Confirmation","ref":"Funx.Validator.Confirmation.html#module-required-options"},{"type":"module","doc":"- `:eq` – An equality comparator. Defaults to `Funx.Eq.Protocol`.\n- `:message` – Custom error message callback `(value -> String.t())`","title":"Optional Options - Funx.Validator.Confirmation","ref":"Funx.Validator.Confirmation.html#module-optional-options"},{"type":"module","doc":"iex> data = %{password: \"secret\", password_confirmation: \"secret\"}\n    iex> Funx.Validator.Confirmation.validate(\"secret\", field: :password, data: data)\n    %Funx.Monad.Either.Right{right: \"secret\"}\n\n    iex> data = %{password: \"secret\", password_confirmation: \"wrong\"}\n    iex> Funx.Validator.Confirmation.validate(\"wrong\", field: :password, data: data)\n    %Funx.Monad.Either.Left{\n      left: %Funx.Errors.ValidationError{errors: [\"does not match password\"]}\n    }","title":"Examples - Funx.Validator.Confirmation","ref":"Funx.Validator.Confirmation.html#module-examples"},{"type":"function","doc":"","title":"Funx.Validator.Confirmation.validate/1","ref":"Funx.Validator.Confirmation.html#validate/1"},{"type":"function","doc":"","title":"Funx.Validator.Confirmation.validate/2","ref":"Funx.Validator.Confirmation.html#validate/2"},{"type":"module","doc":"Validates that every element in a list passes a given validator (or validators).\n\n`Each` provides universal quantification over list elements. It applies one or more\nvalidators to each element and collects all errors using applicative semantics.","title":"Funx.Validator.Each","ref":"Funx.Validator.Each.html"},{"type":"module","doc":"Exactly one of the following must be provided:\n\n- `:validator` - A single validator to apply to each element\n- `:validators` - A list of validators; each element must pass all of them\n\nEach validator may be:\n- A validator module implementing `Funx.Validate.Behaviour`\n- A `{Validator, opts}` tuple for optioned validators\n- A validator function with arity 1, 2, or 3","title":"Options - Funx.Validator.Each","ref":"Funx.Validator.Each.html#module-options"},{"type":"module","doc":"- Uses `traverse_a` for applicative error collection (all failures reported)\n- Empty lists pass validation (vacuous truth)\n- `Nothing` passes through unchanged\n- `Just(list)` unwraps and validates the list","title":"Semantics - Funx.Validator.Each","ref":"Funx.Validator.Each.html#module-semantics"},{"type":"module","doc":"iex> Funx.Validator.Each.validate([1, 2, 3], validator: Funx.Validator.Positive)\n    %Funx.Monad.Either.Right{right: [1, 2, 3]}\n\n    iex> Funx.Validator.Each.validate([1, 2, 3], validators: [Funx.Validator.Positive, Funx.Validator.Integer])\n    %Funx.Monad.Either.Right{right: [1, 2, 3]}","title":"Examples - Funx.Validator.Each","ref":"Funx.Validator.Each.html#module-examples"},{"type":"function","doc":"","title":"Funx.Validator.Each.validate/1","ref":"Funx.Validator.Each.html#validate/1"},{"type":"function","doc":"","title":"Funx.Validator.Each.validate/2","ref":"Funx.Validator.Each.html#validate/2"},{"type":"module","doc":"Validates that a string is a valid email format.","title":"Funx.Validator.Email","ref":"Funx.Validator.Email.html"},{"type":"module","doc":"This is a simple email validator that checks for the presence of an `@` symbol.\nFor more robust email validation, use a dedicated library or custom validator.","title":"Basic Check - Funx.Validator.Email","ref":"Funx.Validator.Email.html#module-basic-check"},{"type":"module","doc":"- `:message` - Custom error message callback `(value -> String.t())`","title":"Optional Options - Funx.Validator.Email","ref":"Funx.Validator.Email.html#module-optional-options"},{"type":"module","doc":"iex> Funx.Validator.Email.validate(\"user@example.com\")\n    %Funx.Monad.Either.Right{right: \"user@example.com\"}\n\n    iex> Funx.Validator.Email.validate(\"not-an-email\")\n    %Funx.Monad.Either.Left{left: %Funx.Errors.ValidationError{errors: [\"must be a valid email\"]}}","title":"Examples - Funx.Validator.Email","ref":"Funx.Validator.Email.html#module-examples"},{"type":"function","doc":"","title":"Funx.Validator.Email.validate/1","ref":"Funx.Validator.Email.html#validate/1"},{"type":"function","doc":"","title":"Funx.Validator.Email.validate/2","ref":"Funx.Validator.Email.html#validate/2"},{"type":"module","doc":"Validates that a value is equal to a given expected value using an `Eq`\ncomparator.\n\n`Equal` enforces an equality constraint of the form:\n\"value must equal X\".\n\nEquality is defined by an `Eq` instance, not by structural equality.\n\nOptions\n\n- `:value` (required)\n  The expected value to compare against.\n\n- `:eq` (optional)\n  An equality comparator. Defaults to `Funx.Eq.Protocol`.\n\n- `:message` (optional)\n  A custom error message callback `(value -> String.t())` used to override the\n  default error message on failure.\n\nSemantics\n\n- If the value equals the expected value under the given `Eq`, validation\n  succeeds.\n- If the expected value is a module and the value is a struct, validation\n  succeeds when `value.__struct__ == expected`.\n- If the value does not equal the expected value, validation fails.\n- `Nothing` values are preserved and treated as not applicable.\n- `Just` values are unwrapped before comparison.","title":"Funx.Validator.Equal","ref":"Funx.Validator.Equal.html"},{"type":"function","doc":"","title":"Funx.Validator.Equal.validate/1","ref":"Funx.Validator.Equal.html#validate/1"},{"type":"function","doc":"","title":"Funx.Validator.Equal.validate/2","ref":"Funx.Validator.Equal.html#validate/2"},{"type":"module","doc":"Validates that a value is strictly greater than a given reference value\nusing an `Ord` comparator.\n\n`GreaterThan` enforces an ordering constraint of the form:\n\"value must be greater than X\".\n\nOrdering is defined by an `Ord` instance, not by numeric comparison or\nstructural operators.\n\nOptions\n\n- `:value` (required)\n  The reference value to compare against.\n\n- `:ord` (optional)\n  An ordering comparator. Defaults to `Funx.Ord.Protocol`.\n\n- `:message` (optional)\n  A custom error message callback `(value -> String.t())` used to override the\n  default error message on failure.\n\nSemantics\n\n- If the value compares as `:gt` relative to the reference value under\n  the given `Ord`, validation succeeds.\n- If the value compares as `:lt` or `:eq`, validation fails.\n- `Nothing` values are preserved and treated as not applicable.\n- `Just` values are unwrapped before comparison.\n\nExamples\n\n    iex> Funx.Validator.GreaterThan.validate(7, value: 5)\n    %Funx.Monad.Either.Right{right: 7}\n\n    iex> Funx.Validator.GreaterThan.validate(\"b\", value: \"a\")\n    %Funx.Monad.Either.Right{right: \"b\"}\n\n    iex> Funx.Validator.GreaterThan.validate(\"a\", value: \"a\")\n    %Funx.Monad.Either.Left{\n      left: %Funx.Errors.ValidationError{\n        errors: [\"must be greater than \\\"a\\\"\"]\n      }\n    }\n\n    iex> Funx.Validator.GreaterThan.validate(%Funx.Monad.Maybe.Nothing{}, value: 5)\n    %Funx.Monad.Either.Right{right: %Funx.Monad.Maybe.Nothing{}}","title":"Funx.Validator.GreaterThan","ref":"Funx.Validator.GreaterThan.html"},{"type":"function","doc":"","title":"Funx.Validator.GreaterThan.validate/1","ref":"Funx.Validator.GreaterThan.html#validate/1"},{"type":"function","doc":"","title":"Funx.Validator.GreaterThan.validate/2","ref":"Funx.Validator.GreaterThan.html#validate/2"},{"type":"module","doc":"Validates that a value is greater than or equal to a given reference value\nusing an `Ord` comparator.\n\nOptions\n\n- `:value` (required) - The reference value to compare against\n- `:ord` (optional) - An ordering comparator. Defaults to `Funx.Ord.Protocol`\n- `:message` (optional) - Custom error message callback `(value -> String.t())`\n\nSemantics\n\n- If the value compares as `:gt` or `:eq` relative to the reference, validation succeeds.\n- If the value compares as `:lt`, validation fails.\n- `Nothing` values pass unchanged.\n- `Just` values are unwrapped before comparison.","title":"Funx.Validator.GreaterThanOrEqual","ref":"Funx.Validator.GreaterThanOrEqual.html"},{"type":"function","doc":"","title":"Funx.Validator.GreaterThanOrEqual.validate/1","ref":"Funx.Validator.GreaterThanOrEqual.html#validate/1"},{"type":"function","doc":"","title":"Funx.Validator.GreaterThanOrEqual.validate/2","ref":"Funx.Validator.GreaterThanOrEqual.html#validate/2"},{"type":"module","doc":"Validates that a value is a member of a given collection using an `Eq`\ncomparator.\n\n`In` enforces a membership constraint of the form:\n\"value must be one of these\".\n\nMembership is defined by an `Eq` instance, not by structural equality or\nElixir's `in` operator.\n\nOptions\n\n- `:values` (required)\n  The list of allowed values to compare against.\n\n- `:eq` (optional)\n  An equality comparator. Defaults to `Funx.Eq.Protocol`.\n\n- `:message` (optional)\n  A custom error message callback `(value -> String.t())`.\n\nSemantics\n\n- Succeeds if the value equals any element in `:values` under `Eq`,\n  or if the value is a struct whose module is listed in `:values`.\n- Fails otherwise.\n- `Nothing` passes through.\n- `Just` is unwrapped before comparison.","title":"Funx.Validator.In","ref":"Funx.Validator.In.html"},{"type":"function","doc":"","title":"Funx.Validator.In.validate/1","ref":"Funx.Validator.In.html#validate/1"},{"type":"function","doc":"","title":"Funx.Validator.In.validate/2","ref":"Funx.Validator.In.html#validate/2"},{"type":"module","doc":"Validates that a value is an integer.","title":"Funx.Validator.Integer","ref":"Funx.Validator.Integer.html"},{"type":"module","doc":"- `:message` - Custom error message callback `(value -> String.t())`","title":"Optional Options - Funx.Validator.Integer","ref":"Funx.Validator.Integer.html#module-optional-options"},{"type":"module","doc":"iex> Funx.Validator.Integer.validate(5)\n    %Funx.Monad.Either.Right{right: 5}\n\n    iex> Funx.Validator.Integer.validate(5.5)\n    %Funx.Monad.Either.Left{left: %Funx.Errors.ValidationError{errors: [\"must be an integer\"]}}","title":"Examples - Funx.Validator.Integer","ref":"Funx.Validator.Integer.html#module-examples"},{"type":"function","doc":"","title":"Funx.Validator.Integer.validate/1","ref":"Funx.Validator.Integer.html#validate/1"},{"type":"function","doc":"","title":"Funx.Validator.Integer.validate/2","ref":"Funx.Validator.Integer.html#validate/2"},{"type":"module","doc":"Validates that a value is strictly less than a given reference value\nusing an `Ord` comparator.\n\nOptions\n\n- `:value` (required) - The reference value to compare against\n- `:ord` (optional) - An ordering comparator. Defaults to `Funx.Ord.Protocol`\n- `:message` (optional) - Custom error message callback `(value -> String.t())`\n\nSemantics\n\n- If the value compares as `:lt` relative to the reference, validation succeeds.\n- If the value compares as `:eq` or `:gt`, validation fails.\n- `Nothing` values pass unchanged.\n- `Just` values are unwrapped before comparison.","title":"Funx.Validator.LessThan","ref":"Funx.Validator.LessThan.html"},{"type":"function","doc":"","title":"Funx.Validator.LessThan.validate/1","ref":"Funx.Validator.LessThan.html#validate/1"},{"type":"function","doc":"","title":"Funx.Validator.LessThan.validate/2","ref":"Funx.Validator.LessThan.html#validate/2"},{"type":"module","doc":"Validates that a value is less than or equal to a given reference value\nusing an `Ord` comparator.\n\nOptions\n\n- `:value` (required) - The reference value to compare against\n- `:ord` (optional) - An ordering comparator. Defaults to `Funx.Ord.Protocol`\n- `:message` (optional) - Custom error message callback `(value -> String.t())`\n\nSemantics\n\n- If the value compares as `:lt` or `:eq` relative to the reference, validation succeeds.\n- If the value compares as `:gt`, validation fails.\n- `Nothing` values pass unchanged.\n- `Just` values are unwrapped before comparison.","title":"Funx.Validator.LessThanOrEqual","ref":"Funx.Validator.LessThanOrEqual.html"},{"type":"function","doc":"","title":"Funx.Validator.LessThanOrEqual.validate/1","ref":"Funx.Validator.LessThanOrEqual.html#validate/1"},{"type":"function","doc":"","title":"Funx.Validator.LessThanOrEqual.validate/2","ref":"Funx.Validator.LessThanOrEqual.html#validate/2"},{"type":"module","doc":"Lifts a predicate into the validation context.\n\n`LiftPredicate` adapts a predicate function into a validator that conforms to\n`Funx.Validate.Behaviour`. It allows predicate-style logic to participate in\nthe validation pipeline, producing `Either` results and `ValidationError`s\ninstead of booleans.\n\nThis module is intended as an escape hatch for ad-hoc or externally-defined\npredicates. For reusable domain rules, prefer defining a dedicated validator\nmodule or using the Predicate DSL directly.\n\nOptions\n\n- `:pred` (required)\n  A predicate function `(value -> boolean)` that determines whether validation\n  succeeds.\n\n- `:message` (optional)\n  A callback `(value -> String.t())` used to override the default error message\n  when the predicate fails.\n\nSemantics\n\n- If the predicate returns `true`, validation succeeds and the value is returned.\n- If the predicate returns `false`, validation fails with a `ValidationError`.\n- `Nothing` values succeed without invoking the predicate.\n- `Just` values are unwrapped before validation.\n.\nExamples\n\n    iex> Funx.Validator.LiftPredicate.validate(150, pred: fn v -> v > 100 end)\n    %Funx.Monad.Either.Right{right: 150}\n\n    iex> Funx.Validator.LiftPredicate.validate(50, pred: fn v -> v > 100 end)\n    %Funx.Monad.Either.Left{\n      left: %Funx.Errors.ValidationError{errors: [\"invalid value\"]}\n    }\n\n    iex> Funx.Validator.LiftPredicate.validate(\n    ...>   50,\n    ...>   pred: fn v -> v > 100 end,\n    ...>   message: fn _ -> \"must be greater than 100\" end\n    ...> )\n    %Funx.Monad.Either.Left{\n      left: %Funx.Errors.ValidationError{errors: [\"must be greater than 100\"]}\n    }","title":"Funx.Validator.LiftPredicate","ref":"Funx.Validator.LiftPredicate.html"},{"type":"function","doc":"","title":"Funx.Validator.LiftPredicate.validate/1","ref":"Funx.Validator.LiftPredicate.html#validate/1"},{"type":"function","doc":"","title":"Funx.Validator.LiftPredicate.validate/2","ref":"Funx.Validator.LiftPredicate.html#validate/2"},{"type":"module","doc":"Validates that a string does not exceed a maximum length.","title":"Funx.Validator.MaxLength","ref":"Funx.Validator.MaxLength.html"},{"type":"module","doc":"- `:max` - Maximum length (integer)","title":"Required Options - Funx.Validator.MaxLength","ref":"Funx.Validator.MaxLength.html#module-required-options"},{"type":"module","doc":"- `:message` - Custom error message callback `(value -> String.t())`","title":"Optional Options - Funx.Validator.MaxLength","ref":"Funx.Validator.MaxLength.html#module-optional-options"},{"type":"module","doc":"iex> Funx.Validator.MaxLength.validate(\"hi\", [max: 5])\n    %Funx.Monad.Either.Right{right: \"hi\"}\n\n    iex> Funx.Validator.MaxLength.validate(\"hello world\", [max: 5])\n    %Funx.Monad.Either.Left{left: %Funx.Errors.ValidationError{errors: [\"must be at most 5 characters\"]}}\n\n    iex> Funx.Validator.MaxLength.validate(\"hello world\", [max: 5, message: fn val -> \"'#{val}' is too long\" end])\n    %Funx.Monad.Either.Left{left: %Funx.Errors.ValidationError{errors: [\"'hello world' is too long\"]}}","title":"Examples - Funx.Validator.MaxLength","ref":"Funx.Validator.MaxLength.html#module-examples"},{"type":"function","doc":"","title":"Funx.Validator.MaxLength.validate/1","ref":"Funx.Validator.MaxLength.html#validate/1"},{"type":"function","doc":"","title":"Funx.Validator.MaxLength.validate/2","ref":"Funx.Validator.MaxLength.html#validate/2"},{"type":"module","doc":"Validates that a string meets a minimum length requirement.","title":"Funx.Validator.MinLength","ref":"Funx.Validator.MinLength.html"},{"type":"module","doc":"- `:min` - Minimum length (integer)","title":"Required Options - Funx.Validator.MinLength","ref":"Funx.Validator.MinLength.html#module-required-options"},{"type":"module","doc":"- `:message` - Custom error message callback `(value -> String.t())`","title":"Optional Options - Funx.Validator.MinLength","ref":"Funx.Validator.MinLength.html#module-optional-options"},{"type":"module","doc":"iex> Funx.Validator.MinLength.validate(\"hello\", min: 3)\n    %Funx.Monad.Either.Right{right: \"hello\"}\n\n    iex> Funx.Validator.MinLength.validate(\"hi\", min: 5)\n    %Funx.Monad.Either.Left{left: %Funx.Errors.ValidationError{errors: [\"must be at least 5 characters\"]}}","title":"Examples - Funx.Validator.MinLength","ref":"Funx.Validator.MinLength.html#module-examples"},{"type":"function","doc":"","title":"Funx.Validator.MinLength.validate/1","ref":"Funx.Validator.MinLength.html#validate/1"},{"type":"function","doc":"","title":"Funx.Validator.MinLength.validate/2","ref":"Funx.Validator.MinLength.html#validate/2"},{"type":"module","doc":"Validates that a number is strictly negative (< 0).","title":"Funx.Validator.Negative","ref":"Funx.Validator.Negative.html"},{"type":"module","doc":"- `:message` - Custom error message callback `(value -> String.t())`","title":"Optional Options - Funx.Validator.Negative","ref":"Funx.Validator.Negative.html#module-optional-options"},{"type":"module","doc":"iex> Funx.Validator.Negative.validate(-5)\n    %Funx.Monad.Either.Right{right: -5}\n\n    iex> Funx.Validator.Negative.validate(0)\n    %Funx.Monad.Either.Left{left: %Funx.Errors.ValidationError{errors: [\"must be negative\"]}}\n\n    iex> Funx.Validator.Negative.validate(5)\n    %Funx.Monad.Either.Left{left: %Funx.Errors.ValidationError{errors: [\"must be negative\"]}}","title":"Examples - Funx.Validator.Negative","ref":"Funx.Validator.Negative.html#module-examples"},{"type":"function","doc":"","title":"Funx.Validator.Negative.validate/1","ref":"Funx.Validator.Negative.html#validate/1"},{"type":"function","doc":"","title":"Funx.Validator.Negative.validate/2","ref":"Funx.Validator.Negative.html#validate/2"},{"type":"module","doc":"Validates that a given validator does not succeed.\n\n`Not` provides logical negation for validation. It inverts the success and failure\nof a single validator while preserving inapplicability semantics for optional\n(`Prism`) foci.\n\nThis validator is useful for expressing constraints such as:\n\"value must not satisfy rule A\".\n\nOptions\n\n- `:validator` (required)\n  A single validator to negate. This may be:\n  - a validator module implementing `Funx.Validate.Behaviour`\n  - a `{Validator, opts}` tuple for optioned validators\n\n- `:message` (optional)\n  Note: Not  uses a zero-arity callback `(() -> String.t())` used to override the default error\n  message when the negated validator succeeds.\n\nSemantics\n\n- The inner validator is evaluated first.\n- If the inner validator returns `Left`, `Not` succeeds and returns the original value.\n- If the inner validator returns `Right`, `Not` fails with a `ValidationError`.\n- `Nothing` values are preserved and never cause failure.\n- `Just` values are validated by the inner validator, but the original input is\n  returned unchanged on success.\n\nExamples\n\n    iex> Funx.Validator.Not.validate(0,\n    ...>   validator: Funx.Validator.Positive\n    ...> )\n    %Funx.Monad.Either.Right{right: 0}\n\n    iex> Funx.Validator.Not.validate(10,\n    ...>   validator: Funx.Validator.Positive\n    ...> )\n    %Funx.Monad.Either.Left{\n      left: %Funx.Errors.ValidationError{\n        errors: [\"must not satisfy condition\"]\n      }\n    }\n\n    iex> Funx.Validator.Not.validate(%Funx.Monad.Maybe.Nothing{},\n    ...>   validator: Funx.Validator.Positive\n    ...> )\n    %Funx.Monad.Either.Right{right: %Funx.Monad.Maybe.Nothing{}}\n\n    iex> Funx.Validator.Not.validate(10,\n    ...>   validator: Funx.Validator.Positive,\n    ...>   message: fn -> \"must not be positive\" end\n    ...> )\n    %Funx.Monad.Either.Left{\n      left: %Funx.Errors.ValidationError{\n        errors: [\"must not be positive\"]\n      }\n    }","title":"Funx.Validator.Not","ref":"Funx.Validator.Not.html"},{"type":"function","doc":"","title":"Funx.Validator.Not.validate/2","ref":"Funx.Validator.Not.html#validate/2"},{"type":"module","doc":"Validates that a value is not equal to a given reference value using an `Eq`\ncomparator.\n\n`NotEqual` enforces an inequality constraint of the form:\n\"value must not equal X\".\n\nEquality is defined by an `Eq` instance, not by structural equality.\n\nOptions\n\n- `:value` (required)\n  The reference value to compare against.\n\n- `:eq` (optional)\n  An equality comparator. Defaults to `Funx.Eq.Protocol`.\n\n- `:message` (optional)\n  A custom error message callback `(value -> String.t())` used to override the\n  default error message on failure.\n\nSemantics\n\n- If the value does not equal the reference value under the given `Eq`,\n  validation succeeds.\n- If the value equals the reference value, validation fails.\n- `Nothing` values are preserved and treated as not applicable.\n- `Just` values are unwrapped before comparison.","title":"Funx.Validator.NotEqual","ref":"Funx.Validator.NotEqual.html"},{"type":"function","doc":"","title":"Funx.Validator.NotEqual.validate/1","ref":"Funx.Validator.NotEqual.html#validate/1"},{"type":"function","doc":"","title":"Funx.Validator.NotEqual.validate/2","ref":"Funx.Validator.NotEqual.html#validate/2"},{"type":"module","doc":"Validates that a value is not a member of a given collection using an `Eq`\ncomparator.\n\n`NotIn` enforces an exclusion constraint of the form:\n“value must not be one of these”.\n\nMembership is defined by an `Eq` instance, not by structural equality or\nElixir’s `in` operator.\n\nOptions\n\n- `:values` (required)\n  The list of disallowed values.\n\n- `:eq` (optional)\n  An equality comparator. Defaults to `Funx.Eq.Protocol`.\n\n- `:message` (optional)\n  A custom error message callback `(value -> String.t())` used to override the\n  default error message on failure.\n\nSemantics\n\n- If the value matches any element in `:values` under `Eq`, validation fails.\n- If the value does not match any element, validation succeeds.\n- `Nothing` values are preserved and treated as not applicable.\n- `Just` values are unwrapped before comparison.\n\nExamples\n\n  iex> Funx.Validator.NotIn.validate(\"deleted\", values: [\"active\", \"inactive\"])\n  %Funx.Monad.Either.Right{right: \"deleted\"}\n\n  iex> Funx.Validator.NotIn.validate(\"active\", values: [\"active\", \"inactive\"])\n  %Funx.Monad.Either.Left{\n    left: %Funx.Errors.ValidationError{\n      errors: [\"must not be one of: [\\\"active\\\", \\\"inactive\\\"]\"]\n    }\n  }\n\n  iex> Funx.Validator.NotIn.validate(%Funx.Monad.Maybe.Nothing{}, values: [\"a\", \"b\"])\n  %Funx.Monad.Either.Right{right: %Funx.Monad.Maybe.Nothing{}}","title":"Funx.Validator.NotIn","ref":"Funx.Validator.NotIn.html"},{"type":"function","doc":"","title":"Funx.Validator.NotIn.validate/1","ref":"Funx.Validator.NotIn.html#validate/1"},{"type":"function","doc":"","title":"Funx.Validator.NotIn.validate/2","ref":"Funx.Validator.NotIn.html#validate/2"},{"type":"module","doc":"Validates that a string matches a regular expression pattern.","title":"Funx.Validator.Pattern","ref":"Funx.Validator.Pattern.html"},{"type":"module","doc":"- `:regex` - Regular expression pattern (Regex.t())","title":"Required Options - Funx.Validator.Pattern","ref":"Funx.Validator.Pattern.html#module-required-options"},{"type":"module","doc":"- `:message` - Custom error message callback `(value -> String.t())`","title":"Optional Options - Funx.Validator.Pattern","ref":"Funx.Validator.Pattern.html#module-optional-options"},{"type":"module","doc":"iex> Funx.Validator.Pattern.validate(\"ABC123\", regex: ~r/^[A-Z0-9]+$/)\n    %Funx.Monad.Either.Right{right: \"ABC123\"}\n\n    iex> Funx.Validator.Pattern.validate(\"abc\", regex: ~r/^[A-Z0-9]+$/)\n    %Funx.Monad.Either.Left{left: %Funx.Errors.ValidationError{errors: [\"has invalid format\"]}}","title":"Examples - Funx.Validator.Pattern","ref":"Funx.Validator.Pattern.html#module-examples"},{"type":"function","doc":"","title":"Funx.Validator.Pattern.validate/1","ref":"Funx.Validator.Pattern.html#validate/1"},{"type":"function","doc":"","title":"Funx.Validator.Pattern.validate/2","ref":"Funx.Validator.Pattern.html#validate/2"},{"type":"module","doc":"Validates that a number is strictly positive (> 0).","title":"Funx.Validator.Positive","ref":"Funx.Validator.Positive.html"},{"type":"module","doc":"- `:message` - Custom error message callback `(value -> String.t())`","title":"Optional Options - Funx.Validator.Positive","ref":"Funx.Validator.Positive.html#module-optional-options"},{"type":"module","doc":"iex> Funx.Validator.Positive.validate(5)\n    %Funx.Monad.Either.Right{right: 5}\n\n    iex> Funx.Validator.Positive.validate(0)\n    %Funx.Monad.Either.Left{left: %Funx.Errors.ValidationError{errors: [\"must be positive\"]}}\n\n    iex> Funx.Validator.Positive.validate(-5)\n    %Funx.Monad.Either.Left{left: %Funx.Errors.ValidationError{errors: [\"must be positive\"]}}","title":"Examples - Funx.Validator.Positive","ref":"Funx.Validator.Positive.html#module-examples"},{"type":"function","doc":"","title":"Funx.Validator.Positive.validate/1","ref":"Funx.Validator.Positive.html#validate/1"},{"type":"function","doc":"","title":"Funx.Validator.Positive.validate/2","ref":"Funx.Validator.Positive.html#validate/2"},{"type":"module","doc":"Validates that a number falls within an inclusive range.","title":"Funx.Validator.Range","ref":"Funx.Validator.Range.html"},{"type":"module","doc":"- `:min` - Minimum value (inclusive)\n- `:max` - Maximum value (inclusive)\n- `:message` - Custom error message callback `(value -> String.t())`\n\nAt least one of `:min` or `:max` must be provided.","title":"Optional Options - Funx.Validator.Range","ref":"Funx.Validator.Range.html#module-optional-options"},{"type":"module","doc":"iex> Funx.Validator.Range.validate(5, min: 1, max: 10)\n    %Funx.Monad.Either.Right{right: 5}\n\n    iex> Funx.Validator.Range.validate(15, min: 1, max: 10)\n    %Funx.Monad.Either.Left{left: %Funx.Errors.ValidationError{errors: [\"must be between 1 and 10\"]}}\n\n    iex> Funx.Validator.Range.validate(5, min: 10)\n    %Funx.Monad.Either.Left{left: %Funx.Errors.ValidationError{errors: [\"must be at least 10\"]}}\n\n    iex> Funx.Validator.Range.validate(15, max: 10)\n    %Funx.Monad.Either.Left{left: %Funx.Errors.ValidationError{errors: [\"must be at most 10\"]}}","title":"Examples - Funx.Validator.Range","ref":"Funx.Validator.Range.html#module-examples"},{"type":"function","doc":"","title":"Funx.Validator.Range.validate/1","ref":"Funx.Validator.Range.html#validate/1"},{"type":"function","doc":"","title":"Funx.Validator.Range.validate/2","ref":"Funx.Validator.Range.html#validate/2"},{"type":"module","doc":"Validates that a value is present (not nil, not empty string, not Nothing).","title":"Funx.Validator.Required","ref":"Funx.Validator.Required.html"},{"type":"module","doc":"**Required is the ONLY validator that runs on `Maybe.Nothing`.**\n\nAll other validators skip `Nothing` values (from Prism projections).\nThis makes fields optional-by-default with explicit presence checks.","title":"Special Semantics - Funx.Validator.Required","ref":"Funx.Validator.Required.html#module-special-semantics"},{"type":"module","doc":"- `nil`\n- `\"\"` (empty string)\n- `%Maybe.Nothing{}` (from Prism projections)","title":"Failure Conditions - Funx.Validator.Required","ref":"Funx.Validator.Required.html#module-failure-conditions"},{"type":"module","doc":"All other values, including:\n- `0`, `false`, `[]` (falsy but present values)","title":"Success Conditions - Funx.Validator.Required","ref":"Funx.Validator.Required.html#module-success-conditions"},{"type":"module","doc":"- `:message` - Custom error message callback `(value -> String.t())`","title":"Options - Funx.Validator.Required","ref":"Funx.Validator.Required.html#module-options"},{"type":"module","doc":"iex> Funx.Validator.Required.validate(\"hello\")\n    %Funx.Monad.Either.Right{right: \"hello\"}\n\n    iex> Funx.Validator.Required.validate(nil)\n    %Funx.Monad.Either.Left{left: %Funx.Errors.ValidationError{errors: [\"is required\"]}}\n\n    iex> Funx.Validator.Required.validate(0)\n    %Funx.Monad.Either.Right{right: 0}","title":"Examples - Funx.Validator.Required","ref":"Funx.Validator.Required.html#module-examples"},{"type":"function","doc":"","title":"Funx.Validator.Required.validate/1","ref":"Funx.Validator.Required.html#validate/1"},{"type":"function","doc":"","title":"Funx.Validator.Required.validate/2","ref":"Funx.Validator.Required.html#validate/2"},{"type":"exception","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Ferrors%2Feffect_error.livemd)\n\nRepresents a system-level failure in an effectful computation.\n\n`EffectError` is raised or returned when a failure occurs during the execution\nof an `Effect` stage, such as `map`, `bind`, or `ap`. It is not meant for user-facing\nvalidation, but rather for internal tracing, telemetry, and diagnostics.","title":"Funx.Errors.EffectError","ref":"Funx.Errors.EffectError.html"},{"type":"exception","doc":"* `stage` – the name of the effect stage where the error occurred (`:map`, `:bind`, `:ap`, etc.)\n  * `reason` – the term (often an exception) that caused the failure\n\nThis error implements the `Exception`, `String.Chars`, and `Funx.Summarizable` behaviours.","title":"Fields - Funx.Errors.EffectError","ref":"Funx.Errors.EffectError.html#module-fields"},{"type":"type","doc":"","title":"Funx.Errors.EffectError.t/0","ref":"Funx.Errors.EffectError.html#t:t/0"},{"type":"function","doc":"Creates a new `EffectError` from the given stage and reason.","title":"Funx.Errors.EffectError.new/2","ref":"Funx.Errors.EffectError.html#new/2"},{"type":"function","doc":"iex> Funx.Errors.EffectError.new(:bind, %RuntimeError{message: \"boom\"})\n    %Funx.Errors.EffectError{stage: :bind, reason: %RuntimeError{message: \"boom\"}}","title":"Examples - Funx.Errors.EffectError.new/2","ref":"Funx.Errors.EffectError.html#new/2-examples"},{"type":"exception","doc":"[![Run in Livebook](https://livebook.dev/badge/v1/black.svg)](https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FJKWA%2Ffunx%2Fblob%2Fmain%2Flivebooks%2Ferrors%2Fvalidation_error.livemd)\n\nRepresents a validation error in the Funx library.\n\nA `ValidationError` wraps one or more domain-level validation messages. It is typically used with `Either.Left` to indicate that a value failed validation and should not proceed in a computation. It can also be raised directly, as it implements the `Exception` behaviour.\n\nThis module provides functions to construct, merge, and convert validation errors, enabling structured, composable error handling across pipelines and validation chains.","title":"Funx.Errors.ValidationError","ref":"Funx.Errors.ValidationError.html"},{"type":"exception","doc":"* `new/1` – Creates a `ValidationError` from a single error string or a list of error strings.\n* `empty/0` – Returns an empty `ValidationError`.\n* `merge/2` – Combines two `ValidationError` structs into one.\n* `from_tagged/1` – Converts a tagged error tuple (`{:error, errors}`) into a `ValidationError`.\n\nThis module also implements the `Exception`, `String.Chars`, and `Funx.Summarizable` protocols, supporting both human-readable output and structured reporting.","title":"Functions - Funx.Errors.ValidationError","ref":"Funx.Errors.ValidationError.html#module-functions"},{"type":"exception","doc":"You can validate a value using a list of validator functions. Each validator returns an `Either.Right` if\nthe check passes, or an `Either.Left` with an error message if it fails. If any validation fails,\nall errors are aggregated and returned in a single `Left`.\n\nIn contexts where an error must halt execution, `ValidationError` can be raised directly using `raise/1`.","title":"Usage in validation - Funx.Errors.ValidationError","ref":"Funx.Errors.ValidationError.html#module-usage-in-validation"},{"type":"exception","doc":"You can also use a `ValidationError` to hold errors:\n\n```elixir\nalias Funx.Errors.ValidationError\n\nvalidate_positive = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(&1 > 0), fn v -> \"Value must be positive: \" <> to_string(v) end)\n  |> Funx.Monad.Either.map_left(&ValidationError.new/1)\nend\n\nvalidate_even = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(rem(&1, 2) == 0), fn v -> \"Value must be even: \" <> to_string(v) end)\n  |> Funx.Monad.Either.map_left(&ValidationError.new/1)\nend\n\nFunx.Monad.Either.validate(-3, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Left{\n#     left: %ValidationError{\n#       errors: [\"Value must be positive: -3\", \"Value must be even: -3\"]\n#     }\n#   }\n```","title":"Examples - Funx.Errors.ValidationError","ref":"Funx.Errors.ValidationError.html#module-examples"},{"type":"type","doc":"","title":"Funx.Errors.ValidationError.t/0","ref":"Funx.Errors.ValidationError.html#t:t/0"},{"type":"function","doc":"Returns an empty `ValidationError`.","title":"Funx.Errors.ValidationError.empty/0","ref":"Funx.Errors.ValidationError.html#empty/0"},{"type":"function","doc":"iex> Funx.Errors.ValidationError.empty()\n    %Funx.Errors.ValidationError{errors: []}","title":"Examples - Funx.Errors.ValidationError.empty/0","ref":"Funx.Errors.ValidationError.html#empty/0-examples"},{"type":"function","doc":"Converts a tagged error tuple into a `ValidationError`.","title":"Funx.Errors.ValidationError.from_tagged/1","ref":"Funx.Errors.ValidationError.html#from_tagged/1"},{"type":"function","doc":"iex> Funx.Errors.ValidationError.from_tagged({:error, [\"must be positive\"]})\n    %Funx.Errors.ValidationError{errors: [\"must be positive\"]}","title":"Examples - Funx.Errors.ValidationError.from_tagged/1","ref":"Funx.Errors.ValidationError.html#from_tagged/1-examples"},{"type":"function","doc":"Merges two `ValidationError` structs into one by concatenating their error lists.","title":"Funx.Errors.ValidationError.merge/2","ref":"Funx.Errors.ValidationError.html#merge/2"},{"type":"function","doc":"iex> e1 = Funx.Errors.ValidationError.new(\"must be positive\")\n    iex> e2 = Funx.Errors.ValidationError.new(\"must be even\")\n    iex> Funx.Errors.ValidationError.merge(e1, e2)\n    %Funx.Errors.ValidationError{errors: [\"must be positive\", \"must be even\"]}","title":"Examples - Funx.Errors.ValidationError.merge/2","ref":"Funx.Errors.ValidationError.html#merge/2-examples"},{"type":"function","doc":"Creates a `ValidationError` from a single string or list of strings.","title":"Funx.Errors.ValidationError.new/1","ref":"Funx.Errors.ValidationError.html#new/1"},{"type":"function","doc":"iex> Funx.Errors.ValidationError.new(\"must be positive\")\n    %Funx.Errors.ValidationError{errors: [\"must be positive\"]}\n\n    iex> Funx.Errors.ValidationError.new([\"must be positive\", \"must be even\"])\n    %Funx.Errors.ValidationError{errors: [\"must be positive\", \"must be even\"]}","title":"Examples - Funx.Errors.ValidationError.new/1","ref":"Funx.Errors.ValidationError.html#new/1-examples"},{"type":"extras","doc":"# Changelog\n\n## [0.8.0] - Unreleased","title":"Changelog","ref":"changelog.html"},{"type":"extras","doc":"* Can now use DSL `Eq` and `Ord` in the Macro `eq_for` and `ord_for`","title":"Added - Changelog","ref":"changelog.html#added"},{"type":"extras","doc":"* Ord DSL no longer adds default protocol tiebreaker. Instead, add it explicitly with `Ord.Protocol`:\n\n```elixir\nord do\n  desc :name\n  asc Ord.Protocol\nend\n```\n\nThis makes the DSL more composable.\n\n## [0.7.1] - Unreleased","title":"Breaking Changes - Changelog","ref":"changelog.html#breaking-changes"},{"type":"extras","doc":"* Exported .formatter to hex\n\n## [0.7.0] - Unreleased","title":"Added - Changelog","ref":"changelog.html#added-1"},{"type":"extras","doc":"* `Funx.Validate` – A declarative DSL for building composable validators with optics-based field projection, applicative error accumulation, and identity preservation. Supports sequential and parallel modes, environment passing, and composable nested validators.\n* `Funx.Validator` – Built-in validators for common validation patterns:\n  * `Required` – Presence validation (handles `Nothing` from Prism)\n  * `Email` – Email format validation\n  * `MinLength` / `MaxLength` – String length constraints\n  * `Pattern` – Regex pattern matching\n  * `Positive` / `Negative` – Numeric sign validation\n  * `Integer` – Integer type validation\n  * `GreaterThan` / `LessThan` / `GreaterThanOrEq` / `LessThanOrEq` – Numeric comparisons\n  * `In` / `NotIn` – Set membership validation\n  * `Range` – Numeric range validation\n  * `Each` – Collection item validation\n  * `Confirmation` – Field matching validation\n  * `Not` – Validator negation","title":"Added - Changelog","ref":"changelog.html#added-2"},{"type":"extras","doc":"* Removed the import Either and import Maybe from the DSLs.\n* Changed behavior for Either and Maybe to use Monad behaviours (not `run/3` and `run_maybe/3`)\n\n## [0.6.1] - Unreleased","title":"Breaking Changes - Changelog","ref":"changelog.html#breaking-changes-1"},{"type":"extras","doc":"* `Funx.Predicate.DSL` – A declarative DSL for building boolean predicates with support for logical operators (`all`/`any`/`negate`), projections via optics or functions (`check`), and reusable validation modules.\n\n## [0.6.0] - Unreleased","title":"Added - Changelog","ref":"changelog.html#added-3"},{"type":"extras","doc":"**Module reorganization** for cleaner separation of protocols and utilities:\n\n#### Eq Module Changes\n\n* **`Funx.Eq` (protocol) → `Funx.Eq.Protocol`**\n  * The equality protocol is now `Funx.Eq.Protocol`\n  * Protocol implementations must use `defimpl Funx.Eq.Protocol, for: YourType`\n\n* **`Funx.Eq.Utils` → `Funx.Eq`**\n  * Utility functions moved from `Funx.Eq.Utils` to `Funx.Eq`\n  * DSL merged into `Funx.Eq` (no more separate `Funx.Eq.Dsl`)\n  * `use Funx.Eq` imports the `eq` DSL macro\n  * `alias Funx.Eq` for utility functions (optional, or use fully qualified)\n\n#### Ord Module Changes\n\n* **`Funx.Ord` (protocol) → `Funx.Ord.Protocol`**\n  * The ordering protocol is now `Funx.Ord.Protocol`\n  * Protocol implementations must use `defimpl Funx.Ord.Protocol, for: YourType`\n\n* **`Funx.Ord.Utils` → `Funx.Ord`**\n  * Utility functions moved from `Funx.Ord.Utils` to `Funx.Ord`\n  * DSL merged into `Funx.Ord` (no more separate `Funx.Ord.Dsl`)\n  * `use Funx.Ord` imports the `ord` DSL macro\n  * `alias Funx.Ord` for utility functions (optional, or use fully qualified)\n\n#### Migration Guide\n\n**Eq changes:**\n\n```elixir\n# Before\nalias Funx.Eq.Utils\nuse Funx.Eq.Dsl\nUtils.contramap(&(&1.age))\n\ndefimpl Funx.Eq, for: MyStruct do\n  def eq?(a, b), do: a.id == b.id\nend\n\n# After\nuse Funx.Eq              # Imports eq DSL macro\nalias Funx.Eq            # For utility functions\n\nEq.contramap(&(&1.age))\n\ndefimpl Funx.Eq.Protocol, for: MyStruct do\n  def eq?(a, b), do: a.id == b.id\nend\n```\n\n**Ord changes:**\n\n```elixir\n# Before\nalias Funx.Ord.Utils\nuse Funx.Ord.Dsl\nUtils.contramap(&(&1.score))\n\ndefimpl Funx.Ord, for: MyStruct do\n  def lt?(a, b), do: a.score < b.score\nend\n\n# After\nuse Funx.Ord             # Imports ord DSL macro\nalias Funx.Ord           # For utility functions\n\nOrd.contramap(&(&1.score))\n\ndefimpl Funx.Ord.Protocol, for: MyStruct do\n  def lt?(a, b), do: a.score < b.score\nend\n```\n\n**Default parameter changes:**\n\n* Functions with `ord \\\\ Ord` now use `ord \\\\ Funx.Ord.Protocol`\n* DSL parser defaults to `Funx.Ord.Protocol` for comparison checks","title":"Breaking Changes - Changelog","ref":"changelog.html#breaking-changes-2"},{"type":"extras","doc":"This reorganization provides:\n\n* Clear separation: Protocols (`*.Protocol`) vs utilities (`Funx.Eq`, `Funx.Ord`)\n* Minimal imports: `use` imports only the DSL macro, not all functions\n* Better discoverability: Main modules contain the utilities users interact with\n* User control: Users decide whether to alias or use fully qualified names\n\n## [0.5.0] - Unreleased","title":"Rationale - Changelog","ref":"changelog.html#rationale"},{"type":"extras","doc":"* `Funx.Optics.Traversal` – A composable optic for accessing multiple foci simultaneously. Supports filtering, combining multiple optics, and working with collections.\n* `Funx.Ord.Dsl` – A declarative DSL for building custom ordering comparators with support for multiple projections, ascending/descending order, and automatic identity tiebreakers.\n* `Funx.Eq.Dsl` – A declarative DSL for building equality comparators with support for projections, boolean logic (`all`/`any` blocks), and negation (`diff_on`).","title":"Added - Changelog","ref":"changelog.html#added-4"},{"type":"extras","doc":"* `Funx.List.maybe_head` renamed to `Funx.List.head/1` for consistency with `head!/1`. The function still returns `Maybe.t()` for safe head access.\n\n## [0.4.2] - Unreleased","title":"Breaking - Changelog","ref":"changelog.html#breaking"},{"type":"extras","doc":"* `Funx.Optics.Iso` – A lawful isomorphism optic for reversible, lossless transformations between equivalent representations.\n* `Funx.Maybe.Dsl` – A structured DSL for sequencing `Maybe` computations with explicit boundaries, validation, and side effects.\n\n## [0.4.0] - Unreleased","title":"Added - Changelog","ref":"changelog.html#added-5"},{"type":"extras","doc":"Introduced **Optics** for composable, lawful data access and transformation:\n\n* `Funx.Optics.Lens` - Total optic for required fields. Raises `KeyError` if focus is missing. Use for fields that should always exist.\n* `Funx.Optics.Prism` - Partial optic for optional fields. Returns `Maybe`. Use for fields that may be absent or for selecting struct types.\n* `Funx.Monoid.Optics.LensCompose` - Monoid wrapper for sequential lens composition\n* `Funx.Monoid.Optics.PrismCompose` - Monoid wrapper for sequential prism composition\n\n## [0.3.0] - Unreleased","title":"Added - Changelog","ref":"changelog.html#added-6"},{"type":"extras","doc":"Introduced a Funx.Tap protocol and migrated all monads to use protocol-based tap.","title":"Added - Changelog","ref":"changelog.html#added-7"},{"type":"extras","doc":"tap implementations for Identity, Maybe, Either, Reader, and Effect now delegate through the Funx.Tap protocol.","title":"Changed - Changelog","ref":"changelog.html#changed"},{"type":"extras","doc":"Existing direct tap/2 implementations have been removed. Code relying on the previous module-specific tap implementations require updates.\n\n## [0.2.3] - Unreleased","title":"Breaking - Changelog","ref":"changelog.html#breaking-1"},{"type":"extras","doc":"* Refactored the Either DSL implementation to make it safer and easier to maintain.\n\n## [0.2.2] - Unreleased","title":"Updated - Changelog","ref":"changelog.html#updated"},{"type":"extras","doc":"* Add `tap` behavior across Identity, Maybe, Either, Reader, and Effect Monads\n* Add `tap` behavior to Either DSL\n\n## [0.2.0] - Unreleased","title":"Added - Changelog","ref":"changelog.html#added-8"},{"type":"extras","doc":"* Either DSL for writing declarative error-handling pipelines with support for `bind`, `map`, `ap`, `validate`, and Either functions (`filter_or_else`, `or_else`, `map_left`, `flip`)","title":"Added - Changelog","ref":"changelog.html#added-9"},{"type":"extras","doc":"⚠️ **Funx is in active development. APIs may change until version 1.0.**\n\nWe're currently in beta, focusing on:\n\n* Core functionality implementation and stabilization\n* Comprehensive usage rules and documentation for humans and LLMs\n* Real-world testing and feedback incorporation\n* API refinement based on practical usage patterns\n\n**Current Status**: Feature-complete beta with comprehensive documentation. Ready for experimentation and feedback, but expect potential API changes before 1.0.","title":"Beta Status (v0.1.x) - Changelog","ref":"changelog.html#beta-status-v0-1-x"},{"type":"extras","doc":"* 🐛 **Issues**: [Report bugs and suggest improvements](https://github.com/JKWA/funx/issues)\n* 📖 **Documentation**: Help us improve usage rules and examples\n* 🧪 **Real-world usage**: Share your experience using Funx in projects\n* 💬 **Discussion**: Join conversations about functional programming patterns in Elixir\n\n---\n\n*Detailed changelog will begin with version 1.0. Until then, see [GitHub releases](https://github.com/JKWA/funx/releases) for version-specific changes.*","title":"Feedback Welcome - Changelog","ref":"changelog.html#feedback-welcome"},{"type":"extras","doc":"# MIT License\n\nCopyright (c) 2024 Joseph Koski\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.","title":"LICENSE","ref":"license.html"},{"type":"extras","doc":"# Learning resources","title":"Learning resources","ref":"resources.html"},{"type":"extras","doc":"Interactive notebooks you can run in your browser:\n\n* [Funx examples](https://www.funxlib.com/funx-livebooks.html): hands-on examples of Funx features\n* [Book examples](https://www.funxlib.com/book-livebooks.html): material from Advanced Functional Programming with Elixir","title":"LiveBooks - Learning resources","ref":"resources.html#livebooks"},{"type":"extras","doc":"* [Use your LLM as a tutor](https://www.funxlib.com/tutor.html): learn Funx with AI-powered assistance","title":"Tutor - Learning resources","ref":"resources.html#tutor"},{"type":"extras","doc":"* [Funx posts from my blog](https://www.joekoski.com/categories/funx/): articles and tutorials about using Funx, including deep dives into the Either DSL","title":"Blog posts - Learning resources","ref":"resources.html#blog-posts"},{"type":"extras","doc":"* [Advanced Functional Programming with Elixir](https://pragprog.com/titles/jkelixir/advanced-functional-programming-with-elixir): advanced functional programming techniques and patterns in Elixir","title":"Book - Learning resources","ref":"resources.html#book"},{"type":"extras","doc":"# Funx - Functional Programming Patterns for Elixir\n\n[![Continuous Integration](https://github.com/JKWA/funx/actions/workflows/ci.yml/badge.svg)](https://github.com/JKWA/funx/actions/workflows/ci.yml)\n[![Hex.pm](https://img.shields.io/hexpm/v/funx.svg)](https://hex.pm/packages/funx)\n\n⚠️ **Beta:** Funx is in active development. APIs may change until version 1.0. Feedback and contributions are welcome.\n\n**Official website:** [https://www.funxlib.com](https://www.funxlib.com)\n**Code and API documentation:** [https://hex.pm/packages/funx](https://hex.pm/packages/funx)","title":"README","ref":"readme.html"},{"type":"extras","doc":"If you're upgrading from 0.6.0 or earlier, be aware of the module reorganization:","title":"Breaking Changes in 0.6.0 - README","ref":"readme.html#breaking-changes-in-0-6-0"},{"type":"extras","doc":"```elixir\n# Change protocol implementations\ndefimpl Funx.Eq, for: MyStruct          # Old\ndefimpl Funx.Eq.Protocol, for: MyStruct  # New\n\n# Change imports and aliases\nalias Funx.Eq.Utils  # Old\nuse Funx.Eq.Dsl      # Old\n\nuse Funx.Eq          # New (imports eq DSL macro)\nalias Funx.Eq        # New (for utility functions)\n\n# Example usage\nEq.contramap(&(&1.age))\n```","title":"Eq changes - README","ref":"readme.html#eq-changes"},{"type":"extras","doc":"```elixir\n# Change protocol implementations\ndefimpl Funx.Ord, for: MyStruct          # Old\ndefimpl Funx.Ord.Protocol, for: MyStruct  # New\n\n# Change imports and aliases\nalias Funx.Ord.Utils  # Old\nuse Funx.Ord.Dsl      # Old\n\nuse Funx.Ord          # New (imports ord DSL macro)\nalias Funx.Ord        # New (for utility functions)\n\n# Example usage\nOrd.contramap(&(&1.score))\n```\n\nSee the [CHANGELOG](CHANGELOG.md) for more details.","title":"Ord changes - README","ref":"readme.html#ord-changes"},{"type":"extras","doc":"To use Funx, add it to the list of dependencies in `mix.exs`:\n\n```elixir\ndef deps do\n  [\n    {:funx, \"~> 0.8\"}\n  ]\nend\n```\n\nThen, run the following command to fetch the dependencies:\n\n```bash\nmix deps.get\n```","title":"Installation - README","ref":"readme.html#installation"},{"type":"extras","doc":"Funx includes embedded **usage rules** in addition to API documentation.  \nThey are written for development workflows assisted by LLMs.","title":"Usage Rules - README","ref":"readme.html#usage-rules"},{"type":"extras","doc":"The `Eq` protocol defines how two values are compared, making equality explicit and adaptable to your domain.\n\n- Define what “equal” means—compare by ID, name, or any derived attribute.\n- Compose multiple comparisons—require all to match or just one.\n- Implement for structs, built-in types, or custom comparators.","title":"Equality - README","ref":"readme.html#equality"},{"type":"extras","doc":"The `Ord` protocol defines ordering relationships in a structured way, without relying on Elixir's built-in comparison operators.\n\n- Define comparisons based on properties like size, age, or priority.\n- Chain orderings to create fallback tiebreakers.\n- Implement for any type, including custom structs.","title":"Ordering - README","ref":"readme.html#ordering"},{"type":"extras","doc":"The Ord module includes a DSL for building custom ordering comparators declaratively:\n\n```elixir\nuse Funx.Ord\n\nuser_ord = ord do\n  desc :priority\n  asc :name\n  desc :created_at\nend\n\nEnum.sort(users, Funx.Ord.comparator(user_ord))\n```\n\nFeatures:\n\n- Multiple projections with `asc` and `desc` directions\n- Support for optics (Lens, Prism), functions, and modules\n- Ord variables for composing and reversing orderings","title":"Ord DSL - README","ref":"readme.html#ord-dsl"},{"type":"extras","doc":"The Eq module includes a DSL for building equality comparators with boolean logic:\n\n```elixir\nuse Funx.Eq\n\ncontact_eq = eq do\n  on :name\n  any do\n    on :email\n    on :username\n  end\nend\n\nFunx.Eq.eq?(user1, user2, contact_eq)\n```\n\nFeatures:\n\n- `on` - Field must be equal\n- `diff_on` - Field must differ (non-equivalence constraint)\n- `all` blocks - All checks must pass (AND logic)\n- `any` blocks - At least one check must pass (OR logic)\n- Support for optics, functions, and custom comparators","title":"Eq DSL - README","ref":"readme.html#eq-dsl"},{"type":"extras","doc":"Monads encapsulate computations, allowing operations to be chained while handling concerns like optional values, failures, dependencies, or deferred effects.\n\n- `Identity`: Wraps a value with no additional behavior—useful for organizing transformations.\n- `Maybe`: Represents optional data using `Just` for presence and `Nothing` for absence.\n- `Either`: Models computations with two possibilities—`Left` and `Right`.\n- `Effect`: Encapsulates deferred execution with error handling, similar to `Task`.\n- `Reader`: Passes an immutable environment through a computation for dependency injection or configuration.\n- `Writer`: Threads a log alongside a result using any monoid—useful for tracing, reporting, or accumulating metadata during computation.","title":"Monads - README","ref":"readme.html#monads"},{"type":"extras","doc":"The Either monad includes a DSL for writing declarative pipelines that handle errors gracefully:\n\n```elixir\nuse Funx.Monad.Either\n\neither user_id do\n  bind fetch_user()\n  bind validate_active()\n  map transform_to_dto()\nend\n```\n\nSupported operations:\n\n- `bind` - for operations that return Either or result tuples\n- `map` - for transformations that return plain values\n- `ap` - for applying a function in an Either to a value in an Either\n- `validate` - for accumulating multiple validation errors\n- Either functions: `filter_or_else`, `or_else`, `map_left`, `flip`, `tap`\n\n**Formatter Configuration**: Funx exports formatter rules for clean DSL formatting. Add `:funx` to `import_deps` in your `.formatter.exs`:\n\n```elixir\n[\n  import_deps: [:funx],\n  inputs: [\"{mix,.formatter}.exs\", \"{config,lib,test}/**/*.{ex,exs}\"]\n]\n```\n\nSee [FORMATTER_EXPORT.md](FORMATTER_EXPORT.md) for details.","title":"Either DSL - README","ref":"readme.html#either-dsl"},{"type":"extras","doc":"Optics provide composable, lawful abstractions for focusing on and transforming parts of data structures.\n\n- `Lens`: Total optic for required fields—raises if focus is missing. Use for fields that should always exist.\n- `Prism`: Partial optic for optional fields—returns `Maybe`. Use for fields that may be absent or for selecting struct types.\n- `Traversal`: Optic for accessing multiple foci simultaneously. Use for filtering collections, combining multiple optics, or working with list-like structures.\n- `Iso`: Total optic for reversible representation changes. Use when two shapes carry the same information and you need guaranteed round trip conversion (`view` then `review`).","title":"Optics - README","ref":"readme.html#optics"},{"type":"extras","doc":"Monoids combine values using an associative operation and an identity element. They are useful for accumulation, selection, and combining logic.\n\n- `Sum`: Adds numbers (`0` is the identity).\n- `Product`: Multiplies numbers (`1` is the identity).\n- `Eq.All`: Values are equal only if all comparators agree.\n- `Eq.Any`: Values are equal if any comparator agrees.\n- `Predicate.All`: All predicates must hold.\n- `Predicate.Any`: At least one predicate must hold.\n- `Ord`: Defines ordering compositionally.\n- `Max` and `Min`: Select the largest or smallest value by custom ordering.\n- `ListConcat`: Concatenates lists (`[]` is the identity).\n- `StringConcat`: Concatenates strings (`\"\"` is the identity).","title":"Monoids - README","ref":"readme.html#monoids"},{"type":"extras","doc":"Predicates are functions that return `true` or `false`. Funx provides combinators for composing them cleanly.\n\n- `p_and`: Returns `true` if both predicates pass.\n- `p_or`: Returns `true` if either predicate passes.\n- `p_not`: Negates a predicate.\n- `p_all`: Returns `true` if all predicates in a list pass.\n- `p_any`: Returns `true` if any predicate in a list passes.\n- `p_none`: Returns `true` if none pass.","title":"Predicates - README","ref":"readme.html#predicates"},{"type":"extras","doc":"The Predicate module includes a DSL for building boolean predicates declaratively:\n\n```elixir\nuse Funx.Predicate\n\ncheck_eligible = pred do\n  check :age, fn age -> age >= 18 end\n  check :verified, fn v -> v == true end\n  any do\n    check :role, fn r -> r == :admin end\n    check :role, fn r -> r == :moderator end\n  end\nend\n\nEnum.filter(users, check_eligible)\n```\n\nFeatures:\n\n- `check` - Project into a field and test with a predicate\n- `negate` - Invert a predicate (logical NOT)\n- `all` blocks - All predicates must pass (AND logic)\n- `any` blocks - At least one must pass (OR logic)\n- Support for optics (Lens, Prism), functions, and behaviour modules","title":"Pred DSL - README","ref":"readme.html#pred-dsl"},{"type":"extras","doc":"The `Validate` module provides declarative data validation with applicative error accumulation—all validators run and all errors are collected.","title":"Validation - README","ref":"readme.html#validation"},{"type":"extras","doc":"```elixir\nuse Funx.Validate\nalias Funx.Monad.Either\nalias Funx.Validator.{Required, Email, MinLength, Positive}\n\nuser_validation =\n  validate do\n    at :name, [Required, {MinLength, min: 3}]\n    at :email, [Required, Email]\n    at :age, Positive\n  end\n\nEither.validate(%{name: \"Alice\", email: \"alice@example.com\", age: 30}, user_validation)\n# => %Right{right: %{name: \"Alice\", email: \"alice@example.com\", age: 30}}\n\nEither.validate(%{name: \"\", email: \"bad\", age: -5}, user_validation)\n# => %Left{left: %ValidationError{errors: [\"is required\", \"must be at least 3 characters\", ...]}}\n```\n\nFeatures:\n\n- `at :field, Validator` - Field validation using Prism (optional by default)\n- `at [:a, :b], Validator` - Nested path validation\n- `at Lens.key(:field), Validator` - Required field (raises if missing)\n- Multiple validators: `[Required, Email]` or `{MinLength, min: 3}`\n- Root validators for whole-structure validation\n- Environment passing for context-dependent validation\n- Composable validators that can be nested and reused\n\nBuilt-in validators: `Required`, `Email`, `MinLength`, `MaxLength`, `Pattern`, `Positive`, `Negative`, `Integer`, `GreaterThan`, `LessThan`, `In`, `NotIn`, `Range`, `Each`, `Confirmation`, `Not`","title":"Validate DSL - README","ref":"readme.html#validate-dsl"},{"type":"extras","doc":"The `Foldable` protocol defines how to reduce a structure to a single result.\n\n- `fold_l`: Reduces from the left, applying functions in order.\n- `fold_r`: Reduces from the right, applying functions in reverse.\n\nUseful for accumulating values, transforming collections, or extracting data.","title":"Folding - README","ref":"readme.html#folding"},{"type":"extras","doc":"The `Filterable` protocol defines how to conditionally retain values within a context.\n\n- `guard`: Keeps a value if a condition is met; otherwise returns an empty context.\n- `filter`: Retains values that satisfy a predicate.\n- `filter_map`: Applies a transformation and keeps results only when the transformed value is present.","title":"Filtering - README","ref":"readme.html#filtering"},{"type":"extras","doc":"Sequencing runs a series of monadic operations in order, combining the results.\n\n- `concat/1`: Removes empty values and unwraps the present results from a list.\n- `concat_map/2`: Applies a function to each element and collects only the present results.\n- `sequence/1`: Converts a list of monadic values into a single monadic value containing a list. Short-circuits on the first failure or absence.\n- `traverse/2`: Applies a function to each element and sequences the resulting monadic values.\n- `sequence_a/1`: Applicative version of sequence—combines all and collects results.\n- `traverse_a/2`: Applicative version of traverse—applies a function to each element and collects results.","title":"Sequencing - README","ref":"readme.html#sequencing"},{"type":"extras","doc":"Lifting functions promote ordinary logic into a monadic or contextual form.\n\n- `lift_predicate/3`: Wraps a value in a monad if a condition holds; returns an empty or failed context otherwise.\n- `lift_eq/1`: Adapts an `Eq` comparator to work within a monadic context.\n- `lift_ord/1`: Adapts an `Ord` comparator to work within a monadic context.","title":"Lifting - README","ref":"readme.html#lifting"},{"type":"extras","doc":"Funx integrates with common Elixir patterns like `{:ok, value}` and `{:error, reason}`.\n\n- `from_result/1`: Converts a result tuple into a monadic context that distinguishes success from failure.\n- `to_result/1`: Converts a monadic value back into a result tuple.\n- `from_try/1`: Wraps a function call in a monad, capturing exceptions as failures.\n- `to_try!/1`: Extracts the value from a monad or raises if it represents a failure.","title":"Interop - README","ref":"readme.html#interop"},{"type":"extras","doc":"The authoritative API documentation is published on [HexDocs](https://hexdocs.pm/funx).","title":"Documentation - README","ref":"readme.html#documentation"},{"type":"extras","doc":"- **[Funx Blog Posts](https://www.joekoski.com/categories/funx/)** - Articles and tutorials about using Funx, including deep dives into the Either DSL and functional programming patterns in Elixir","title":"Learning Resources - README","ref":"readme.html#learning-resources"},{"type":"extras","doc":"1. Fork the repository.  \n2. Create a new branch for the feature or bugfix (`git checkout -b feature-branch`).  \n3. Commit changes (`git commit -am 'Add new feature'`).  \n4. Push the branch (`git push origin feature-branch`).  \n5. Create a pull request.","title":"Contributing - README","ref":"readme.html#contributing"},{"type":"extras","doc":"This project is licensed under the MIT License.","title":"License - README","ref":"readme.html#license"},{"type":"extras","doc":"# Formatter Rules\n\nThe Funx library exports formatter rules for its DSLs, allowing projects that depend on Funx to automatically format DSL code without extra parentheses.","title":"Formatter Rules","ref":"formatter_export.html"},{"type":"extras","doc":"","title":"Exported Rules - Formatter Rules","ref":"formatter_export.html#exported-rules"},{"type":"extras","doc":"The following Either DSL functions are configured to format without parentheses:\n\n- `either/2` - DSL entry point\n- `bind/1` - Chain operations that return Either or result tuples\n- `map/1` - Transform values with plain functions\n- `ap/1` - Apply function in Either to value in Either\n- `validate/1` - Collect all errors from validators\n- `filter_or_else/2` - Filter with predicate, fallback if fails\n- `or_else/1` - Provide fallback on error\n- `map_left/1` - Transform error values\n- `tap` - Run a side-effecting function inside the chain without changing the data\n\nNote that `flip/0` - Swap Left and Right still requires parentheses.","title":"Either DSL - Formatter Rules","ref":"formatter_export.html#either-dsl"},{"type":"extras","doc":"The following Maybe DSL functions are configured to format without parentheses:\n\n- `maybe/2` - DSL entry point\n- `bind/1` - Chain operations that return Maybe, Either, result tuples, or nil (shared with Either DSL)\n- `map/1` - Transform values with plain functions (shared with Either DSL)\n- `ap/1` - Apply function in Maybe to value in Maybe (shared with Either DSL)\n- `or_else/1` - Provide fallback on Nothing (shared with Either DSL)\n- `tap/1` - Run a side-effecting function inside the chain without changing the data (shared with Either DSL)\n- `filter/1` - Filter with a predicate, returns Nothing if predicate fails\n- `filter_map/2` - Filter and transform in one step\n- `guard/1` - Guard with a boolean condition","title":"Maybe DSL - Formatter Rules","ref":"formatter_export.html#maybe-dsl"},{"type":"extras","doc":"The following Ord DSL functions are configured to format without parentheses:\n\n- `asc/1` - Ascending order for a projection\n- `asc/2` - Ascending order with options (e.g., `default:`)\n- `desc/1` - Descending order for a projection\n- `desc/2` - Descending order with options (e.g., `default:`)","title":"Ord DSL - Formatter Rules","ref":"formatter_export.html#ord-dsl"},{"type":"extras","doc":"The following Eq DSL functions are configured to format without parentheses:\n\n- `on/1` - Compare on a projection\n- `on/2` - Compare on a projection with options\n- `not_on/1` - Exclude a projection from comparison\n- `not_on/2` - Exclude a projection from comparison with options\n- `any/1` - Match any of the given comparisons (shared with Predicate DSL)\n- `all/1` - Match all of the given comparisons (shared with Predicate DSL)","title":"Eq DSL - Formatter Rules","ref":"formatter_export.html#eq-dsl"},{"type":"extras","doc":"The following Predicate DSL functions are configured to format without parentheses:\n\n- `pred/1` - DSL entry point for defining predicates\n- `check/2` - Project and test a value (e.g., `check :field, predicate`)\n- `negate/1` - Negate a predicate or block\n- `negate_all/1` - Negate an AND block (applies De Morgan's Laws)\n- `negate_any/1` - Negate an OR block (applies De Morgan's Laws)\n- `any/1` - OR logic - at least one predicate must pass (shared with Eq DSL)\n- `all/1` - AND logic - all predicates must pass (shared with Eq DSL)","title":"Predicate DSL - Formatter Rules","ref":"formatter_export.html#predicate-dsl"},{"type":"extras","doc":"","title":"Usage in Dependent Projects - Formatter Rules","ref":"formatter_export.html#usage-in-dependent-projects"},{"type":"extras","doc":"Make sure your `mix.exs` includes Funx as a dependency:\n\n```elixir\ndef deps do\n  [\n    {:funx, \"~> 0.2\"}\n  ]\nend\n```","title":"Step 1: Add to Dependencies - Formatter Rules","ref":"formatter_export.html#step-1-add-to-dependencies"},{"type":"extras","doc":"In your project's `.formatter.exs`, add `:funx` to `import_deps`:\n\n```elixir\n[\n  import_deps: [:funx],\n  inputs: [\"{mix,.formatter}.exs\", \"{config,lib,test}/**/*.{ex,exs}\"]\n]\n```","title":"Step 2: Update .formatter.exs - Formatter Rules","ref":"formatter_export.html#step-2-update-formatter-exs"},{"type":"extras","doc":"","title":"Examples - Formatter Rules","ref":"formatter_export.html#examples"},{"type":"extras","doc":"With this configuration, your DSL code will format cleanly:\n\n```elixir\neither user_input do\n  bind ParseUser\n  map ValidateEmail\n  validate [CheckLength, CheckFormat]\n  bind SaveToDatabase\n  or_else default_user()\nend\n```\n\nInstead of:\n\n```elixir\neither(user_input) do\n  bind(ParseUser)\n  map(ValidateEmail)\n  validate([CheckLength, CheckFormat])\n  bind(SaveToDatabase)\n  or_else(default_user())\nend\n```","title":"Either DSL - Formatter Rules","ref":"formatter_export.html#either-dsl-1"},{"type":"extras","doc":"Your Maybe pipelines will format cleanly:\n\n```elixir\nmaybe user_input do\n  bind ParseInt\n  filter PositiveNumber\n  map Double\n  or_else default_value()\nend\n```\n\nInstead of:\n\n```elixir\nmaybe(user_input) do\n  bind(ParseInt)\n  filter(PositiveNumber)\n  map(Double)\n  or_else(default_value())\nend\n```","title":"Maybe DSL - Formatter Rules","ref":"formatter_export.html#maybe-dsl-1"},{"type":"extras","doc":"Your ordering definitions will format cleanly:\n\n```elixir\nord do\n  asc :name\n  desc :age\n  asc :score, default: 0\nend\n```\n\nInstead of:\n\n```elixir\nord do\n  asc(:name)\n  desc(:age)\n  asc(:score, default: 0)\nend\n```","title":"Ord DSL - Formatter Rules","ref":"formatter_export.html#ord-dsl-1"},{"type":"extras","doc":"Your predicate definitions will format cleanly:\n\n```elixir\npred do\n  check :age, fn age -> age >= 18 end\n  negate check :banned, fn b -> b == true end\n  any do\n    check :role, fn r -> r == :admin end\n    check :verified, fn v -> v == true end\n  end\n  negate_all do\n    check :suspended, fn s -> s == true end\n    check :deleted, fn d -> d == true end\n  end\nend\n```\n\nInstead of:\n\n```elixir\npred do\n  check(:age, fn age -> age >= 18 end)\n  negate(check(:banned, fn b -> b == true end))\n  any do\n    check(:role, fn r -> r == :admin end)\n    check(:verified, fn v -> v == true end)\n  end\n  negate_all do\n    check(:suspended, fn s -> s == true end)\n    check(:deleted, fn d -> d == true end)\n  end\nend\n```","title":"Predicate DSL - Formatter Rules","ref":"formatter_export.html#predicate-dsl-1"},{"type":"extras","doc":"To verify the formatter rules are being imported correctly, you can run:\n\n```bash\nmix format --check-formatted\n```\n\nYour DSL code should format without adding parentheses.","title":"Verification - Formatter Rules","ref":"formatter_export.html#verification"},{"type":"extras","doc":"# Overview\n\nFunx provides two distinct categories of DSLs with different purposes and semantics.","title":"Overview","ref":"overview.html"},{"type":"extras","doc":"","title":"DSL Categories - Overview","ref":"overview.html#dsl-categories"},{"type":"extras","doc":"Builder DSLs construct data structures (comparators, orderings, predicates, validators) for later use.\n\nExamples: `eq`, `ord`, `pred`, `validate`\n\nCharacteristics:\n\n- No input parameter — builds a reusable function or comparator\n- Returns a data structure — built via monoidal composition (Eq.All, Ord monoid, predicate function)\n- Used with utility functions — `Eq.eq?/3`, `Ord.compare/3`, `Enum.filter/2`\n- May support nesting — `any`/`all` blocks for boolean composition (Eq, Pred only)\n\nExample:\n\n```elixir\n# Build a comparator\nuser_eq = eq do\n  on :name\n  on :email\nend\n\n# Use it later\nEq.eq?(user1, user2, user_eq)\n```","title":"Builder DSLs - Overview","ref":"overview.html#builder-dsls"},{"type":"extras","doc":"Pipeline DSLs execute a sequence of operations on an input value.\n\nExamples: `maybe`, `either`\n\nCharacteristics:\n\n- Takes input parameter — transforms/validates the input\n- Returns a result — Maybe.t() or Either.t() with the transformed value\n- Sequential execution — steps run in order, short-circuit on failure\n- Supports transformers — compile-time pipeline optimization\n\nExample:\n\n```elixir\n# Execute pipeline on input\nmaybe user_id do\n  bind GetUser\n  bind ValidateActive\n  map FormatResponse\nend\n# Returns Maybe.t()\n```","title":"Pipeline DSLs - Overview","ref":"overview.html#pipeline-dsls"},{"type":"extras","doc":"| Aspect      | Builder DSLs                | Pipeline DSLs             |\n| ----------- | --------------------------- | ------------------------- |\n| Signature   | `dsl do ... end`            | `dsl input do ... end`    |\n| Purpose     | Build reusable structures   | Transform input values    |\n| Execution   | Deferred (used later)       | Immediate (on input)      |\n| Return Type | Monoid/Function             | Monad (Maybe/Either)      |\n| Nesting     | Supports `any`/`all` blocks | Linear (sequential steps) |","title":"Key Differences - Overview","ref":"overview.html#key-differences"},{"type":"extras","doc":"A Funx DSL block compiles at macro-expansion time. The compiler parses the block syntax, applies transformations, and produces executable code. The compiled representation varies by DSL but typically involves structured data describing the operations to perform.\n\n```text\nCompilation\n    ├── DSL Block (AST)\n    ├── Parser\n    │     └── Builds internal representation\n    ├── Transformers\n    │     └── Optional rewrites\n    ├── Compiled Form\n    └── Executor\n          └── Produces result\n```","title":"Structure - Overview","ref":"overview.html#structure"},{"type":"extras","doc":"Each DSL defines its own internal representation of operations. For pipeline DSLs, these are typically step structs describing transformations. For builder DSLs, operations describe composition rules. The executor interprets these representations to produce the final result.\n\n```text\nParsed Operations\n    ├── Operation\n    ├── Operation\n    ├── Operation\n    └── Operation\n```","title":"Operations - Overview","ref":"overview.html#operations"},{"type":"extras","doc":"Each DSL provides its own parser. The parser converts the DSL block into an internal representation, applies lifting and alias-expansion rules, and raises compile-time errors for invalid or unsupported forms.","title":"Parser - Overview","ref":"overview.html#parser"},{"type":"extras","doc":"Transformers run during compilation and may rewrite the parsed operations before code generation. They can insert, remove, or modify operations. A transformer must return a valid representation for that DSL and introduces a compile-time dependency. Currently supported by pipeline DSLs (Maybe, Either).","title":"Transformers - Overview","ref":"overview.html#transformers"},{"type":"extras","doc":"Each DSL has a dedicated executor. The executor interprets the compiled representation and produces the final result. It does not inspect source code; it operates only on the compiled form.","title":"Execution - Overview","ref":"overview.html#execution"},{"type":"extras","doc":"Each DSL defines a behaviour for modules that participate in the DSL. Modules implementing this behaviour supply the callback the executor invokes. The DSL determines how the callback's return value is interpreted.","title":"Behaviours - Overview","ref":"overview.html#behaviours"},{"type":"extras","doc":"","title":"Architectural Choices - Overview","ref":"overview.html#architectural-choices"},{"type":"extras","doc":"The `ord` DSL does not support `any`/`all` blocks like `eq` and `pred` do. This is intentional.\n\nTotal orderings compose linearly. When you combine orderings with `Ord.concat/1`, you get a lexicographic ordering where the first comparison that returns `:lt` or `:gt` determines the result. This is fundamentally different from the boolean logic of equality or predicates.\n\n```elixir\n# Ord: Linear composition (lexicographic)\nord do\n  asc :last_name   # First comparison\n  asc :first_name  # Tiebreaker if last names equal\n  desc :age        # Further tiebreaker\nend\n\n# Eq: Can express OR logic\neq do\n  any do\n    on :email\n    on :username\n  end\nend\n```\n\nThere's no meaningful \"OR\" for orderings - you can't say \"order by name OR age\". The order is always determined by a sequence of tiebreakers.","title":"Why Ord Doesn't Support Nesting - Overview","ref":"overview.html#why-ord-doesn-t-support-nesting"},{"type":"extras","doc":"Pipeline DSLs (`maybe`, `either`) execute sequentially and short-circuit on failure. They don't support `any`/`all` blocks because monadic composition is inherently sequential — each operation depends on the result of the previous one. There's no boolean combination to express; operations either succeed (Right/Just) or fail (Left/Nothing), and failure stops the pipeline.\n\nFor conditional logic in pipelines, use the monad's native operations:\n\n- `filter` - conditionally keep/drop values\n- `guard` - assert a condition\n- Pattern matching in behaviour callbacks","title":"Why Pipeline DSLs Don't Support Nesting - Overview","ref":"overview.html#why-pipeline-dsls-don-t-support-nesting"},{"type":"extras","doc":"# Either\n\nThe Either DSL is a pipeline DSL that executes a sequence of operations on an input value. See the [DSL Overview](overview.md) for the distinction between builder and pipeline DSLs.","title":"Either","ref":"either.html"},{"type":"extras","doc":"An `either` block compiles to a struct containing the pipeline input, ordered steps, return mode (`:either`, `:tuple`, or `:raise`), and user-supplied options. This struct is the complete representation of the DSL expression and is what the executor receives at runtime.","title":"Structure - Either","ref":"either.html#structure"},{"type":"extras","doc":"The Either DSL uses a small set of step types, each represented by its own struct:\n\n* `Step.Bind`\n* `Step.Map`\n* `Step.Ap`\n* `Step.EitherFunction`\n* `Step.BindableFunction` (used by `validate`)\n\nEach step describes a single operation. The executor pattern-matches on these structs to determine how the pipeline proceeds.\n\n```text\nPipeline\n    ├── Step.Bind\n    ├── Step.Map\n    ├── Step.EitherFunction\n    └── Step.Ap\n```","title":"Steps - Either","ref":"either.html#steps"},{"type":"extras","doc":"The parser converts the DSL block into a step list. It applies the Either DSL’s lifting rules (turning call forms into unary functions), expands module aliases, validates operations, and raises compile-time errors for unsupported syntax. The parser produces the final step list that appears in the compiled struct.","title":"Parser - Either","ref":"either.html#parser"},{"type":"extras","doc":"Transformers run during compilation and may rewrite the step list before it is finalized. They can add, remove, or rearrange steps. A transformer must return a valid list of Either step structs and introduces a compile-time dependency for modules that use it.","title":"Transformers - Either","ref":"either.html#transformers"},{"type":"extras","doc":"The executor evaluates steps in order:\n\n* `Step.Bind` unpacks the current Either value, calls the operation, and normalizes its return into Either.\n* `Step.Map` applies a pure function to the inner value.\n* `Step.Ap` applies an applicative function contained in an Either.\n* `Step.EitherFunction` calls a built-in Either operation such as `filter_or_else`, `or_else`, `map_left`, `flip`, or `tap`.\n* `Step.BindableFunction` wraps functions like `validate`, which accumulate errors instead of short-circuiting.\n\nExcept for validation, a `Left` value stops the pipeline immediately. The return mode controls how the final result is wrapped.","title":"Execution - Either","ref":"either.html#execution"},{"type":"extras","doc":"Modules participating in the Either DSL implement specific monad behaviors based on their purpose:\n- `Funx.Validate.Behaviour` - validators (called with `validate/3`)\n- `Funx.Monad.Behaviour.Bind` - operations that can fail (called with `bind/3`)\n- `Funx.Monad.Behaviour.Map` - pure transformations (called with `map/3`)\n- `Funx.Monad.Behaviour.Predicate` - boolean tests (called with `predicate/3`)\n\nThe executor calls the appropriate behavior method based on the DSL operation. Each behavior has specific semantics for how the result is interpreted and processed in the pipeline.","title":"Behaviours - Either","ref":"either.html#behaviours"},{"type":"extras","doc":"# Maybe\n\nThe Maybe DSL is a pipeline DSL that executes a sequence of operations on an input value. See the [DSL Overview](overview.md) for the distinction between builder and pipeline DSLs.","title":"Maybe","ref":"maybe.html"},{"type":"extras","doc":"A `maybe` block compiles to a struct containing the pipeline input, ordered steps, return mode (`:maybe`, `:nil`, or `:raise`), and user-supplied options. This struct is the complete representation of the DSL expression and is what the executor receives at runtime.","title":"Structure - Maybe","ref":"maybe.html#structure"},{"type":"extras","doc":"The Maybe DSL uses a small set of step types, each represented by its own struct:\n\n* `Step.Bind`\n* `Step.Map`\n* `Step.Ap`\n* `Step.MaybeFunction`\n* `Step.ProtocolFunction`\n\nEach step describes a single operation. The executor pattern-matches on these structs to determine how the pipeline proceeds.\n\n```text\nPipeline\n    ├── Step.Bind\n    ├── Step.Map\n    ├── Step.Ap\n    ├── Step.MaybeFunction\n    └── Step.ProtocolFunction\n```","title":"Steps - Maybe","ref":"maybe.html#steps"},{"type":"extras","doc":"The parser converts the DSL block into a step list. It applies the Maybe DSL's lifting rules (turning call forms into unary functions), expands module aliases, validates operations, and raises compile-time errors for unsupported syntax. The parser produces the final step list that appears in the compiled struct.","title":"Parser - Maybe","ref":"maybe.html#parser"},{"type":"extras","doc":"Transformers run during compilation and may rewrite the step list before it is finalized. They can add, remove, or rearrange steps. A transformer must return a valid list of Maybe step structs and introduces a compile-time dependency for modules that use it.","title":"Transformers - Maybe","ref":"maybe.html#transformers"},{"type":"extras","doc":"The executor evaluates steps in order:\n\n* `Step.Bind` unpacks the current Maybe value, calls the operation, and normalizes its return into Maybe (accepting Maybe, Either, result tuples, or nil).\n* `Step.Map` applies a pure function to the inner value.\n* `Step.Ap` applies an applicative function contained in a Maybe.\n* `Step.MaybeFunction` calls a built-in Maybe operation such as `or_else`.\n* `Step.ProtocolFunction` calls a protocol operation such as `tap` (Funx.Tappable), `filter`, `filter_map`, or `guard` (Funx.Filterable).\n\nA `Nothing` value stops the pipeline immediately. The return mode controls how the final result is wrapped (`:maybe` returns the Maybe struct, `:nil` unwraps to the value or nil, `:raise` unwraps or raises an error).","title":"Execution - Maybe","ref":"maybe.html#execution"},{"type":"extras","doc":"Modules participating in the Maybe DSL implement specific monad behaviors based on their purpose:\n- `Funx.Monad.Behaviour.Bind` - operations that can fail (called with `bind/3`, `tap/3`, `filter_map/3`)\n- `Funx.Monad.Behaviour.Map` - pure transformations (called with `map/3`)\n- `Funx.Monad.Behaviour.Predicate` - boolean tests (called with `predicate/3` for `filter` and `guard`)\n- `Funx.Monad.Behaviour.Ap` - applicative functors (called with `ap/3`)\n\nThe executor calls the appropriate behavior method based on the DSL operation. Each behavior has specific semantics for how the result is interpreted and processed in the pipeline.","title":"Behaviours - Maybe","ref":"maybe.html#behaviours"},{"type":"extras","doc":"# Ord\n\nThe Ord DSL is a builder DSL that constructs ordering comparators for later use. See the [DSL Overview](overview.md) for the distinction between builder and pipeline DSLs.","title":"Ord","ref":"ord.html"},{"type":"extras","doc":"An `ord` block compiles entirely at compile time to quoted AST that builds an `%Funx.Monoid.Ord{}` struct. Unlike pipeline DSLs (Maybe, Either), there is no runtime executor—the DSL produces static composition of `contramap`, `reverse`, and `concat` calls that execute directly.","title":"Structure - Ord","ref":"ord.html#structure"},{"type":"extras","doc":"The Ord DSL uses a single structure type represented by `Step`:\n\n* `Step` - Contains direction (`:asc` or `:desc`), projection AST, ord module, and metadata\n\nEach Step describes a single ordering projection. The compiler pattern-matches on these structs to generate the final quoted AST.\n\n```text\nCompilation\n    ├── Step (asc :name)\n    ├── Step (desc :age)\n    └── Step (asc :score, or_else: 0)\n```","title":"Internal Representation - Ord","ref":"ord.html#internal-representation"},{"type":"extras","doc":"The parser converts the DSL block into a list of structures. It normalizes all projection syntax into one of four canonical types that `contramap/2` accepts:\n\n* `Lens.t()` - Bare lens struct\n* `Prism.t()` - Bare prism struct (uses `Maybe.lift_ord`)\n* `{Prism.t(), or_else}` - Prism with or_else value\n* `(a -> b)` - Projection function\n\nPlus special types for modules and runtime values:\n\n* Module with `lt?/2` - Converted via `to_ord_map`\n* Behaviour module - Calls `ord/1` at runtime\n* 0-arity helper - Runtime type detection\n* **Ord variable** - Runtime validation of ord map\n\nAll syntax sugar resolves to these types:\n\n* `:atom` → `Prism.key(:atom)`\n* `[:a, :b]` → `Prism.path([:a, :b])` (supports nested keys and structs)\n* `:atom, or_else: x` → `{Prism.key(:atom), x}`\n* `[:a, :b], or_else: x` → `{Prism.path([:a, :b]), x}`\n* `Lens.key(...)` → `Lens.key(...)` (pass through)\n* `Prism.key(...)` → `Prism.key(...)` (pass through)\n* `{Prism, x}` → `{Prism, x}` (pass through)\n* `fn -> ... end` → `fn -> ... end` (pass through)\n* `Behaviour` → `fn v -> Behaviour.project(v, []) end`\n* `StructModule` → `fn v -> match?(%StructModule{}, v) end` (type filtering)\n* `ord_variable` → runtime validation, use directly if valid ord map\n\nThe parser validates projections and raises compile-time errors for unsupported syntax, producing the final list of structures that the executor will compile.","title":"Parser - Ord","ref":"ord.html#parser"},{"type":"extras","doc":"The Ord DSL does not currently support transformers. All compilation is handled by the parser and executor without intermediate rewriting stages.","title":"Transformers - Ord","ref":"ord.html#transformers"},{"type":"extras","doc":"The executor runs at compile time and generates quoted AST. It follows a single, non-branching path:\n\n1. Take normalized structures from the parser\n2. Wrap each in `Ord.contramap(projection, ord)`\n3. Optionally wrap in `Ord.reverse(...)` for `:desc` direction\n4. Combine all with `Ord.concat([...])` (or return single ord for one step)","title":"Execution - Ord","ref":"ord.html#execution"},{"type":"extras","doc":"Each operation compiles based on its type:\n\n**Regular projections:**\n* `:asc` → `contramap(projection, ord)`\n* `:desc` → `reverse(contramap(projection, ord))`\n\n**Ord variables:**\n* `:asc` → runtime validation, then use ord directly\n* `:desc` → runtime validation, then `reverse(ord)`\n\nMultiple operations are combined with `concat([...])` (monoid composition).","title":"Execution Model - Ord","ref":"ord.html#execution-model"},{"type":"extras","doc":"The DSL does NOT add an implicit tiebreaker. If two values are equal on all specified fields, they compare as `:eq`.\n\nThis means:\n\n* You have explicit control over what matters for ordering\n* DSL results can be composed without hidden tiebreakers in the middle\n* DSL results can be used with `ord_for` macro without recursion issues\n\nTo add a tiebreaker, explicitly include `Funx.Ord.Protocol` as the last projection:\n\n```elixir\nord do\n  asc :name\n  asc Funx.Ord.Protocol  # Falls back to struct's Ord implementation\nend\n```","title":"No Implicit Tiebreaker - Ord","ref":"ord.html#no-implicit-tiebreaker"},{"type":"extras","doc":"```elixir\nord do\n  asc :name\n  desc :age\nend\n```\n\nCompiles to:\n\n```elixir\nOrd.concat([\n  Ord.contramap(Prism.key(:name), Funx.Ord.Protocol),\n  Ord.reverse(Ord.contramap(Prism.key(:age), Funx.Ord.Protocol))\n])\n```","title":"Compilation Example - Ord","ref":"ord.html#compilation-example"},{"type":"extras","doc":"List paths provide convenient syntax for accessing nested fields without manually composing optics:\n\n```elixir\n# Instead of:\nord do\n  asc Prism.path([:user, :profile, :age])\nend\n\n# You can write:\nord do\n  asc [:user, :profile, :age]\nend\n```\n\nList paths support both atom keys and struct modules:\n\n```elixir\ndefmodule Company, do: defstruct [:name, :address]\ndefmodule Address, do: defstruct [:city, :state]\n\n# Sort companies by nested city\nord_by_city = ord do\n  asc [Company, :address, Address, :city]\nend\n\ncompanies = [\n  %Company{name: \"ACME\", address: %Address{city: \"Seattle\", state: \"WA\"}},\n  %Company{name: \"Corp\", address: %Address{city: \"Austin\", state: \"TX\"}},\n  %Company{name: \"Inc\", address: %Address{city: \"Boston\", state: \"MA\"}}\n]\n\nEnum.sort(companies, &Ord.lt?(&1, &2, ord_by_city))\n# => [Austin, Boston, Seattle]\n```\n\nList paths work with `or_else` for handling missing values:\n\n```elixir\nord do\n  asc [:user, :profile, :score], or_else: 0\nend\n```\n\nList paths work with `desc` for descending order:\n\n```elixir\nord do\n  desc [:user, :profile, :created_at]\nend\n```","title":"List Paths (Nested Field Access) - Ord","ref":"ord.html#list-paths-nested-field-access"},{"type":"extras","doc":"Ord variables allow you to compose and reuse existing ord maps within the DSL. A variable holding an ord map can be used directly as a projection:\n\n```elixir\nbase_ord = ord do\n  asc :name\n  desc :age\nend\n\ncombined_ord = ord do\n  asc :priority\n  asc base_ord  # Use the ord variable\nend\n\nreversed_ord = ord do\n  desc base_ord  # Reverse the ord variable\nend\n```","title":"Ord Variables - Ord","ref":"ord.html#ord-variables"},{"type":"extras","doc":"When the parser encounters a variable reference (not a module alias or literal), it marks it as `:ord_variable` type. The executor generates runtime validation code:\n\n```elixir\n# asc base_ord compiles to:\ncase base_ord do\n  %{lt?: lt_fun, le?: le_fun, gt?: gt_fun, ge?: ge_fun}\n  when is_function(lt_fun, 2) and is_function(le_fun, 2) and\n       is_function(gt_fun, 2) and is_function(ge_fun, 2) ->\n    base_ord  # Valid ord map, use it directly\n\n  _ ->\n    raise RuntimeError, \"Expected an Ord map, got: #{inspect(base_ord)}\"\nend\n```\n\nThis validation happens when the containing ord is created (not when it's used for comparison).","title":"How It Works - Ord","ref":"ord.html#how-it-works"},{"type":"extras","doc":"Any value that is a valid ord map:\n\n* `ord do ... end` - Ord maps from the DSL\n* `Ord.contramap(...)` - Contramap projections\n* `Ord.reverse(...)` - Reversed orderings\n* `Ord.concat([...])` - Combined orderings\n* `Ord.to_ord_map(module)` - Module-based orderings","title":"What Works as an Ord Variable - Ord","ref":"ord.html#what-works-as-an-ord-variable"},{"type":"extras","doc":"When you use an ord variable with `asc` or `desc`:\n\n* `asc ord_var` - Uses the ord variable as-is\n* `desc ord_var` - Reverses the ord variable\n\nOrd variables preserve their complete ordering semantics when composed.","title":"Composition Semantics - Ord","ref":"ord.html#composition-semantics"},{"type":"extras","doc":"**Reversing complex orderings:**\n\n```elixir\npayment_ord = ord do\n  asc Prism.key(:credit_card_payment)\n  asc Prism.key(:credit_card_refund)\n  asc Prism.key(:check_payment)\nend\n\npayment_desc = ord do\n  desc payment_ord\nend\n```\n\n**Building on base orderings:**\n\n```elixir\nname_age_ord = ord do\n  asc :name\n  desc :age\nend\n\nfull_ord = ord do\n  asc :priority\n  asc name_age_ord\n  asc :created_at\nend\n```\n\n**Composing multiple ord variables:**\n\n```elixir\nprimary_ord = ord do asc :group end\nsecondary_ord = ord do desc :score end\ntertiary_ord = ord do asc :name end\n\ncomplete_ord = ord do\n  asc primary_ord\n  asc secondary_ord\n  asc tertiary_ord\nend\n```","title":"Common Patterns - Ord","ref":"ord.html#common-patterns"},{"type":"extras","doc":"Modules participating in the Ord DSL implement `Funx.Ord.Dsl.Behaviour`. The parser converts behaviour module references into projection functions that call `project/2` on these modules. The behaviour's return value must be a comparable type (any type implementing the `Funx.Ord` protocol).\n\nThe `project/2` callback receives:\n\n* `value` - The input value being projected\n* `opts` - Keyword list of options passed in the DSL (e.g., `asc MyBehaviour, weight: 2.0`)\n\nExample:\n\n```elixir\ndefmodule WeightedScore do\n  @behaviour Funx.Ord.Dsl.Behaviour\n\n  @impl true\n  def project(item, opts) do\n    weight = Keyword.get(opts, :weight, 1.0)\n    (item.score || 0) * weight\n  end\nend\n\nord do\n  desc WeightedScore, weight: 2.0\nend\n```\n\nThe parser compiles this to `fn v -> WeightedScore.project(v, [weight: 2.0]) end`.","title":"Behaviours - Ord","ref":"ord.html#behaviours"},{"type":"extras","doc":"# Eq\n\nThe Eq DSL is a builder DSL that constructs equality comparators for later use. See the [DSL Overview](overview.md) for the distinction between builder and pipeline DSLs.","title":"Eq","ref":"eq.html"},{"type":"extras","doc":"An `eq` block compiles entirely at compile time to quoted AST that builds an `%Funx.Monoid.Eq.All{}` struct. Unlike pipeline DSLs (Maybe, Either), there is no runtime executor—the DSL produces static composition of `contramap`, `concat_all`, and `concat_any` calls that execute directly.","title":"Structure - Eq","ref":"eq.html#structure"},{"type":"extras","doc":"The Eq DSL uses two structure types to represent the equality composition:\n\n* `Step` - Contains projection AST, eq module, negate flag, type, and metadata\n* `Block` - Contains strategy (`:all` or `:any`), children, and metadata\n\nEach Step describes a single equality check (on a field or projection). Each Block groups multiple checks with AND/OR logic. The compiler pattern-matches on these structs to generate the final quoted AST.\n\n```text\nCompilation\n    ├── Block (all - implicit at top level)\n    │   ├── Step (on :name)\n    │   ├── Step (on :age)\n    │   └── Block (any)\n    │       ├── Step (on :email)\n    │       └── Step (on :username)\n```","title":"Internal Representation - Eq","ref":"eq.html#internal-representation"},{"type":"extras","doc":"The parser converts the DSL block into a tree of Step and Block structures. It normalizes all projection syntax into one of four canonical types that `contramap/2` accepts:\n\n* `Lens.t()` - Bare lens struct\n* `Prism.t()` - Bare prism struct (Nothing == Nothing)\n* `{Prism.t(), or_else}` - Prism with or_else value\n* `(a -> b)` - Projection function\n\nAll syntax sugar resolves to these types:\n\n* `:atom` → `Prism.key(:atom)`\n* `[:a, :b]` → `Prism.path([:a, :b])` (supports nested keys and structs)\n* `:atom, or_else: x` → `{Prism.key(:atom), x}`\n* `[:a, :b], or_else: x` → `{Prism.path([:a, :b]), x}`\n* `Lens.key(...)` → `Lens.key(...)` (pass through)\n* `Prism.key(...)` → `Prism.key(...)` (pass through)\n* `{Prism, x}` → `{Prism, x}` (pass through)\n* `fn -> ... end` → `fn -> ... end` (pass through)\n* `Behaviour` → Behaviour.eq([]) (returns Eq map)\n* `StructModule` → `Utils.to_eq_map(StructModule)` (uses protocol)\n\nAdditionally, the parser tracks a `type` field for each Step to enable compile-time optimization:\n\n* `:projection` - Optics or functions → wrap in contramap\n* `:module_eq` - Module with `eq?/2` → convert via `to_eq_map`\n* `:eq_map` - Behaviour returning Eq map → use directly\n* `:dynamic` - Unknown (0-arity helper) → runtime detection\n\nThe parser validates projections and raises compile-time errors for unsupported syntax, producing the final structure tree that the executor will compile.","title":"Parser - Eq","ref":"eq.html#parser"},{"type":"extras","doc":"The Eq DSL does not currently support transformers. All compilation is handled by the parser and executor without intermediate rewriting stages.","title":"Transformers - Eq","ref":"eq.html#transformers"},{"type":"extras","doc":"The executor runs at compile time and generates quoted AST. It recursively walks the structure tree:\n\n1. Take normalized structures from the parser\n2. For each Step:\n   * If `negate: false` → `Utils.contramap(projection, eq)`\n   * If `negate: true` → `Utils.contramap(projection, negated_eq)`\n3. For each Block:\n   * If `strategy: :all` → `Utils.concat_all([children...])`\n   * If `strategy: :any` → `Utils.concat_any([children...])`\n4. Top-level operations are implicitly combined with `concat_all` (AND logic)","title":"Execution - Eq","ref":"eq.html#execution"},{"type":"extras","doc":"An empty `eq` block compiles to an identity Eq that considers all values equal. Similarly, an empty `ord` block compiles to an identity Ord where all values compare as `:eq`.\n\nEach directive compiles to:\n\n* `on` → `contramap(projection, eq)`\n* `diff_on` → `contramap(projection, negated_eq)`\n* `all` → `concat_all([children...])`\n* `any` → `concat_any([children...])`","title":"Execution Model - Eq","ref":"eq.html#execution-model"},{"type":"extras","doc":"The executor uses the `type` field from Steps to generate specific code paths, eliminating runtime branching and compiler warnings:\n\n* `:projection` - Direct contramap with projection\n* `:module_eq` - Convert module via `to_eq_map` then use\n* `:eq_map` - Use Eq map directly (from Behaviour)\n* `:dynamic` - Runtime case statement to detect type","title":"Type-Specific Code Generation - Eq","ref":"eq.html#type-specific-code-generation"},{"type":"extras","doc":"The `diff_on` directive swaps the `eq?/not_eq?` functions to check for inequality. This is implemented by creating a negated Eq map:\n\n```elixir\nnegated_eq = %{\n  eq?: original.not_eq?,\n  not_eq?: original.eq?\n}\n```\n\nImportant: Using `diff_on` breaks transitivity and creates an Extended Eq that is not an equivalence relation. Do not use with grouping operations like `Funx.List.uniq/2` or `MapSet`.","title":"Negation (diff_on) - Eq","ref":"eq.html#negation-diff_on"},{"type":"extras","doc":"```elixir\neq do\n  on :name\n  on :age\n  any do\n    on :email\n    on :username\n  end\nend\n```\n\nCompiles to:\n\n```elixir\nUtils.concat_all([\n  Utils.contramap(Prism.key(:name), Funx.Eq),\n  Utils.contramap(Prism.key(:age), Funx.Eq),\n  Utils.concat_any([\n    Utils.contramap(Prism.key(:email), Funx.Eq),\n    Utils.contramap(Prism.key(:username), Funx.Eq)\n  ])\n])\n```","title":"Compilation Example - Eq","ref":"eq.html#compilation-example"},{"type":"extras","doc":"List paths provide convenient syntax for accessing nested fields without manually composing optics:\n\n```elixir\n# Instead of:\neq do\n  on Prism.path([:user, :profile, :name])\nend\n\n# You can write:\neq do\n  on [:user, :profile, :name]\nend\n```\n\nList paths support both atom keys and struct modules:\n\n```elixir\ndefmodule Company, do: defstruct [:name, :address]\ndefmodule Address, do: defstruct [:city, :state]\n\n# Compare companies by nested city\neq_by_city = eq do\n  on [Company, :address, Address, :city]\nend\n\ncompany1 = %Company{name: \"ACME\", address: %Address{city: \"NYC\", state: \"NY\"}}\ncompany2 = %Company{name: \"Corp\", address: %Address{city: \"NYC\", state: \"NY\"}}\n\nFunx.Eq.eq?(company1, company2, eq_by_city)  # true\n```\n\nList paths work with `or_else` for handling missing values:\n\n```elixir\neq do\n  on [:user, :profile, :age], or_else: 0\nend\n```","title":"List Paths (Nested Field Access) - Eq","ref":"eq.html#list-paths-nested-field-access"},{"type":"extras","doc":"Modules participating in the Eq DSL implement `Funx.Eq.Dsl.Behaviour`. The parser detects behaviour modules and calls their `eq/1` callback, which must return an Eq map (not a projection).\n\nThe `eq/1` callback receives:\n\n* `opts` - Keyword list of options passed in the DSL (e.g., `on MyBehaviour, threshold: 0.5`)\n\nExample:\n\n```elixir\ndefmodule FuzzyStringEq do\n  @behaviour Funx.Eq.Dsl.Behaviour\n\n  @impl true\n  def eq(opts) do\n    threshold = Keyword.get(opts, :threshold, 0.8)\n\n    %{\n      eq?: fn a, b -> string_similarity(a, b) >= threshold end,\n      not_eq?: fn a, b -> string_similarity(a, b) < threshold end\n    }\n  end\n\n  defp string_similarity(a, b) do\n    # Implementation here\n  end\nend\n\neq do\n  on FuzzyStringEq, threshold: 0.9\nend\n```\n\nThe executor uses the returned Eq map directly (type `:eq_map`), avoiding the need to wrap it in `contramap`.","title":"Behaviours - Eq","ref":"eq.html#behaviours"},{"type":"extras","doc":"The Eq DSL supports two modes:","title":"Equivalence Relations and diff_on - Eq","ref":"eq.html#equivalence-relations-and-diff_on"},{"type":"extras","doc":"Using only `on`, `all`, and `any` creates a Core Eq that forms an equivalence relation:\n\n* Reflexive: `eq?(a, a)` is always true\n* Symmetric: If `eq?(a, b)` then `eq?(b, a)`\n* Transitive: If `eq?(a, b)` and `eq?(b, c)` then `eq?(a, c)`\n\nCore Eq safely partitions values into equivalence classes, making it suitable for:\n\n* `Funx.List.uniq/2` - Remove duplicates\n* `MapSet` - Set membership\n* `Enum.group_by/2` - Grouping operations","title":"Core Eq (Equivalence Relations) - Eq","ref":"eq.html#core-eq-equivalence-relations"},{"type":"extras","doc":"Using `diff_on` creates an Extended Eq that expresses boolean equality predicates but does not guarantee transitivity.\n\nExample transitivity violation:\n\n```elixir\ndefmodule Person, do: defstruct [:name, :id]\n\neq_diff_id = eq do\n  on :name\n  diff_on :id\nend\n\na = %Person{name: \"Alice\", id: 1}\nb = %Person{name: \"Alice\", id: 2}\nc = %Person{name: \"Alice\", id: 1}\n\neq?(a, b)  # true  (same name, different ids)\neq?(b, c)  # true  (same name, different ids)\neq?(a, c)  # false (same name, SAME id - violates diff_on)\n```\n\nEven though `a == b` and `b == c`, we have `a != c`, violating transitivity.\n\nRule: If you need equivalence classes, do not use `diff_on`. Use it only for boolean predicates where transitivity is not required.","title":"Extended Eq (Boolean Predicates) - Eq","ref":"eq.html#extended-eq-boolean-predicates"},{"type":"extras","doc":"# Predicate\n\nThe Predicate DSL is a builder DSL that constructs boolean predicates for later use. See the [DSL Overview](overview.md) for the distinction between builder and pipeline DSLs.","title":"Predicate","ref":"predicate.html"},{"type":"extras","doc":"A `pred` block compiles entirely at compile time to quoted AST that builds a predicate function. Unlike pipeline DSLs (Maybe, Either), there is no runtime executor—the DSL produces static composition of boolean logic that executes directly.","title":"Structure - Predicate","ref":"predicate.html#structure"},{"type":"extras","doc":"The Predicate DSL uses two structure types to represent the predicate composition:\n\n* `Step` - Contains predicate AST, projection AST (optional), negate flag, type, and metadata\n* `Block` - Contains strategy (`:all` or `:any`), children, and metadata\n\nEach Step describes a single predicate check (bare predicate or projection with predicate). Each Block groups multiple checks with AND/OR logic. The compiler pattern-matches on these structs to generate the final quoted AST.\n\n```text\nCompilation\n    ├── Block (all - implicit at top level)\n    │   ├── Step (bare predicate)\n    │   ├── Step (check :field, predicate)\n    │   └── Block (any)\n    │       ├── Step (predicate1)\n    │       └── Step (predicate2)\n```","title":"Internal Representation - Predicate","ref":"predicate.html#internal-representation"},{"type":"extras","doc":"The parser converts the DSL block into a tree of Step and Block structures. It normalizes all syntax into canonical types:","title":"Parser - Predicate","ref":"predicate.html#parser"},{"type":"extras","doc":"* `(a -> boolean)` - Function predicate\n* Variable reference - Resolved at runtime\n* Module implementing Behaviour - Calls `pred/1` at runtime\n* `{Module, opts}` - Behaviour with options\n* 0-arity helper - Runtime predicate resolution","title":"Bare Predicates - Predicate","ref":"predicate.html#bare-predicates"},{"type":"extras","doc":"The `check` directive composes a projection with a predicate. All projection syntax normalizes to one of:\n\n* `Lens.t()` - Bare lens struct\n* `Prism.t()` - Bare prism struct (Nothing fails the predicate)\n* `(a -> b)` - Projection function\n\nSyntax sugar for projections:\n\n* `:atom` → `Prism.key(:atom)`\n* `[:a, :b]` → `Prism.path([:a, :b])` (supports nested keys and structs)\n* `Lens.key(...)` → `Lens.key(...)` (pass through)\n* `Prism.key(...)` → `Prism.key(...)` (pass through)\n* `fn -> ... end` → `fn -> ... end` (pass through)\n* `Traversal.t()` → Converted to projection function\n\nThe parser validates predicates and projections, raising compile-time errors for unsupported syntax.","title":"Projection-Based Predicates (check directive) - Predicate","ref":"predicate.html#projection-based-predicates-check-directive"},{"type":"extras","doc":"The Predicate DSL does not currently support transformers. All compilation is handled by the parser and executor without intermediate rewriting stages.","title":"Transformers - Predicate","ref":"predicate.html#transformers"},{"type":"extras","doc":"The executor runs at compile time and generates quoted AST. It recursively walks the structure tree:\n\n1. Take normalized structures from the parser\n2. For each Step:\n   * If bare predicate → generate predicate call\n   * If `check projection, pred` → compose projection with predicate\n   * If `negate: true` → wrap in boolean negation\n3. For each Block:\n   * If `strategy: :all` → combine children with AND logic\n   * If `strategy: :any` → combine children with OR logic\n4. Top-level operations are implicitly combined with AND logic","title":"Execution - Predicate","ref":"predicate.html#execution"},{"type":"extras","doc":"An empty `pred` block compiles to a predicate that always returns `true`.\n\nEach directive compiles to:\n\n* Bare predicate → `predicate.(value)`\n* `check projection, pred` → `compose_projection(projection, pred).(value)`\n* `negate predicate` → `not predicate.(value)`\n* `negate check proj, pred` → `not compose_projection(projection, pred).(value)`\n* `all do ... end` → `pred1.(value) and pred2.(value) and ...`\n* `any do ... end` → `pred1.(value) or pred2.(value) or ...`\n* `negate_all do ... end` → `not pred1.(value) or not pred2.(value) or ...` (De Morgan)\n* `negate_any do ... end` → `not pred1.(value) and not pred2.(value) and ...` (De Morgan)","title":"Execution Model - Predicate","ref":"predicate.html#execution-model"},{"type":"extras","doc":"The `check` directive composes projections with predicates:\n\n**With Lens:**\n\n```elixir\ncheck Lens.key(:age), fn age -> age >= 18 end\n```\n\nCompiles to a function that gets the value, then tests it.\n\n**With Prism:**\n\n```elixir\ncheck Prism.key(:email), fn email -> String.contains?(email, \"@\") end\n```\n\nCompiles to a function that returns `false` if the prism returns `Nothing`, otherwise tests the focused value.\n\n**With atom (sugar for Prism.key):**\n\n```elixir\ncheck :name, fn name -> String.length(name) > 5 end\n```\n\nEquivalent to `check Prism.key(:name), fn name -> String.length(name) > 5 end`.\n\n**With list path (nested fields):**\n\n```elixir\ncheck [:user, :profile, :age], fn age -> age >= 18 end\n```\n\nEquivalent to `check Prism.path([:user, :profile, :age]), fn age -> age >= 18 end`. The list path supports both atom keys and struct modules:\n\n```elixir\ndefmodule User, do: defstruct [:name, :profile]\ndefmodule Profile, do: defstruct [:age, :verified]\n\ncheck_adult = pred do\n  check [User, :profile, Profile, :age], fn age -> age >= 18 end\nend\n\nuser = %User{name: \"Alice\", profile: %Profile{age: 25, verified: true}}\ncheck_adult.(user)  # true\n```","title":"Projection Composition - Predicate","ref":"predicate.html#projection-composition"},{"type":"extras","doc":"```elixir\npred do\n  check :active, fn active -> active end\n  any do\n    check :role, fn role -> role == :admin end\n    check :verified, fn verified -> verified end\n  end\nend\n```\n\nCompiles to a function equivalent to:\n\n```elixir\nfn value ->\n  (case Prism.preview(value, Prism.key(:active)) do\n    {:ok, active} -> active\n    :error -> false\n  end) and\n  (case Prism.preview(value, Prism.key(:role)) do\n    {:ok, role} -> role == :admin\n    :error -> false\n  end or\n  case Prism.preview(value, Prism.key(:verified)) do\n    {:ok, verified} -> verified\n    :error -> false\n  end)\nend\n```","title":"Compilation Example - Predicate","ref":"predicate.html#compilation-example"},{"type":"extras","doc":"Modules participating in the Predicate DSL implement `Funx.Predicate.Dsl.Behaviour`. The parser detects behaviour modules and calls their `pred/1` callback, which must return a predicate function.\n\nThe `pred/1` callback receives:\n\n* `opts` - Keyword list of options passed in the DSL (e.g., `{HasMinimumAge, minimum: 21}`)\n\nExample:\n\n```elixir\ndefmodule HasMinimumAge do\n  @behaviour Funx.Predicate.Dsl.Behaviour\n\n  @impl true\n  def pred(opts) do\n    minimum = Keyword.get(opts, :minimum, 18)\n    fn user -> user.age >= minimum end\n  end\nend\n\npred do\n  {HasMinimumAge, minimum: 21}\nend\n```\n\nThe parser compiles this to a call to `HasMinimumAge.pred([minimum: 21])` which returns the predicate function.","title":"Behaviours - Predicate","ref":"predicate.html#behaviours"},{"type":"extras","doc":"The Predicate DSL supports two composition strategies:","title":"Boolean Logic - Predicate","ref":"predicate.html#boolean-logic"},{"type":"extras","doc":"Using bare predicates or explicit `all` blocks creates AND composition where all predicates must pass:\n\n```elixir\npred do\n  is_active\n  is_verified\n  is_adult\nend\n```\n\nEquivalent to:\n\n```elixir\npred do\n  all do\n    is_active\n    is_verified\n    is_adult\n  end\nend\n```","title":"All (AND Logic) - Predicate","ref":"predicate.html#all-and-logic"},{"type":"extras","doc":"Using `any` blocks creates OR composition where at least one predicate must pass:\n\n```elixir\npred do\n  any do\n    is_admin\n    is_moderator\n  end\nend\n```","title":"Any (OR Logic) - Predicate","ref":"predicate.html#any-or-logic"},{"type":"extras","doc":"Blocks can be nested arbitrarily deep for complex logic:\n\n```elixir\npred do\n  is_active\n  any do\n    is_admin\n    all do\n      is_verified\n      is_adult\n    end\n  end\nend\n```\n\nThis reads as: \"active AND (admin OR (verified AND adult))\"","title":"Nesting - Predicate","ref":"predicate.html#nesting"},{"type":"extras","doc":"The Predicate DSL supports negation at multiple levels using the `negate`, `negate_all`, and `negate_any` directives.","title":"Negation - Predicate","ref":"predicate.html#negation"},{"type":"extras","doc":"Use `negate` to invert any bare predicate:\n\n```elixir\npred do\n  negate is_banned\nend\n```\n\nCompiles to: `not is_banned.(value)`","title":"Simple Negation - Predicate","ref":"predicate.html#simple-negation"},{"type":"extras","doc":"Use `negate check` to test that a projected value does NOT match a condition:\n\n```elixir\npred do\n  negate check :age, fn age -> age < 18 end\nend\n```\n\nThis is equivalent to checking that age >= 18, but handles missing fields safely (returns true if field is missing).","title":"Negating Projections - Predicate","ref":"predicate.html#negating-projections"},{"type":"extras","doc":"The `negate_all` and `negate_any` directives apply De Morgan's Laws to negate entire blocks:\n\n**negate_all** - NOT (A AND B) = (NOT A) OR (NOT B)\n\n```elixir\npred do\n  negate_all do\n    is_adult\n    is_verified\n  end\nend\n```\n\nCompiles to: `not is_adult.(value) or not is_verified.(value)`\n\nReturns `true` if at least one condition fails.\n\n**negate_any** - NOT (A OR B) = (NOT A) AND (NOT B)\n\n```elixir\npred do\n  negate_any do\n    is_vip\n    is_admin\n  end\nend\n```\n\nCompiles to: `not is_vip.(value) and not is_admin.(value)`\n\nReturns `true` only if all conditions fail (regular user, not special).","title":"Negating Blocks (De Morgan's Laws) - Predicate","ref":"predicate.html#negating-blocks-de-morgan-s-laws"},{"type":"extras","doc":"The parser applies De Morgan's Laws at compile time:\n\n* `negate_all do ... end` → `Block{strategy: :any, children: [negated...]}`\n* `negate_any do ... end` → `Block{strategy: :all, children: [negated...]}`\n\nThis means negated blocks transform into their logical equivalent without requiring runtime negation of the entire block result.","title":"Parser Transformation - Predicate","ref":"predicate.html#parser-transformation"},{"type":"extras","doc":"Each directive compiles to:\n\n* Bare predicate → `predicate.(value)`\n* `check projection, pred` → `compose_projection(projection, pred).(value)`\n* `negate predicate` → `not predicate.(value)`\n* `negate check proj, pred` → `not compose_projection(projection, pred).(value)`\n* `all do ... end` → `pred1.(value) and pred2.(value) and ...`\n* `any do ... end` → `pred1.(value) or pred2.(value) or ...`\n* `negate_all do ... end` → `not pred1.(value) or not pred2.(value) or ...`\n* `negate_any do ... end` → `not pred1.(value) and not pred2.(value) and ...`","title":"Execution Model (Updated) - Predicate","ref":"predicate.html#execution-model-updated"},{"type":"extras","doc":"Predicates built with the DSL work seamlessly with Elixir's Enum module:\n\n```elixir\ncheck_eligible = pred do\n  check :age, fn age -> age >= 18 end\n  check :verified, fn verified -> verified end\nend\n\n# Filter\nEnum.filter(users, check_eligible)\n\n# Find\nEnum.find(users, check_eligible)\n\n# Count\nEnum.count(users, check_eligible)\n\n# Any/All\nEnum.any?(users, check_eligible)\nEnum.all?(users, check_eligible)\n\n# Partition\nEnum.split_with(users, check_eligible)\n```","title":"Integration with Enum - Predicate","ref":"predicate.html#integration-with-enum"},{"type":"extras","doc":"# Validate\n\nThe Validate DSL is a builder DSL that constructs validators for later use. See the [DSL Overview](overview.md) for the distinction between builder and pipeline DSLs.","title":"Validate","ref":"validate.html"},{"type":"extras","doc":"A `validate` block compiles at compile time to quoted AST that builds a validator function. The validator takes a value and options, projects into fields using optics, runs validators, and accumulates all errors applicatively.","title":"Structure - Validate","ref":"validate.html#structure"},{"type":"extras","doc":"The Validate DSL uses a single structure type to represent validation steps:\n\n* `Step` - Contains optic AST (optional), validators list, and metadata\n\nEach Step describes a single validation target: either a root validator (no optic) or a field validator (with optic projection). The compiler pattern-matches on these structs to generate the final quoted AST.\n\n```text\nCompilation\n    ├── Step (root validator - no optic)\n    ├── Step (at :name, [Required, MinLength])\n    ├── Step (at [:user, :email], [Required, Email])\n    └── Step (at Traversal.combine([...]), DateRange)\n```","title":"Internal Representation - Validate","ref":"validate.html#internal-representation"},{"type":"extras","doc":"The parser converts the DSL block into a list of Step structures. It normalizes all syntax into canonical forms:","title":"Parser - Validate","ref":"validate.html#parser"},{"type":"extras","doc":"* Module implementing `Funx.Validate.Behaviour` - Validates entire structure\n* `{Module, opts}` - Behaviour with options\n* Function (arity-2 or arity-3) - Custom validator function\n* Previously defined validator - Composable validator","title":"Root Validators - Validate","ref":"validate.html#root-validators"},{"type":"extras","doc":"The `at` directive composes an optic projection with validators. All projection syntax normalizes to one of:\n\n* `Prism.t()` - Optional field projection (default for atoms)\n* `Lens.t()` - Required field projection (raises on missing)\n* `Traversal.t()` - Multiple foci projection\n* `(a -> b)` - Projection function\n\nSyntax sugar for projections:\n\n* `:atom` → `Prism.key(:atom)`\n* `[:a, :b]` → `Prism.path([:a, :b])` (supports nested keys and structs)\n* `Lens.key(...)` → `Lens.key(...)` (pass through)\n* `Prism.key(...)` → `Prism.key(...)` (pass through)\n* `Traversal.combine(...)` → `Traversal.combine(...)` (pass through)\n* `fn -> ... end` → `fn -> ... end` (pass through)","title":"Field Validators (at directive) - Validate","ref":"validate.html#field-validators-at-directive"},{"type":"extras","doc":"* Module alias → `Module`\n* Tuple with options → `{Module, opts}`\n* List of validators → `[V1, V2, V3]`\n* Function (arity-2) → `fn value, opts -> ... end`\n* Function (arity-3) → `fn value, opts, env -> ... end`\n* Composable validator → Previously defined validator function\n\nThe parser validates projections and validators, raising compile-time errors for unsupported syntax (literals, empty lists, nested lists).","title":"Validator Forms - Validate","ref":"validate.html#validator-forms"},{"type":"extras","doc":"The Validate DSL does not currently support transformers. All compilation is handled by the parser and executor without intermediate rewriting stages.","title":"Transformers - Validate","ref":"validate.html#transformers"},{"type":"extras","doc":"The executor runs at compile time and generates quoted AST. It processes the list of steps:\n\n1. Take normalized steps from the parser\n2. For each Step:\n   * If root validator (no optic) → generate validator call on entire structure\n   * If field validator (with optic) → project with optic, run validators on projected value\n3. Combine all validators using applicative composition\n4. Return `Either.t(ValidationError.t(), value)`","title":"Execution - Validate","ref":"validate.html#execution"},{"type":"extras","doc":"The DSL supports two execution modes:\n\n**Sequential (default):**\n\n```elixir\nvalidate do\n  at :name, Required\n  at :email, Email\nend\n```\n\nUses `Either.traverse_a` for monadic composition. All validators still run and accumulate errors.\n\n**Parallel:**\n\n```elixir\nvalidate mode: :parallel do\n  at :name, Required\n  at :email, Email\nend\n```\n\nUses `Effect.traverse_a` for explicit applicative composition. Semantically equivalent but makes the applicative nature explicit.","title":"Execution Modes - Validate","ref":"validate.html#execution-modes"},{"type":"extras","doc":"An empty `validate` block compiles to a validator that always returns `Right(value)` (identity element).\n\nEach directive compiles to:\n\n* Root validator → `validator.validate(value, opts, env)`\n* `at optic, validators` → Project value, run validators on projected result, accumulate errors\n* Multiple validators → All run, all errors accumulated via `Appendable`","title":"Execution Model - Validate","ref":"validate.html#execution-model"},{"type":"extras","doc":"The `at` directive projects into the structure before validation:\n\n**With Prism (default for atoms):**\n\n```elixir\nat :email, Email\n```\n\nProjects using `Prism.preview/2`. Missing keys result in `Nothing`, which most validators skip. Only `Required` validates on `Nothing`.\n\n**With Lens:**\n\n```elixir\nat Lens.key(:name), Required\n```\n\nProjects using `Lens.view/2`. Missing keys raise `KeyError`. Use when field must structurally exist.\n\n**With list path:**\n\n```elixir\nat [:user, :profile, :name], Required\n```\n\nConverts to `Prism.path([:user, :profile, :name])`. Supports nested keys and struct modules.\n\n**With Traversal:**\n\n```elixir\nat Traversal.combine([Lens.key(:start_date), Lens.key(:end_date)]), DateRange\n```\n\nCollects multiple foci into a list for relationship validation.","title":"Optic Projection - Validate","ref":"validate.html#optic-projection"},{"type":"extras","doc":"```elixir\nvalidate do\n  HasContactMethod\n  at :name, [Required, {MinLength, min: 3}]\n  at :email, [Required, Email]\nend\n```\n\nCompiles to a function equivalent to:\n\n```elixir\nfn value, opts ->\n  env = Keyword.get(opts, :env, %{})\n\n  validators = [\n    fn v -> HasContactMethod.validate(v, [], env) end,\n    fn v ->\n      projected = Prism.preview(v, Prism.key(:name))\n      run_validators(projected, [Required, {MinLength, min: 3}], env)\n    end,\n    fn v ->\n      projected = Prism.preview(v, Prism.key(:email))\n      run_validators(projected, [Required, Email], env)\n    end\n  ]\n\n  validators\n  |> Enum.map(& &1.(value))\n  |> accumulate_results(value)\nend\n```\n\nWhere `accumulate_results` combines all `Either` results applicatively, returning `Right(original_value)` on success or `Left(accumulated_errors)` on failure.","title":"Compilation Example - Validate","ref":"validate.html#compilation-example"},{"type":"extras","doc":"Modules participating in the Validate DSL implement `Funx.Validate.Behaviour`. The callback receives the value, options, and environment.\n\nThe `validate/3` callback receives:\n\n* `value` - The value to validate (may be `Nothing` from Prism projection)\n* `opts` - Keyword list of options passed in the DSL\n* `env` - Environment map passed via `Either.validate(data, validator, env: env)`\n\nExample:\n\n```elixir\ndefmodule Positive do\n  @behaviour Funx.Validate.Behaviour\n  alias Funx.Monad.Maybe.Nothing\n  alias Funx.Errors.ValidationError\n  alias Funx.Monad.Either\n\n  def validate(value, opts) when is_list(opts), do: validate(value, opts, %{})\n\n  @impl true\n  def validate(%Nothing{} = value, _opts, _env), do: Either.right(value)\n\n  def validate(value, _opts, _env) when is_number(value) and value > 0,\n    do: Either.right(value)\n\n  def validate(_, _opts, _env),\n    do: Either.left(ValidationError.new(\"must be positive\"))\nend\n```","title":"Behaviours - Validate","ref":"validate.html#behaviours"},{"type":"extras","doc":"The DSL normalizes various return formats:\n\n* `Either.t()` → Used directly\n* `:ok` → Converted to `Right(value)`\n* `{:ok, value}` → Converted to `Right(value)`\n* `{:error, ValidationError.t()}` → Converted to `Left(error)`","title":"Return Value Normalization - Validate","ref":"validate.html#return-value-normalization"},{"type":"extras","doc":"The Validate DSL uses applicative composition for error accumulation:","title":"Error Accumulation - Validate","ref":"validate.html#error-accumulation"},{"type":"extras","doc":"All validators run regardless of earlier failures. Errors are accumulated via `Appendable`:\n\n```elixir\nvalidate do\n  at :name, Required      # Fails: \"is required\"\n  at :email, Email        # Fails: \"must be a valid email\"\n  at :age, Positive       # Fails: \"must be positive\"\nend\n```\n\nResult: `Left(%ValidationError{errors: [\"is required\", \"must be a valid email\", \"must be positive\"]})`","title":"Applicative Semantics - Validate","ref":"validate.html#applicative-semantics"},{"type":"extras","doc":"`ValidationError` implements `Appendable`, allowing errors to be concatenated:\n\n```elixir\nValidationError.append(\n  ValidationError.new(\"error 1\"),\n  ValidationError.new(\"error 2\")\n)\n# => %ValidationError{errors: [\"error 1\", \"error 2\"]}\n```","title":"ValidationError Accumulation - Validate","ref":"validate.html#validationerror-accumulation"},{"type":"extras","doc":"The Validate DSL preserves the original structure on success:\n\n```elixir\nvalidation =\n  validate do\n    at :name, Required\n  end\n\ninput = %{name: \"Alice\", extra: \"field\", nested: %{data: 123}}\nEither.validate(input, validation)\n# => %Right{right: %{name: \"Alice\", extra: \"field\", nested: %{data: 123}}}\n```\n\nThe original structure is returned unchanged. Validators check data; they do not transform it.","title":"Identity Preservation - Validate","ref":"validate.html#identity-preservation"},{"type":"extras","doc":"The parser validates at compile time, rejecting invalid forms:\n\n**Rejected:**\n\n* Literal numbers: `at :name, 123`\n* Literal strings: `at :name, \"string\"`\n* Literal atoms: `at :name, :atom`\n* Empty lists: `at :name, []`\n* Nested lists: `at :name, [Required, [Email]]`\n\n**Accepted:**\n\n* Module aliases: `Required`, `Email`\n* Tuples with options: `{MinLength, min: 3}`\n* Lists of validators: `[Required, Email]`\n* Function captures: `&my_validator/2`\n* Anonymous functions: `fn x, opts -> ... end`\n* Variables: `my_validator`\n* Function calls: `my_validator()`, `Module.validator()`","title":"Compile-Time Validation - Validate","ref":"validate.html#compile-time-validation"},{"type":"extras","doc":"Validators created with `validate` can be used inside other validators:\n\n```elixir\nitem_validation =\n  validate do\n    at :name, Required\n    at :price, Positive\n  end\n\norder_validation =\n  validate do\n    at :item, item_validation  # Nested validator\n    at :quantity, Positive\n  end\n```\n\nThe nested validator runs on the projected value and its errors are accumulated with the parent's errors.","title":"Composable Validators - Validate","ref":"validate.html#composable-validators"},{"type":"extras","doc":"Validators can receive context via the environment:\n\n```elixir\nvalidation =\n  validate do\n    at :email, UniqueEmail  # Uses env[:existing_emails]\n  end\n\nEither.validate(data, validation, env: %{existing_emails: [\"taken@example.com\"]})\n```\n\nThe environment is passed to all validators via the third argument of the `validate/3` callback.","title":"Environment Passing - Validate","ref":"validate.html#environment-passing"},{"type":"extras","doc":"Validators are executed via `Either.validate/3`:\n\n```elixir\nEither.validate(data, validator)\nEither.validate(data, validator, env: %{key: value})\n```\n\nThe result is `Either.t(ValidationError.t(), value)`:\n\n* `%Right{right: value}` - Validation passed, original value returned\n* `%Left{left: %ValidationError{errors: [...]}}` - Validation failed, all errors accumulated","title":"Integration with Either - Validate","ref":"validate.html#integration-with-either"}],"proglang":"elixir","content_type":"text/markdown","producer":{"name":"ex_doc","version":"0.39.3"}}