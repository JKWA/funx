searchData={"items":[{"type":"protocol","title":"Funx.Appendable","doc":"A protocol for combining values in a generic, extensible way.\n\nThe `Appendable` protocol defines how two values of the same type can be combined. It is\nused throughout Funx in functions like `traverse_a/2` and `wither_a/2` to accumulate\nintermediate results without coupling logic to a specific type.\n\nThis protocol enables functions to remain flexible and composable when reducing,\naggregating, or accumulating values across a wide variety of domains.","ref":"Funx.Appendable.html"},{"type":"protocol","title":"Required functions - Funx.Appendable","doc":"* `coerce/1` – Normalizes an input value into a form suitable for aggregation.\n* `append/2` – Combines two values of the same type into one.","ref":"Funx.Appendable.html#module-required-functions"},{"type":"protocol","title":"Default – Flat list aggregation - Funx.Appendable","doc":"A fallback implementation is provided for all types that do not define a specific\n`Appendable` instance. This default uses list concatenation as a universal aggregation\nstrategy: all inputs are coerced into lists (if not already), and combined using `++`.\n\nWhen using the default aggregation strategy, values are collected in a plain list:\n\n```elixir\nvalidate_positive = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(&1 > 0), fn v -> \"Value must be positive: \" <> to_string(v) end)\nend\n\nvalidate_even = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(rem(&1, 2) == 0), fn v -> \"Value must be even: \" <> to_string(v) end)\nend\n\nFunx.Monad.Either.validate(4, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Right{right: 4}\n\nFunx.Monad.Either.validate(3, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Left{left: [\"Value must be even: 3\"]}\n\nFunx.Monad.Either.validate(-3, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Left{left: [\"Value must be positive: -3\", \"Value must be even: -3\"]}\n```","ref":"Funx.Appendable.html#module-default-flat-list-aggregation"},{"type":"protocol","title":"Structured aggregation with `ValidationError` - Funx.Appendable","doc":"You can also use a custom struct to hold errors. This example uses `ValidationError`:\n\n```elixir\nalias Funx.Errors.ValidationError\n\nvalidate_positive = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(&1 > 0), fn v -> \"Value must be positive: \" <> to_string(v) end)\n  |> Funx.Monad.Either.map_left(&ValidationError.new/1)\nend\n\nvalidate_even = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(rem(&1, 2) == 0), fn v -> \"Value must be even: \" <> to_string(v) end)\n  |> Funx.Monad.Either.map_left(&ValidationError.new/1)\nend\n\nFunx.Monad.Either.validate(-3, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Left{\n#     left: %ValidationError{\n#       errors: [\"Value must be positive: -3\", \"Value must be even: -3\"]\n#     }\n#   }\n```","ref":"Funx.Appendable.html#module-structured-aggregation-with-validationerror"},{"type":"function","title":"Funx.Appendable.append/2","doc":"Combines two values into a single result.\n\nImplementations must ensure the operation is associative within their type. For types\nthat require disambiguation or structural control, define a custom implementation.","ref":"Funx.Appendable.html#append/2"},{"type":"function","title":"Funx.Appendable.coerce/1","doc":"Normalizes a single input value into a form suitable for accumulation.","ref":"Funx.Appendable.html#coerce/1"},{"type":"type","title":"Funx.Appendable.t/0","doc":"All the types that implement this protocol.","ref":"Funx.Appendable.html#t:t/0"},{"type":"module","title":"Funx.Config","doc":"Internal access to `:funx` application configuration.\n\nThese functions read from `Application.get_env/3` with sane defaults.\nUsed by effect modules for settings like timeouts, telemetry, and summarization.","ref":"Funx.Config.html"},{"type":"module","title":"Supported config keys - Funx.Config","doc":"- `:timeout` — default timeout for running effects (default: `5_000` ms)\n- `:telemetry_prefix` — base prefix for telemetry events (default: `[:funx]`)\n- `:telemetry_enabled` — whether telemetry spans are emitted (default: `true`)\n- `:summarizer` — function used to summarize effect results for telemetry\n- `:default_span_name` — fallback span name for telemetry traces","ref":"Funx.Config.html#module-supported-config-keys"},{"type":"function","title":"Funx.Config.default_span_name/0","doc":"","ref":"Funx.Config.html#default_span_name/0"},{"type":"function","title":"Funx.Config.summarizer/0","doc":"","ref":"Funx.Config.html#summarizer/0"},{"type":"function","title":"Funx.Config.telemetry_enabled?/0","doc":"","ref":"Funx.Config.html#telemetry_enabled?/0"},{"type":"function","title":"Funx.Config.telemetry_prefix/0","doc":"","ref":"Funx.Config.html#telemetry_prefix/0"},{"type":"function","title":"Funx.Config.timeout/0","doc":"","ref":"Funx.Config.html#timeout/0"},{"type":"protocol","title":"Funx.Eq","doc":"The `Funx.Eq` protocol defines an equality function, `eq?/2`, for comparing two values,\nand its complement, `not_eq?/2`, for checking inequality.\n\nTypes that implement this protocol can define custom equality logic, allowing for\ndomain-specific comparisons.","ref":"Funx.Eq.html"},{"type":"protocol","title":"Fallback - Funx.Eq","doc":"The protocol uses `@fallback_to_any true`, meaning that if a specific type does not\nimplement `Funx.Eq`, it falls back to the default implementation for `Any`, which\nuses Elixir's built-in equality operator (`==`).","ref":"Funx.Eq.html#module-fallback"},{"type":"protocol","title":"Examples - Funx.Eq","doc":"With a custom implementation for a `Funx.Monad.Maybe` type:\n\n    iex> Funx.Eq.eq?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(3))\n    true\n\n    iex> Funx.Eq.eq?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(5))\n    false\n\n    iex> Funx.Eq.eq?(Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.nothing())\n    true\n\n    iex> Funx.Eq.eq?(Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.just(5))\n    false\n\nChecking inequality with `not_eq?/2`:\n\n    iex> Funx.Eq.not_eq?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(3))\n    false\n\n    iex> Funx.Eq.not_eq?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(5))\n    true\n\n    iex> Funx.Eq.not_eq?(Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.nothing())\n    false\n\n    iex> Funx.Eq.not_eq?(Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.just(5))\n    true","ref":"Funx.Eq.html#module-examples"},{"type":"function","title":"Funx.Eq.eq?/2","doc":"Returns `true` if `a` is equal to `b`, otherwise returns `false`.","ref":"Funx.Eq.html#eq?/2"},{"type":"function","title":"Examples - Funx.Eq.eq?/2","doc":"iex> Funx.Eq.eq?(1, 1)\n    true\n\n    iex> Funx.Eq.eq?(1, 2)\n    false","ref":"Funx.Eq.html#eq?/2-examples"},{"type":"function","title":"Funx.Eq.not_eq?/2","doc":"Returns `true` if `a` is not equal to `b`, otherwise returns `false`.","ref":"Funx.Eq.html#not_eq?/2"},{"type":"function","title":"Examples - Funx.Eq.not_eq?/2","doc":"iex> Funx.Eq.not_eq?(1, 1)\n    false\n\n    iex> Funx.Eq.not_eq?(1, 2)\n    true","ref":"Funx.Eq.html#not_eq?/2-examples"},{"type":"type","title":"Funx.Eq.t/0","doc":"All the types that implement this protocol.","ref":"Funx.Eq.html#t:t/0"},{"type":"module","title":"Funx.Eq.Utils","doc":"Utility functions for working with the `Funx.Eq` protocol.\nThese functions assume that types passed in either support Elixir's equality operator\nor implement the `Funx.Eq` protocol.","ref":"Funx.Eq.Utils.html"},{"type":"function","title":"Funx.Eq.Utils.append_all/2","doc":"Combines two equality comparators using the `Eq.All` monoid.\n\nThis function merges two equality comparisons, requiring **both** to return `true`\nfor the final result to be considered equal. This enforces a **strict** equality rule,\nwhere all comparators must agree.","ref":"Funx.Eq.Utils.html#append_all/2"},{"type":"function","title":"Examples - Funx.Eq.Utils.append_all/2","doc":"iex> eq1 = Funx.Eq.Utils.contramap(& &1.name)\n    iex> eq2 = Funx.Eq.Utils.contramap(& &1.age)\n    iex> combined = Funx.Eq.Utils.append_all(eq1, eq2)\n    iex> Funx.Eq.Utils.eq?(%{name: \"Alice\", age: 30}, %{name: \"Alice\", age: 30}, combined)\n    true\n    iex> Funx.Eq.Utils.eq?(%{name: \"Alice\", age: 30}, %{name: \"Alice\", age: 25}, combined)\n    false","ref":"Funx.Eq.Utils.html#append_all/2-examples"},{"type":"function","title":"Funx.Eq.Utils.append_any/2","doc":"Combines two equality comparators using the `Eq.Any` monoid.\n\nThis function merges two equality comparisons, where **at least one**\nmust return `true` for the final result to be considered equal.","ref":"Funx.Eq.Utils.html#append_any/2"},{"type":"function","title":"Examples - Funx.Eq.Utils.append_any/2","doc":"iex> eq1 = Funx.Eq.Utils.contramap(& &1.name)\n    iex> eq2 = Funx.Eq.Utils.contramap(& &1.age)\n    iex> combined = Funx.Eq.Utils.append_any(eq1, eq2)\n    iex> Funx.Eq.Utils.eq?(%{name: \"Alice\", age: 30}, %{name: \"Alice\", age: 25}, combined)\n    true\n    iex> Funx.Eq.Utils.eq?(%{name: \"Alice\", age: 30}, %{name: \"Bob\", age: 25}, combined)\n    false","ref":"Funx.Eq.Utils.html#append_any/2-examples"},{"type":"function","title":"Funx.Eq.Utils.concat_all/1","doc":"Concatenates a list of equality comparators using the `Eq.All` monoid.\n\nThe resulting comparator requires **all** comparators in the list to agree\nthat two values are equal.","ref":"Funx.Eq.Utils.html#concat_all/1"},{"type":"function","title":"Examples - Funx.Eq.Utils.concat_all/1","doc":"iex> eq1 = Funx.Eq.Utils.contramap(& &1.name)\n    iex> eq2 = Funx.Eq.Utils.contramap(& &1.age)\n    iex> combined = Funx.Eq.Utils.concat_all([eq1, eq2])\n    iex> Funx.Eq.Utils.eq?(%{name: \"Alice\", age: 30}, %{name: \"Alice\", age: 30}, combined)\n    true\n    iex> Funx.Eq.Utils.eq?(%{name: \"Alice\", age: 30}, %{name: \"Alice\", age: 25}, combined)\n    false","ref":"Funx.Eq.Utils.html#concat_all/1-examples"},{"type":"function","title":"Funx.Eq.Utils.concat_any/1","doc":"Concatenates a list of equality comparators using the `Eq.Any` monoid.\n\nThe resulting comparator allows **any** comparator in the list to determine\nequality, making it more permissive.","ref":"Funx.Eq.Utils.html#concat_any/1"},{"type":"function","title":"Examples - Funx.Eq.Utils.concat_any/1","doc":"iex> eq1 = Funx.Eq.Utils.contramap(& &1.name)\n    iex> eq2 = Funx.Eq.Utils.contramap(& &1.age)\n    iex> combined = Funx.Eq.Utils.concat_any([eq1, eq2])\n    iex> Funx.Eq.Utils.eq?(%{name: \"Alice\", age: 30}, %{name: \"Alice\", age: 25}, combined)\n    true\n    iex> Funx.Eq.Utils.eq?(%{name: \"Alice\", age: 30}, %{name: \"Bob\", age: 25}, combined)\n    false","ref":"Funx.Eq.Utils.html#concat_any/1-examples"},{"type":"function","title":"Funx.Eq.Utils.contramap/2","doc":"Transforms an equality check by applying a function `f` to values before comparison.\n\nThe `eq` parameter can be an `Eq` module or a custom comparator map with an `:eq?` function.\nIf an `Eq` module is provided, it wraps the module’s function to apply `f` to each value before invoking the equality check.\nIf a custom comparator map is provided, it wraps the function in the map to apply `f` to each value.","ref":"Funx.Eq.Utils.html#contramap/2"},{"type":"function","title":"Examples - Funx.Eq.Utils.contramap/2","doc":"iex> eq = Funx.Eq.Utils.contramap(& &1.age)\n    iex> eq.eq?.(%{age: 30}, %{age: 30})\n    true\n    iex> eq.eq?.(%{age: 30}, %{age: 25})\n    false","ref":"Funx.Eq.Utils.html#contramap/2-examples"},{"type":"function","title":"Funx.Eq.Utils.eq?/3","doc":"Returns true if two values are equal, using a specified or default `Eq`.","ref":"Funx.Eq.Utils.html#eq?/3"},{"type":"function","title":"Examples - Funx.Eq.Utils.eq?/3","doc":"iex> Funx.Eq.Utils.eq?(42, 42)\n    true\n    iex> Funx.Eq.Utils.eq?(\"foo\", \"bar\")\n    false","ref":"Funx.Eq.Utils.html#eq?/3-examples"},{"type":"function","title":"Funx.Eq.Utils.eq_by?/4","doc":"Checks equality of values by applying a projection function, using a specified or default `Eq`.\n\nThe `eq` parameter can be an `Eq` module or a custom comparator map with an `:eq?` function.","ref":"Funx.Eq.Utils.html#eq_by?/4"},{"type":"function","title":"Examples - Funx.Eq.Utils.eq_by?/4","doc":"iex> Funx.Eq.Utils.eq_by?(& &1.age, %{age: 30}, %{age: 30})\n    true\n    iex> Funx.Eq.Utils.eq_by?(& &1.age, %{age: 30}, %{age: 25})\n    false","ref":"Funx.Eq.Utils.html#eq_by?/4-examples"},{"type":"function","title":"Funx.Eq.Utils.not_eq?/3","doc":"Returns false if two values are not equal, using a specified or default `Eq`.","ref":"Funx.Eq.Utils.html#not_eq?/3"},{"type":"function","title":"Examples - Funx.Eq.Utils.not_eq?/3","doc":"iex> Funx.Eq.Utils.not_eq?(42, 99)\n    true\n    iex> Funx.Eq.Utils.not_eq?(\"foo\", \"foo\")\n    false","ref":"Funx.Eq.Utils.html#not_eq?/3-examples"},{"type":"function","title":"Funx.Eq.Utils.to_eq_map/1","doc":"","ref":"Funx.Eq.Utils.html#to_eq_map/1"},{"type":"function","title":"Funx.Eq.Utils.to_predicate/2","doc":"Converts an `Eq` comparator into a single-argument predicate function for use in `Enum` functions.\n\nThe resulting predicate takes a single element and returns `true` if it matches the `target`\nbased on the specified `Eq`. If no custom `Eq` is provided, it defaults to `Funx.Eq`.","ref":"Funx.Eq.Utils.html#to_predicate/2"},{"type":"function","title":"Examples - Funx.Eq.Utils.to_predicate/2","doc":"iex> eq = Funx.Eq.Utils.contramap(& &1.name)\n    iex> predicate = Funx.Eq.Utils.to_predicate(%{name: \"Alice\"}, eq)\n    iex> Funx.Filterable.filter([%{name: \"Alice\"}, %{name: \"Bob\"}], predicate)\n    [%{name: \"Alice\"}]","ref":"Funx.Eq.Utils.html#to_predicate/2-examples"},{"type":"type","title":"Funx.Eq.Utils.eq_map/0","doc":"","ref":"Funx.Eq.Utils.html#t:eq_map/0"},{"type":"type","title":"Funx.Eq.Utils.eq_t/0","doc":"","ref":"Funx.Eq.Utils.html#t:eq_t/0"},{"type":"protocol","title":"Funx.Filterable","doc":"The `Funx.Filterable` protocol defines functions for conditionally retaining or discarding\nvalues within a context. It generalizes the concepts of `filter`, `filter_map`, and `guard`\nacross different data structures like `Maybe`, `List`, and others.\n\nThese functions enable conditional value retention, transformation, and short-circuiting based\non boolean conditions or predicate functions.","ref":"Funx.Filterable.html"},{"type":"function","title":"Funx.Filterable.filter/2","doc":"Retains values that satisfy the given predicate.\n\nThe `filter/2` function applies a predicate to the value(s) inside the context. If the predicate returns `true`,\nthe value is retained; otherwise, it is discarded. For collections, it filters all elements based on the predicate.","ref":"Funx.Filterable.html#filter/2"},{"type":"function","title":"Parameters: - Funx.Filterable.filter/2","doc":"- `structure`: The context-wrapped value or collection.\n- `predicate`: A function `(a -> boolean)` determining whether to retain each value.","ref":"Funx.Filterable.html#filter/2-parameters"},{"type":"function","title":"Examples - Funx.Filterable.filter/2","doc":"iex> Funx.Filterable.filter(Funx.Monad.Maybe.just(5), &(&1 > 3))\n    %Funx.Monad.Maybe.Just{value: 5}\n\n    iex> Funx.Filterable.filter(Funx.Monad.Maybe.just(2), &(&1 > 3))\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Filterable.html#filter/2-examples"},{"type":"function","title":"Funx.Filterable.filter_map/2","doc":"Applies a function that returns a `Maybe` value, combining filtering and mapping in a single pass.\n\n`filter_map/2` applies the provided function to the value(s) within the context. If the function returns `Just`,\nthe transformed value is retained; if it returns `Nothing`, the value is discarded. This avoids multiple traversals\nwhen both mapping and filtering are required.","ref":"Funx.Filterable.html#filter_map/2"},{"type":"function","title":"Parameters: - Funx.Filterable.filter_map/2","doc":"- `structure`: The context-wrapped value or collection.\n- `func`: A function `(a -> Maybe b)` that both transforms and conditionally retains values.","ref":"Funx.Filterable.html#filter_map/2-parameters"},{"type":"function","title":"Examples - Funx.Filterable.filter_map/2","doc":"iex> Funx.Filterable.filter_map(Funx.Monad.Maybe.just(5), fn x -> if x > 3, do: Funx.Monad.Maybe.just(x * 2), else: Funx.Monad.Maybe.nothing() end)\n    %Funx.Monad.Maybe.Just{value: 10}\n\n    iex> Funx.Filterable.filter_map(Funx.Monad.Maybe.just(2), fn x -> if x > 3, do: Funx.Monad.Maybe.just(x * 2), else: Funx.Monad.Maybe.nothing() end)\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Filterable.html#filter_map/2-examples"},{"type":"function","title":"Funx.Filterable.guard/2","doc":"Conditionally retains a value within the context. If the boolean is true, returns the existing value;\notherwise, returns an empty value for the context.","ref":"Funx.Filterable.html#guard/2"},{"type":"function","title":"Parameters: - Funx.Filterable.guard/2","doc":"- `structure`: The context-wrapped value (e.g., `Just`, list, etc.).\n- `bool`: A boolean indicating whether to retain the value.","ref":"Funx.Filterable.html#guard/2-parameters"},{"type":"function","title":"Examples - Funx.Filterable.guard/2","doc":"iex> Funx.Filterable.guard(Funx.Monad.Maybe.just(42), true)\n    %Funx.Monad.Maybe.Just{value: 42}\n\n    iex> Funx.Filterable.guard(Funx.Monad.Maybe.just(42), false)\n    %Funx.Monad.Maybe.Nothing{}\n\n    iex> Funx.Filterable.guard(Funx.Monad.Maybe.nothing(), true)\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Filterable.html#guard/2-examples"},{"type":"type","title":"Funx.Filterable.t/0","doc":"All the types that implement this protocol.","ref":"Funx.Filterable.html#t:t/0"},{"type":"protocol","title":"Funx.Foldable","doc":"The `Funx.Foldable` protocol defines two core folding operations: `fold_l/3` (fold left) and `fold_r/3` (fold right).\n\nThese functions allow structures to be collapsed into a single value by applying functions in a specific order.\nDepending on the structure, folding can be done from the left (`fold_l/3`) or from the right (`fold_r/3`).","ref":"Funx.Foldable.html"},{"type":"function","title":"Funx.Foldable.fold_l/3","doc":"Folds the structure from the left, applying `func_a` if a condition is met, otherwise applying `func_b`.\n\nThis function collapses a structure by recursively applying the provided functions from the leftmost element to the rightmost.","ref":"Funx.Foldable.html#fold_l/3"},{"type":"function","title":"Parameters: - Funx.Foldable.fold_l/3","doc":"- `structure`: The structure to fold.\n- `func_a`: The function to apply in case of a matching condition.\n- `func_b`: The function to apply if the condition is not met.","ref":"Funx.Foldable.html#fold_l/3-parameters"},{"type":"function","title":"Examples - Funx.Foldable.fold_l/3","doc":"iex> Funx.Foldable.fold_l(Funx.Monad.Maybe.just(5), fn x -> x + 1 end, fn -> 0 end)\n    6\n\n    iex> Funx.Foldable.fold_l(Funx.Monad.Maybe.nothing(), fn _ -> 1 end, fn -> 0 end)\n    0","ref":"Funx.Foldable.html#fold_l/3-examples"},{"type":"function","title":"Funx.Foldable.fold_r/3","doc":"Folds the structure from the right, applying `func_a` if a condition is met, otherwise applying `func_b`.\n\nThis function collapses a structure by recursively applying the provided functions from the rightmost element to the leftmost.","ref":"Funx.Foldable.html#fold_r/3"},{"type":"function","title":"Parameters: - Funx.Foldable.fold_r/3","doc":"- `structure`: The structure to fold.\n- `func_a`: The function to apply in case of a matching condition.\n- `func_b`: The function to apply if the condition is not met.","ref":"Funx.Foldable.html#fold_r/3-parameters"},{"type":"function","title":"Examples - Funx.Foldable.fold_r/3","doc":"iex> Funx.Foldable.fold_r(Funx.Monad.Maybe.just(5), fn x -> x + 1 end, fn -> 0 end)\n    6\n\n    iex> Funx.Foldable.fold_r(Funx.Monad.Maybe.nothing(), fn _ -> 1 end, fn -> 0 end)\n    0","ref":"Funx.Foldable.html#fold_r/3-examples"},{"type":"type","title":"Funx.Foldable.t/0","doc":"All the types that implement this protocol.","ref":"Funx.Foldable.html#t:t/0"},{"type":"module","title":"Funx.List","doc":"The `Funx.List` module provides utility functions for working with lists while respecting `Eq` and `Ord` instances. This allows for set-like operations, uniqueness constraints, and sorted collections that align with functional programming principles.","ref":"Funx.List.html"},{"type":"module","title":"Features - Funx.List","doc":"- **Equality-based Operations**: Use `Eq` instances to compare elements for uniqueness, intersection, and difference.\n- **Ordering Functions**: Leverage `Ord` instances to sort and enforce uniqueness in sorted collections.\n- **Set Operations**: Perform union, intersection, difference, and symmetric difference while preserving custom equality logic.\n- **Subset & Superset Checks**: Verify relationships between lists in terms of inclusion.\n- **Functional Constructs**: Implements `Monad` and `Foldable` protocols for lists, supporting mapping, binding, and folding.","ref":"Funx.List.html#module-features"},{"type":"module","title":"Usage Overview - Funx.List","doc":"1. **Deduplicate**: Use `uniq/1` to remove duplicates based on `Eq`.\n2. **Combine**: Use `union/2` to merge lists without duplicates.\n3. **Filter**: Use `intersection/2` or `difference/2` for set operations.\n4. **Sort**: Use `sort/2` or `strict_sort/2` with `Ord` instances.\n5. **Check Membership**: Use `subset?/2` or `superset?/2` to verify inclusion relationships.","ref":"Funx.List.html#module-usage-overview"},{"type":"module","title":"Equality-Based Operations - Funx.List","doc":"- `uniq/1`: Removes duplicates using `Eq`.\n- `union/2`: Merges lists while preserving uniqueness.\n- `intersection/2`: Returns elements common to both lists.\n- `difference/2`: Returns elements from the first list not in the second.\n- `symmetric_difference/2`: Returns elements unique to each list.","ref":"Funx.List.html#module-equality-based-operations"},{"type":"module","title":"Ordering Functions - Funx.List","doc":"- `sort/2`: Sorts a list using `Ord`.\n- `strict_sort/2`: Sorts while ensuring uniqueness.","ref":"Funx.List.html#module-ordering-functions"},{"type":"module","title":"Set Operations - Funx.List","doc":"- `subset?/2`: Checks if one list is a subset of another.\n- `superset?/2`: Checks if one list is a superset of another.","ref":"Funx.List.html#module-set-operations"},{"type":"module","title":"Monad Implementation - Funx.List","doc":"- `map/2`: Transforms list elements.\n- `bind/2`: Applies a function returning lists and flattens the result.\n- `ap/2`: Applies functions in a list to elements in another list.","ref":"Funx.List.html#module-monad-implementation"},{"type":"module","title":"Foldable Implementation - Funx.List","doc":"- `fold_l/3`: Performs left-associative folding.\n- `fold_r/3`: Performs right-associative folding.","ref":"Funx.List.html#module-foldable-implementation"},{"type":"function","title":"Funx.List.concat/1","doc":"Concatenates a list of lists from left to right.\n\nThis uses the `ListConcat` monoid, preserving the original order of elements.","ref":"Funx.List.html#concat/1"},{"type":"function","title":"Examples - Funx.List.concat/1","doc":"iex> Funx.List.concat([[1], [2, 3], [4]])\n    [1, 2, 3, 4]","ref":"Funx.List.html#concat/1-examples"},{"type":"function","title":"Funx.List.difference/3","doc":"Returns the difference of two lists.","ref":"Funx.List.html#difference/3"},{"type":"function","title":"Examples - Funx.List.difference/3","doc":"iex> Funx.List.difference([1, 2, 3, 4], [3, 4, 5])\n    [1, 2]","ref":"Funx.List.html#difference/3-examples"},{"type":"function","title":"Funx.List.intersection/3","doc":"Returns the intersection of two lists.","ref":"Funx.List.html#intersection/3"},{"type":"function","title":"Examples - Funx.List.intersection/3","doc":"iex> Funx.List.intersection([1, 2, 3, 4], [3, 4, 5])\n    [3, 4]","ref":"Funx.List.html#intersection/3-examples"},{"type":"function","title":"Funx.List.sort/2","doc":"Sorts a list using the given ordering module.","ref":"Funx.List.html#sort/2"},{"type":"function","title":"Examples - Funx.List.sort/2","doc":"iex> Funx.List.sort([3, 1, 4, 1, 5])\n    [1, 1, 3, 4, 5]","ref":"Funx.List.html#sort/2-examples"},{"type":"function","title":"Funx.List.strict_sort/2","doc":"Sorts a list while ensuring uniqueness.","ref":"Funx.List.html#strict_sort/2"},{"type":"function","title":"Examples - Funx.List.strict_sort/2","doc":"iex> Funx.List.strict_sort([3, 1, 4, 1, 5])\n    [1, 3, 4, 5]","ref":"Funx.List.html#strict_sort/2-examples"},{"type":"function","title":"Funx.List.subset?/3","doc":"Checks if the first list is a subset of the second.","ref":"Funx.List.html#subset?/3"},{"type":"function","title":"Examples - Funx.List.subset?/3","doc":"iex> Funx.List.subset?([1, 2], [1, 2, 3, 4])\n    true\n\n    iex> Funx.List.subset?([1, 5], [1, 2, 3, 4])\n    false","ref":"Funx.List.html#subset?/3-examples"},{"type":"function","title":"Funx.List.superset?/3","doc":"Checks if the first list is a superset of the second.","ref":"Funx.List.html#superset?/3"},{"type":"function","title":"Examples - Funx.List.superset?/3","doc":"iex> Funx.List.superset?([1, 2, 3, 4], [1, 2])\n    true\n\n    iex> Funx.List.superset?([1, 2, 3, 4], [1, 5])\n    false","ref":"Funx.List.html#superset?/3-examples"},{"type":"function","title":"Funx.List.symmetric_difference/3","doc":"Returns the symmetric difference of two lists.","ref":"Funx.List.html#symmetric_difference/3"},{"type":"function","title":"Examples - Funx.List.symmetric_difference/3","doc":"iex> Funx.List.symmetric_difference([1, 2, 3], [3, 4, 5])\n    [1, 2, 4, 5]","ref":"Funx.List.html#symmetric_difference/3-examples"},{"type":"function","title":"Funx.List.union/3","doc":"Returns the union of two lists, removing duplicates.","ref":"Funx.List.html#union/3"},{"type":"function","title":"Examples - Funx.List.union/3","doc":"iex> Funx.List.union([1, 2, 3], [3, 4, 5])\n    [1, 2, 3, 4, 5]","ref":"Funx.List.html#union/3-examples"},{"type":"function","title":"Funx.List.uniq/2","doc":"Removes duplicate elements from a list based on the given equality module.","ref":"Funx.List.html#uniq/2"},{"type":"function","title":"Examples - Funx.List.uniq/2","doc":"iex> Funx.List.uniq([1, 2, 2, 3, 1, 4, 5])\n    [1, 2, 3, 4, 5]","ref":"Funx.List.html#uniq/2-examples"},{"type":"module","title":"Funx.Macros","doc":"Provides macros for automatically implementing `Funx.Eq` and `Funx.Ord` protocols\nfor a given struct based on a specified field.\n\nThese macros simplify the process of defining equality and ordering behaviors\nfor custom structs by leveraging an existing field's comparison operations.","ref":"Funx.Macros.html"},{"type":"macro","title":"Funx.Macros.eq_for/2","doc":"Generates an implementation of the `Funx.Eq` protocol for the given struct,\nusing the specified field as the basis for equality comparison.","ref":"Funx.Macros.html#eq_for/2"},{"type":"macro","title":"Examples - Funx.Macros.eq_for/2","doc":"defmodule Person do\n      defstruct [:name, :age]\n    end\n\n    require Funx.Macros\n    Funx.Macros.eq_for(Person, :age)\n\n    iex> Eq.eq?(%Person{age: 30}, %Person{age: 30})\n    true\n\n    iex> Eq.eq?(%Person{age: 25}, %Person{age: 30})\n    false","ref":"Funx.Macros.html#eq_for/2-examples"},{"type":"macro","title":"Funx.Macros.ord_for/2","doc":"Generates an implementation of the `Funx.Ord` protocol for the given struct,\nusing the specified field as the basis for ordering comparisons.","ref":"Funx.Macros.html#ord_for/2"},{"type":"macro","title":"Examples - Funx.Macros.ord_for/2","doc":"defmodule Person do\n      defstruct [:name, :age]\n    end\n\n    require Funx.Macros\n    Funx.Macros.ord_for(Person, :age)\n\n    iex> Ord.lt?(%Person{age: 25}, %Person{age: 30})\n    true\n\n    iex> Ord.gt?(%Person{age: 35}, %Person{age: 30})\n    true","ref":"Funx.Macros.html#ord_for/2-examples"},{"type":"module","title":"Funx.Math","doc":"Provides mathematical operations using Monoids.\n\nThis module uses the `Sum` and `Product` monoids to perform operations\nsuch as addition and multiplication over values or lists of values.","ref":"Funx.Math.html"},{"type":"function","title":"Funx.Math.deviation/1","doc":"Computes the deviations from the mean for a list of numbers.\n\nReturns `Nothing` if the list is empty.","ref":"Funx.Math.html#deviation/1"},{"type":"function","title":"Examples - Funx.Math.deviation/1","doc":"iex> Funx.Math.deviation([1, 2, 3, 4])\n    Funx.Monad.Maybe.pure([-1.5, -0.5, 0.5, 1.5])\n\n    iex> Funx.Math.deviation([5, 5, 5])\n    Funx.Monad.Maybe.pure([0.0, 0.0, 0.0])\n\n    iex> Funx.Math.deviation([])\n    Funx.Monad.Maybe.nothing()","ref":"Funx.Math.html#deviation/1-examples"},{"type":"function","title":"Funx.Math.max/1","doc":"Finds the maximum value in a list using the `Max` monoid.\n\nReturns `Float.min_finite()` if the list is empty.","ref":"Funx.Math.html#max/1"},{"type":"function","title":"Examples - Funx.Math.max/1","doc":"iex> Funx.Math.max([3, 7, 2])\n    7\n\n    iex> Funx.Math.max([])\n    Float.min_finite()","ref":"Funx.Math.html#max/1-examples"},{"type":"function","title":"Funx.Math.max/2","doc":"Returns the maximum of two numbers using the `Max` monoid.","ref":"Funx.Math.html#max/2"},{"type":"function","title":"Examples - Funx.Math.max/2","doc":"iex> Funx.Math.max(3, 7)\n    7\n\n    iex> Funx.Math.max(-1, -5)\n    -1","ref":"Funx.Math.html#max/2-examples"},{"type":"function","title":"Funx.Math.mean/1","doc":"Computes the arithmetic mean of a list of numbers.\n\nReturns `Nothing` if the list is empty.","ref":"Funx.Math.html#mean/1"},{"type":"function","title":"Examples - Funx.Math.mean/1","doc":"iex> Funx.Math.mean([1, 2, 3, 4])\n    Funx.Monad.Maybe.pure(2.5)\n\n    iex> Funx.Math.mean([])\n    Funx.Monad.Maybe.nothing()","ref":"Funx.Math.html#mean/1-examples"},{"type":"function","title":"Funx.Math.min/1","doc":"Finds the minimum value in a list using the `Min` monoid.\n\nReturns `Float.max_finite()` if the list is empty.","ref":"Funx.Math.html#min/1"},{"type":"function","title":"Examples - Funx.Math.min/1","doc":"iex> Funx.Math.min([3, 7, 2])\n    2\n\n    iex> Funx.Math.min([])\n    Float.max_finite()","ref":"Funx.Math.html#min/1-examples"},{"type":"function","title":"Funx.Math.min/2","doc":"Returns the minimum of two numbers using the `Min` monoid.","ref":"Funx.Math.html#min/2"},{"type":"function","title":"Examples - Funx.Math.min/2","doc":"iex> Funx.Math.min(3, 7)\n    3\n\n    iex> Funx.Math.min(-1, -5)\n    -5","ref":"Funx.Math.html#min/2-examples"},{"type":"function","title":"Funx.Math.product/1","doc":"Multiplies a list of numbers using the `Product` monoid.","ref":"Funx.Math.html#product/1"},{"type":"function","title":"Examples - Funx.Math.product/1","doc":"iex> Funx.Math.product([2, 3, 4])\n    24\n\n    iex> Funx.Math.product([])\n    1","ref":"Funx.Math.html#product/1-examples"},{"type":"function","title":"Funx.Math.product/2","doc":"Multiplies two numbers using the `Product` monoid.","ref":"Funx.Math.html#product/2"},{"type":"function","title":"Examples - Funx.Math.product/2","doc":"iex> Funx.Math.product(3, 4)\n    12","ref":"Funx.Math.html#product/2-examples"},{"type":"function","title":"Funx.Math.range/1","doc":"Computes the range (difference between max and min) of a list.\n\nReturns `nothing()` if the list is empty.","ref":"Funx.Math.html#range/1"},{"type":"function","title":"Examples - Funx.Math.range/1","doc":"iex> Funx.Math.range([3, 7, 2])\n    Funx.Monad.Maybe.pure(5)\n\n    iex> Funx.Math.range([])\n    Funx.Monad.Maybe.nothing()","ref":"Funx.Math.html#range/1-examples"},{"type":"function","title":"Funx.Math.square/1","doc":"Computes the square of a number.","ref":"Funx.Math.html#square/1"},{"type":"function","title":"Examples - Funx.Math.square/1","doc":"iex> Funx.Math.square(3)\n    9\n\n    iex> Funx.Math.square(-4)\n    16","ref":"Funx.Math.html#square/1-examples"},{"type":"function","title":"Funx.Math.std_dev/1","doc":"Computes the standard deviation of a list of numbers.\n\nReturns `Nothing` if the list is empty.","ref":"Funx.Math.html#std_dev/1"},{"type":"function","title":"Examples - Funx.Math.std_dev/1","doc":"iex> Funx.Math.std_dev([1, 2, 3, 4])\n    Funx.Monad.Maybe.pure(1.118033988749895)\n\n    iex> Funx.Math.std_dev([5, 5, 5])\n    Funx.Monad.Maybe.pure(0.0)\n\n    iex> Funx.Math.std_dev([])\n    Funx.Monad.Maybe.nothing()","ref":"Funx.Math.html#std_dev/1-examples"},{"type":"function","title":"Funx.Math.sum/1","doc":"Sums a list of numbers using the `Sum` monoid.","ref":"Funx.Math.html#sum/1"},{"type":"function","title":"Examples - Funx.Math.sum/1","doc":"iex> Funx.Math.sum([1, 2, 3])\n    6\n\n    iex> Funx.Math.sum([])\n    0","ref":"Funx.Math.html#sum/1-examples"},{"type":"function","title":"Funx.Math.sum/2","doc":"Sums two numbers using the `Sum` monoid.","ref":"Funx.Math.html#sum/2"},{"type":"function","title":"Examples - Funx.Math.sum/2","doc":"iex> Funx.Math.sum(1, 2)\n    3","ref":"Funx.Math.html#sum/2-examples"},{"type":"function","title":"Funx.Math.sum_of_squares/1","doc":"Computes the sum of squares of a list of numbers.\n\nReturns `0` if the list is empty.","ref":"Funx.Math.html#sum_of_squares/1"},{"type":"function","title":"Examples - Funx.Math.sum_of_squares/1","doc":"iex> Funx.Math.sum_of_squares([1, 2, 3])\n    14\n\n    iex> Funx.Math.sum_of_squares([-2, 5])\n    29\n\n    iex> Funx.Math.sum_of_squares([])\n    0","ref":"Funx.Math.html#sum_of_squares/1-examples"},{"type":"function","title":"Funx.Math.variance/1","doc":"Computes the variance of a list of numbers.\n\nReturns `Nothing` if the list is empty.","ref":"Funx.Math.html#variance/1"},{"type":"function","title":"Examples - Funx.Math.variance/1","doc":"iex> Funx.Math.variance([1, 2, 3, 4])\n    Funx.Monad.Maybe.pure(1.25)\n\n    iex> Funx.Math.variance([5, 5, 5])\n    Funx.Monad.Maybe.pure(0.0)\n\n    iex> Funx.Math.variance([])\n    Funx.Monad.Maybe.nothing()","ref":"Funx.Math.html#variance/1-examples"},{"type":"protocol","title":"Funx.Monad","doc":"The `Funx.Monad` protocol defines the core monadic operations: `ap/2`, `bind/2`, and `map/2`.\n\nA monad is an abstraction that represents computations as a series of steps.\nThis protocol is designed to be implemented by types that wrap a value and allow chaining of operations while preserving the wrapped context.","ref":"Funx.Monad.html"},{"type":"protocol","title":"Functions - Funx.Monad","doc":"- `map/2`: Applies a function to the value within the monad.\n- `bind/2`: Chains operations by passing the unwrapped value into a function that returns another monad.\n- `ap/2`: Applies a monadic function to another monadic value.","ref":"Funx.Monad.html#module-functions"},{"type":"function","title":"Funx.Monad.ap/2","doc":"Applies a monadic function to another monadic value.\n\nThe function `func` is expected to be wrapped in a monadic context and is applied to the value `m` within its own monadic context.\nThe result is wrapped in the same context as the original monad.","ref":"Funx.Monad.html#ap/2"},{"type":"function","title":"Examples - Funx.Monad.ap/2","doc":"iex> Funx.Monad.ap(Funx.Monad.Maybe.just(fn x -> x * 2 end), Funx.Monad.Maybe.just(3))\n    %Funx.Monad.Maybe.Just{value: 6}\n\nIn the case of `Nothing`:\n\n    iex> Funx.Monad.ap(Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.just(3))\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Monad.html#ap/2-examples"},{"type":"function","title":"Funx.Monad.bind/2","doc":"Chains a monadic operation.\n\nThe `bind/2` function takes a monad `m` and a function `func`. The function `func` is applied to the unwrapped value of `m`,\nand must return another monad. The result is the new monad produced by `func`.\n\nThis is the core operation that allows chaining of computations, with the value being passed from one function to the next in a sequence.","ref":"Funx.Monad.html#bind/2"},{"type":"function","title":"Examples - Funx.Monad.bind/2","doc":"iex> Funx.Monad.bind(Funx.Monad.Maybe.just(5), fn x -> Funx.Monad.Maybe.just(x * 2) end)\n    %Funx.Monad.Maybe.Just{value: 10}\n\nIn the case of `Nothing`:\n\n    iex> Funx.Monad.bind(Funx.Monad.Maybe.nothing(), fn _ -> Funx.Monad.Maybe.just(5) end)\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Monad.html#bind/2-examples"},{"type":"function","title":"Funx.Monad.map/2","doc":"Maps a function over the value inside the monad.\n\nThe `map/2` function takes a monad `m` and a function `func`, applies the function to the value inside `m`, and returns a new monad\ncontaining the result. The original monadic context is preserved.","ref":"Funx.Monad.html#map/2"},{"type":"function","title":"Examples - Funx.Monad.map/2","doc":"iex> Funx.Monad.map(Funx.Monad.Maybe.just(2), fn x -> x + 3 end)\n    %Funx.Monad.Maybe.Just{value: 5}\n\nIn the case of `Nothing`:\n\n    iex> Funx.Monad.map(Funx.Monad.Maybe.nothing(), fn x -> x + 3 end)\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Monad.html#map/2-examples"},{"type":"type","title":"Funx.Monad.t/0","doc":"","ref":"Funx.Monad.html#t:t/0"},{"type":"module","title":"Funx.Monad.Effect","doc":"The `Funx.Monad.Effect` module defines the `Effect` monad, which represents asynchronous computations\nthat may succeed (`Right`) or fail (`Left`). Execution is deferred until explicitly run, making\n`Effect` useful for structuring lazy, asynchronous workflows.\n\nThis module integrates tracing and telemetry, making it suitable for observability in concurrent\nElixir systems. All effects carry a `Effect.Context`, which links operations and records spans\nwhen `run/2` is called.","ref":"Funx.Monad.Effect.html"},{"type":"module","title":"Constructors - Funx.Monad.Effect","doc":"* `right/1` – Wraps a value in a successful `Right` effect.\n  * `left/1` – Wraps a value in a failing `Left` effect.\n  * `pure/1` – Alias for `right/1`.","ref":"Funx.Monad.Effect.html#module-constructors"},{"type":"module","title":"Execution - Funx.Monad.Effect","doc":"* `run/2` – Executes the deferred effect and returns an `Either` result (`Right` or `Left`).\n\nYou may pass `:task_supervisor` in the `opts` to run the effect under a specific `Task.Supervisor`. This supervises the top-level task, any internal tasks spawned within the effect function are not supervised.","ref":"Funx.Monad.Effect.html#module-execution"},{"type":"module","title":"Sequencing - Funx.Monad.Effect","doc":"* `sequence/1` – Runs a list of effects, stopping at the first `Left`.\n  * `traverse/2` – Applies a function returning an `Effect` to each element of a list, sequencing results.\n  * `sequence_a/2` – Runs a list of effects, collecting all `Left` errors instead of short-circuiting.\n  * `traverse_a/3` – Like `traverse/2`, but accumulates errors across the list.","ref":"Funx.Monad.Effect.html#module-sequencing"},{"type":"module","title":"Validation - Funx.Monad.Effect","doc":"* `validate/2` – Validates a value using one or more effectful validators.","ref":"Funx.Monad.Effect.html#module-validation"},{"type":"module","title":"Error Handling - Funx.Monad.Effect","doc":"* `map_left/2` – Transforms a `Left` using a function, leaving `Right` values unchanged.\n  * `flip_either/1` –  Inverts the success and failure branches of an `Effect`.","ref":"Funx.Monad.Effect.html#module-error-handling"},{"type":"module","title":"Lifting - Funx.Monad.Effect","doc":"* `lift_func/2` – Lifts a thunk that returns any value into an `Effect`, wrapping it in `Right`. If the thunk raises, the error is captured as a `Left(EffectError)`.\n  * `lift_either/2` – Lifts a thunk that returns an `Either` into an `Effect`. Evaluation is deferred until the effect is run. Errors are also captured and wrapped in `Left(EffectError)`.\n  * `lift_maybe/3` – Lifts a `Maybe` into an `Effect`, using a fallback error if the value is `Nothing`.\n  * `lift_predicate/3` – Lifts a predicate check into an `Effect`. Returns `Right(value)` if the predicate passes; otherwise returns `Left(fallback)`.","ref":"Funx.Monad.Effect.html#module-lifting"},{"type":"module","title":"Reader Operations - Funx.Monad.Effect","doc":"* `ask/0` – Returns the environment passed to `run/2` as a `Right`.\n  * `asks/1` – Applies a function to the environment passed to `run/2`, wrapping the result in a `Right`.\n  * `fail/0` – Returns the environment passed to `run/2` as a `Left`.\n  * `fails/1` – Applies a function to the environment passed to `run/2`, wrapping the result in a `Left`.","ref":"Funx.Monad.Effect.html#module-reader-operations"},{"type":"module","title":"Elixir Interop - Funx.Monad.Effect","doc":"* `from_result/2` – Converts a `{:ok, _}` or `{:error, _}` tuple into an `Effect`.\n  * `to_result/1` – Converts an `Effect` to `{:ok, _}` or `{:error, _}`.\n  * `from_try/2` – Wraps a function that may raise, returning Right on success, or Left if an exception is raised.\n  * `to_try!/1` – Extracts the value from a `Right`, or raises an exception if `Left`.","ref":"Funx.Monad.Effect.html#module-elixir-interop"},{"type":"module","title":"Protocols - Funx.Monad.Effect","doc":"The Left and Right structs implement the following protocols:\n\n   * Funx.Monad – Provides map/2, ap/2, and bind/2 for compositional workflows.\n\n  Although protocol implementations are defined on Left and Right individually, the behavior\n  is unified under the Effect abstraction.\n\n  This module enables structured concurrency, error handling, and observability in\n  asynchronous workflows.","ref":"Funx.Monad.Effect.html#module-protocols"},{"type":"module","title":"Telemetry - Funx.Monad.Effect","doc":"The `run/2` function emits telemetry using `:telemetry.span/3`.","ref":"Funx.Monad.Effect.html#module-telemetry"},{"type":"module","title":"Events - Funx.Monad.Effect","doc":"* `[:funx, :effect, :run, :start]`\n  * `[:funx, :effect, :run, :stop]`","ref":"Funx.Monad.Effect.html#module-events"},{"type":"module","title":"Measurements - Funx.Monad.Effect","doc":"* `:monotonic_time` – included in both `:start` and `:stop` events.\n  * `:system_time` – included only in the `:start` event.\n  * `:duration` – included only in the `:stop` event.","ref":"Funx.Monad.Effect.html#module-measurements"},{"type":"module","title":"Metadata - Funx.Monad.Effect","doc":"* `:timeout` – the timeout in milliseconds passed to `run/2`.\n  * `:result` – a summarized version of the result using `Funx.Summarizable`.\n  * `:effect_type` – `:right` or `:left`, depending on the effect being run.\n  * `:status` – `:ok` if the result is a `Right`, or `:error` if it's a `Left`.\n  * `:trace_id` – optional value used to correlate traces across boundaries.\n  * `:span_name` – optional name for the span (defaults to `\"funx.effect.run\"`).\n  * `:telemetry_span_context` – reference to correlate `:start` and `:stop` events.","ref":"Funx.Monad.Effect.html#module-metadata"},{"type":"module","title":"Example - Funx.Monad.Effect","doc":":telemetry.attach(\n      \"effect-run-handler\",\n      [:funx, :effect, :run, :stop],\n      fn event, measurements, metadata, _config ->\n        IO.inspect({event, measurements, metadata}, label: \"Effect telemetry\")\n      end,\n      nil\n    )","ref":"Funx.Monad.Effect.html#module-example"},{"type":"function","title":"Funx.Monad.Effect.ask/0","doc":"Returns a `Funx.Monad.Effect.Right` that yields the environment passed to `Funx.Monad.Effect.run/2`.\n\nThis is the Reader-style `ask`, used to access the full environment inside an effectful computation.","ref":"Funx.Monad.Effect.html#ask/0"},{"type":"function","title":"Example - Funx.Monad.Effect.ask/0","doc":"iex> Funx.Monad.Effect.ask()\n    ...> |> Funx.Monad.map(& &1[:region])\n    ...> |> Funx.Monad.Effect.run(%{region: \"us-west\"})\n    %Funx.Monad.Either.Right{right: \"us-west\"}","ref":"Funx.Monad.Effect.html#ask/0-example"},{"type":"function","title":"Funx.Monad.Effect.asks/1","doc":"Returns a `Funx.Monad.Effect.Right` that applies the given function to the environment passed to `Funx.Monad.Effect.run/2`.\n\nThis allows extracting a value from the environment and using it in an effectful computation,\nfollowing the Reader pattern.","ref":"Funx.Monad.Effect.html#asks/1"},{"type":"function","title":"Example - Funx.Monad.Effect.asks/1","doc":"iex> Funx.Monad.Effect.asks(fn env -> env[:user] end)\n    ...> |> Funx.Monad.bind(fn user -> Funx.Monad.Effect.right(user) end)\n    ...> |> Funx.Monad.Effect.run(%{user: \"alice\"})\n    %Funx.Monad.Either.Right{right: \"alice\"}","ref":"Funx.Monad.Effect.html#asks/1-example"},{"type":"function","title":"Funx.Monad.Effect.await/2","doc":"","ref":"Funx.Monad.Effect.html#await/2"},{"type":"function","title":"Funx.Monad.Effect.fail/0","doc":"Returns a `Funx.Monad.Effect.Left` that fails with the entire environment passed to `Funx.Monad.Effect.run/2`.\n\nThis is the Reader-style equivalent of `ask/0`, but marks the environment as a failure.\nUseful when the presence of certain runtime data should short-circuit execution.","ref":"Funx.Monad.Effect.html#fail/0"},{"type":"function","title":"Example - Funx.Monad.Effect.fail/0","doc":"iex> Funx.Monad.Effect.fail()\n    ...> |> Funx.Monad.Effect.run(%{error: :invalid_token})\n    %Funx.Monad.Either.Left{left: %{error: :invalid_token}}","ref":"Funx.Monad.Effect.html#fail/0-example"},{"type":"function","title":"Funx.Monad.Effect.fails/1","doc":"Returns a `Funx.Monad.Effect.Left` that applies the given function to the environment passed to `Funx.Monad.Effect.run/2`.\n\nThis is the failure-side equivalent of `asks/1`, used to produce an error effect based on runtime context.","ref":"Funx.Monad.Effect.html#fails/1"},{"type":"function","title":"Example - Funx.Monad.Effect.fails/1","doc":"iex> Funx.Monad.Effect.fails(fn env -> {:missing_key, env} end)\n    ...> |> Funx.Monad.Effect.run(%{input: nil})\n    %Funx.Monad.Either.Left{left: {:missing_key, %{input: nil}}}","ref":"Funx.Monad.Effect.html#fails/1-example"},{"type":"function","title":"Funx.Monad.Effect.flip_either/1","doc":"Inverts the success and failure branches of an `Effect`.\n\nFor a `Right`, this reverses the result: a successful value becomes a failure, and\na failure becomes a success. For a `Left`, only failure is expected; if the `Left`\nproduces a success, it is ignored.\n\nThis is useful when you want to reverse the semantics of a computation—treating\nan expected error as success, or vice versa.","ref":"Funx.Monad.Effect.html#flip_either/1"},{"type":"function","title":"Examples - Funx.Monad.Effect.flip_either/1","doc":"iex> effect = Funx.Monad.Effect.pure(42)\n    iex> flipped = Funx.Monad.Effect.flip_either(effect)\n    iex> Funx.Monad.Effect.run(flipped)\n    %Funx.Monad.Either.Left{left: 42}\n    iex> effect = Funx.Monad.Effect.left(\"fail\")\n    iex> flipped = Funx.Monad.Effect.flip_either(effect)\n    iex> Funx.Monad.Effect.run(flipped)\n    %Funx.Monad.Either.Right{right: \"fail\"}","ref":"Funx.Monad.Effect.html#flip_either/1-examples"},{"type":"function","title":"Funx.Monad.Effect.from_result/2","doc":"Converts an Elixir `{:ok, value}` or `{:error, reason}` tuple into an `Effect`.\n\nAccepts an optional context context which includes telemetry tracking.","ref":"Funx.Monad.Effect.html#from_result/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.from_result/2","doc":"iex> result = Funx.Monad.Effect.from_result({:ok, 42})\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}\n\n    iex> result = Funx.Monad.Effect.from_result({:error, \"error\"})\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: \"error\"}","ref":"Funx.Monad.Effect.html#from_result/2-examples"},{"type":"function","title":"Funx.Monad.Effect.from_try/2","doc":"Lifts a potentially exception-raising function into a Kleisli function for the `Effect` monad.\n\nThis returns a function of type (`input -> Effect`) that applies the given function to a value.\nIf the function raises, the error is captured and returned in a `Left`. You can optionally\nprovide a context (or opts) for tracing and telemetry.","ref":"Funx.Monad.Effect.html#from_try/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.from_try/2","doc":"iex> safe_div = Funx.Monad.Effect.from_try(fn x -> 10 / x end)\n    iex> effect = Funx.Monad.Effect.pure(2) |> Funx.Monad.bind(safe_div)\n    iex> Funx.Monad.Effect.run(effect)\n    %Funx.Monad.Either.Right{right: 5.0}\n    iex> bad_div = Funx.Monad.Effect.pure(0) |> Funx.Monad.bind(safe_div)\n    iex> Funx.Monad.Effect.run(bad_div)\n    %Funx.Monad.Either.Left{left: %ArithmeticError{}}","ref":"Funx.Monad.Effect.html#from_try/2-examples"},{"type":"function","title":"Funx.Monad.Effect.left/2","doc":"Wraps a value in the `Left` variant of the `Effect` monad, representing a failed asynchronous computation.\n\nAccepts either a keyword list of context options or a `Effect.Context` struct.","ref":"Funx.Monad.Effect.html#left/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.left/2","doc":"iex> result = Funx.Monad.Effect.left(\"error\")\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: \"error\"}\n\n    iex> context = Funx.Monad.Effect.Context.new(trace_id: \"err-id\", span_name: \"failure\")\n    iex> result = Funx.Monad.Effect.left(\"error\", context)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: \"error\"}","ref":"Funx.Monad.Effect.html#left/2-examples"},{"type":"function","title":"Funx.Monad.Effect.lift_either/2","doc":"Lifts a thunk that returns an `Either` into the `Effect` monad.\n\nInstead of passing an `Either` value directly, you provide a zero-arity function (`thunk`) that returns one.\nThis defers execution until the effect is run, allowing integration with tracing and composable pipelines.\n\nYou may also pass a context or options (`opts`) to configure telemetry or span metadata.\n\nIf the thunk raises an exception, it is caught and returned as a `Left` containing an `EffectError` tagged with `:lift`.","ref":"Funx.Monad.Effect.html#lift_either/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.lift_either/2","doc":"iex> result = Funx.Monad.Effect.lift_either(fn -> %Funx.Monad.Either.Right{right: 42} end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}\n\n    iex> result = Funx.Monad.Effect.lift_either(fn -> %Funx.Monad.Either.Left{left: \"error\"} end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: \"error\"}","ref":"Funx.Monad.Effect.html#lift_either/2-examples"},{"type":"function","title":"Funx.Monad.Effect.lift_func/2","doc":"Lifts a thunk into the `Effect` monad, wrapping its result in a `Right`.\n\nThis function defers execution of the given zero-arity function (`thunk`) until the effect is run.\nThe result is automatically wrapped as `Either.Right`.\n\nYou may also pass a context or options (`opts`) to configure telemetry or span metadata.\n\nIf the thunk raises an exception, it is caught and returned as a `Left` containing an `EffectError` tagged with `:lift`.","ref":"Funx.Monad.Effect.html#lift_func/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.lift_func/2","doc":"iex> result = Funx.Monad.Effect.lift_func(fn -> 42 end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}\n\n    iex> result = Funx.Monad.Effect.lift_func(fn -> raise \"boom\" end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{\n      left: %Funx.Errors.EffectError{stage: :lift_func, reason: %RuntimeError{message: \"boom\"}}\n    }","ref":"Funx.Monad.Effect.html#lift_func/2-examples"},{"type":"function","title":"Funx.Monad.Effect.lift_maybe/3","doc":"Converts a `Maybe` value into the `Effect` monad.\nIf the `Maybe` is `Just`, the value is wrapped in `Right`.\nIf it is `Nothing`, the result of `on_none` is wrapped in `Left`.\n\nYou can optionally provide context metadata via `opts`.","ref":"Funx.Monad.Effect.html#lift_maybe/3"},{"type":"function","title":"Examples - Funx.Monad.Effect.lift_maybe/3","doc":"iex> maybe = Funx.Monad.Maybe.just(42)\n    iex> result = Funx.Monad.Effect.lift_maybe(maybe, fn -> \"No value\" end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}\n\n    iex> maybe = Funx.Monad.Maybe.nothing()\n    iex> result = Funx.Monad.Effect.lift_maybe(maybe, fn -> \"No value\" end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: \"No value\"}","ref":"Funx.Monad.Effect.html#lift_maybe/3-examples"},{"type":"function","title":"Funx.Monad.Effect.lift_predicate/4","doc":"Lifts a value into the `Effect` monad based on a predicate.\nIf the predicate returns true, the value is wrapped in `Right`.\nOtherwise, the result of calling `on_false` with the value is wrapped in `Left`.\n\nOptional context metadata (e.g. `:span_name`, `:trace_id`) can be passed via `opts`.","ref":"Funx.Monad.Effect.html#lift_predicate/4"},{"type":"function","title":"Examples - Funx.Monad.Effect.lift_predicate/4","doc":"iex> result = Funx.Monad.Effect.lift_predicate(10, &(&1 > 5), fn x -> \"#{x} is too small\" end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 10}\n\n    iex> result = Funx.Monad.Effect.lift_predicate(3, &(&1 > 5), fn x -> \"#{x} is too small\" end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: \"3 is too small\"}","ref":"Funx.Monad.Effect.html#lift_predicate/4-examples"},{"type":"function","title":"Funx.Monad.Effect.map_left/2","doc":"Transforms the `Left` branch of an `Effect`.\n\nIf the `Effect` resolves to a `Left`, the provided function is applied to the error.\nIf the `Effect` resolves to a `Right`, the value is returned unchanged.\n\nThis function is useful when you want to rewrite or wrap errors without affecting successful computations.","ref":"Funx.Monad.Effect.html#map_left/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.map_left/2","doc":"iex> effect = Funx.Monad.Effect.left(\"error\")\n    iex> transformed = Funx.Monad.Effect.map_left(effect, fn e -> \"wrapped: \" <> e end)\n    iex> Funx.Monad.Effect.run(transformed)\n    %Funx.Monad.Either.Left{left: \"wrapped: error\"}\n\n    iex> effect = Funx.Monad.Effect.pure(42)\n    iex> transformed = Funx.Monad.Effect.map_left(effect, fn _ -> \"should not be called\" end)\n    iex> Funx.Monad.Effect.run(transformed)\n    %Funx.Monad.Either.Right{right: 42}","ref":"Funx.Monad.Effect.html#map_left/2-examples"},{"type":"function","title":"Funx.Monad.Effect.pure/2","doc":"Alias for `right/2`.\n\nWraps a value in the `Right` variant of the `Effect` monad, representing a successful asynchronous computation.\n\nAccepts either a keyword list of context options or a `Effect.Context` struct.","ref":"Funx.Monad.Effect.html#pure/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.pure/2","doc":"iex> result = Funx.Monad.Effect.pure(42)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}\n\n    iex> context = Funx.Monad.Effect.Context.new(trace_id: \"custom-id\", span_name: \"pure example\")\n    iex> result = Funx.Monad.Effect.pure(42, context)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}","ref":"Funx.Monad.Effect.html#pure/2-examples"},{"type":"function","title":"Funx.Monad.Effect.right/2","doc":"Wraps a value in the `Right` variant of the `Effect` monad, representing a successful asynchronous computation.\n\nThis is an alias for `pure/2`. You may optionally provide execution context, either as a keyword list or\na `%Funx.Monad.Effect.Context{}` struct. The context is attached to the effect and propagated during execution.","ref":"Funx.Monad.Effect.html#right/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.right/2","doc":"iex> result = Funx.Monad.Effect.right(42)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}\n\n    iex> context = Funx.Monad.Effect.Context.new(trace_id: \"custom-id\", span_name: \"from right\")\n    iex> result = Funx.Monad.Effect.right(42, context)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}","ref":"Funx.Monad.Effect.html#right/2-examples"},{"type":"function","title":"Funx.Monad.Effect.run/1","doc":"Runs the `Effect` and returns the result, awaiting the task if necessary.\n\nYou may provide optional telemetry metadata using `opts`, such as `:span_name`\nto promote the current context with a new label.","ref":"Funx.Monad.Effect.html#run/1"},{"type":"function","title":"Options - Funx.Monad.Effect.run/1","doc":"* `:span_name` – (optional) promotes the trace to a new span with the given name.","ref":"Funx.Monad.Effect.html#run/1-options"},{"type":"function","title":"Examples - Funx.Monad.Effect.run/1","doc":"iex> result = Funx.Monad.Effect.right(42)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 42}\n\n    iex> result = Funx.Monad.Effect.right(42, span_name: \"initial\")\n    iex> Funx.Monad.Effect.run(result, span_name: \"promoted\")\n    %Funx.Monad.Either.Right{right: 42}","ref":"Funx.Monad.Effect.html#run/1-examples"},{"type":"function","title":"Funx.Monad.Effect.run/2","doc":"","ref":"Funx.Monad.Effect.html#run/2"},{"type":"function","title":"Funx.Monad.Effect.run/3","doc":"","ref":"Funx.Monad.Effect.html#run/3"},{"type":"function","title":"Funx.Monad.Effect.sequence/2","doc":"Sequences a list of `Effect` computations, running each in order.\n\nIf all effects resolve to `Right`, the result is a `Right` containing a list of values.\nIf any effect resolves to `Left`, the sequencing stops early and that `Left` is returned.\n\nEach effect is executed with its own context context, and telemetry spans are emitted for observability.","ref":"Funx.Monad.Effect.html#sequence/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.sequence/2","doc":"iex> effects = [Funx.Monad.Effect.right(1), Funx.Monad.Effect.right(2)]\n    iex> result = Funx.Monad.Effect.sequence(effects)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: [1, 2]}\n\n    iex> effects = [Funx.Monad.Effect.right(1), Funx.Monad.Effect.left(\"error\")]\n    iex> result = Funx.Monad.Effect.sequence(effects)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: \"error\"}","ref":"Funx.Monad.Effect.html#sequence/2-examples"},{"type":"function","title":"Funx.Monad.Effect.sequence_a/2","doc":"Sequences a list of `Effect` computations, collecting all `Right` results\nor accumulating all `Left` errors if present.\n\nUnlike `sequence/1`, which stops at the first `Left`, this version continues processing\nall effects, returning a list of errors if any failures occur.\n\nEach effect emits its own telemetry span, and error contexts are preserved through tracing.","ref":"Funx.Monad.Effect.html#sequence_a/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.sequence_a/2","doc":"iex> effects = [\n    ...>   Funx.Monad.Effect.right(1),\n    ...>   Funx.Monad.Effect.left(\"Error 1\"),\n    ...>   Funx.Monad.Effect.left(\"Error 2\")\n    ...> ]\n    iex> result = Funx.Monad.Effect.sequence_a(effects)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: [\"Error 1\", \"Error 2\"]}","ref":"Funx.Monad.Effect.html#sequence_a/2-examples"},{"type":"function","title":"Funx.Monad.Effect.to_result/2","doc":"Converts an `Effect` into an Elixir `{:ok, _}` or `{:error, _}` tuple by running the effect.\n\nIf the effect completes successfully (`Right`), the result is wrapped in `{:ok, value}`.\nIf the effect fails (`Left`), the error is returned as `{:error, reason}`.\n\nThis function also emits telemetry via `run/2` and supports optional context metadata through keyword options.","ref":"Funx.Monad.Effect.html#to_result/2"},{"type":"function","title":"Options - Funx.Monad.Effect.to_result/2","doc":"* `:span_name` – sets a custom span name for tracing and telemetry.","ref":"Funx.Monad.Effect.html#to_result/2-options"},{"type":"function","title":"Examples - Funx.Monad.Effect.to_result/2","doc":"iex> effect = Funx.Monad.Effect.right(42, span_name: \"convert-ok\")\n    iex> Funx.Monad.Effect.to_result(effect, span_name: \"to_result\")\n    {:ok, 42}\n\n    iex> error = Funx.Monad.Effect.left(\"fail\", span_name: \"convert-error\")\n    iex> Funx.Monad.Effect.to_result(error, span_name: \"to_result\")\n    {:error, \"fail\"}\n\nTelemetry will include the promoted span name (`\"to_result -> convert-ok\"`) and context metadata.","ref":"Funx.Monad.Effect.html#to_result/2-examples"},{"type":"function","title":"Funx.Monad.Effect.to_try!/2","doc":"Executes an `Effect` and returns the result if it is a `Right`. If the result is a `Left`,\nthis function raises the contained error.\n\nThis is useful when you want to interoperate with code that expects regular exceptions,\nsuch as within test assertions or imperative pipelines.\n\nRuns the effect with full telemetry tracing.","ref":"Funx.Monad.Effect.html#to_try!/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.to_try!/2","doc":"iex> effect = Funx.Monad.Effect.right(42, span_name: \"return\")\n    iex> Funx.Monad.Effect.to_try!(effect)\n    42\n\n    iex> error = Funx.Monad.Effect.left(%RuntimeError{message: \"failure\"}, span_name: \"error\")\n    iex> Funx.Monad.Effect.to_try!(error)\n    ** (RuntimeError) failure\n\nTelemetry will emit a `:stop` event with `:status` set to `:ok` or `:error`, depending on the outcome.","ref":"Funx.Monad.Effect.html#to_try!/2-examples"},{"type":"function","title":"Funx.Monad.Effect.traverse/2","doc":"Traverses a list with a function that returns `Effect` computations,\nrunning each in sequence and collecting the `Right` results.\n\nIf all effects resolve to `Right`, returns a single `Effect` with a list of results.\nIf any effect resolves to `Left`, the traversal stops early and returns that `Left`.\n\nEach step preserves context context and emits telemetry spans, including nested spans when bound.","ref":"Funx.Monad.Effect.html#traverse/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.traverse/2","doc":"iex> is_positive = fn num ->\n    ...>   Funx.Monad.Effect.lift_predicate(num, fn x -> x > 0 end, fn x -> Integer.to_string(x) <> \" is not positive\" end)\n    ...> end\n    iex> result = Funx.Monad.Effect.traverse([1, 2, 3], fn num -> is_positive.(num) end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: [1, 2, 3]}\n    iex> result = Funx.Monad.Effect.traverse([1, -2, 3], fn num -> is_positive.(num) end)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: \"-2 is not positive\"}","ref":"Funx.Monad.Effect.html#traverse/2-examples"},{"type":"function","title":"Funx.Monad.Effect.traverse/3","doc":"","ref":"Funx.Monad.Effect.html#traverse/3"},{"type":"function","title":"Funx.Monad.Effect.traverse_a/2","doc":"Traverses a list with a function that returns `Effect` values, combining results\ninto a single `Effect`. Unlike `traverse/2`, this version accumulates all errors\nrather than stopping at the first `Left`.\n\nEach successful computation contributes to the final list of results.\nIf any computations fail, all errors are collected and returned as a single `Left`.\n\nThis function also manages telemetry trace context across all nested effects,\nensuring that span relationships and trace IDs are preserved through the traversal.","ref":"Funx.Monad.Effect.html#traverse_a/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.traverse_a/2","doc":"iex> validate = fn n ->\n    ...>   Funx.Monad.Effect.lift_predicate(n, fn x -> x > 0 end, fn x -> Integer.to_string(x) <> \" is not positive\" end)\n    ...> end\n    iex> result = Funx.Monad.Effect.traverse_a([1, -2, 3], validate)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: [\"-2 is not positive\"]}\n    iex> result = Funx.Monad.Effect.traverse_a([1, 2, 3], validate)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: [1, 2, 3]}","ref":"Funx.Monad.Effect.html#traverse_a/2-examples"},{"type":"function","title":"Funx.Monad.Effect.traverse_a/3","doc":"","ref":"Funx.Monad.Effect.html#traverse_a/3"},{"type":"function","title":"Funx.Monad.Effect.validate/3","doc":"Validates a value using one or more validator functions, each returning an `Effect`.\n\nIf all validators succeed (`Right`), the original value is returned in a `Right`.\nIf any validator fails (`Left`), all errors are accumulated and returned as a single `Left`.\n\nThis function also manages telemetry trace context across all nested validations,\nensuring that span relationships and trace IDs are preserved throughout.\n\nSupports optional `opts` for span metadata (e.g. `:span_name`).","ref":"Funx.Monad.Effect.html#validate/3"},{"type":"function","title":"Examples - Funx.Monad.Effect.validate/3","doc":"iex> validate_positive = fn x ->\n    ...>   Funx.Monad.Effect.lift_predicate(x, fn n -> n > 0 end, fn n -> \"Value \" <> Integer.to_string(n) <> \" must be positive\" end)\n    ...> end\n    iex> validate_even = fn x ->\n    ...>   Funx.Monad.Effect.lift_predicate(x, fn n -> rem(n, 2) == 0 end, fn n -> \"Value \" <> Integer.to_string(n) <> \" must be even\" end)\n    ...> end\n    iex> validators = [validate_positive, validate_even]\n    iex> result = Funx.Monad.Effect.validate(4, validators)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Right{right: 4}\n    iex> result = Funx.Monad.Effect.validate(3, validators)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: [\"Value 3 must be even\"]}\n    iex> result = Funx.Monad.Effect.validate(-3, validators)\n    iex> Funx.Monad.Effect.run(result)\n    %Funx.Monad.Either.Left{left: [\"Value -3 must be positive\", \"Value -3 must be even\"]}","ref":"Funx.Monad.Effect.html#validate/3-examples"},{"type":"type","title":"Funx.Monad.Effect.t/2","doc":"Represents a deferred computation in the `Effect` monad that may either succeed (`Right`) or fail (`Left`).\n\nThis type unifies `Effect.Right.t/1` and `Effect.Left.t/1` under a common interface, allowing code to\noperate over asynchronous effects regardless of success or failure outcome.\n\nEach variant carries a `context` for telemetry and a deferred `effect` function that takes an environment.","ref":"Funx.Monad.Effect.html#t:t/2"},{"type":"module","title":"Funx.Monad.Effect.Context","doc":"Represents the execution context attached to an effect.\n\nThis struct carries contextual information such as `trace_id`, `span_name`,\ntimeouts, and arbitrary metadata (`baggage` and `metadata`). It supports\ntelemetry integration, span linking, and timeout control, and is propagated\nautomatically across composed effects.\n\nDevelopers can set fields like `timeout`, `trace_id`, or `span_name` when\nconstructing `Left` and `Right` effects. The context is merged or promoted\nas needed when chaining effects to preserve trace continuity and execution scope.\n\nThis context is not injected at runtime via `run/2`—it is bound to the effect\nwhen created.","ref":"Funx.Monad.Effect.Context.html"},{"type":"function","title":"Funx.Monad.Effect.Context.default_span_name?/1","doc":"","ref":"Funx.Monad.Effect.Context.html#default_span_name?/1"},{"type":"function","title":"Funx.Monad.Effect.Context.default_span_name_if_empty/2","doc":"","ref":"Funx.Monad.Effect.Context.html#default_span_name_if_empty/2"},{"type":"function","title":"Funx.Monad.Effect.Context.empty_or_default_span_name?/1","doc":"","ref":"Funx.Monad.Effect.Context.html#empty_or_default_span_name?/1"},{"type":"function","title":"Funx.Monad.Effect.Context.generate_trace_id/0","doc":"Generates a random lowercase hexadecimal trace ID.\n\nThis function is used internally to ensure each trace is uniquely identifiable.","ref":"Funx.Monad.Effect.Context.html#generate_trace_id/0"},{"type":"function","title":"Examples - Funx.Monad.Effect.Context.generate_trace_id/0","doc":"iex> id = Funx.Monad.Effect.Context.generate_trace_id()\n    iex> String.length(id)\n    32\n    iex> id =~ ~r/^[a-f0-9]+$/\n    true","ref":"Funx.Monad.Effect.Context.html#generate_trace_id/0-examples"},{"type":"function","title":"Funx.Monad.Effect.Context.merge/2","doc":"Merges two `%Funx.Monad.Effect.Context{}` structs into one, preferring non-nil values from the first context.\n\nThis is used to preserve trace continuity and propagate context across composed effects.\n\n- Non-nil fields from the first context take precedence.\n- `baggage` and `metadata` maps are deeply merged.\n- This operation is idempotent and safe for reuse across nested effect chains.","ref":"Funx.Monad.Effect.Context.html#merge/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.Context.merge/2","doc":"iex> c1 = Funx.Monad.Effect.Context.new(trace_id: \"a\", baggage: %{user: 1})\n    iex> c2 = Funx.Monad.Effect.Context.new(trace_id: \"b\", baggage: %{region: \"us-west\"})\n    iex> Funx.Monad.Effect.Context.merge(c1, c2).baggage\n    %{user: 1, region: \"us-west\"}","ref":"Funx.Monad.Effect.Context.html#merge/2-examples"},{"type":"function","title":"Funx.Monad.Effect.Context.new/0","doc":"Creates a new `Funx.Monad.Effect.Context` struct for use with effectful computations.\n\nIf no `:trace_id` is provided, a unique one is generated automatically.\nYou may also set optional fields such as `:span_name`, `:timeout`, `:baggage`, and `:metadata`.\n\nThe returned context is intended to be passed into `Left` and `Right` effects,\nwhere it will be propagated and updated across chained computations.","ref":"Funx.Monad.Effect.Context.html#new/0"},{"type":"function","title":"Examples - Funx.Monad.Effect.Context.new/0","doc":"iex> ctx = Funx.Monad.Effect.Context.new(span_name: \"load-data\", timeout: 2000)\n    iex> ctx.span_name\n    \"load-data\"\n\n    iex> ctx = Funx.Monad.Effect.Context.new(trace_id: \"abc123\")\n    iex> ctx.trace_id\n    \"abc123\"","ref":"Funx.Monad.Effect.Context.html#new/0-examples"},{"type":"function","title":"Funx.Monad.Effect.Context.new/1","doc":"","ref":"Funx.Monad.Effect.Context.html#new/1"},{"type":"function","title":"Funx.Monad.Effect.Context.override/2","doc":"Returns a new `%Funx.Monad.Effect.Context{}` with fields overridden by values from the given keyword list.\n\n- Direct fields like `:trace_id`, `:parent_trace_id`, `:span_name`, and `:timeout` are replaced if present.\n- Nested maps `:baggage` and `:metadata` are deeply merged, with the keyword list taking precedence.\n\nThis is useful for refining or extending an existing context in a specific part of an effect chain.","ref":"Funx.Monad.Effect.Context.html#override/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.Context.override/2","doc":"iex> ctx = Funx.Monad.Effect.Context.new(trace_id: \"abc\", baggage: %{x: 1}, metadata: %{debug: false})\n    iex> updated = Funx.Monad.Effect.Context.override(ctx, span_name: \"child\", baggage: %{x: 2}, metadata: %{debug: true})\n    iex> updated.span_name\n    \"child\"\n    iex> updated.baggage\n    %{x: 2}\n    iex> updated.metadata\n    %{debug: true}","ref":"Funx.Monad.Effect.Context.html#override/2-examples"},{"type":"function","title":"Funx.Monad.Effect.Context.promote_trace/2","doc":"Promotes the current context into a child trace by generating a new `trace_id` and linking to the original.\n\n- The current `trace_id` is moved to `parent_trace_id`.\n- A new `trace_id` is generated for the child context.\n- The given `label` is prepended to the existing `span_name` as `\"label -> span\"`.\n\nThis is typically used to represent a nested span or sub-operation within a larger effect chain,\npreserving trace lineage across composed effects.","ref":"Funx.Monad.Effect.Context.html#promote_trace/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.Context.promote_trace/2","doc":"iex> parent = Funx.Monad.Effect.Context.new(trace_id: \"abc123\", span_name: \"load\")\n    iex> child = Funx.Monad.Effect.Context.promote_trace(parent, \"decode\")\n    iex> child.parent_trace_id\n    \"abc123\"\n    iex> child.trace_id != \"abc123\"\n    true\n    iex> child.span_name\n    \"decode -> load\"","ref":"Funx.Monad.Effect.Context.html#promote_trace/2-examples"},{"type":"function","title":"Funx.Monad.Effect.Context.span_name?/1","doc":"","ref":"Funx.Monad.Effect.Context.html#span_name?/1"},{"type":"type","title":"Funx.Monad.Effect.Context.opts_or_context/0","doc":"Represents input for constructing an `Effect.Context`.\n\nAccepts either a keyword list of options (`trace_id`, `span_name`, etc.) or an existing `Context` struct.\nUsed throughout the `Effect` system for flexible context propagation.","ref":"Funx.Monad.Effect.Context.html#t:opts_or_context/0"},{"type":"type","title":"Funx.Monad.Effect.Context.t/0","doc":"Represents the contextual metadata associated with an `Effect`.\n\nThe context carries telemetry and tracing information such as `trace_id`, `span_name`, and `timeout`,\nas well as arbitrary metadata and user-defined `baggage`. It is passed through all effectful computations\nand can be promoted to represent nested spans.","ref":"Funx.Monad.Effect.Context.html#t:t/0"},{"type":"module","title":"Funx.Monad.Effect.Left","doc":"Represents the `Left` variant of the `Effect` monad, used to model a failure or error in an asynchronous context.\n\nThis module implements the following protocols:\n  - `Funx.Monad`: Implements `bind/2`, `map/2`, and `ap/2` for monadic sequencing in a lazy, effectful context.\n  - `String.Chars`: Provides a string representation of the effect for debugging and inspection.\n\nA `Left` effect propagates its failure value without invoking further computations, preserving short-circuit behavior.","ref":"Funx.Monad.Effect.Left.html"},{"type":"module","title":"Reader Operations - Funx.Monad.Effect.Left","doc":"* `ask/1` – Returns the environment passed to `run/2` as a `Left`.\n  * `asks/2` – Applies a function to the environment passed to `run/2`, wrapping the result in a `Left`.","ref":"Funx.Monad.Effect.Left.html#module-reader-operations"},{"type":"function","title":"Funx.Monad.Effect.Left.ask/1","doc":"Returns a `Funx.Monad.Effect.Left` that yields the environment passed to `Funx.Monad.Effect.run/2`.\n\nThis is the Reader-style `ask`, used to construct a failure from the full injected environment.\nIt can be useful for debugging, instrumentation, or propagating request-scoped failure information.","ref":"Funx.Monad.Effect.Left.html#ask/1"},{"type":"function","title":"Example - Funx.Monad.Effect.Left.ask/1","doc":"iex> Funx.Monad.Effect.Left.ask()\n    ...> |> Funx.Monad.Effect.run(%{error: :unauthorized})\n    %Funx.Monad.Either.Left{left: %{error: :unauthorized}}","ref":"Funx.Monad.Effect.Left.html#ask/1-example"},{"type":"function","title":"Funx.Monad.Effect.Left.asks/2","doc":"Returns a `Funx.Monad.Effect.Left` that applies the given function to the environment passed to `Funx.Monad.Effect.run/2`.\n\nThis allows constructing a failure (`Left`) based on runtime input. It complements `Right.asks/2`,\nbut marks the result as a failure rather than a success.","ref":"Funx.Monad.Effect.Left.html#asks/2"},{"type":"function","title":"Example - Funx.Monad.Effect.Left.asks/2","doc":"iex> Funx.Monad.Effect.Left.asks(fn env -> {:error, env[:reason]} end)\n    ...> |> Funx.Monad.Effect.run(%{reason: :invalid})\n    %Funx.Monad.Either.Left{left: {:error, :invalid}}","ref":"Funx.Monad.Effect.Left.html#asks/2-example"},{"type":"function","title":"Funx.Monad.Effect.Left.pure/2","doc":"Creates a new `Left` effect.\n\nWraps a failure value in an asynchronous effect. You may provide context either as a keyword list or\nan `Effect.Context` struct.","ref":"Funx.Monad.Effect.Left.html#pure/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.Left.pure/2","doc":"iex> effect = Funx.Monad.Effect.Left.pure(\"error\")\n    iex> Funx.Monad.Effect.run(effect)\n    %Funx.Monad.Either.Left{left: \"error\"}","ref":"Funx.Monad.Effect.Left.html#pure/2-examples"},{"type":"type","title":"Funx.Monad.Effect.Left.t/0","doc":"","ref":"Funx.Monad.Effect.Left.html#t:t/0"},{"type":"type","title":"Funx.Monad.Effect.Left.t/1","doc":"Represents an asynchronous computation that produces a `Left` value.\n\nThe `effect` function is typically a deferred task that takes an environment and returns a `Task`.\nSince Elixir does not support parameterized `Task.t()` types, the return type is written as a union:\neither a `Task.t()` or a plain `Either.Left.t(left)` to support testing and internal optimizations.\n\nThe `context` carries telemetry, trace metadata, and environment configuration for error flows.","ref":"Funx.Monad.Effect.Left.html#t:t/1"},{"type":"module","title":"Funx.Monad.Effect.Right","doc":"Represents the `Right` variant of the `Effect` monad, used to model a successful computation in an asynchronous context.\n\nThis module implements the following protocols:\n  - `Funx.Monad`: Implements the `bind/2`, `map/2`, and `ap/2` functions to handle monadic operations within an effectful, lazy execution context.\n  - `String.Chars`: Provides a `to_string/1` function to represent `Right` values as strings.\n\nThe `Right` effect allows the computation to proceed with successful values, supporting lazy, asynchronous tasks\nand capturing execution context through the `Effect.Context` struct.","ref":"Funx.Monad.Effect.Right.html"},{"type":"module","title":"Reader Operations - Funx.Monad.Effect.Right","doc":"* `ask/1` – Returns the environment passed to `run/2` as a `Right`.\n  * `asks/2` – Applies a function to the environment passed to `run/2`, wrapping the result in a `Right`.","ref":"Funx.Monad.Effect.Right.html#module-reader-operations"},{"type":"function","title":"Funx.Monad.Effect.Right.ask/1","doc":"Returns a `Funx.Monad.Effect.Right` that yields the environment passed to `Funx.Monad.Effect.run/2`.\n\nThis is the Reader monad's equivalent of `ask`, giving access to the entire injected environment\nfor further computation.","ref":"Funx.Monad.Effect.Right.html#ask/1"},{"type":"function","title":"Example - Funx.Monad.Effect.Right.ask/1","doc":"iex> Funx.Monad.Effect.Right.ask()\n    ...> |> Funx.Monad.map(& &1[:user])\n    ...> |> Funx.Monad.Effect.run(%{user: \"alice\"})\n    %Funx.Monad.Either.Right{right: \"alice\"}","ref":"Funx.Monad.Effect.Right.html#ask/1-example"},{"type":"function","title":"Funx.Monad.Effect.Right.asks/2","doc":"Returns a `Funx.Monad.Effect.Right` that applies the given function to the environment passed to `Funx.Monad.Effect.run/2`.\n\nThis allows extracting a value from the environment and using it in an effectful computation,\nfollowing the Reader pattern.","ref":"Funx.Monad.Effect.Right.html#asks/2"},{"type":"function","title":"Example - Funx.Monad.Effect.Right.asks/2","doc":"iex> Funx.Monad.Effect.Right.asks(fn env -> env[:user] end)\n    ...> |> Funx.Monad.bind(fn user -> Funx.Monad.Effect.right(user) end)\n    ...> |> Funx.Monad.Effect.run(%{user: \"alice\"})\n    %Funx.Monad.Either.Right{right: \"alice\"}","ref":"Funx.Monad.Effect.Right.html#asks/2-example"},{"type":"function","title":"Funx.Monad.Effect.Right.pure/2","doc":"Creates a new `Right` effect.\n\nThe `pure/2` function wraps a value in the `Right` effect monad, representing an asynchronous success.","ref":"Funx.Monad.Effect.Right.html#pure/2"},{"type":"function","title":"Examples - Funx.Monad.Effect.Right.pure/2","doc":"iex> effect = Funx.Monad.Effect.Right.pure(\"success\")\n    iex> Funx.Monad.Effect.run(effect)\n    %Funx.Monad.Either.Right{right: \"success\"}","ref":"Funx.Monad.Effect.Right.html#pure/2-examples"},{"type":"type","title":"Funx.Monad.Effect.Right.t/0","doc":"","ref":"Funx.Monad.Effect.Right.html#t:t/0"},{"type":"type","title":"Funx.Monad.Effect.Right.t/1","doc":"Represents an asynchronous computation that produces a `Right` value.\n\nThe `effect` function is typically a deferred task that takes an environment and returns a `Task`.\nSince Elixir does not support parameterized `Task.t()` types, the return type is described as a union:\neither a `Task.t()` or a plain `Either.Right.t(right)` for testability and flexibility.\n\nThe `context` carries telemetry and trace information used during execution.","ref":"Funx.Monad.Effect.Right.html#t:t/1"},{"type":"module","title":"Funx.Monad.Either","doc":"The `Funx.Monad.Either` module provides an implementation of the `Either` monad, a functional abstraction used to model computations that may fail.\n\nAn `Either` represents one of two possibilities:\n\n  - `Right(value)`: a successful result\n  - `Left(error)`: a failure or error\n\nThis pattern is commonly used in place of exceptions to handle errors explicitly and safely in functional pipelines.","ref":"Funx.Monad.Either.html"},{"type":"module","title":"Constructors - Funx.Monad.Either","doc":"- `right/1`: Wraps a value in the `Right` branch.\n  - `left/1`: Wraps a value in the `Left` branch.\n  - `pure/1`: Alias for `right/1`.","ref":"Funx.Monad.Either.html#module-constructors"},{"type":"module","title":"Refinement - Funx.Monad.Either","doc":"- `right?/1`: Returns `true` if the value is a `Right`.\n  - `left?/1`: Returns `true` if the value is a `Left`.","ref":"Funx.Monad.Either.html#module-refinement"},{"type":"module","title":"Fallback and Extraction - Funx.Monad.Either","doc":"- `get_or_else/2`: Returns the value from a `Right`, or a default if `Left`.\n  - `or_else/2`: Returns the original `Right`, or invokes a fallback function if `Left`.\n  - `map_left/2`: Transforms a `Left` using a function, leaving `Right` values unchanged.\n  - `flip/1`: Swaps `Left` and `Right`, turning errors into successes and vice versa.\n  - `filter_or_else/3`: Applies a predicate to the `Right` value; if false, returns a fallback `Left`.","ref":"Funx.Monad.Either.html#module-fallback-and-extraction"},{"type":"module","title":"List Operations - Funx.Monad.Either","doc":"- `concat/1`: Removes all `Left` values and unwraps the `Right` values from a list.\n  - `concat_map/2`: Applies a function and collects only `Right` results.\n  - `sequence/1`: Converts a list of `Either` values into a single `Either` of list.\n  - `traverse/2`: Applies a function to each element in a list and sequences the results.\n  - `sequence_a/1`: Like `sequence/1`, but accumulates all errors from `Left` values.\n  - `traverse_a/2`: Like `traverse/2`, but accumulates all `Left` values instead of short-circuiting.\n  - `wither_a/2`: Like `traverse_a/2`, but filters out `Nothing` results and collects only `Just` values.","ref":"Funx.Monad.Either.html#module-list-operations"},{"type":"module","title":"Validation - Funx.Monad.Either","doc":"- `validate/2`: Applies multiple validators to a single input, collecting all errors.","ref":"Funx.Monad.Either.html#module-validation"},{"type":"module","title":"Lifting - Funx.Monad.Either","doc":"- `lift_predicate/3`: Turns a predicate into an `Either`, returning `Right` on `true` and `Left` on `false`.\n  - `lift_maybe/2`: Converts a `Maybe` to an `Either` using a fallback value.\n  - `lift_eq/1`: Lifts an equality function into the `Either` context.\n  - `lift_ord/1`: Lifts an ordering function into the `Either` context.","ref":"Funx.Monad.Either.html#module-lifting"},{"type":"module","title":"Transformation - Funx.Monad.Either","doc":"- `map_left/2` – Transforms the error inside a `Left`, leaving `Right` values untouched.","ref":"Funx.Monad.Either.html#module-transformation"},{"type":"module","title":"Elixir Interoperability - Funx.Monad.Either","doc":"- `from_result/1`: Converts `{:ok, val}` or `{:error, err}` into an `Either`.\n  - `to_result/1`: Converts an `Either` into a result tuple.\n  - `from_try/1`: Runs a function and returns `Right` on success or `Left` on exception.\n  - `to_try!/1`: Unwraps a `Right`, or raises an error from a `Left`.","ref":"Funx.Monad.Either.html#module-elixir-interoperability"},{"type":"module","title":"Protocols - Funx.Monad.Either","doc":"The `Left` and `Right` structs implement the following protocols, making the `Either` abstraction composable and extensible:\n\n  - `Funx.Eq`: Enables equality comparisons between `Either` values.\n  - `Funx.Foldable`: Implements `fold_l/3` and `fold_r/3` for reducing over contained values.\n  - `Funx.Monad`: Provides `map/2`, `ap/2`, and `bind/2` for monadic composition.\n  - `Funx.Ord`: Defines ordering behavior for comparing `Left` and `Right` values.\n\nAlthough these implementations are defined on each constructor (`Left` and `Right`), the behavior is consistent across the `Either` abstraction.\n\nThis module helps you model failure explicitly, compose error-aware logic, and integrate cleanly with Elixir's functional idioms.","ref":"Funx.Monad.Either.html#module-protocols"},{"type":"function","title":"Funx.Monad.Either.concat/1","doc":"Removes `Left` values from a list of `Either` and returns a list of unwrapped `Right` values.\n\nUseful for discarding failed computations while keeping successful results.","ref":"Funx.Monad.Either.html#concat/1"},{"type":"function","title":"Examples - Funx.Monad.Either.concat/1","doc":"iex> Funx.Monad.Either.concat([Funx.Monad.Either.right(1), Funx.Monad.Either.left(:error), Funx.Monad.Either.right(2)])\n    [1, 2]\n\n    iex> Funx.Monad.Either.concat([Funx.Monad.Either.left(:a), Funx.Monad.Either.left(:b)])\n    []\n\n    iex> Funx.Monad.Either.concat([Funx.Monad.Either.right(\"a\"), Funx.Monad.Either.right(\"b\"), Funx.Monad.Either.right(\"c\")])\n    [\"a\", \"b\", \"c\"]","ref":"Funx.Monad.Either.html#concat/1-examples"},{"type":"function","title":"Funx.Monad.Either.concat_map/2","doc":"Applies the given function to each element in the list and collects the `Right` results, discarding any `Left`.\n\nThis is useful when mapping a function that may fail and you only want the successful results.","ref":"Funx.Monad.Either.html#concat_map/2"},{"type":"function","title":"Examples - Funx.Monad.Either.concat_map/2","doc":"iex> Funx.Monad.Either.concat_map([1, 2, 3], fn x -> if rem(x, 2) == 1, do: Funx.Monad.Either.right(x), else: Funx.Monad.Either.left(:even) end)\n    [1, 3]\n\n    iex> Funx.Monad.Either.concat_map([2, 4], fn x -> if x > 3, do: Funx.Monad.Either.right(x), else: Funx.Monad.Either.left(:too_small) end)\n    [4]\n\n    iex> Funx.Monad.Either.concat_map([], fn _ -> Funx.Monad.Either.left(:none) end)\n    []","ref":"Funx.Monad.Either.html#concat_map/2-examples"},{"type":"function","title":"Funx.Monad.Either.filter_or_else/3","doc":"Filters the value inside a `Right` using the given `predicate`. If the predicate returns `false`,\na `Left` is returned using the `left_func`.","ref":"Funx.Monad.Either.html#filter_or_else/3"},{"type":"function","title":"Examples - Funx.Monad.Either.filter_or_else/3","doc":"iex> Funx.Monad.Either.filter_or_else(Funx.Monad.Either.right(5), fn x -> x > 3 end, fn -> \"error\" end)\n    %Funx.Monad.Either.Right{right: 5}\n\n    iex> Funx.Monad.Either.filter_or_else(Funx.Monad.Either.right(2), fn x -> x > 3 end, fn -> \"error\" end)\n    %Funx.Monad.Either.Left{left: \"error\"}","ref":"Funx.Monad.Either.html#filter_or_else/3-examples"},{"type":"function","title":"Funx.Monad.Either.flip/1","doc":"Swaps the `Left` and `Right` branches of the `Either`.\n\nTurns a `Left` into a `Right` and vice versa, preserving the contained term.","ref":"Funx.Monad.Either.html#flip/1"},{"type":"function","title":"Examples - Funx.Monad.Either.flip/1","doc":"iex> Funx.Monad.Either.flip(Funx.Monad.Either.left(:error))\n    %Funx.Monad.Either.Right{right: :error}\n\n    iex> Funx.Monad.Either.flip(Funx.Monad.Either.right(42))\n    %Funx.Monad.Either.Left{left: 42}","ref":"Funx.Monad.Either.html#flip/1-examples"},{"type":"function","title":"Funx.Monad.Either.from_result/1","doc":"Converts a result (`{:ok, _}` or `{:error, _}`) to an `Either`.","ref":"Funx.Monad.Either.html#from_result/1"},{"type":"function","title":"Examples - Funx.Monad.Either.from_result/1","doc":"iex> Funx.Monad.Either.from_result({:ok, 5})\n    %Funx.Monad.Either.Right{right: 5}\n\n    iex> Funx.Monad.Either.from_result({:error, \"error\"})\n    %Funx.Monad.Either.Left{left: \"error\"}","ref":"Funx.Monad.Either.html#from_result/1-examples"},{"type":"function","title":"Funx.Monad.Either.from_try/1","doc":"Wraps a value in an `Either`, catching any exceptions. If an exception occurs, a `Left` is returned with the exception.","ref":"Funx.Monad.Either.html#from_try/1"},{"type":"function","title":"Examples - Funx.Monad.Either.from_try/1","doc":"iex> Funx.Monad.Either.from_try(fn -> 5 end)\n    %Funx.Monad.Either.Right{right: 5}\n\n    iex> Funx.Monad.Either.from_try(fn -> raise \"error\" end)\n    %Funx.Monad.Either.Left{left: %RuntimeError{message: \"error\"}}","ref":"Funx.Monad.Either.html#from_try/1-examples"},{"type":"function","title":"Funx.Monad.Either.get_or_else/2","doc":"Retrieves the value from a `Right`, returning the `default` value if `Left`.","ref":"Funx.Monad.Either.html#get_or_else/2"},{"type":"function","title":"Examples - Funx.Monad.Either.get_or_else/2","doc":"iex> Funx.Monad.Either.get_or_else(Funx.Monad.Either.right(5), 0)\n    5\n\n    iex> Funx.Monad.Either.get_or_else(Funx.Monad.Either.left(\"error\"), 0)\n    0","ref":"Funx.Monad.Either.html#get_or_else/2-examples"},{"type":"function","title":"Funx.Monad.Either.left/1","doc":"Wraps a value in the `Left` monad.","ref":"Funx.Monad.Either.html#left/1"},{"type":"function","title":"Examples - Funx.Monad.Either.left/1","doc":"iex> Funx.Monad.Either.left(\"error\")\n    %Funx.Monad.Either.Left{left: \"error\"}","ref":"Funx.Monad.Either.html#left/1-examples"},{"type":"function","title":"Funx.Monad.Either.left?/1","doc":"Returns `true` if the `Either` is a `Left` value.","ref":"Funx.Monad.Either.html#left?/1"},{"type":"function","title":"Examples - Funx.Monad.Either.left?/1","doc":"iex> Funx.Monad.Either.left?(Funx.Monad.Either.left(\"error\"))\n    true\n\n    iex> Funx.Monad.Either.left?(Funx.Monad.Either.right(5))\n    false","ref":"Funx.Monad.Either.html#left?/1-examples"},{"type":"function","title":"Funx.Monad.Either.lift_eq/1","doc":"Lifts an equality function to compare `Either` values:\n  - `Right` vs `Right`: Uses the custom equality function.\n  - `Left` vs `Left`: Uses the custom equality function.\n  - `Left` vs `Right` or vice versa: Always `false`.","ref":"Funx.Monad.Either.html#lift_eq/1"},{"type":"function","title":"Examples - Funx.Monad.Either.lift_eq/1","doc":"iex> eq = Funx.Monad.Either.lift_eq(%{\n    ...>   eq?: fn x, y -> x == y end,\n    ...>   not_eq?: fn x, y -> x != y end\n    ...> })\n    iex> eq.eq?.(Funx.Monad.Either.right(5), Funx.Monad.Either.right(5))\n    true\n    iex> eq.eq?.(Funx.Monad.Either.right(5), Funx.Monad.Either.right(10))\n    false\n    iex> eq.eq?.(Funx.Monad.Either.left(:a), Funx.Monad.Either.left(:a))\n    true\n    iex> eq.eq?.(Funx.Monad.Either.left(:a), Funx.Monad.Either.left(:b))\n    false\n    iex> eq.eq?.(Funx.Monad.Either.right(5), Funx.Monad.Either.left(:a))\n    false","ref":"Funx.Monad.Either.html#lift_eq/1-examples"},{"type":"function","title":"Funx.Monad.Either.lift_maybe/2","doc":"Converts a `Maybe` value to an `Either`. If the `Maybe` is `Nothing`, a `Left` is returned using `on_none`.","ref":"Funx.Monad.Either.html#lift_maybe/2"},{"type":"function","title":"Examples - Funx.Monad.Either.lift_maybe/2","doc":"iex> Funx.Monad.Either.lift_maybe(Funx.Monad.Maybe.just(5), fn -> \"error\" end)\n    %Funx.Monad.Either.Right{right: 5}\n\n    iex> Funx.Monad.Either.lift_maybe(Funx.Monad.Maybe.nothing(), fn -> \"error\" end)\n    %Funx.Monad.Either.Left{left: \"error\"}","ref":"Funx.Monad.Either.html#lift_maybe/2-examples"},{"type":"function","title":"Funx.Monad.Either.lift_ord/1","doc":"Creates a custom ordering function for `Either` values using the provided `custom_ord`.\n\nThe `custom_ord` must be a map with `:lt?`, `:le?`, `:gt?`, and `:ge?` functions. These are used to compare the internal `left` or `right` values.","ref":"Funx.Monad.Either.html#lift_ord/1"},{"type":"function","title":"Examples - Funx.Monad.Either.lift_ord/1","doc":"iex> ord = Funx.Monad.Either.lift_ord(%{\n    ...>   lt?: fn x, y -> x     le?: fn x, y -> x <= y end,\n    ...>   gt?: fn x, y -> x > y end,\n    ...>   ge?: fn x, y -> x >= y end\n    ...> })\n    iex> ord.lt?.(Funx.Monad.Either.right(3), Funx.Monad.Either.right(5))\n    true\n    iex> ord.lt?.(Funx.Monad.Either.left(3), Funx.Monad.Either.right(5))\n    true\n    iex> ord.lt?.(Funx.Monad.Either.right(3), Funx.Monad.Either.left(5))\n    false\n    iex> ord.lt?.(Funx.Monad.Either.left(3), Funx.Monad.Either.left(5))\n    true","ref":"Funx.Monad.Either.html#lift_ord/1-examples"},{"type":"function","title":"Funx.Monad.Either.lift_predicate/3","doc":"Lifts a value into an `Either` based on the result of a predicate.\n\nReturns `Right(value)` if the predicate returns `true`, or `Left(on_false.(value))` if it returns `false`.\n\nThis allows you to wrap a conditional check in a functional context with a custom error message.","ref":"Funx.Monad.Either.html#lift_predicate/3"},{"type":"function","title":"Examples - Funx.Monad.Either.lift_predicate/3","doc":"iex> Funx.Monad.Either.lift_predicate(5, fn x -> x > 3 end, fn x -> \"#{x} is too small\" end)\n    %Funx.Monad.Either.Right{right: 5}\n\n    iex> Funx.Monad.Either.lift_predicate(2, fn x -> x > 3 end, fn x -> \"#{x} is too small\" end)\n    %Funx.Monad.Either.Left{left: \"2 is too small\"}","ref":"Funx.Monad.Either.html#lift_predicate/3-examples"},{"type":"function","title":"Funx.Monad.Either.map_left/2","doc":"Transforms the `Left` value using the given function if the `Either` is a `Left`.\nIf the value is `Right`, it is returned unchanged.","ref":"Funx.Monad.Either.html#map_left/2"},{"type":"function","title":"Examples - Funx.Monad.Either.map_left/2","doc":"iex> Funx.Monad.Either.map_left(Funx.Monad.Either.left(\"error\"), fn e -> \"wrapped: \" <> e end)\n    %Funx.Monad.Either.Left{left: \"wrapped: error\"}\n\n    iex> Funx.Monad.Either.map_left(Funx.Monad.Either.right(42), fn _ -> \"ignored\" end)\n    %Funx.Monad.Either.Right{right: 42}","ref":"Funx.Monad.Either.html#map_left/2-examples"},{"type":"function","title":"Funx.Monad.Either.or_else/2","doc":"Returns the current `Right` value or invokes the `fallback_fun` if `Left`.\n\nUseful for recovering from a failure by providing an alternate computation.","ref":"Funx.Monad.Either.html#or_else/2"},{"type":"function","title":"Examples - Funx.Monad.Either.or_else/2","doc":"iex> Funx.Monad.Either.or_else(Funx.Monad.Either.left(\"error\"), fn -> Funx.Monad.Either.right(42) end)\n    %Funx.Monad.Either.Right{right: 42}\n\n    iex> Funx.Monad.Either.or_else(Funx.Monad.Either.right(10), fn -> Funx.Monad.Either.right(42) end)\n    %Funx.Monad.Either.Right{right: 10}","ref":"Funx.Monad.Either.html#or_else/2-examples"},{"type":"function","title":"Funx.Monad.Either.pure/1","doc":"Alias for `right/1`.","ref":"Funx.Monad.Either.html#pure/1"},{"type":"function","title":"Examples - Funx.Monad.Either.pure/1","doc":"iex> Funx.Monad.Either.pure(2)\n    %Funx.Monad.Either.Right{right: 2}","ref":"Funx.Monad.Either.html#pure/1-examples"},{"type":"function","title":"Funx.Monad.Either.right/1","doc":"Wraps a value in the `Right` monad.","ref":"Funx.Monad.Either.html#right/1"},{"type":"function","title":"Examples - Funx.Monad.Either.right/1","doc":"iex> Funx.Monad.Either.right(5)\n    %Funx.Monad.Either.Right{right: 5}","ref":"Funx.Monad.Either.html#right/1-examples"},{"type":"function","title":"Funx.Monad.Either.right?/1","doc":"Returns `true` if the `Either` is a `Right` value.","ref":"Funx.Monad.Either.html#right?/1"},{"type":"function","title":"Examples - Funx.Monad.Either.right?/1","doc":"iex> Funx.Monad.Either.right?(Funx.Monad.Either.right(5))\n    true\n\n    iex> Funx.Monad.Either.right?(Funx.Monad.Either.left(\"error\"))\n    false","ref":"Funx.Monad.Either.html#right?/1-examples"},{"type":"function","title":"Funx.Monad.Either.sequence/1","doc":"Sequences a list of `Either` values into an `Either` of a list.","ref":"Funx.Monad.Either.html#sequence/1"},{"type":"function","title":"Examples - Funx.Monad.Either.sequence/1","doc":"iex> Funx.Monad.Either.sequence([Funx.Monad.Either.right(1), Funx.Monad.Either.right(2)])\n    %Funx.Monad.Either.Right{right: [1, 2]}\n\n    iex> Funx.Monad.Either.sequence([Funx.Monad.Either.right(1), Funx.Monad.Either.left(\"error\")])\n    %Funx.Monad.Either.Left{left: \"error\"}","ref":"Funx.Monad.Either.html#sequence/1-examples"},{"type":"function","title":"Funx.Monad.Either.sequence_a/1","doc":"Sequences a list of `Either` values, collecting all errors from `Left` values, rather than short-circuiting.","ref":"Funx.Monad.Either.html#sequence_a/1"},{"type":"function","title":"Examples - Funx.Monad.Either.sequence_a/1","doc":"iex> Funx.Monad.Either.sequence_a([Funx.Monad.Either.right(1), Funx.Monad.Either.left(\"error\"), Funx.Monad.Either.left(\"another error\")])\n    %Funx.Monad.Either.Left{left: [\"error\", \"another error\"]}","ref":"Funx.Monad.Either.html#sequence_a/1-examples"},{"type":"function","title":"Funx.Monad.Either.to_result/1","doc":"Converts an `Either` to a result (`{:ok, value}` or `{:error, reason}`).","ref":"Funx.Monad.Either.html#to_result/1"},{"type":"function","title":"Examples - Funx.Monad.Either.to_result/1","doc":"iex> Funx.Monad.Either.to_result(Funx.Monad.Either.right(5))\n    {:ok, 5}\n\n    iex> Funx.Monad.Either.to_result(Funx.Monad.Either.left(\"error\"))\n    {:error, \"error\"}","ref":"Funx.Monad.Either.html#to_result/1-examples"},{"type":"function","title":"Funx.Monad.Either.to_try!/1","doc":"Converts an `Either` to its inner value, raising an exception if it is `Left`.\n\nIf the `Left` holds an exception struct, it is raised directly. If it holds a string or list of errors, they are converted into a `RuntimeError`. Unexpected types are inspected and raised as a `RuntimeError`.","ref":"Funx.Monad.Either.html#to_try!/1"},{"type":"function","title":"Examples - Funx.Monad.Either.to_try!/1","doc":"iex> Funx.Monad.Either.to_try!(Funx.Monad.Either.right(5))\n    5\n\n    iex> Funx.Monad.Either.to_try!(Funx.Monad.Either.left(\"error\"))\n    ** (RuntimeError) error\n\n    iex> Funx.Monad.Either.to_try!(Funx.Monad.Either.left([\"error 1\", \"error 2\"]))\n    ** (RuntimeError) error 1, error 2\n\n    iex> Funx.Monad.Either.to_try!(Funx.Monad.Either.left(%ArgumentError{message: \"bad argument\"}))\n    ** (ArgumentError) bad argument","ref":"Funx.Monad.Either.html#to_try!/1-examples"},{"type":"function","title":"Funx.Monad.Either.traverse/2","doc":"Traverses a list, applying the given function to each element and collecting the results in a single `Right`, or short-circuiting with the first `Left`.\n\nThis is useful for validating or transforming a list of values where each step may fail.","ref":"Funx.Monad.Either.html#traverse/2"},{"type":"function","title":"Examples - Funx.Monad.Either.traverse/2","doc":"iex> Funx.Monad.Either.traverse([1, 2, 3], &Funx.Monad.Either.right/1)\n    %Funx.Monad.Either.Right{right: [1, 2, 3]}\n\n    iex> Funx.Monad.Either.traverse([1, -2, 3], fn x -> if x > 0, do: Funx.Monad.Either.right(x), else: Funx.Monad.Either.left(\"error\") end)\n    %Funx.Monad.Either.Left{left: \"error\"}","ref":"Funx.Monad.Either.html#traverse/2-examples"},{"type":"function","title":"Funx.Monad.Either.traverse_a/2","doc":"Traverses a list, applying the given function to each element and collecting the results in a single `Right`.\n\nUnlike `traverse/2`, this version accumulates all `Left` values rather than stopping at the first failure.\nIt is useful for validations where you want to gather all errors at once.","ref":"Funx.Monad.Either.html#traverse_a/2"},{"type":"function","title":"Examples - Funx.Monad.Either.traverse_a/2","doc":"iex> validate = fn x -> Funx.Monad.Either.lift_predicate(x, &(&1 > 0), fn v -> \"must be positive: #{v}\" end) end\n    iex> Funx.Monad.Either.traverse_a([1, 2, 3], validate)\n    %Funx.Monad.Either.Right{right: [1, 2, 3]}\n    iex> Funx.Monad.Either.traverse_a([1, -2, -3], validate)\n    %Funx.Monad.Either.Left{left: [\"must be positive: -2\", \"must be positive: -3\"]}","ref":"Funx.Monad.Either.html#traverse_a/2-examples"},{"type":"function","title":"Funx.Monad.Either.validate/2","doc":"Validates a value using a list of validator functions. Each validator returns an `Either.Right` if\nthe check passes, or an `Either.Left` with an error message if it fails. If any validation fails,\nall errors are aggregated and returned in a single `Left`.","ref":"Funx.Monad.Either.html#validate/2"},{"type":"function","title":"Flat list aggregation - Funx.Monad.Either.validate/2","doc":"When using the default aggregation strategy, errors are collected in a plain list:\n\n```elixir\nvalidate_positive = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(&1 > 0), fn v -> \"Value must be positive: \" <> to_string(v) end)\nend\n\nvalidate_even = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(rem(&1, 2) == 0), fn v -> \"Value must be even: \" <> to_string(v) end)\nend\n\nFunx.Monad.Either.validate(4, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Right{right: 4}\n\nFunx.Monad.Either.validate(3, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Left{left: [\"Value must be even: 3\"]}\n\nFunx.Monad.Either.validate(-3, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Left{left: [\"Value must be positive: -3\", \"Value must be even: -3\"]}\n```","ref":"Funx.Monad.Either.html#validate/2-flat-list-aggregation"},{"type":"function","title":"Structured aggregation with `ValidationError` - Funx.Monad.Either.validate/2","doc":"You can also use a custom struct to hold errors. This example uses `ValidationError` and a corresponding\n`Funx.Semigroup` implementation to accumulate errors into a single structure:\n\n```elixir\nalias Funx.Errors.ValidationError\n\nvalidate_positive = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(&1 > 0), fn v -> \"Value must be positive: \" <> to_string(v) end)\n  |> Funx.Monad.Either.map_left(&ValidationError.new/1)\nend\n\nvalidate_even = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(rem(&1, 2) == 0), fn v -> \"Value must be even: \" <> to_string(v) end)\n  |> Funx.Monad.Either.map_left(&ValidationError.new/1)\nend\n\nFunx.Monad.Either.validate(-3, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Left{\n#     left: %ValidationError{\n#       errors: [\"Value must be positive: -3\", \"Value must be even: -3\"]\n#     }\n#   }\n```","ref":"Funx.Monad.Either.html#validate/2-structured-aggregation-with-validationerror"},{"type":"function","title":"Funx.Monad.Either.wither_a/2","doc":"Traverses a list, applying the given function to each element, and collects the successful `Just` results into a single `Right`.\n\nThe given function must return an `Either` of `Maybe`. `Right(Just x)` values are kept; `Right(Nothing)` values are filtered out.\nIf any application returns `Left`, all `Left` values are accumulated.\n\nThis is useful for effectful filtering, where you want to validate or transform elements and conditionally keep them, while still reporting all errors.","ref":"Funx.Monad.Either.html#wither_a/2"},{"type":"function","title":"Examples - Funx.Monad.Either.wither_a/2","doc":"iex> filter_positive = fn x ->\n    ...>   Funx.Monad.Either.lift_predicate(x, &is_integer/1, fn v -> \"not an integer: #{inspect(v)}\" end)\n    ...>   |> Funx.Monad.map(fn x -> if x > 0, do: Funx.Monad.Maybe.just(x), else: Funx.Monad.Maybe.nothing() end)\n    ...> end\n    iex> Funx.Monad.Either.wither_a([1, -2, 3], filter_positive)\n    %Funx.Monad.Either.Right{right: [1, 3]}\n    iex> Funx.Monad.Either.wither_a([\"oops\", -2], filter_positive)\n    %Funx.Monad.Either.Left{left: [\"not an integer: \\\"oops\\\"\"]}","ref":"Funx.Monad.Either.html#wither_a/2-examples"},{"type":"type","title":"Funx.Monad.Either.t/2","doc":"","ref":"Funx.Monad.Either.html#t:t/2"},{"type":"module","title":"Funx.Monad.Either.Left","doc":"Represents the `Left` variant of the `Either` monad, used to model an error or failure.\n\nThis module implements the following protocols:\n  - `Funx.Eq`: Defines equality checks between `Left` and other `Either` values.\n  - `Funx.Foldable`: Provides `fold_l/3` and `fold_r/3` to handle folding for `Left` values.\n  - `Funx.Monad`: Implements the `bind/2`, `map/2`, and `ap/2` functions for monadic operations.\n  - `Funx.Ord`: Defines ordering logic for `Left` and `Right` values.\n\nThe `Left` monad propagates the wrapped error through operations without executing the success logic.","ref":"Funx.Monad.Either.Left.html"},{"type":"function","title":"Funx.Monad.Either.Left.pure/1","doc":"Creates a new `Left` value.\n\nThe `pure/1` function wraps a value in the `Left` monad, representing an error or failure.","ref":"Funx.Monad.Either.Left.html#pure/1"},{"type":"function","title":"Examples - Funx.Monad.Either.Left.pure/1","doc":"iex> Funx.Monad.Either.Left.pure(\"error\")\n    %Funx.Monad.Either.Left{left: \"error\"}","ref":"Funx.Monad.Either.Left.html#pure/1-examples"},{"type":"type","title":"Funx.Monad.Either.Left.t/1","doc":"","ref":"Funx.Monad.Either.Left.html#t:t/1"},{"type":"module","title":"Funx.Monad.Either.Right","doc":"Represents the `Right` variant of the `Either` monad, used to model a success or valid result.\n\nThis module implements the following protocols:\n  - `Funx.Eq`: Defines equality checks between `Right` and other `Either` values.\n  - `Funx.Foldable`: Provides `fold_l/3` and `fold_r/3` to handle folding for `Right` values.\n  - `Funx.Monad`: Implements the `bind/2`, `map/2`, and `ap/2` functions for monadic operations.\n  - `Funx.Ord`: Defines ordering logic for `Right` and `Left` values.\n\nThe `Right` monad represents a valid result, and the contained value is propagated through operations.","ref":"Funx.Monad.Either.Right.html"},{"type":"function","title":"Funx.Monad.Either.Right.pure/1","doc":"Creates a new `Right` value.\n\nThe `pure/1` function wraps a value in the `Right` monad, representing a valid result.","ref":"Funx.Monad.Either.Right.html#pure/1"},{"type":"function","title":"Examples - Funx.Monad.Either.Right.pure/1","doc":"iex> Funx.Monad.Either.Right.pure(5)\n    %Funx.Monad.Either.Right{right: 5}","ref":"Funx.Monad.Either.Right.html#pure/1-examples"},{"type":"type","title":"Funx.Monad.Either.Right.t/1","doc":"","ref":"Funx.Monad.Either.Right.html#t:t/1"},{"type":"module","title":"Funx.Monad.Identity","doc":"The `Funx.Monad.Identity` module represents the identity monad, where values are simply wrapped in a structure\nand operations are applied directly to those values.\n\nThis module implements the following protocols:\n  - `Funx.Monad`: Implements the `bind/2`, `map/2`, and `ap/2` functions for monadic operations.\n  - `Funx.Eq`: Defines equality checks for `Identity` values.\n  - `Funx.Ord`: Defines ordering logic for `Identity` values.\n  - `String.Chars`: Converts an `Identity` value into a string representation.","ref":"Funx.Monad.Identity.html"},{"type":"function","title":"Funx.Monad.Identity.extract/1","doc":"Extracts the value from an `Identity`.","ref":"Funx.Monad.Identity.html#extract/1"},{"type":"function","title":"Examples - Funx.Monad.Identity.extract/1","doc":"iex> Funx.Monad.Identity.extract(Funx.Monad.Identity.pure(5))\n    5","ref":"Funx.Monad.Identity.html#extract/1-examples"},{"type":"function","title":"Funx.Monad.Identity.lift_eq/1","doc":"","ref":"Funx.Monad.Identity.html#lift_eq/1"},{"type":"function","title":"Funx.Monad.Identity.lift_ord/1","doc":"","ref":"Funx.Monad.Identity.html#lift_ord/1"},{"type":"function","title":"Funx.Monad.Identity.pure/1","doc":"Creates a new `Identity` value by wrapping a given value.","ref":"Funx.Monad.Identity.html#pure/1"},{"type":"function","title":"Examples - Funx.Monad.Identity.pure/1","doc":"iex> Funx.Monad.Identity.pure(5)\n    %Funx.Monad.Identity{value: 5}","ref":"Funx.Monad.Identity.html#pure/1-examples"},{"type":"type","title":"Funx.Monad.Identity.t/1","doc":"","ref":"Funx.Monad.Identity.html#t:t/1"},{"type":"module","title":"Funx.Monad.Maybe","doc":"The `Funx.Monad.Maybe` module provides an implementation of the `Maybe` monad, a functional abstraction used to represent optional values in Elixir.\n\nA `Maybe` represents one of two possibilities:\n\n  - `Just(value)`: the presence of a value\n  - `Nothing`: the absence of a value\n\nThis pattern is useful for eliminating `nil` checks and handling missing data explicitly and safely in functional pipelines.","ref":"Funx.Monad.Maybe.html"},{"type":"module","title":"Constructors - Funx.Monad.Maybe","doc":"- `just/1`: Wraps a value in the `Just` variant.\n  - `nothing/0`: Returns a `Nothing` value.\n  - `pure/1`: Alias for `just/1`.","ref":"Funx.Monad.Maybe.html#module-constructors"},{"type":"module","title":"Refinement - Funx.Monad.Maybe","doc":"- `just?/1`: Returns `true` if the value is a `Just`.\n  - `nothing?/1`: Returns `true` if the value is a `Nothing`.","ref":"Funx.Monad.Maybe.html#module-refinement"},{"type":"module","title":"Fallback and Extraction - Funx.Monad.Maybe","doc":"- `get_or_else/2`: Returns the value from a `Just`, or a default if `Nothing`.\n  - `or_else/2`: Returns the original `Just`, or invokes a fallback function if `Nothing`.","ref":"Funx.Monad.Maybe.html#module-fallback-and-extraction"},{"type":"module","title":"List Operations - Funx.Monad.Maybe","doc":"- `concat/1`: Removes all `Nothing` values and unwraps the `Just` values from a list.\n  - `concat_map/2`: Applies a function and collects only `Just` results.\n  - `sequence/1`: Converts a list of `Maybe` values into a single `Maybe` of list.\n  - `traverse/2`: Applies a function to each element in a list and sequences the results.","ref":"Funx.Monad.Maybe.html#module-list-operations"},{"type":"module","title":"Lifting - Funx.Monad.Maybe","doc":"- `lift_predicate/2`: Converts a value to `Just` if it meets a predicate, otherwise `Nothing`.\n  - `lift_identity/1`: Converts an `Identity` to a `Maybe`.\n  - `lift_either/1`: Converts an `Either` to a `Maybe`.\n  - `lift_eq/1`: Lifts an equality function for use in the `Maybe` context.\n  - `lift_ord/1`: Lifts an ordering function for use in the `Maybe` context.","ref":"Funx.Monad.Maybe.html#module-lifting"},{"type":"module","title":"Elixir Interoperability - Funx.Monad.Maybe","doc":"- `from_nil/1`: Converts `nil` to `Nothing`, otherwise wraps the value in `Just`.\n  - `to_nil/1`: Returns the underlying value or `nil`.\n  - `from_result/1`: Converts `{:ok, val}` or `{:error, _}` into a `Maybe`.\n  - `to_result/1`: Converts a `Maybe` to a result tuple.\n  - `from_try/1`: Runs a function and returns `Just` on success, or `Nothing` if an exception is raised.\n  - `to_try!/2`: Unwraps a `Just`, or raises an error if `Nothing`.","ref":"Funx.Monad.Maybe.html#module-elixir-interoperability"},{"type":"module","title":"Protocols - Funx.Monad.Maybe","doc":"The `Just` and `Nothing` structs implement the following protocols, making the `Maybe` abstraction composable and extensible:\n\n  - `Funx.Eq`: Enables equality comparisons between `Maybe` values.\n  - `Funx.Foldable`: Implements `fold_l/3` and `fold_r/3` for reducing over the value or fallback.\n  - `Funx.Filterable`: Supports conditional retention with `filter/2`, `guard/2`, and `filter_map/2`.\n  - `Funx.Monad`: Provides `map/2`, `ap/2`, and `bind/2` for monadic composition.\n  - `Funx.Ord`: Defines ordering behavior between `Just` and `Nothing` values.\n\nAlthough these implementations are defined per constructor (`Just` and `Nothing`), the behavior is consistent across the `Maybe` abstraction.\n\nThis module helps you represent optional data explicitly, structure conditional logic safely, and eliminate reliance on `nil` in functional pipelines.","ref":"Funx.Monad.Maybe.html#module-protocols"},{"type":"function","title":"Funx.Monad.Maybe.concat/1","doc":"Removes `Nothing` values from a list of `Maybe` and returns a list of unwrapped `Just` values.","ref":"Funx.Monad.Maybe.html#concat/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.concat/1","doc":"iex> Funx.Monad.Maybe.concat([Funx.Monad.Maybe.pure(1), Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.pure(2)])\n    [1, 2]\n\n    iex> Funx.Monad.Maybe.concat([Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.nothing()])\n    []\n\n    iex> Funx.Monad.Maybe.concat([Funx.Monad.Maybe.pure(\"a\"), Funx.Monad.Maybe.pure(\"b\"), Funx.Monad.Maybe.pure(\"c\")])\n    [\"a\", \"b\", \"c\"]","ref":"Funx.Monad.Maybe.html#concat/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.concat_map/2","doc":"Maps a function over a list, collecting unwrapped `Just` values and ignoring `Nothing` in a single pass.","ref":"Funx.Monad.Maybe.html#concat_map/2"},{"type":"function","title":"Examples - Funx.Monad.Maybe.concat_map/2","doc":"iex> Funx.Monad.Maybe.concat_map([1, 2, 3, 4], fn x ->\n    ...>   if rem(x, 2) == 0, do: Funx.Monad.Maybe.pure(x), else: Funx.Monad.Maybe.nothing()\n    ...> end)\n    [2, 4]\n\n    iex> Funx.Monad.Maybe.concat_map([1, nil, 3], fn\n    ...>   nil -> Funx.Monad.Maybe.nothing()\n    ...>   x -> Funx.Monad.Maybe.pure(x * 2)\n    ...> end)\n    [2, 6]\n\n    iex> Funx.Monad.Maybe.concat_map([1, 2, 3], fn x -> Funx.Monad.Maybe.pure(x + 1) end)\n    [2, 3, 4]\n\n    iex> Funx.Monad.Maybe.concat_map([], fn x -> Funx.Monad.Maybe.pure(x) end)\n    []","ref":"Funx.Monad.Maybe.html#concat_map/2-examples"},{"type":"function","title":"Funx.Monad.Maybe.from_nil/1","doc":"Converts `nil` to `Nothing`; any other value becomes `Just`.","ref":"Funx.Monad.Maybe.html#from_nil/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.from_nil/1","doc":"iex> Funx.Monad.Maybe.from_nil(nil)\n    %Funx.Monad.Maybe.Nothing{}\n\n    iex> Funx.Monad.Maybe.from_nil(5)\n    %Funx.Monad.Maybe.Just{value: 5}","ref":"Funx.Monad.Maybe.html#from_nil/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.from_result/1","doc":"Converts a result tuple to a `Maybe`. `{:ok, value}` becomes `Just(value)`, while `{:error, _}` becomes `Nothing`.","ref":"Funx.Monad.Maybe.html#from_result/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.from_result/1","doc":"iex> Funx.Monad.Maybe.from_result({:ok, 5})\n    %Funx.Monad.Maybe.Just{value: 5}\n\n    iex> Funx.Monad.Maybe.from_result({:error, :something})\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Monad.Maybe.html#from_result/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.from_try/1","doc":"Executes a function within a `Maybe` context, returning `Nothing` if an exception occurs.","ref":"Funx.Monad.Maybe.html#from_try/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.from_try/1","doc":"iex> Funx.Monad.Maybe.from_try(fn -> 5 end)\n    %Funx.Monad.Maybe.Just{value: 5}\n\n    iex> Funx.Monad.Maybe.from_try(fn -> raise \"error\" end)\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Monad.Maybe.html#from_try/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.get_or_else/2","doc":"Retrieves the value from a `Maybe`, returning `default` if `Nothing`.","ref":"Funx.Monad.Maybe.html#get_or_else/2"},{"type":"function","title":"Examples - Funx.Monad.Maybe.get_or_else/2","doc":"iex> Funx.Monad.Maybe.get_or_else(Funx.Monad.Maybe.just(5), 0)\n    5\n\n    iex> Funx.Monad.Maybe.get_or_else(Funx.Monad.Maybe.nothing(), 0)\n    0","ref":"Funx.Monad.Maybe.html#get_or_else/2-examples"},{"type":"function","title":"Funx.Monad.Maybe.just/1","doc":"Wraps a value in `Just`.","ref":"Funx.Monad.Maybe.html#just/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.just/1","doc":"iex> Funx.Monad.Maybe.just(2)\n    %Funx.Monad.Maybe.Just{value: 2}","ref":"Funx.Monad.Maybe.html#just/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.just?/1","doc":"Returns `true` if the `Maybe` is `Just`, otherwise `false`.","ref":"Funx.Monad.Maybe.html#just?/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.just?/1","doc":"iex> Funx.Monad.Maybe.just?(Funx.Monad.Maybe.just(5))\n    true\n\n    iex> Funx.Monad.Maybe.just?(Funx.Monad.Maybe.nothing())\n    false","ref":"Funx.Monad.Maybe.html#just?/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.lift_either/1","doc":"Converts an `Either` to a `Maybe`. `Right` becomes `Just`, and `Left` becomes `Nothing`.","ref":"Funx.Monad.Maybe.html#lift_either/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.lift_either/1","doc":"iex> Funx.Monad.Maybe.lift_either(Funx.Monad.Either.right(5))\n    %Funx.Monad.Maybe.Just{value: 5}\n\n    iex> Funx.Monad.Maybe.lift_either(Funx.Monad.Either.left(\"Error\"))\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Monad.Maybe.html#lift_either/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.lift_eq/1","doc":"Lifts an equality function to compare `Maybe` values:\n  - `Just` vs `Just`: Uses the custom equality function.\n  - `Nothing` vs `Nothing`: Always `true`.\n  - `Just` vs `Nothing` or vice versa: Always `false`.","ref":"Funx.Monad.Maybe.html#lift_eq/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.lift_eq/1","doc":"iex> eq = Funx.Monad.Maybe.lift_eq(%{\n    ...>   eq?: fn x, y -> x == y end,\n    ...>   not_eq?: fn x, y -> x != y end\n    ...> })\n    iex> eq.eq?.(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.just(5))\n    true\n    iex> eq.eq?.(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.just(10))\n    false\n    iex> eq.eq?.(Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.nothing())\n    true\n    iex> eq.eq?.(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.nothing())\n    false","ref":"Funx.Monad.Maybe.html#lift_eq/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.lift_identity/1","doc":"Converts an `Identity` value into a `Maybe`. If the value is `nil`, returns `Nothing`; otherwise `Just`.","ref":"Funx.Monad.Maybe.html#lift_identity/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.lift_identity/1","doc":"iex> Funx.Monad.Maybe.lift_identity(Funx.Monad.Identity.pure(5))\n    %Funx.Monad.Maybe.Just{value: 5}\n\n    iex> Funx.Monad.Maybe.lift_identity(Funx.Monad.Identity.pure(nil))\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Monad.Maybe.html#lift_identity/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.lift_ord/1","doc":"Adapts an ordering function to compare `Maybe` values:\n  - `Nothing` is considered less than any `Just`.\n  - Two `Just` values are compared by the provided function.","ref":"Funx.Monad.Maybe.html#lift_ord/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.lift_ord/1","doc":"iex> ord = Funx.Monad.Maybe.lift_ord(%{\n    ...>   lt?: &</2,\n    ...>   le?: &<=/2,\n    ...>   gt?: &>/2,\n    ...>   ge?: &>=/2\n    ...> })\n    iex> ord.lt?.(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(5))\n    true\n    iex> ord.lt?.(Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.just(5))\n    true","ref":"Funx.Monad.Maybe.html#lift_ord/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.lift_predicate/2","doc":"Lifts a value into `Maybe` based on a predicate. If `predicate.(value)` is `true`, returns `Just(value)`; otherwise `Nothing`.","ref":"Funx.Monad.Maybe.html#lift_predicate/2"},{"type":"function","title":"Examples - Funx.Monad.Maybe.lift_predicate/2","doc":"iex> Funx.Monad.Maybe.lift_predicate(5, fn x -> x > 3 end)\n    %Funx.Monad.Maybe.Just{value: 5}\n\n    iex> Funx.Monad.Maybe.lift_predicate(2, fn x -> x > 3 end)\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Monad.Maybe.html#lift_predicate/2-examples"},{"type":"function","title":"Funx.Monad.Maybe.nothing/0","doc":"Returns a `Nothing` value.","ref":"Funx.Monad.Maybe.html#nothing/0"},{"type":"function","title":"Examples - Funx.Monad.Maybe.nothing/0","doc":"iex> Funx.Monad.Maybe.nothing()\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Monad.Maybe.html#nothing/0-examples"},{"type":"function","title":"Funx.Monad.Maybe.nothing?/1","doc":"Returns `true` if the `Maybe` is `Nothing`, otherwise `false`.","ref":"Funx.Monad.Maybe.html#nothing?/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.nothing?/1","doc":"iex> Funx.Monad.Maybe.nothing?(Funx.Monad.Maybe.nothing())\n    true\n\n    iex> Funx.Monad.Maybe.nothing?(Funx.Monad.Maybe.just(5))\n    false","ref":"Funx.Monad.Maybe.html#nothing?/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.or_else/2","doc":"Returns the current `Just` value or invokes the `fallback_fun` if `Nothing`.","ref":"Funx.Monad.Maybe.html#or_else/2"},{"type":"function","title":"Examples - Funx.Monad.Maybe.or_else/2","doc":"iex> Funx.Monad.Maybe.or_else(Funx.Monad.Maybe.nothing(), fn -> Funx.Monad.Maybe.just(42) end)\n    %Funx.Monad.Maybe.Just{value: 42}\n\n    iex> Funx.Monad.Maybe.or_else(Funx.Monad.Maybe.just(10), fn -> Funx.Monad.Maybe.just(42) end)\n    %Funx.Monad.Maybe.Just{value: 10}","ref":"Funx.Monad.Maybe.html#or_else/2-examples"},{"type":"function","title":"Funx.Monad.Maybe.pure/1","doc":"Alias for `just/1`.","ref":"Funx.Monad.Maybe.html#pure/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.pure/1","doc":"iex> Funx.Monad.Maybe.pure(5)\n    %Funx.Monad.Maybe.Just{value: 5}","ref":"Funx.Monad.Maybe.html#pure/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.sequence/1","doc":"Converts a list of `Maybe` values into a `Maybe` containing a list. If any element is `Nothing`, the entire result is `Nothing`.","ref":"Funx.Monad.Maybe.html#sequence/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.sequence/1","doc":"iex> Funx.Monad.Maybe.sequence([Funx.Monad.Maybe.just(1), Funx.Monad.Maybe.just(2)])\n    %Funx.Monad.Maybe.Just{value: [1, 2]}\n\n    iex> Funx.Monad.Maybe.sequence([Funx.Monad.Maybe.just(1), Funx.Monad.Maybe.nothing()])\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Monad.Maybe.html#sequence/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.to_nil/1","doc":"Converts a `Maybe` to its wrapped value or `nil`.","ref":"Funx.Monad.Maybe.html#to_nil/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.to_nil/1","doc":"iex> Funx.Monad.Maybe.to_nil(Funx.Monad.Maybe.just(5))\n    5\n\n    iex> Funx.Monad.Maybe.to_nil(Funx.Monad.Maybe.nothing())\n    nil","ref":"Funx.Monad.Maybe.html#to_nil/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.to_predicate/1","doc":"Returns `true` if the given `Maybe` is a `Just`, or `false` if it is `Nothing`.\n\nThis provides a simple way to treat a `Maybe` as a boolean condition, useful when filtering or making branching decisions based on presence.","ref":"Funx.Monad.Maybe.html#to_predicate/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.to_predicate/1","doc":"iex> Funx.Monad.Maybe.to_predicate(Funx.Monad.Maybe.just(42))\n    true\n\n    iex> Funx.Monad.Maybe.to_predicate(Funx.Monad.Maybe.nothing())\n    false\n\nRaises an error if the input is not a `Just` or `Nothing`.","ref":"Funx.Monad.Maybe.html#to_predicate/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.to_result/1","doc":"Converts a `Maybe` to a result tuple. `Just(value)` becomes `{:ok, value}`, while `Nothing` becomes `{:error, :nothing}`.","ref":"Funx.Monad.Maybe.html#to_result/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.to_result/1","doc":"iex> Funx.Monad.Maybe.to_result(Funx.Monad.Maybe.just(5))\n    {:ok, 5}\n\n    iex> Funx.Monad.Maybe.to_result(Funx.Monad.Maybe.nothing())\n    {:error, :nothing}","ref":"Funx.Monad.Maybe.html#to_result/1-examples"},{"type":"function","title":"Funx.Monad.Maybe.to_try!/2","doc":"Extracts a value from a `Maybe`, raising an exception if `Nothing`.","ref":"Funx.Monad.Maybe.html#to_try!/2"},{"type":"function","title":"Examples - Funx.Monad.Maybe.to_try!/2","doc":"iex> Funx.Monad.Maybe.to_try!(Funx.Monad.Maybe.just(5))\n    5\n\n    iex> Funx.Monad.Maybe.to_try!(Funx.Monad.Maybe.nothing(), \"No value found\")\n    ** (RuntimeError) No value found","ref":"Funx.Monad.Maybe.html#to_try!/2-examples"},{"type":"function","title":"Funx.Monad.Maybe.traverse/2","doc":"Applies a function to each element of a list, collecting results into a single `Maybe`. If any call returns `Nothing`, the operation halts and returns `Nothing`.","ref":"Funx.Monad.Maybe.html#traverse/2"},{"type":"function","title":"Examples - Funx.Monad.Maybe.traverse/2","doc":"iex> Funx.Monad.Maybe.traverse([1, 2], fn x -> Funx.Monad.Maybe.just(x * 2) end)\n    %Funx.Monad.Maybe.Just{value: [2, 4]}\n\n    iex> Funx.Monad.Maybe.traverse([1, nil, 3], fn\n    ...>   nil -> Funx.Monad.Maybe.nothing()\n    ...>   x -> Funx.Monad.Maybe.just(x * 2)\n    ...> end)\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Monad.Maybe.html#traverse/2-examples"},{"type":"type","title":"Funx.Monad.Maybe.t/1","doc":"","ref":"Funx.Monad.Maybe.html#t:t/1"},{"type":"module","title":"Funx.Monad.Maybe.Just","doc":"Represents the `Just` variant of the `Maybe` monad, used to model the presence of a value.\n\nA `Just` wraps a single value and participates in functional composition by propagating the contained value through monadic operations.\n\nThis module implements the following protocols:\n\n  - `Funx.Monad`: Implements `bind/2`, `map/2`, and `ap/2` for monadic composition.\n  - `Funx.Foldable`: Provides `fold_l/3` and `fold_r/3` to fold over the wrapped value.\n  - `Funx.Filterable`: Supports filtering with `filter/2`, `filter_map/2`, and `guard/2`.\n  - `Funx.Eq`: Enables equality checks between `Just` and other `Maybe` values.\n  - `Funx.Ord`: Defines ordering behavior between `Just` and `Nothing`.\n\nThese protocol implementations allow `Just` to participate in structured computation, validation, filtering, and comparison within the `Maybe` context.","ref":"Funx.Monad.Maybe.Just.html"},{"type":"function","title":"Funx.Monad.Maybe.Just.pure/1","doc":"Creates a new `Just` value.\n\nThe `pure/1` function wraps a value in the `Just` monad, representing the presence of the value.","ref":"Funx.Monad.Maybe.Just.html#pure/1"},{"type":"function","title":"Examples - Funx.Monad.Maybe.Just.pure/1","doc":"iex> Funx.Monad.Maybe.Just.pure(5)\n    %Funx.Monad.Maybe.Just{value: 5}","ref":"Funx.Monad.Maybe.Just.html#pure/1-examples"},{"type":"function","title":"Raises - Funx.Monad.Maybe.Just.pure/1","doc":"- `ArgumentError` if `nil` is provided.\n\n    iex> Funx.Monad.Maybe.Just.pure(nil)\n    ** (ArgumentError) Cannot wrap nil in a Just","ref":"Funx.Monad.Maybe.Just.html#pure/1-raises"},{"type":"type","title":"Funx.Monad.Maybe.Just.t/1","doc":"","ref":"Funx.Monad.Maybe.Just.html#t:t/1"},{"type":"module","title":"Funx.Monad.Maybe.Nothing","doc":"Represents the `Nothing` variant of the `Maybe` monad, used to model the absence of a value.\n\nA `Nothing` indicates that no value is present. All operations in the monad context simply propagate the absence, making `Nothing` an identity for failure or emptiness.\n\nThis module implements the following protocols:\n\n  - `Funx.Monad`: Implements `bind/2`, `map/2`, and `ap/2`, all of which return `Nothing`.\n  - `Funx.Foldable`: Provides `fold_l/3` and `fold_r/3`, invoking the fallback function when folding.\n  - `Funx.Filterable`: Supports filtering operations, which always return `Nothing`.\n  - `Funx.Eq`: Enables equality checks between `Nothing` and other `Maybe` values.\n  - `Funx.Ord`: Defines ordering behavior between `Nothing` and `Just`.\n\nThese implementations ensure that `Nothing` behaves consistently in functional composition, filtering, and comparison, treating absence as a stable and composable case.","ref":"Funx.Monad.Maybe.Nothing.html"},{"type":"function","title":"Funx.Monad.Maybe.Nothing.pure/0","doc":"Creates a new `Nothing` value.","ref":"Funx.Monad.Maybe.Nothing.html#pure/0"},{"type":"function","title":"Examples - Funx.Monad.Maybe.Nothing.pure/0","doc":"iex> Funx.Monad.Maybe.Nothing.pure()\n    %Funx.Monad.Maybe.Nothing{}","ref":"Funx.Monad.Maybe.Nothing.html#pure/0-examples"},{"type":"type","title":"Funx.Monad.Maybe.Nothing.t/0","doc":"","ref":"Funx.Monad.Maybe.Nothing.html#t:t/0"},{"type":"module","title":"Funx.Monad.Reader","doc":"The `Funx.Monad.Reader` module represents the Reader monad, which allows computations to access\nshared, read-only environment values.\n\nThis module defines core Reader functions:\n\n  * `pure/1` – Lifts a value into the Reader context.\n  * `run/2` – Executes the Reader with a given environment.\n  * `asks/1` – Extracts and transforms a value from the environment.\n  * `ask/0` – Extracts the full environment.\n\nThis module implements the following protocol:\n\n  * `Funx.Monad`: Implements `bind/2`, `map/2`, and `ap/2` for monadic composition.\n\nNote: The Reader monad does not implement `Eq` or `Ord`, since Readers are lazy— they do not actually contain a value until they are run. We only can compare the results of a Reader, not the Reader itself.","ref":"Funx.Monad.Reader.html"},{"type":"function","title":"Funx.Monad.Reader.ask/0","doc":"Extracts the value contained in the environment, making it available within the Reader context.","ref":"Funx.Monad.Reader.html#ask/0"},{"type":"function","title":"Examples - Funx.Monad.Reader.ask/0","doc":"iex> reader = Funx.Monad.Reader.ask()\n    iex> Funx.Monad.Reader.run(reader, %{foo: \"bar\"})\n    %{foo: \"bar\"}","ref":"Funx.Monad.Reader.html#ask/0-examples"},{"type":"function","title":"Funx.Monad.Reader.asks/1","doc":"Extracts and transforms the value contained in the environment, making it available within the Reader context.","ref":"Funx.Monad.Reader.html#asks/1"},{"type":"function","title":"Examples - Funx.Monad.Reader.asks/1","doc":"iex> reader = Funx.Monad.Reader.asks(fn env -> Map.get(env, :foo) end)\n    iex> Funx.Monad.Reader.run(reader, %{foo: \"bar\"})\n    \"bar\"","ref":"Funx.Monad.Reader.html#asks/1-examples"},{"type":"function","title":"Funx.Monad.Reader.pure/1","doc":"Lifts a value into the `Reader` context.","ref":"Funx.Monad.Reader.html#pure/1"},{"type":"function","title":"Examples - Funx.Monad.Reader.pure/1","doc":"iex> reader = Funx.Monad.Reader.pure(42)\n    iex> Funx.Monad.Reader.run(reader, %{})\n    42","ref":"Funx.Monad.Reader.html#pure/1-examples"},{"type":"function","title":"Funx.Monad.Reader.run/2","doc":"Runs the `Reader` with the provided environment, returning the computed value.","ref":"Funx.Monad.Reader.html#run/2"},{"type":"function","title":"Examples - Funx.Monad.Reader.run/2","doc":"iex> reader = Funx.Monad.Reader.pure(42)\n    iex> Funx.Monad.Reader.run(reader, %{})\n    42","ref":"Funx.Monad.Reader.html#run/2-examples"},{"type":"type","title":"Funx.Monad.Reader.t/2","doc":"","ref":"Funx.Monad.Reader.html#t:t/2"},{"type":"module","title":"Funx.Monad.Writer","doc":"The `Funx.Monad.Writer` module defines the Writer monad, which threads a log alongside a computed result.\n\nLogs are accumulated using a `Monoid` implementation, injected lazily at runtime. This makes the Writer monad flexible and monoid-polymorphic—supporting lists, strings, or any user-defined monoid.","ref":"Funx.Monad.Writer.html"},{"type":"module","title":"Core functions - Funx.Monad.Writer","doc":"* `pure/1` – Wraps a result with an empty log.\n  * `writer/1` – Wraps a result and an explicit log.\n  * `tell/1` – Emits a log with no result.\n  * `listen/1` – Returns both result and log as a pair.\n  * `censor/2` – Applies a function to transform the final log.\n  * `pass/1` – Uses a log-transforming function returned from within the computation.\n  * `run/2` – Executes the Writer and returns a `%Writer.Result{}` with result and log.\n  * `eval/2` – Executes and returns only the result.\n  * `exec/2` – Executes and returns only the log.\n\nBy default, the `ListConcat` monoid is used unless a different monoid is passed to `run`, `eval`, or `exec`.\n\nThis module also implements the `Funx.Monad` protocol.","ref":"Funx.Monad.Writer.html#module-core-functions"},{"type":"function","title":"Funx.Monad.Writer.censor/2","doc":"Transforms the final log by applying a function to it.\n\nThe result remains unchanged—only the log is modified.","ref":"Funx.Monad.Writer.html#censor/2"},{"type":"function","title":"Example - Funx.Monad.Writer.censor/2","doc":"iex> writer = Funx.Monad.Writer.writer({\"ok\", [:a, :b]})\n    iex> censored = Funx.Monad.Writer.censor(writer, fn log -> Enum.reverse(log) end)\n    iex> result = Funx.Monad.Writer.run(censored)\n    iex> result.value\n    \"ok\"\n    iex> result.log\n    [:b, :a]","ref":"Funx.Monad.Writer.html#censor/2-example"},{"type":"function","title":"Funx.Monad.Writer.eval/2","doc":"Executes the Writer and returns only the final result value.\n\nUses `ListConcat` by default.","ref":"Funx.Monad.Writer.html#eval/2"},{"type":"function","title":"Example - Funx.Monad.Writer.eval/2","doc":"iex> writer =\n    ...>   Funx.Monad.Writer.writer({10, [:init]})\n    ...>   |> Funx.Monad.bind(fn x ->\n    ...>     Funx.Monad.Writer.tell([:logged])\n    ...>     |> Funx.Monad.bind(fn _ -> Funx.Monad.Writer.pure(x * 2) end)\n    ...>   end)\n    iex> Funx.Monad.Writer.eval(writer)\n    20","ref":"Funx.Monad.Writer.html#eval/2-example"},{"type":"function","title":"Funx.Monad.Writer.exec/2","doc":"Executes the Writer and returns only the final accumulated log.\n\nUses `ListConcat` by default.","ref":"Funx.Monad.Writer.html#exec/2"},{"type":"function","title":"Example - Funx.Monad.Writer.exec/2","doc":"iex> writer =\n    ...>   Funx.Monad.Writer.writer({:ok, [:step1]})\n    ...>   |> Funx.Monad.bind(fn _ -> Funx.Monad.Writer.tell([:step2]) end)\n    iex> Funx.Monad.Writer.exec(writer)\n    [:step1, :step2]","ref":"Funx.Monad.Writer.html#exec/2-example"},{"type":"function","title":"Funx.Monad.Writer.listen/1","doc":"Captures the current log and returns it alongside the result.\n\nThe log remains unchanged—only the result is modified to include it.","ref":"Funx.Monad.Writer.html#listen/1"},{"type":"function","title":"Example - Funx.Monad.Writer.listen/1","doc":"iex> writer = Funx.Monad.Writer.writer({\"done\", [:start, :finish]})\n    iex> listened = Funx.Monad.Writer.listen(writer)\n    iex> result = Funx.Monad.Writer.run(listened)\n    iex> result.value\n    {\"done\", [:start, :finish]}\n    iex> result.log\n    [:start, :finish]","ref":"Funx.Monad.Writer.html#listen/1-example"},{"type":"function","title":"Funx.Monad.Writer.pass/1","doc":"Applies a log-transforming function that is returned from within the computation.\n\nThis allows the result of a computation to include not only a value, but also\na function that modifies the final accumulated log.\n\nThe input to `pass/1` must be a Writer containing a tuple `{result, f}`, where\n`f` is a function from log to log. This function will be applied to the final log\njust before it's returned.","ref":"Funx.Monad.Writer.html#pass/1"},{"type":"function","title":"Example - Funx.Monad.Writer.pass/1","doc":"iex> result =\n    ...>   Funx.Monad.Writer.pure({\"done\", fn log -> log ++ [:transformed] end})\n    ...>   |> Funx.Monad.Writer.pass()\n    ...>   |> Funx.Monad.Writer.run()\n    iex> result.value\n    \"done\"\n    iex> result.log\n    [:transformed]","ref":"Funx.Monad.Writer.html#pass/1-example"},{"type":"function","title":"Funx.Monad.Writer.pure/1","doc":"Wraps a value with no log.","ref":"Funx.Monad.Writer.html#pure/1"},{"type":"function","title":"Example - Funx.Monad.Writer.pure/1","doc":"iex> writer = Funx.Monad.Writer.pure(42)\n    iex> result = Funx.Monad.Writer.run(writer)\n    iex> result.value\n    42\n    iex> result.log\n    []","ref":"Funx.Monad.Writer.html#pure/1-example"},{"type":"function","title":"Funx.Monad.Writer.run/2","doc":"Executes the Writer and returns both the result and the final accumulated log.\n\nBy default, it uses `ListConcat` unless a monoid is explicitly passed.","ref":"Funx.Monad.Writer.html#run/2"},{"type":"function","title":"Example - Funx.Monad.Writer.run/2","doc":"iex> writer = Funx.Monad.Writer.writer({\"ok\", [:a, :b]})\n    iex> result = Funx.Monad.Writer.run(writer)\n    iex> result.value\n    \"ok\"\n    iex> result.log\n    [:a, :b]","ref":"Funx.Monad.Writer.html#run/2-example"},{"type":"function","title":"Funx.Monad.Writer.tell/1","doc":"Appends a log value using the monoid, returning `:ok` as the result.","ref":"Funx.Monad.Writer.html#tell/1"},{"type":"function","title":"Example - Funx.Monad.Writer.tell/1","doc":"iex> writer = Funx.Monad.Writer.tell([:event])\n    iex> result = Funx.Monad.Writer.run(writer)\n    iex> result.value\n    :ok\n    iex> result.log\n    [:event]","ref":"Funx.Monad.Writer.html#tell/1-example"},{"type":"function","title":"Funx.Monad.Writer.writer/1","doc":"Wraps both a value and a raw log into the Writer context.","ref":"Funx.Monad.Writer.html#writer/1"},{"type":"function","title":"Example - Funx.Monad.Writer.writer/1","doc":"iex> writer = Funx.Monad.Writer.writer({:ok, [:step1, :step2]})\n    iex> result = Funx.Monad.Writer.run(writer)\n    iex> result.value\n    :ok\n    iex> result.log\n    [:step1, :step2]","ref":"Funx.Monad.Writer.html#writer/1-example"},{"type":"type","title":"Funx.Monad.Writer.t/1","doc":"Represents a computation that produces a result along with a log,\naccumulated using a monoid.\n\nThe internal `writer` function takes an initial monoid and returns\na `{value, monoid}` tuple, where the monoid contains the accumulated log.","ref":"Funx.Monad.Writer.html#t:t/1"},{"type":"module","title":"Funx.Monad.Writer.Result","doc":"Represents the result of running a Writer computation:\nthe final value and the accumulated monoid.","ref":"Funx.Monad.Writer.Result.html"},{"type":"type","title":"Funx.Monad.Writer.Result.t/2","doc":"","ref":"Funx.Monad.Writer.Result.html#t:t/2"},{"type":"protocol","title":"Funx.Monoid","doc":"A protocol defining the Monoid algebraic structure, which consists of\nan identity element and an associative binary operation for combining values.\n\nThis protocol provides four key functions:\n\n- `empty/1`: Returns the identity element for the given monoid.\n- `append/2`: Combines two monoid structs.\n- `wrap/2`: Wraps a value into the monoid struct.\n- `unwrap/1`: Extracts the underlying value from the monoid struct.","ref":"Funx.Monoid.html"},{"type":"function","title":"Funx.Monoid.append/2","doc":"Combines two monoid structs.\n\nThe operation must satisfy associativity:\n\n    append(append(a, b), c) == append(a, append(b, c))","ref":"Funx.Monoid.html#append/2"},{"type":"function","title":"Examples - Funx.Monoid.append/2","doc":"iex> Funx.Monoid.append(%Funx.Monoid.Sum{value: 1}, %Funx.Monoid.Sum{value: 2})\n    %Funx.Monoid.Sum{value: 3}","ref":"Funx.Monoid.html#append/2-examples"},{"type":"function","title":"Funx.Monoid.empty/1","doc":"Returns the identity element for the given monoid struct.\n\nThe identity element is a special value that satisfies the property:\n\n    append(empty(monoid_struct), x) == x\n    append(x, empty(monoid_struct)) == x","ref":"Funx.Monoid.html#empty/1"},{"type":"function","title":"Examples - Funx.Monoid.empty/1","doc":"iex> Funx.Monoid.empty(%Funx.Monoid.Sum{})\n    %Funx.Monoid.Sum{value: 0}","ref":"Funx.Monoid.html#empty/1-examples"},{"type":"function","title":"Funx.Monoid.unwrap/1","doc":"Extracts the underlying value from the monoid struct.","ref":"Funx.Monoid.html#unwrap/1"},{"type":"function","title":"Examples - Funx.Monoid.unwrap/1","doc":"iex> Funx.Monoid.unwrap(%Funx.Monoid.Sum{value: 10})\n    10","ref":"Funx.Monoid.html#unwrap/1-examples"},{"type":"function","title":"Funx.Monoid.wrap/2","doc":"Wraps a value into the given monoid struct.","ref":"Funx.Monoid.html#wrap/2"},{"type":"function","title":"Examples - Funx.Monoid.wrap/2","doc":"iex> Funx.Monoid.wrap(%Funx.Monoid.Sum{}, 10)\n    %Funx.Monoid.Sum{value: 10}","ref":"Funx.Monoid.html#wrap/2-examples"},{"type":"type","title":"Funx.Monoid.t/0","doc":"All the types that implement this protocol.","ref":"Funx.Monoid.html#t:t/0"},{"type":"module","title":"Funx.Monoid.Eq.All","doc":"A Monoid implementation for equality checks for All.","ref":"Funx.Monoid.Eq.All.html"},{"type":"function","title":"Funx.Monoid.Eq.All.default_eq?/2","doc":"","ref":"Funx.Monoid.Eq.All.html#default_eq?/2"},{"type":"function","title":"Funx.Monoid.Eq.All.default_not_eq?/2","doc":"","ref":"Funx.Monoid.Eq.All.html#default_not_eq?/2"},{"type":"type","title":"Funx.Monoid.Eq.All.t/0","doc":"","ref":"Funx.Monoid.Eq.All.html#t:t/0"},{"type":"module","title":"Funx.Monoid.Eq.Any","doc":"A Monoid implementation for equality checks for Any.","ref":"Funx.Monoid.Eq.Any.html"},{"type":"function","title":"Funx.Monoid.Eq.Any.default_eq?/2","doc":"","ref":"Funx.Monoid.Eq.Any.html#default_eq?/2"},{"type":"function","title":"Funx.Monoid.Eq.Any.default_not_eq?/2","doc":"","ref":"Funx.Monoid.Eq.Any.html#default_not_eq?/2"},{"type":"type","title":"Funx.Monoid.Eq.Any.t/0","doc":"","ref":"Funx.Monoid.Eq.Any.html#t:t/0"},{"type":"module","title":"Funx.Monoid.ListConcat","doc":"A Monoid implementation for concatenating lists.\n\nThis monoid uses list concatenation as its associative operation\nand `[]` as the identity element.","ref":"Funx.Monoid.ListConcat.html"},{"type":"type","title":"Funx.Monoid.ListConcat.t/0","doc":"","ref":"Funx.Monoid.ListConcat.html#t:t/0"},{"type":"module","title":"Funx.Monoid.Max","doc":"A Monoid implementation for maximum values.","ref":"Funx.Monoid.Max.html"},{"type":"module","title":"Funx.Monoid.Min","doc":"A Monoid implementation for minimum values.","ref":"Funx.Monoid.Min.html"},{"type":"module","title":"Funx.Monoid.Ord","doc":"A monoid implementation for ordering logic (Ord).\nProvides default comparison functions and supports combining multiple\n`Ord` comparators into a single composite comparator.","ref":"Funx.Monoid.Ord.html"},{"type":"function","title":"Funx.Monoid.Ord.default?/2","doc":"","ref":"Funx.Monoid.Ord.html#default?/2"},{"type":"type","title":"Funx.Monoid.Ord.t/0","doc":"","ref":"Funx.Monoid.Ord.html#t:t/0"},{"type":"module","title":"Funx.Monoid.Predicate.All","doc":"A Monoid implementation for combining predicates using logical AND.","ref":"Funx.Monoid.Predicate.All.html"},{"type":"function","title":"Funx.Monoid.Predicate.All.default_pred?/1","doc":"","ref":"Funx.Monoid.Predicate.All.html#default_pred?/1"},{"type":"module","title":"Funx.Monoid.Predicate.Any","doc":"A Monoid implementation for combining predicates using logical OR.","ref":"Funx.Monoid.Predicate.Any.html"},{"type":"function","title":"Funx.Monoid.Predicate.Any.default_pred?/1","doc":"","ref":"Funx.Monoid.Predicate.Any.html#default_pred?/1"},{"type":"module","title":"Funx.Monoid.Product","doc":"A Monoid implementation for products.\n\nThis monoid uses multiplication as its associative operation\nand `1` as the identity element.","ref":"Funx.Monoid.Product.html"},{"type":"type","title":"Funx.Monoid.Product.t/0","doc":"","ref":"Funx.Monoid.Product.html#t:t/0"},{"type":"module","title":"Funx.Monoid.StringConcat","doc":"A Monoid implementation for concatenating strings.\n\nThis monoid uses binary string concatenation (`<>`) as its associative operation\nand `\"\"` (empty string) as the identity element.","ref":"Funx.Monoid.StringConcat.html"},{"type":"type","title":"Funx.Monoid.StringConcat.t/0","doc":"","ref":"Funx.Monoid.StringConcat.html#t:t/0"},{"type":"module","title":"Funx.Monoid.Sum","doc":"A Monoid implementation for sums.\n\nThis monoid uses addition as its associative operation\nand `0` as the identity element.","ref":"Funx.Monoid.Sum.html"},{"type":"type","title":"Funx.Monoid.Sum.t/0","doc":"","ref":"Funx.Monoid.Sum.html#t:t/0"},{"type":"module","title":"Funx.Monoid.Utils","doc":"Utility functions for working with Monoids.\n\nThis module provides functions to combine monoidal values using\n`m_append/3` and `m_concat/2`.","ref":"Funx.Monoid.Utils.html"},{"type":"function","title":"Funx.Monoid.Utils.m_append/3","doc":"Appends two values within a given monoid.\n\nThis function wraps the input values using the provided `monoid`, applies\nthe `append/2` operation, and then unwraps the result.","ref":"Funx.Monoid.Utils.html#m_append/3"},{"type":"function","title":"Parameters - Funx.Monoid.Utils.m_append/3","doc":"- `monoid` – A monoid struct defining how values should be combined.\n  - `a` – The first raw value.\n  - `b` – The second raw value.","ref":"Funx.Monoid.Utils.html#m_append/3-parameters"},{"type":"function","title":"Examples - Funx.Monoid.Utils.m_append/3","doc":"iex> alias Funx.Monoid.Sum\n    iex> Funx.Monoid.Utils.m_append(%Sum{}, 3, 5)\n    8","ref":"Funx.Monoid.Utils.html#m_append/3-examples"},{"type":"function","title":"Funx.Monoid.Utils.m_concat/2","doc":"Concatenates a list of values using the given monoid.\n\nThis function wraps each value using the provided `monoid`, folds the list\nusing the monoid's identity and append operation, and then unwraps the result.","ref":"Funx.Monoid.Utils.html#m_concat/2"},{"type":"function","title":"Parameters - Funx.Monoid.Utils.m_concat/2","doc":"- `monoid` – A monoid struct defining how values should be combined.\n  - `values` – A list of raw values.","ref":"Funx.Monoid.Utils.html#m_concat/2-parameters"},{"type":"function","title":"Examples - Funx.Monoid.Utils.m_concat/2","doc":"iex> alias Funx.Monoid.Sum\n    iex> Funx.Monoid.Utils.m_concat(%Sum{}, [1, 2, 3])\n    6","ref":"Funx.Monoid.Utils.html#m_concat/2-examples"},{"type":"protocol","title":"Funx.Ord","doc":"The `Funx.Ord` protocol defines a set of comparison functions: `lt?/2`, `le?/2`, `gt?/2`, and `ge?/2`.\n\nThis protocol is intended for types that can be ordered, allowing values to be compared for their relative positions in a total order.\n\nBy implementing this protocol, you can provide custom logic for how values of a certain type are compared.","ref":"Funx.Ord.html"},{"type":"protocol","title":"Fallback - Funx.Ord","doc":"The protocol uses `@fallback_to_any true`, which means if a specific type does not implement `Funx.Ord`,\nthe default implementation for `Any` will be used, which relies on Elixir's built-in comparison operators.","ref":"Funx.Ord.html#module-fallback"},{"type":"function","title":"Funx.Ord.ge?/2","doc":"Returns `true` if `a` is greater than or equal to `b`, otherwise returns `false`.","ref":"Funx.Ord.html#ge?/2"},{"type":"function","title":"Examples - Funx.Ord.ge?/2","doc":"iex> Funx.Ord.ge?(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.just(3))\n    true\n\n    iex> Funx.Ord.ge?(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.just(5))\n    true\n\n    iex> Funx.Ord.ge?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(5))\n    false","ref":"Funx.Ord.html#ge?/2-examples"},{"type":"function","title":"Funx.Ord.gt?/2","doc":"Returns `true` if `a` is greater than `b`, otherwise returns `false`.","ref":"Funx.Ord.html#gt?/2"},{"type":"function","title":"Examples - Funx.Ord.gt?/2","doc":"iex> Funx.Ord.gt?(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.just(3))\n    true\n\n    iex> Funx.Ord.gt?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(5))\n    false\n\n    iex> Funx.Ord.gt?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.nothing())\n    true","ref":"Funx.Ord.html#gt?/2-examples"},{"type":"function","title":"Funx.Ord.le?/2","doc":"Returns `true` if `a` is less than or equal to `b`, otherwise returns `false`.","ref":"Funx.Ord.html#le?/2"},{"type":"function","title":"Examples - Funx.Ord.le?/2","doc":"iex> Funx.Ord.le?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(5))\n    true\n\n    iex> Funx.Ord.le?(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.just(5))\n    true\n\n    iex> Funx.Ord.le?(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.just(3))\n    false","ref":"Funx.Ord.html#le?/2-examples"},{"type":"function","title":"Funx.Ord.lt?/2","doc":"Returns `true` if `a` is less than `b`, otherwise returns `false`.","ref":"Funx.Ord.html#lt?/2"},{"type":"function","title":"Examples - Funx.Ord.lt?/2","doc":"iex> Funx.Ord.lt?(Funx.Monad.Maybe.just(3), Funx.Monad.Maybe.just(5))\n    true\n\n    iex> Funx.Ord.lt?(Funx.Monad.Maybe.just(5), Funx.Monad.Maybe.just(3))\n    false\n\n    iex> Funx.Ord.lt?(Funx.Monad.Maybe.nothing(), Funx.Monad.Maybe.just(3))\n    true","ref":"Funx.Ord.html#lt?/2-examples"},{"type":"type","title":"Funx.Ord.t/0","doc":"All the types that implement this protocol.","ref":"Funx.Ord.html#t:t/0"},{"type":"module","title":"Funx.Ord.Utils","doc":"Utility functions for working with the `Funx.Ord` protocol.\nThese functions assume that types passed in either support Elixir's comparison operators\nor implement the `Funx.Ord` protocol.","ref":"Funx.Ord.Utils.html"},{"type":"function","title":"Funx.Ord.Utils.append/2","doc":"Appends two `Ord` instances, combining their comparison logic.\n\nIf the first `Ord` comparator determines an order, that result is used.\nIf not, the second comparator is used as a fallback.","ref":"Funx.Ord.Utils.html#append/2"},{"type":"function","title":"Examples - Funx.Ord.Utils.append/2","doc":"iex> ord1 = Funx.Ord.Utils.contramap(& &1.age, Funx.Ord.Any)\n    iex> ord2 = Funx.Ord.Utils.contramap(& &1.name, Funx.Ord.Any)\n    iex> combined = Funx.Ord.Utils.append(ord1, ord2)\n    iex> combined.lt?.(%{age: 30, name: \"Alice\"}, %{age: 30, name: \"Bob\"})\n    true","ref":"Funx.Ord.Utils.html#append/2-examples"},{"type":"function","title":"Funx.Ord.Utils.between/4","doc":"Checks if `value` is between `min` and `max`, inclusive, with an optional custom `Ord`.","ref":"Funx.Ord.Utils.html#between/4"},{"type":"function","title":"Examples - Funx.Ord.Utils.between/4","doc":"iex> Funx.Ord.Utils.between(5, 1, 10)\n    true\n\n    iex> Funx.Ord.Utils.between(0, 1, 10)\n    false\n\n    iex> Funx.Ord.Utils.between(11, 1, 10)\n    false","ref":"Funx.Ord.Utils.html#between/4-examples"},{"type":"function","title":"Funx.Ord.Utils.clamp/4","doc":"Clamps a value between `min` and `max`, with an optional custom `Ord`.","ref":"Funx.Ord.Utils.html#clamp/4"},{"type":"function","title":"Examples - Funx.Ord.Utils.clamp/4","doc":"iex> Funx.Ord.Utils.clamp(5, 1, 10)\n    5\n\n    iex> Funx.Ord.Utils.clamp(0, 1, 10)\n    1\n\n    iex> Funx.Ord.Utils.clamp(15, 1, 10)\n    10","ref":"Funx.Ord.Utils.html#clamp/4-examples"},{"type":"function","title":"Funx.Ord.Utils.comparator/1","doc":"Creates a comparator function from the given `Ord` module, returning `true`\nif `a` is less than or equal to `b` according to the module’s ordering.\n\nUseful for sorting with `Enum.sort/2` or similar functions.","ref":"Funx.Ord.Utils.html#comparator/1"},{"type":"function","title":"Examples - Funx.Ord.Utils.comparator/1","doc":"iex> comparator = Funx.Ord.Utils.comparator(Funx.Ord.Any)\n    iex> Enum.sort([3, 1, 2], comparator)\n    [1, 2, 3]","ref":"Funx.Ord.Utils.html#comparator/1-examples"},{"type":"function","title":"Funx.Ord.Utils.compare/3","doc":"Compares two values and returns `:lt`, `:eq`, or `:gt`, with an optional custom `Ord`.","ref":"Funx.Ord.Utils.html#compare/3"},{"type":"function","title":"Examples - Funx.Ord.Utils.compare/3","doc":"iex> Funx.Ord.Utils.compare(3, 5)\n    :lt\n\n    iex> Funx.Ord.Utils.compare(7, 7)\n    :eq\n\n    iex> Funx.Ord.Utils.compare(9, 4)\n    :gt","ref":"Funx.Ord.Utils.html#compare/3-examples"},{"type":"function","title":"Funx.Ord.Utils.concat/1","doc":"Concatenates a list of `Ord` instances into a single composite comparator.\n\nThis function reduces a list of `Ord` comparators into a single `Ord`,\napplying them in sequence until an order is determined.","ref":"Funx.Ord.Utils.html#concat/1"},{"type":"function","title":"Examples - Funx.Ord.Utils.concat/1","doc":"iex> ord_list = [\n    ...>   Funx.Ord.Utils.contramap(& &1.age, Funx.Ord.Any),\n    ...>   Funx.Ord.Utils.contramap(& &1.name, Funx.Ord.Any)\n    ...> ]\n    iex> combined = Funx.Ord.Utils.concat(ord_list)\n    iex> combined.gt?.(%{age: 25, name: \"Charlie\"}, %{age: 25, name: \"Bob\"})\n    true","ref":"Funx.Ord.Utils.html#concat/1-examples"},{"type":"function","title":"Funx.Ord.Utils.contramap/2","doc":"Transforms an ordering by applying a function `f` to values before comparison.\n\nThe `ord` parameter can be an `Ord` module or a custom comparator map with comparison functions (`:lt?`, `:le?`, `:gt?`, and `:ge?`).\nWhen an `Ord` module is provided, it wraps the module’s functions to apply `f` to each value before invoking the comparison.\nIf a custom comparator map is provided, it wraps the functions in the map to apply `f` to each value.","ref":"Funx.Ord.Utils.html#contramap/2"},{"type":"function","title":"Examples - Funx.Ord.Utils.contramap/2","doc":"iex> ord = Funx.Ord.Utils.contramap(&String.length/1, Funx.Ord.Any)\n    iex> ord.lt?.(\"cat\", \"zebra\")\n    true","ref":"Funx.Ord.Utils.html#contramap/2-examples"},{"type":"function","title":"Funx.Ord.Utils.max/3","doc":"Returns the maximum of two values, with an optional custom `Ord`.","ref":"Funx.Ord.Utils.html#max/3"},{"type":"function","title":"Examples - Funx.Ord.Utils.max/3","doc":"iex> Funx.Ord.Utils.max(3, 5)\n    5\n\n    iex> ord = Funx.Ord.Utils.contramap(&String.length/1, Funx.Ord.Any)\n    iex> Funx.Ord.Utils.max(\"cat\", \"zebra\", ord)\n    \"zebra\"","ref":"Funx.Ord.Utils.html#max/3-examples"},{"type":"function","title":"Funx.Ord.Utils.min/3","doc":"Returns the minimum of two values, with an optional custom `Ord`.","ref":"Funx.Ord.Utils.html#min/3"},{"type":"function","title":"Examples - Funx.Ord.Utils.min/3","doc":"iex> Funx.Ord.Utils.min(10, 7)\n    7\n\n    iex> ord = Funx.Ord.Utils.contramap(&String.length/1, Funx.Ord.Any)\n    iex> Funx.Ord.Utils.min(\"apple\", \"kiwi\", ord)\n    \"kiwi\"","ref":"Funx.Ord.Utils.html#min/3-examples"},{"type":"function","title":"Funx.Ord.Utils.reverse/1","doc":"Reverses the ordering logic.","ref":"Funx.Ord.Utils.html#reverse/1"},{"type":"function","title":"Examples - Funx.Ord.Utils.reverse/1","doc":"iex> ord = Funx.Ord.Utils.reverse(Funx.Ord.Any)\n    iex> ord.lt?.(10, 5)\n    true","ref":"Funx.Ord.Utils.html#reverse/1-examples"},{"type":"function","title":"Funx.Ord.Utils.to_eq/1","doc":"Converts an `Ord` instance into an equality comparator.\n\nThis function creates a map containing two functions:\n  - `eq?/2`: Returns `true` if `a` and `b` are considered equal by the given `Ord`.\n  - `not_eq?/2`: Returns `true` if `a` and `b` are not considered equal by the given `Ord`.","ref":"Funx.Ord.Utils.html#to_eq/1"},{"type":"function","title":"Examples - Funx.Ord.Utils.to_eq/1","doc":"iex> eq = Funx.Ord.Utils.to_eq(Funx.Ord.Any)\n    iex> eq.eq?.(5, 5)\n    true","ref":"Funx.Ord.Utils.html#to_eq/1-examples"},{"type":"function","title":"Funx.Ord.Utils.to_ord_map/1","doc":"","ref":"Funx.Ord.Utils.html#to_ord_map/1"},{"type":"type","title":"Funx.Ord.Utils.ord_map/0","doc":"","ref":"Funx.Ord.Utils.html#t:ord_map/0"},{"type":"type","title":"Funx.Ord.Utils.ord_t/0","doc":"","ref":"Funx.Ord.Utils.html#t:ord_t/0"},{"type":"module","title":"Funx.Predicate","doc":"Provides utility functions for working with predicates—functions that return `true` or `false`.\n\nThis module enables combining predicates in a declarative way using logical operations:\n\n- `p_and/2`: Returns `true` if **both** predicates are `true`.\n- `p_or/2`: Returns `true` if **at least one** predicate is `true`.\n- `p_not/1`: Negates a predicate.\n- `p_all/1`: Returns `true` if **all** predicates in a list are `true`.\n- `p_any/1`: Returns `true` if **any** predicate in a list is `true`.\n- `p_none/1`: Returns `true` if **none** of the predicates in a list are `true`.\n\nThese functions simplify complex conditional logic.","ref":"Funx.Predicate.html"},{"type":"module","title":"Examples - Funx.Predicate","doc":"","ref":"Funx.Predicate.html#module-examples"},{"type":"module","title":"Combining predicates with `p_and/2`: - Funx.Predicate","doc":"iex> is_adult = fn person -> person.age >= 18 end\n    iex> has_ticket = fn person -> person.tickets > 0 end\n    iex> can_enter = Funx.Predicate.p_and(is_adult, has_ticket)\n\n    iex> can_enter.(%{age: 20, tickets: 1})\n    true\n    iex> can_enter.(%{age: 16, tickets: 1})\n    false","ref":"Funx.Predicate.html#module-combining-predicates-with-p_and-2"},{"type":"module","title":"Using `p_or/2` for alternative conditions: - Funx.Predicate","doc":"iex> is_vip = fn person -> person.vip end\n    iex> is_sponsor = fn person -> person.sponsor end\n    iex> can_access_vip_area = Funx.Predicate.p_or(is_vip, is_sponsor)\n\n    iex> can_access_vip_area.(%{vip: true, sponsor: false})\n    true\n    iex> can_access_vip_area.(%{vip: false, sponsor: false})\n    false","ref":"Funx.Predicate.html#module-using-p_or-2-for-alternative-conditions"},{"type":"module","title":"Negating predicates with `p_not/1`: - Funx.Predicate","doc":"iex> is_minor = fn person -> person.age < 18 end\n    iex> is_adult = Funx.Predicate.p_not(is_minor)\n\n    iex> is_adult.(%{age: 20})\n    true\n    iex> is_adult.(%{age: 16})\n    false","ref":"Funx.Predicate.html#module-negating-predicates-with-p_not-1"},{"type":"module","title":"Using `p_all/1` and `p_any/1` for predicate lists: - Funx.Predicate","doc":"iex> conditions = [is_adult, has_ticket]\n    iex> must_meet_all = Funx.Predicate.p_all(conditions)\n    iex> must_meet_any = Funx.Predicate.p_any(conditions)\n\n    iex> must_meet_all.(%{age: 20, tickets: 1})\n    true\n    iex> must_meet_all.(%{age: 20, tickets: 0})\n    false\n\n    iex> must_meet_any.(%{age: 20, tickets: 0})\n    true\n    iex> must_meet_any.(%{age: 16, tickets: 0})\n    false","ref":"Funx.Predicate.html#module-using-p_all-1-and-p_any-1-for-predicate-lists"},{"type":"module","title":"Using `p_none/1` to reject multiple conditions: - Funx.Predicate","doc":"iex> cannot_enter = Funx.Predicate.p_none([is_adult, is_vip])\n\n    iex> cannot_enter.(%{age: 20, ticket: :vip})\n    false\n    iex> cannot_enter.(%{age: 16, ticket: :basic})\n    true","ref":"Funx.Predicate.html#module-using-p_none-1-to-reject-multiple-conditions"},{"type":"function","title":"Funx.Predicate.p_all/1","doc":"Combines a list of predicates (`p_list`) using logical AND.\nReturns `true` only if all predicates return `true`. An empty list returns `true`.","ref":"Funx.Predicate.html#p_all/1"},{"type":"function","title":"Examples - Funx.Predicate.p_all/1","doc":"iex> can_enter = Funx.Predicate.p_all([is_adult, has_ticket])\n\n    iex> can_enter.(%{age: 20, tickets: 1})\n    true\n    iex> can_enter.(%{age: 16, tickets: 1})\n    false","ref":"Funx.Predicate.html#p_all/1-examples"},{"type":"function","title":"Funx.Predicate.p_and/2","doc":"Combines two predicates (`pred1` and `pred2`) using logical AND.\nReturns a predicate that evaluates to `true` only if both `pred1` and `pred2` return `true`.","ref":"Funx.Predicate.html#p_and/2"},{"type":"function","title":"Examples - Funx.Predicate.p_and/2","doc":"iex> is_adult = fn person -> person.age >= 18 end\n    iex> has_ticket = fn person -> person.tickets > 0 end\n    iex> can_enter = Funx.Predicate.p_and(is_adult, has_ticket)\n\n    iex> can_enter.(%{age: 20, tickets: 1})\n    true\n    iex> can_enter.(%{age: 16, tickets: 1})\n    false","ref":"Funx.Predicate.html#p_and/2-examples"},{"type":"function","title":"Funx.Predicate.p_any/1","doc":"Combines a list of predicates (`p_list`) using logical OR.\nReturns `true` if at least one predicate returns `true`. An empty list returns `false`.","ref":"Funx.Predicate.html#p_any/1"},{"type":"function","title":"Examples - Funx.Predicate.p_any/1","doc":"iex> can_access_vip_area = Funx.Predicate.p_any([is_vip, is_sponsor])\n\n    iex> can_access_vip_area.(%{vip: true, sponsor: false})\n    true\n    iex> can_access_vip_area.(%{vip: false, sponsor: false})\n    false","ref":"Funx.Predicate.html#p_any/1-examples"},{"type":"function","title":"Funx.Predicate.p_none/1","doc":"Combines a list of predicates (`p_list`) using logical NOR (negated OR).\nReturns `true` only if **none** of the predicates return `true`. An empty list returns `true`.","ref":"Funx.Predicate.html#p_none/1"},{"type":"function","title":"Examples - Funx.Predicate.p_none/1","doc":"iex> cannot_enter = Funx.Predicate.p_none([is_adult, is_vip])\n\n    iex> cannot_enter.(%{age: 20, ticket: :vip})\n    false\n    iex> cannot_enter.(%{age: 16, ticket: :basic})\n    true","ref":"Funx.Predicate.html#p_none/1-examples"},{"type":"function","title":"Funx.Predicate.p_not/1","doc":"Negates a predicate (`pred`).\nReturns a predicate that evaluates to `true` when `pred` returns `false`, and vice versa.","ref":"Funx.Predicate.html#p_not/1"},{"type":"function","title":"Examples - Funx.Predicate.p_not/1","doc":"iex> is_minor = fn person -> person.age < 18 end\n    iex> is_adult = Funx.Predicate.p_not(is_minor)\n\n    iex> is_adult.(%{age: 20})\n    true\n    iex> is_adult.(%{age: 16})\n    false","ref":"Funx.Predicate.html#p_not/1-examples"},{"type":"function","title":"Funx.Predicate.p_or/2","doc":"Combines two predicates (`pred1` and `pred2`) using logical OR.\nReturns a predicate that evaluates to `true` if either `pred1` or `pred2` return `true`.","ref":"Funx.Predicate.html#p_or/2"},{"type":"function","title":"Examples - Funx.Predicate.p_or/2","doc":"iex> is_vip = fn person -> person.vip end\n    iex> is_sponsor = fn person -> person.sponsor end\n    iex> can_access_vip_area = Funx.Predicate.p_or(is_vip, is_sponsor)\n\n    iex> can_access_vip_area.(%{vip: true, sponsor: false})\n    true\n    iex> can_access_vip_area.(%{vip: false, sponsor: false})\n    false","ref":"Funx.Predicate.html#p_or/2-examples"},{"type":"type","title":"Funx.Predicate.t/0","doc":"","ref":"Funx.Predicate.html#t:t/0"},{"type":"protocol","title":"Funx.Summarizable","doc":"","ref":"Funx.Summarizable.html"},{"type":"function","title":"Funx.Summarizable.summarize/1","doc":"Summarizes a value in a telemetry-safe, compact format.","ref":"Funx.Summarizable.html#summarize/1"},{"type":"type","title":"Funx.Summarizable.t/0","doc":"All the types that implement this protocol.","ref":"Funx.Summarizable.html#t:t/0"},{"type":"module","title":"Funx.Utils","doc":"A collection of higher-order functions for functional programming in Elixir.\n\nThis module provides utilities for working with functions in a functional\nprogramming style. It includes:\n\n- `curry/1`: Transforms a multi-argument function into a curried version.\n- `curry_r/1`: Transforms a multi-argument function into a curried version, but from right to left.\n- `flip/1`: Reverses the argument order of a two-argument function.","ref":"Funx.Utils.html"},{"type":"function","title":"Funx.Utils.curry/1","doc":"Transforms a function of arity `n` into a curried version,\nallowing it to be applied one argument at a time.","ref":"Funx.Utils.html#curry/1"},{"type":"function","title":"Example - Funx.Utils.curry/1","doc":"iex> add = fn a, b -> a + b end\n    iex> curried_add = FunPark.Utils.curry(add)\n    iex> add_three = curried_add.(3)\n    iex> add_three.(2)\n    5","ref":"Funx.Utils.html#curry/1-example"},{"type":"function","title":"Funx.Utils.curry_l/1","doc":"Alias for `curry/1`, explicitly denoting left-to-right argument application.","ref":"Funx.Utils.html#curry_l/1"},{"type":"function","title":"Example - Funx.Utils.curry_l/1","doc":"iex> subtract = fn a, b -> a - b end\n    iex> curried_subtract = FunPark.Utils.curry_l(subtract)\n    iex> subtract_five = curried_subtract.(5)\n    iex> subtract_five.(3)\n    2","ref":"Funx.Utils.html#curry_l/1-example"},{"type":"function","title":"Funx.Utils.curry_r/1","doc":"Transforms a function of arity `n` into a right-curried version,\napplying arguments from right to left.","ref":"Funx.Utils.html#curry_r/1"},{"type":"function","title":"Example - Funx.Utils.curry_r/1","doc":"iex> divide = fn a, b -> a / b end\n    iex> curried_divide = FunPark.Utils.curry_r(divide)\n    iex> divide_by_two = curried_divide.(2)\n    iex> divide_by_two.(10)\n    5.0","ref":"Funx.Utils.html#curry_r/1-example"},{"type":"function","title":"Funx.Utils.flip/1","doc":"Reverses the argument order of a two-argument function.\n\nThe `flip/1` function takes a function of arity 2 and returns a new function\nwhere the first and second arguments are swapped.","ref":"Funx.Utils.html#flip/1"},{"type":"function","title":"Examples - Funx.Utils.flip/1","doc":"iex> divide = fn a, b -> a / b end\n    iex> flipped_divide = Utils.flip(divide)\n    iex> flipped_divide.(2, 10)\n    5.0","ref":"Funx.Utils.html#flip/1-examples"},{"type":"function","title":"Funx.Utils.summarize_string/2","doc":"","ref":"Funx.Utils.html#summarize_string/2"},{"type":"exception","title":"Funx.Errors.EffectError","doc":"Represents a system-level failure in an effectful computation.\n\n`EffectError` is raised or returned when a failure occurs during the execution\nof an `Effect` stage, such as `map`, `bind`, or `ap`. It is not meant for user-facing\nvalidation, but rather for internal tracing, telemetry, and diagnostics.","ref":"Funx.Errors.EffectError.html"},{"type":"exception","title":"Fields - Funx.Errors.EffectError","doc":"* `stage` – the name of the effect stage where the error occurred (`:map`, `:bind`, `:ap`, etc.)\n  * `reason` – the term (often an exception) that caused the failure\n\nThis error implements the `Exception`, `String.Chars`, and `Funx.Summarizable` behaviours.","ref":"Funx.Errors.EffectError.html#module-fields"},{"type":"function","title":"Funx.Errors.EffectError.new/2","doc":"Creates a new `EffectError` from the given stage and reason.","ref":"Funx.Errors.EffectError.html#new/2"},{"type":"function","title":"Examples - Funx.Errors.EffectError.new/2","doc":"iex> Funx.Errors.EffectError.new(:bind, %RuntimeError{message: \"boom\"})\n    %Funx.Errors.EffectError{stage: :bind, reason: %RuntimeError{message: \"boom\"}}","ref":"Funx.Errors.EffectError.html#new/2-examples"},{"type":"type","title":"Funx.Errors.EffectError.t/0","doc":"","ref":"Funx.Errors.EffectError.html#t:t/0"},{"type":"exception","title":"Funx.Errors.ValidationError","doc":"Represents a validation error in the Funx library.\n\nA `ValidationError` wraps one or more domain-level validation messages. It is typically used with `Either.Left` to indicate that a value failed validation and should not proceed in a computation. It can also be raised directly, as it implements the `Exception` behaviour.\n\nThis module provides functions to construct, merge, and convert validation errors, enabling structured, composable error handling across pipelines and validation chains.","ref":"Funx.Errors.ValidationError.html"},{"type":"exception","title":"Functions - Funx.Errors.ValidationError","doc":"* `new/1` – Creates a `ValidationError` from a single error string or a list of error strings.\n* `empty/0` – Returns an empty `ValidationError`.\n* `merge/2` – Combines two `ValidationError` structs into one.\n* `from_tagged/1` – Converts a tagged error tuple (`{:error, errors}`) into a `ValidationError`.\n\nThis module also implements the `Exception`, `String.Chars`, and `Funx.Summarizable` protocols, supporting both human-readable output and structured reporting.","ref":"Funx.Errors.ValidationError.html#module-functions"},{"type":"exception","title":"Usage in validation - Funx.Errors.ValidationError","doc":"You can validate a value using a list of validator functions. Each validator returns an `Either.Right` if\nthe check passes, or an `Either.Left` with an error message if it fails. If any validation fails,\nall errors are aggregated and returned in a single `Left`.\n\nIn contexts where an error must halt execution, `ValidationError` can be raised directly using `raise/1`.","ref":"Funx.Errors.ValidationError.html#module-usage-in-validation"},{"type":"exception","title":"Examples - Funx.Errors.ValidationError","doc":"You can also use a `ValidationError` to hold errors:\n\n```elixir\nalias Funx.Errors.ValidationError\n\nvalidate_positive = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(&1 > 0), fn v -> \"Value must be positive: \" <> to_string(v) end)\n  |> Funx.Monad.Either.map_left(&ValidationError.new/1)\nend\n\nvalidate_even = fn x ->\n  Funx.Monad.Either.lift_predicate(x, &(rem(&1, 2) == 0), fn v -> \"Value must be even: \" <> to_string(v) end)\n  |> Funx.Monad.Either.map_left(&ValidationError.new/1)\nend\n\nFunx.Monad.Either.validate(-3, [validate_positive, validate_even])\n#=> %Funx.Monad.Either.Left{\n#     left: %ValidationError{\n#       errors: [\"Value must be positive: -3\", \"Value must be even: -3\"]\n#     }\n#   }\n```","ref":"Funx.Errors.ValidationError.html#module-examples"},{"type":"function","title":"Funx.Errors.ValidationError.empty/0","doc":"Returns an empty `ValidationError`.","ref":"Funx.Errors.ValidationError.html#empty/0"},{"type":"function","title":"Examples - Funx.Errors.ValidationError.empty/0","doc":"iex> Funx.Errors.ValidationError.empty()\n    %Funx.Errors.ValidationError{errors: []}","ref":"Funx.Errors.ValidationError.html#empty/0-examples"},{"type":"function","title":"Funx.Errors.ValidationError.from_tagged/1","doc":"Converts a tagged error tuple into a `ValidationError`.","ref":"Funx.Errors.ValidationError.html#from_tagged/1"},{"type":"function","title":"Examples - Funx.Errors.ValidationError.from_tagged/1","doc":"iex> Funx.Errors.ValidationError.from_tagged({:error, [\"must be positive\"]})\n    %Funx.Errors.ValidationError{errors: [\"must be positive\"]}","ref":"Funx.Errors.ValidationError.html#from_tagged/1-examples"},{"type":"function","title":"Funx.Errors.ValidationError.merge/2","doc":"Merges two `ValidationError` structs into one by concatenating their error lists.","ref":"Funx.Errors.ValidationError.html#merge/2"},{"type":"function","title":"Examples - Funx.Errors.ValidationError.merge/2","doc":"iex> e1 = Funx.Errors.ValidationError.new(\"must be positive\")\n    iex> e2 = Funx.Errors.ValidationError.new(\"must be even\")\n    iex> Funx.Errors.ValidationError.merge(e1, e2)\n    %Funx.Errors.ValidationError{errors: [\"must be positive\", \"must be even\"]}","ref":"Funx.Errors.ValidationError.html#merge/2-examples"},{"type":"function","title":"Funx.Errors.ValidationError.new/1","doc":"Creates a `ValidationError` from a single string or list of strings.","ref":"Funx.Errors.ValidationError.html#new/1"},{"type":"function","title":"Examples - Funx.Errors.ValidationError.new/1","doc":"iex> Funx.Errors.ValidationError.new(\"must be positive\")\n    %Funx.Errors.ValidationError{errors: [\"must be positive\"]}\n\n    iex> Funx.Errors.ValidationError.new([\"must be positive\", \"must be even\"])\n    %Funx.Errors.ValidationError{errors: [\"must be positive\", \"must be even\"]}","ref":"Funx.Errors.ValidationError.html#new/1-examples"},{"type":"type","title":"Funx.Errors.ValidationError.t/0","doc":"","ref":"Funx.Errors.ValidationError.html#t:t/0"},{"type":"extras","title":"README","doc":"# Funx - Functional Programming Patterns for Elixir\n\n[![Continuous Integration](https://github.com/JKWA/funx/actions/workflows/ci.yml/badge.svg)](https://github.com/JKWA/funx/actions/workflows/ci.yml)\n[![Hex.pm](https://img.shields.io/hexpm/v/funx.svg)](https://hex.pm/packages/funx)\n\n⚠️ **Beta:** Funx is in active development. APIs may change until version 1.0. Feedback and contributions are welcome.\n\n**Funx** is a functional programming library for Elixir that provides protocols and combinators for equality, ordering, monoids, monads, and other core abstractions. Elixir doesn’t have a static type system, so it can’t enforce functional patterns through the compiler. Funx brings those patterns into Elixir using the language’s own tools—pattern matching, protocols, and structs—without sacrificing its dynamic nature.  \n\nFunx was built alongside [**Advanced Functional Programming with Elixir**](https://pragprog.com/titles/jkelixir/advanced-functional-programming-with-elixir), a PragProg title that shows how to apply these abstractions in real systems.  \n\n \n\n💡 **AI-assisted learning:** With an LLM, Funx becomes more than a library. It becomes your teacher for functional programming in Elixir. Install the library into a demo project, ask questions, and let it generate code as you learn.","ref":"readme.html"},{"type":"extras","title":"Installation - README","doc":"To use Funx, add it to the list of dependencies in `mix.exs`:\n\n```elixir\ndef deps do\n  [\n    {:funx, \"~> 0.1.5\"}\n  ]\nend\n```\n\nThen, run the following command to fetch the dependencies:\n\n```bash\nmix deps.get\n```","ref":"readme.html#installation"},{"type":"extras","title":"Usage Rules - README","doc":"Each module includes usage rules designed for humans and LLMs:\n\n- When to use a given abstraction\n- How to compose and combine it\n- Examples of domain modeling with `Eq`, `Ord`, `Maybe`, etc.\n\n➡️ [Browse Usage Rules](./lib/usage-rules.md)","ref":"readme.html#usage-rules"},{"type":"extras","title":"Equality - README","doc":"The `Eq` protocol defines how two values are compared, making equality explicit and adaptable to your domain.\n\n- Define what “equal” means—compare by ID, name, or any derived attribute.\n- Compose multiple comparisons—require all to match or just one.\n- Implement for structs, built-in types, or custom comparators.","ref":"readme.html#equality"},{"type":"extras","title":"Ordering - README","doc":"The `Ord` protocol defines ordering relationships in a structured way, without relying on Elixir’s built-in comparison operators.\n\n- Define comparisons based on properties like size, age, or priority.\n- Chain orderings to create fallback tiebreakers.\n- Implement for any type, including custom structs.","ref":"readme.html#ordering"},{"type":"extras","title":"Monads - README","doc":"Monads encapsulate computations, allowing operations to be chained while handling concerns like optional values, failures, dependencies, or deferred effects.\n\n- `Identity`: Wraps a value with no additional behavior—useful for organizing transformations.\n- `Maybe`: Represents optional data using `Just` for presence and `Nothing` for absence.\n- `Either`: Models computations with two possibilities—`Left` and `Right`.\n- `Effect`: Encapsulates deferred execution with error handling, similar to `Task`.\n- `Reader`: Passes an immutable environment through a computation for dependency injection or configuration.\n- `Writer`: Threads a log alongside a result using any monoid—useful for tracing, reporting, or accumulating metadata during computation.","ref":"readme.html#monads"},{"type":"extras","title":"Monoids - README","doc":"Monoids combine values using an associative operation and an identity element. They are useful for accumulation, selection, and combining logic.\n\n- `Sum`: Adds numbers (`0` is the identity).\n- `Product`: Multiplies numbers (`1` is the identity).\n- `Eq.All`: Values are equal only if all comparators agree.\n- `Eq.Any`: Values are equal if any comparator agrees.\n- `Predicate.All`: All predicates must hold.\n- `Predicate.Any`: At least one predicate must hold.\n- `Ord`: Defines ordering compositionally.\n- `Max` and `Min`: Select the largest or smallest value by custom ordering.\n- `ListConcat`: Concatenates lists (`[]` is the identity).\n- `StringConcat`: Concatenates strings (`\"\"` is the identity).","ref":"readme.html#monoids"},{"type":"extras","title":"Predicates - README","doc":"Predicates are functions that return `true` or `false`. Funx provides combinators for composing them cleanly.\n\n- `p_and`: Returns `true` if both predicates pass.\n- `p_or`: Returns `true` if either predicate passes.\n- `p_not`: Negates a predicate.\n- `p_all`: Returns `true` if all predicates in a list pass.\n- `p_any`: Returns `true` if any predicate in a list passes.\n- `p_none`: Returns `true` if none pass.","ref":"readme.html#predicates"},{"type":"extras","title":"Folding - README","doc":"The `Foldable` protocol defines how to reduce a structure to a single result.\n\n- `fold_l`: Reduces from the left, applying functions in order.\n- `fold_r`: Reduces from the right, applying functions in reverse.\n\nUseful for accumulating values, transforming collections, or extracting data.","ref":"readme.html#folding"},{"type":"extras","title":"Filtering - README","doc":"The `Filterable` protocol defines how to conditionally retain values within a context.\n\n- `guard`: Keeps a value if a condition is met; otherwise returns an empty context.\n- `filter`: Retains values that satisfy a predicate.\n- `filter_map`: Applies a transformation and keeps results only when the transformed value is present.","ref":"readme.html#filtering"},{"type":"extras","title":"Sequencing - README","doc":"Sequencing runs a series of monadic operations in order, combining the results.\n\n- `concat/1`: Removes empty values and unwraps the present results from a list.\n- `concat_map/2`: Applies a function to each element and collects only the present results.\n- `sequence/1`: Converts a list of monadic values into a single monadic value containing a list. Short-circuits on the first failure or absence.\n- `traverse/2`: Applies a function to each element and sequences the resulting monadic values.\n- `sequence_a/1`: Applicative version of sequence—combines all and collects results.\n- `traverse_a/2`: Applicative version of traverse—applies a function to each element and collects results.","ref":"readme.html#sequencing"},{"type":"extras","title":"Lifting - README","doc":"Lifting functions promote ordinary logic into a monadic or contextual form.\n\n- `lift_predicate/3`: Wraps a value in a monad if a condition holds; returns an empty or failed context otherwise.\n- `lift_eq/1`: Adapts an `Eq` comparator to work within a monadic context.\n- `lift_ord/1`: Adapts an `Ord` comparator to work within a monadic context.","ref":"readme.html#lifting"},{"type":"extras","title":"Interop - README","doc":"Funx integrates with common Elixir patterns like `{:ok, value}` and `{:error, reason}`.\n\n- `from_result/1`: Converts a result tuple into a monadic context that distinguishes success from failure.\n- `to_result/1`: Converts a monadic value back into a result tuple.\n- `from_try/1`: Wraps a function call in a monad, capturing exceptions as failures.\n- `to_try!/1`: Extracts the value from a monad or raises if it represents a failure.","ref":"readme.html#interop"},{"type":"extras","title":"Documentation - README","doc":"Full documentation is available on [GitHub Pages](https://jkwa.github.io/funx/readme.html).","ref":"readme.html#documentation"},{"type":"extras","title":"Contributing - README","doc":"1. Fork the repository.  \n2. Create a new branch for the feature or bugfix (`git checkout -b feature-branch`).  \n3. Commit changes (`git commit -am 'Add new feature'`).  \n4. Push the branch (`git push origin feature-branch`).  \n5. Create a pull request.","ref":"readme.html#contributing"},{"type":"extras","title":"License - README","doc":"This project is licensed under the MIT License.","ref":"readme.html#license"},{"type":"extras","title":"Changelog","doc":"# Changelog","ref":"changelog.html"},{"type":"extras","title":"Beta Status (v0.1.x) - Changelog","doc":"⚠️ **Funx is in active development. APIs may change until version 1.0.**\n\nWe're currently in beta, focusing on:\n\n- Core functionality implementation and stabilization\n- Comprehensive usage rules and documentation for humans and LLMs\n- Real-world testing and feedback incorporation\n- API refinement based on practical usage patterns\n\n**Current Status**: Feature-complete beta with comprehensive documentation. Ready for experimentation and feedback, but expect potential API changes before 1.0.","ref":"changelog.html#beta-status-v0-1-x"},{"type":"extras","title":"Feedback Welcome - Changelog","doc":"- 🐛 **Issues**: [Report bugs and suggest improvements](https://github.com/JKWA/funx/issues)\n- 📖 **Documentation**: Help us improve usage rules and examples\n- 🧪 **Real-world usage**: Share your experience using Funx in projects\n- 💬 **Discussion**: Join conversations about functional programming patterns in Elixir\n\n---\n\n*Detailed changelog will begin with version 1.0. Until then, see [GitHub releases](https://github.com/JKWA/funx/releases) for version-specific changes.*","ref":"changelog.html#feedback-welcome"},{"type":"extras","title":"LICENSE","doc":"# MIT License\n\nCopyright (c) 2024 Joseph Koski\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.","ref":"license.html"},{"type":"extras","title":"Funx Usage Rules","doc":"# Funx Usage Rules (Index)\n\nUsage rules describe how to use Funx protocols and utilities in practice.  \nThey complement the module docs (which describe *what* the APIs do).  \n\nEach protocol or major module has its own `usage-rules.md`, stored next to the code.  \nThis index links them together.","ref":"usage-rules.html"},{"type":"extras","title":"Author's Voice and Approach - Funx Usage Rules","doc":"These usage rules reflect **Joseph Koski's** approach to functional programming in Elixir, developed alongside his book [**\"Advanced Functional Programming with Elixir\"**](https://pragprog.com/titles/jkelixir/advanced-functional-programming-with-elixir). \n\nThe documentation emphasizes **practical application over academic theory**, focusing on real-world patterns, business problems, and incremental adoption. Joseph's philosophy is that functional programming should be approachable and immediately useful, not an abstract mathematical exercise.\n\nWhen reading these usage rules, you're getting Joseph's perspective on how to effectively apply functional patterns in Elixir production systems.","ref":"usage-rules.html#author-s-voice-and-approach"},{"type":"extras","title":"Available Rules - Funx Usage Rules","doc":"- [Funx.Appendable Usage Rules](./appendable/usage-rules.md)  \n  Flexible aggregation for accumulating results - structured vs flat collection strategies.\n\n- [Funx.Eq Usage Rules](./eq/usage-rules.md)  \n  Domain-specific equality and identity for comparison, deduplication, and filtering.\n\n- [Funx.Errors.ValidationError Usage Rules](./errors/validation_error/usage-rules.md)  \n  Domain validation with structured error collection, composition, and Either integration.\n\n- [Funx.List Usage Rules](./list/usage-rules.md)  \n  Equality- and order-aware set operations, deduplication, and sorting.\n\n- [Funx.Monad Usage Rules](./monad/usage-rules.md)  \n  Declarative control flow with `map`, `bind`, and `ap`—composing context-aware steps.\n\n- [Funx.Monad.Either Usage Rules](./monad/either/usage-rules.md)  \n  Branching computation with error context—fail fast or accumulate validation errors.\n\n- [Funx.Monad.Identity Usage Rules](./monad/identity/usage-rules.md)  \n  Structure without effects—used as a baseline for composing monads.\n\n- [Funx.Monad.Maybe Usage Rules](./monad/maybe/usage-rules.md)  \n  Optional computation: preserve structure, short-circuit on absence, avoid `nil`.\n\n- [Funx.Monad.Reader Usage Rules](./monad/reader/usage-rules.md)  \n  Deferred computation with read-only environment access—dependency injection and configuration.\n\n- [Funx.Monoid Usage Rules](./monoid/usage-rules.md)  \n  Identity and associative combination, enabling folds, logs, and accumulation.\n\n- [Funx.Ord Usage Rules](./ord/usage-rules.md)  \n  Context-aware ordering for sorting, ranking, and prioritization.\n\n- [Funx.Predicate Usage Rules](./predicate/usage-rules.md)  \n  Logical composition using `&&`/`||`, reusable combinators, and lifted conditions.\n\n- [Funx.Utils Usage Rules](./utils/usage-rules.md)  \n  Currying, flipping, and function transformation for point-free, pipeline-friendly composition.","ref":"usage-rules.html#available-rules"},{"type":"extras","title":"Conventions - Funx Usage Rules","doc":"- Collocation: rules live beside the code they describe.  \n- Scope: focus on *usage guidance* and best practices, not API reference.  \n- LLM-friendly: small sections, explicit examples, stable links.","ref":"usage-rules.html#conventions"},{"type":"extras","title":"Project Layout (rules only) - Funx Usage Rules","doc":"```text\nlib/\n  usage-rules.md            # ← index (this file)\n  appendable/\n    usage-rules.md          # ← Funx.Appendable rules\n  eq/\n    usage-rules.md          # ← Funx.Eq rules\n  errors/\n    validation_error/\n      usage-rules.md        # ← Funx.Errors.ValidationError rules\n  list/\n    usage-rules.md          # ← Funx.List rules\n  monad/\n    usage-rules.md          # ← Funx.Monad rules\n    either/\n      usage-rules.md        # ← Funx.Monad.Either rules\n    identity/\n      usage-rules.md        # ← Funx.Monad.Identity rules\n    maybe/\n      usage-rules.md        # ← Funx.Monad.Maybe rules\n    reader/\n      usage-rules.md        # ← Funx.Monad.Reader rules\n  monoid/\n    usage-rules.md          # ← Funx.Monoid rules\n  ord/\n    usage-rules.md          # ← Funx.Ord rules\n  predicate/\n    usage-rules.md          # ← Funx.Predicate rules\n  utils/\n    usage-rules.md          # ← Funx.Utils rules\n```","ref":"usage-rules.html#project-layout-rules-only"},{"type":"extras","title":"Funx.Appendable Usage Rules","doc":"# `Funx.Appendable` Usage Rules","ref":"appendable-usage-rules.html"},{"type":"extras","title":"Core Concepts - Funx.Appendable Usage Rules","doc":"**Protocol + Any Fallback Pattern**: Use both together for maximum flexibility\n\n- **Protocol implementation** = custom aggregation logic for your domain types\n- **Any fallback** = flat list aggregation when no custom implementation exists\n- **Key insight**: Protocol provides structured accumulation, fallback provides universal compatibility\n\n**Coerce + Append Pattern**: Two-step aggregation process\n\n- `coerce/1` - normalizes input value into aggregatable form\n- `append/2` - combines two values of the same type\n- **Key pattern**: coerce first, then append - enables type-safe accumulation\n\n**Structured vs Flat Aggregation**: Choose accumulation strategy\n\n- **Flat aggregation** - uses Any fallback, collects values in plain list\n- **Structured aggregation** - uses custom protocol, maintains domain semantics","ref":"appendable-usage-rules.html#core-concepts"},{"type":"extras","title":"Decision: When to Use Each Strategy - Funx.Appendable Usage Rules","doc":"","ref":"appendable-usage-rules.html#decision-when-to-use-each-strategy"},{"type":"extras","title":"Use Protocol When: - Funx.Appendable Usage Rules","doc":"- You need domain-specific aggregation logic (ValidationError, Metrics, FormErrors)\n- Error context matters for debugging or user feedback\n- Combining values requires business logic (timestamps, severity levels, nested structures)\n- Type safety and structured data are important for downstream processing","ref":"appendable-usage-rules.html#use-protocol-when"},{"type":"extras","title":"Use Fallback When: - Funx.Appendable Usage Rules","doc":"- Simple collection is sufficient for your use case\n- You're working with heterogeneous data that doesn't need domain structure\n- Performance is critical and flat lists meet your needs\n- You're prototyping or in early development phases","ref":"appendable-usage-rules.html#use-fallback-when"},{"type":"extras","title":"Quick Patterns - Funx.Appendable Usage Rules","doc":"```elixir\n# STEP 1: Use Any fallback for simple aggregation\nvalidate_positive = fn x ->\n  Either.lift_predicate(x, &(&1 > 0), \"Must be positive: #{x}\")\nend\n\nEither.validate(-3, [validate_positive])\n# Left([\"Must be positive: -3\"])  # Flat list via Any fallback\n\n# STEP 2: Implement protocol for structured aggregation\ndefimpl Funx.Appendable, for: ValidationError do\n  def coerce(%ValidationError{errors: e}), do: ValidationError.new(e)\n  def append(%ValidationError{} = acc, %ValidationError{} = other) do\n    ValidationError.merge(acc, other)\n  end\nend\n\n# STEP 3: Use structured aggregation with custom protocol\nvalidate_with_structure = fn x ->\n  Either.lift_predicate(x, &(&1 > 0), \"Must be positive: #{x}\")\n  |> Either.map_left(&ValidationError.new/1)\nend\n\nEither.validate(-3, [validate_with_structure])\n# Left(ValidationError{errors: [\"Must be positive: -3\"]})  # Structured\n\n# STEP 4: Custom domain aggregation\ndefimpl Funx.Appendable, for: MyErrorReport do\n  def coerce(%MyErrorReport{} = report), do: report\n  def append(%MyErrorReport{errors: e1}, %MyErrorReport{errors: e2}) do\n    %MyErrorReport{\n      errors: e1 ++ e2,\n      timestamp: DateTime.utc_now(),\n      severity: max_severity(e1, e2)\n    }\n  end\nend\n```","ref":"appendable-usage-rules.html#quick-patterns"},{"type":"extras","title":"Key Rules - Funx.Appendable Usage Rules","doc":"- **IMPLEMENT PROTOCOL** when you need structured, domain-specific aggregation\n- **USE ANY FALLBACK** when flat list accumulation is sufficient\n- **MUST implement both** `coerce/1` and `append/2` (no optional defaults)\n- **ENSURE ASSOCIATIVITY** - `append(append(a, b), c) = append(a, append(b, c))`\n- **Pattern**: Custom protocol for structure, fallback for simplicity\n- **Integration**: Powers `validate/2`, `traverse_a/2`, and other accumulating operations","ref":"appendable-usage-rules.html#key-rules"},{"type":"extras","title":"When to Use - Funx.Appendable Usage Rules","doc":"- **Protocol implementation**: When you need structured aggregation with domain semantics\n- **Any fallback**: When simple list collection is sufficient for your use case\n- **Validation chains**: Error accumulation in `Either.validate/2`\n- **Parallel operations**: Result collection in `traverse_a/2`\n- **Custom domains**: Metrics, logs, reports that need special combination logic","ref":"appendable-usage-rules.html#when-to-use"},{"type":"extras","title":"Anti-Patterns - Funx.Appendable Usage Rules","doc":"```elixir\n# ❌ Don't forget associativity requirement\ndefimpl Funx.Appendable, for: BadExample do\n  def append(a, b), do: %BadExample{value: a.value - b.value}  # Not associative!\nend\n\n# ❌ Don't mix flat and structured in same pipeline\nEither.validate(data, [\n  fn x -> Either.left(\"simple error\") end,              # String\n  fn x -> Either.left(ValidationError.new(\"struct\")) end # ValidationError - inconsistent!\n])\n\n# ❌ Don't implement protocol unnecessarily\ndefimpl Funx.Appendable, for: SimpleList do\n  def coerce(list), do: list\n  def append(a, b), do: a ++ b  # Same as Any fallback - unnecessary!\nend\n\n# ❌ Don't violate coerce expectations\ndefimpl Funx.Appendable, for: WrongExample do\n  def coerce(value), do: transform_completely(value)  # Should normalize, not transform!\n  def append(a, b), do: combine(a, b)\nend\n```","ref":"appendable-usage-rules.html#anti-patterns"},{"type":"extras","title":"Testing - Funx.Appendable Usage Rules","doc":"```elixir\ntest \"Appendable laws hold\" do\n  e1 = ValidationError.new([\"error 1\"])\n  e2 = ValidationError.new([\"error 2\"])\n  e3 = ValidationError.new([\"error 3\"])\n  \n  # Associativity: (a + b) + c = a + (b + c)\n  left_assoc = Appendable.append(Appendable.append(e1, e2), e3)\n  right_assoc = Appendable.append(e1, Appendable.append(e2, e3))\n  assert left_assoc.errors == right_assoc.errors\nend\n\ntest \"coerce normalizes values\" do\n  # Coerce should normalize, not transform\n  original = ValidationError.new([\"test\"])\n  coerced = Appendable.coerce(original)\n  assert coerced == original  # Should be normalized form\nend\n\ntest \"Any fallback works for unknown types\" do\n  # Any implementation provides universal compatibility\n  result = Appendable.append(\"hello\", \"world\")\n  assert result == [\"hello\", \"world\"]\n  \n  result = Appendable.append([\"a\", \"b\"], \"c\")\n  assert result == [\"a\", \"b\", \"c\"]\nend\n\ntest \"integration with Either.validate\" do\n  validators = [\n    fn x -> if x > 0, do: Either.right(x), \n            else: Either.left(ValidationError.new([\"must be positive\"])) end,\n    fn x -> if rem(x, 2) == 0, do: Either.right(x), \n            else: Either.left(ValidationError.new([\"must be even\"])) end\n  ]\n  \n  case Either.validate(-3, validators) do\n    %Left{left: %ValidationError{errors: errors}} ->\n      assert \"must be positive\" in errors\n      assert \"must be even\" in errors\n      assert length(errors) == 2\n    _ -> flunk(\"Expected accumulated validation errors\")\n  end\nend\n```","ref":"appendable-usage-rules.html#testing"},{"type":"extras","title":"Core Functions - Funx.Appendable Usage Rules","doc":"","ref":"appendable-usage-rules.html#core-functions"},{"type":"extras","title":"Protocol Functions - Funx.Appendable Usage Rules","doc":"```elixir\n# Normalize value for aggregation\nAppendable.coerce(ValidationError.new([\"error\"]))\n# Result: %ValidationError{errors: [\"error\"]}\n\n# Combine two values\nve1 = ValidationError.new([\"error 1\"])\nve2 = ValidationError.new([\"error 2\"])\nAppendable.append(ve1, ve2)\n# Result: %ValidationError{errors: [\"error 1\", \"error 2\"]}\n```","ref":"appendable-usage-rules.html#protocol-functions"},{"type":"extras","title":"Any Fallback Functions - Funx.Appendable Usage Rules","doc":"```elixir\n# Universal list coercion\nAppendable.coerce(\"single value\")  # Result: [\"single value\"]\nAppendable.coerce([\"already\", \"list\"])  # Result: [\"already\", \"list\"]\n\n# Universal list combination\nAppendable.append([\"a\", \"b\"], [\"c\", \"d\"])  # Result: [\"a\", \"b\", \"c\", \"d\"]\nAppendable.append(\"single\", [\"list\"])      # Result: [\"single\", \"list\"]\n```","ref":"appendable-usage-rules.html#any-fallback-functions"},{"type":"extras","title":"How the Any Fallback Works - Funx.Appendable Usage Rules","doc":"**Automatic List Coercion**: Values are normalized into lists for universal compatibility\n\n- `coerce(\"single value\")` → `[\"single value\"]` (wraps non-lists)\n- `coerce([\"already\", \"list\"])` → `[\"already\", \"list\"]` (preserves lists)\n- **Key insight**: Every value becomes list-compatible for aggregation\n\n**Flat List Combination**: Uses `++` operator for simple concatenation\n\n- `append([\"a\", \"b\"], [\"c\", \"d\"])` → `[\"a\", \"b\", \"c\", \"d\"]`\n- `append(\"single\", [\"list\"])` → `[\"single\", \"list\"]` (coerces then appends)\n- **Performance note**: O(n) for each append operation due to list concatenation\n\n**Protocol Dispatch Skip**: When no custom implementation exists, Any fallback activates\n\n- No struct-specific logic needed\n- Universal compatibility across all types\n- Simple, predictable behavior for mixed-type scenarios","ref":"appendable-usage-rules.html#how-the-any-fallback-works"},{"type":"extras","title":"Integration with Monadic Operations - Funx.Appendable Usage Rules","doc":"","ref":"appendable-usage-rules.html#integration-with-monadic-operations"},{"type":"extras","title":"Either.validate Integration - Funx.Appendable Usage Rules","doc":"**Note on map_left**: While Appendable itself doesn't provide `map`, it frequently appears within monadic transformations like `map_left` for wrapping structured errors.\n\n```elixir\n# Flat aggregation (Any fallback)\nEither.validate(data, [\n  fn x -> Either.left(\"error 1\") end,\n  fn x -> Either.left(\"error 2\") end\n])\n# Result: Left([\"error 1\", \"error 2\"])\n\n# Structured aggregation (custom protocol with map_left)\nvalidate_with_structure = fn x ->\n  Either.lift_predicate(x, &valid?/1, \"validation failed\")\n  |> Either.map_left(&ValidationError.new/1)  # map_left wraps for Appendable\nend\n\nEither.validate(data, [validate_with_structure])\n# Result: Left(ValidationError{errors: [\"validation failed\"]})\n```","ref":"appendable-usage-rules.html#either-validate-integration"},{"type":"extras","title":"traverse_a Integration - Funx.Appendable Usage Rules","doc":"```elixir\n# Accumulate results using Appendable\ndata = [invalid1, invalid2, valid3]\nkleisli_validator = fn item ->\n  if valid?(item) do\n    Either.right(process(item))\n  else\n    Either.left(ValidationError.new([\"Invalid: #{item}\"]))\n  end\nend\n\nEither.traverse_a(data, kleisli_validator)\n# Result: Left(ValidationError{errors: [\"Invalid: invalid1\", \"Invalid: invalid2\"]})\n```","ref":"appendable-usage-rules.html#traverse_a-integration"},{"type":"extras","title":"Custom Domain Integration - Funx.Appendable Usage Rules","doc":"```elixir\n# Custom metrics aggregation\ndefimpl Funx.Appendable, for: Metrics do\n  def coerce(%Metrics{} = m), do: m\n  def append(%Metrics{count: c1, sum: s1}, %Metrics{count: c2, sum: s2}) do\n    %Metrics{count: c1 + c2, sum: s1 + s2}\n  end\nend\n\n# Use with parallel operations\nEither.traverse_a(data, &collect_metrics/1)\n# Result: Right(Metrics{count: total_count, sum: total_sum})\n```","ref":"appendable-usage-rules.html#custom-domain-integration"},{"type":"extras","title":"Advanced Patterns - Funx.Appendable Usage Rules","doc":"","ref":"appendable-usage-rules.html#advanced-patterns"},{"type":"extras","title":"Conditional Aggregation - Funx.Appendable Usage Rules","doc":"```elixir\n# Choose aggregation strategy based on context\ndef validate_with_strategy(data, strategy) do\n  validators = case strategy do\n    :strict -> strict_validators() |> Enum.map(&wrap_in_validation_error/1)\n    :lenient -> lenient_validators()  # Use Any fallback\n  end\n  \n  Either.validate(data, validators)\nend\n```","ref":"appendable-usage-rules.html#conditional-aggregation"},{"type":"extras","title":"Monoid-like Aggregation - Funx.Appendable Usage Rules","doc":"```elixir\n# Empty/identity-like behavior\ndefimpl Funx.Appendable, for: OptionalResult do\n  def coerce(%OptionalResult{} = r), do: r\n  def append(%OptionalResult{present: false}, other), do: other  # Identity-like\n  def append(first, %OptionalResult{present: false}), do: first  # Identity-like\n  def append(first, second), do: combine_results(first, second)\nend\n```","ref":"appendable-usage-rules.html#monoid-like-aggregation"},{"type":"extras","title":"Hierarchical Aggregation - Funx.Appendable Usage Rules","doc":"```elixir\n# Nested error structures\ndefimpl Funx.Appendable, for: FormErrors do\n  def coerce(%FormErrors{} = fe), do: fe\n  def append(%FormErrors{field_errors: fe1}, %FormErrors{field_errors: fe2}) do\n    %FormErrors{\n      field_errors: Map.merge(fe1, fe2, fn _key, v1, v2 -> \n        Appendable.append(v1, v2)  # Recursive aggregation\n      end)\n    }\n  end\nend\n```","ref":"appendable-usage-rules.html#hierarchical-aggregation"},{"type":"extras","title":"Performance Considerations - Funx.Appendable Usage Rules","doc":"- Appendable operations should be efficient for repeated aggregation\n- `coerce/1` is called on every value - keep it lightweight\n- `append/2` is called repeatedly during accumulation - optimize for performance\n- Consider lazy evaluation for expensive aggregation operations\n- Any fallback uses list concatenation - O(n) for each append operation","ref":"appendable-usage-rules.html#performance-considerations"},{"type":"extras","title":"Best Practices - Funx.Appendable Usage Rules","doc":"- Implement Appendable for types that need structured accumulation\n- Keep coerce/1 as a normalization step, not a transformation\n- Ensure append/2 is associative for predictable behavior\n- Use Any fallback when simple list collection is sufficient\n- Test associativity law in your implementations\n- Consider performance implications of repeated aggregation\n- Document domain-specific aggregation semantics clearly","ref":"appendable-usage-rules.html#best-practices"},{"type":"extras","title":"Design Patterns - Funx.Appendable Usage Rules","doc":"","ref":"appendable-usage-rules.html#design-patterns"},{"type":"extras","title":"Error Accumulation Pattern - Funx.Appendable Usage Rules","doc":"Use Appendable to collect validation errors without coupling to specific error types:\n\n```elixir\ndef validate_user(user_data) do\n  validators = [\n    &validate_email/1,\n    &validate_password/1,\n    &validate_age/1\n  ]\n  \n  Either.validate(user_data, validators)  # Uses Appendable automatically\nend\n```","ref":"appendable-usage-rules.html#error-accumulation-pattern"},{"type":"extras","title":"Metrics Collection Pattern - Funx.Appendable Usage Rules","doc":"Aggregate domain metrics using custom Appendable implementations:\n\n```elixir\ndef collect_processing_metrics(items) do\n  Either.traverse_a(items, &process_with_metrics/1)\n  # Automatically aggregates metrics using custom Appendable\nend\n```","ref":"appendable-usage-rules.html#metrics-collection-pattern"},{"type":"extras","title":"Flexible Aggregation Pattern - Funx.Appendable Usage Rules","doc":"Choose aggregation strategy at runtime without changing core logic:\n\n```elixir\ndef process_with_aggregation(data, error_type) do\n  validator = case error_type do\n    :structured -> &wrap_in_custom_error/1\n    :simple -> &return_simple_string/1\n  end\n  \n  Either.validate(data, [validator])  # Appendable handles both cases\nend\n```","ref":"appendable-usage-rules.html#flexible-aggregation-pattern"},{"type":"extras","title":"Summary - Funx.Appendable Usage Rules","doc":"`Funx.Appendable` provides **flexible, type-safe aggregation** for accumulating results across monadic operations:\n\n- **Custom protocol** - implement for structured, domain-specific aggregation\n- **Any fallback** - universal flat list aggregation for simple cases  \n- **Two-step process** - coerce for normalization, append for combination\n- **Associative requirement** - ensures predictable aggregation behavior\n- **Monadic integration** - powers `validate/2`, `traverse_a/2`, and other accumulating operations\n- **Performance aware** - optimize coerce/append for repeated aggregation scenarios\n\n**Canon**: Use custom Appendable for structured accumulation, rely on Any fallback for simple collection, ensure associativity in implementations.","ref":"appendable-usage-rules.html#summary"},{"type":"extras","title":"Funx.Eq Usage Rules","doc":"# `Funx.Eq` Usage Rules","ref":"eq-usage-rules.html"},{"type":"extras","title":"Core Concepts - Funx.Eq Usage Rules","doc":"**Protocol + Custom Eq Pattern**: Use both together for maximum flexibility\n\n- **Protocol implementation** = domain's default equality (whatever makes business sense)\n- **Custom Eq injection** = context-specific equality when needed\n- **Key insight**: Protocol provides sensible defaults, custom Eq provides flexibility\n\n**Contramap**: Contravariant functor - transforms inputs before comparison\n\n- `contramap(& &1.id, Eq)` compares by ID field only\n- Mathematical dual of `map` - transforms \"backwards\" through the data flow\n- Key pattern: transform the input, not the comparison result\n\n**Utils Pattern**: Inject custom Eq logic or default to protocol\n\n- `Eq.Utils.eq?(a, b, custom_eq)` - uses custom_eq\n- `Eq.Utils.eq?(a, b)` - uses protocol dispatch\n\n**Monoid Composition**: Combine equality checks\n\n- `append_all/any(eq1, eq2)` - combine two (FALSE/TRUE-biased)\n- `concat_all/any([eq1, eq2, eq3])` - combine list (FALSE/TRUE-biased)","ref":"eq-usage-rules.html#core-concepts"},{"type":"extras","title":"Quick Patterns - Funx.Eq Usage Rules","doc":"```elixir\n# STEP 1: Implement protocol for domain's default equality\ndefimpl Funx.Eq, for: User do\n  def eq?(%User{id: id1}, %User{id: id2}), do: Funx.Eq.eq?(id1, id2)\n  def not_eq?(a, b), do: not eq?(a, b)\nend\n\n# STEP 2: Use protocol directly for default equality\nEq.eq?(user1, user2)  # Uses protocol (by ID)\nList.uniq(users)      # Uses protocol default\n\n# STEP 3: Inject custom Eq for specific contexts\nby_name = Eq.Utils.contramap(& &1.name)\nEq.Utils.eq?(user1, user2, by_name)  # Compare by name instead\nList.uniq(users, by_name)            # Dedupe by name, not ID\n\n# Combine fields\nname_and_age = Eq.Utils.concat_all([\n  Eq.Utils.contramap(& &1.name),\n  Eq.Utils.contramap(& &1.age)\n])\n\n# Use with Funx.List\nFunx.List.uniq(users, by_id)\n```","ref":"eq-usage-rules.html#quick-patterns"},{"type":"extras","title":"Key Rules - Funx.Eq Usage Rules","doc":"- **IMPLEMENT PROTOCOL** for domain's default equality (whatever makes business sense)\n- **USE CUSTOM EQ** when you need different equality for specific operations\n- **MUST implement both** `eq?/2` and `not_eq?/2` (no optional defaults)\n- **Best practice**: `not_eq?(a, b) = not eq?(a, b)`\n- Use `contramap/2` to transform inputs before comparison\n- Use monoid functions for composition: `append_all/any`, `concat_all/any`\n- Pattern: Protocol for defaults, Utils injection for flexibility","ref":"eq-usage-rules.html#key-rules"},{"type":"extras","title":"When to Use - Funx.Eq Usage Rules","doc":"- **Protocol implementation**: When you need domain's default equality (whatever makes business sense, not structural equality)\n- **Custom Eq injection**: When you need different equality for specific contexts\n- Deduplication with `Funx.List.uniq/2` (protocol default or custom)\n- Set operations (`union`, `intersection`, etc.)\n- Context-specific filtering and comparison logic","ref":"eq-usage-rules.html#when-to-use"},{"type":"extras","title":"Anti-Patterns - Funx.Eq Usage Rules","doc":"```elixir\n# ❌ Don't mix == and Eq.eq?\nif user1 == user2 and Eq.eq?(user1.name, user2.name), do: ...\n\n# ❌ Don't forget not_eq?/2\ndefimpl Funx.Eq, for: User do\n  def eq?(%User{id: id1}, %User{id: id2}), do: id1 == id2\n  # Missing not_eq?/2!\nend\n\n# ❌ Don't transform comparison result\ncontramap(fn result -> not result end)  # Wrong!\n```","ref":"eq-usage-rules.html#anti-patterns"},{"type":"extras","title":"Testing - Funx.Eq Usage Rules","doc":"```elixir\ntest \"Eq laws hold\" do\n  # Reflexivity: a == a\n  assert Eq.eq?(user, user)\n  \n  # Symmetry: a == b implies b == a  \n  assert Eq.eq?(user1, user2) == Eq.eq?(user2, user1)\n  \n  # Complement: eq? and not_eq? are opposites\n  assert Eq.eq?(user1, user2) == not Eq.not_eq?(user1, user2)\nend\n\ntest \"contramap preserves Eq laws\" do\n  by_id = Eq.Utils.contramap(& &1.id)\n  user1 = %User{id: 1, name: \"Alice\"}\n  user2 = %User{id: 1, name: \"Bob\"}  # Same ID, different name\n  \n  # Contramap projection maintains equality laws\n  assert by_id.eq?.(user1, user2)  # Same ID\n  assert by_id.eq?.(user1, user1)  # Reflexive\nend\n\ntest \"monoid composition laws\" do\n  eq1 = Eq.Utils.contramap(& &1.name)\n  eq2 = Eq.Utils.contramap(& &1.age)\n  \n  # Monoid bias behavior\n  all_eq = Eq.Utils.concat_all([eq1, eq2])  # FALSE-biased\n  any_eq = Eq.Utils.concat_any([eq1, eq2])  # TRUE-biased\n  \n  person1 = %{name: \"Alice\", age: 25}\n  person2 = %{name: \"Alice\", age: 30}  # Name matches, age differs\n  \n  assert any_eq.eq?.(person1, person2)  # TRUE-bias: stops at name match\n  refute all_eq.eq?.(person1, person2) # FALSE-bias: fails on age difference\nend\n```","ref":"eq-usage-rules.html#testing"},{"type":"extras","title":"Fallback Behavior - Funx.Eq Usage Rules","doc":"- **Any protocol**: Uses Elixir's `==` and `!=` for primitive types\n- **Custom types**: Define explicit `Eq` implementation for domain logic\n- **Time types**: Built-in instances use standard library comparison","ref":"eq-usage-rules.html#fallback-behavior"},{"type":"extras","title":"Summary - Funx.Eq Usage Rules","doc":"`Funx.Eq` provides **extensible, composable equality** for domain semantics beyond structural `==`:\n\n- **Contramap** (contravariant functor): Transform inputs before comparison\n- **Monoid composition**: Combine equality checks with FALSE/TRUE-biased operations  \n- **Utils injection**: `Eq.Utils.eq?(a, b, custom_eq)` pattern for flexible equality\n- **Protocol + fallback**: Custom domain logic with `Any` fallback for primitives\n- **Mathematical foundation**: Preserves equality laws through transformations and composition\n\n**Canon**: Use `contramap` for projections, monoid functions for composition, Utils injection for flexibility.","ref":"eq-usage-rules.html#summary"},{"type":"extras","title":"Funx.Errors.ValidationError Usage Rules","doc":"# `Funx.Errors.ValidationError` Usage Rules","ref":"errors-validation-error-usage-rules.html"},{"type":"extras","title":"Core Concepts - Funx.Errors.ValidationError Usage Rules","doc":"**Domain Validation**: User-facing validation errors with structured messages\n\n- Wraps one or more validation failure messages\n- Used with `Either.Left` to represent validation failures\n- Composable and mergeable for comprehensive error collection\n\n**Either Integration**: Primary use in Either-based validation chains\n\n- `ValidationError` as Left value in `Either.Left` \n- Integrates with `Either.validate/2` for comprehensive validation\n- Use `map_left` to wrap errors in ValidationError struct\n\n**Appendable Composition**: Combine multiple validation errors\n\n- `merge/2` - combines two ValidationError structs\n- `Appendable` protocol - enables automatic error accumulation\n- `empty/0` - provides identity for composition","ref":"errors-validation-error-usage-rules.html#core-concepts"},{"type":"extras","title":"Quick Patterns - Funx.Errors.ValidationError Usage Rules","doc":"```elixir\nalias Funx.Errors.ValidationError\nimport Funx.Monad, only: [map: 2, bind: 2]\n\n# Single validator returning ValidationError\nvalidate_positive = fn x ->\n  if x > 0 do\n    Either.right(x)\n  else\n    Either.left(ValidationError.new(\"Value must be positive: #{x}\"))\n  end\nend\n\n# PREFERRED: Use Either.validate/2 for comprehensive validation\nvalidators = [\n  fn x -> Either.lift_predicate(x, &(&1 > 0), \"Must be positive\")\n           |> Either.map_left(&ValidationError.new/1) end,\n  fn x -> Either.lift_predicate(x, &(rem(&1, 2) == 0), \"Must be even\") \n           |> Either.map_left(&ValidationError.new/1) end\n]\n\nEither.validate(-3, validators)\n# Left(ValidationError{errors: [\"Must be positive\", \"Must be even\"]})\n\n# Form validation with comprehensive errors\nEither.validate(form_data, [\n  &validate_name_field/1,\n  &validate_email_field/1, \n  &validate_age_field/1\n]) |> Either.map_left(&format_validation_response/1)\n```","ref":"errors-validation-error-usage-rules.html#quick-patterns"},{"type":"extras","title":"Key Rules - Funx.Errors.ValidationError Usage Rules","doc":"- **Always wrap in Either.Left** for validation failures - never use bare ValidationError\n- **Use list format for errors** - `[\"error1\", \"error2\"]` not single strings\n- **Prefer Either.validate/2** over manual error accumulation\n- **Use map_left to wrap** regular error messages in ValidationError struct\n- **Implement Exception** behavior when validation must halt execution\n- **Merge compatible** - use `merge/2` to combine multiple ValidationError instances","ref":"errors-validation-error-usage-rules.html#key-rules"},{"type":"extras","title":"When to Use - Funx.Errors.ValidationError Usage Rules","doc":"- Form validation with multiple field errors\n- Domain validation that collects all problems\n- API validation responses that need comprehensive error lists\n- Business rule validation with structured error reporting\n- Validation chains where partial success isn't meaningful","ref":"errors-validation-error-usage-rules.html#when-to-use"},{"type":"extras","title":"Anti-Patterns - Funx.Errors.ValidationError Usage Rules","doc":"```elixir\n# Don't use ValidationError directly without Either\ndef validate_user(user) do\n  ValidationError.new(\"Invalid user\")  # No context!\nend\n\n# Don't mix ValidationError with simple strings in Left\nEither.left(\"simple error\")  # Then later...\nEither.left(ValidationError.new(\"structured error\"))  # Inconsistent!\n\n# Don't forget to accumulate errors\ndef validate_fields(data) do\n  case validate_name(data.name) do\n    {:error, name_error} -> Either.left(ValidationError.new(name_error))\n    {:ok, _} ->\n      case validate_email(data.email) do  # Lost name validation!\n        {:error, email_error} -> Either.left(ValidationError.new(email_error))\n        {:ok, _} -> Either.right(data)\n      end\n  end\nend\n\n# Don't create ValidationError with single string when you need lists\nValidationError.new(\"single error\")  # Use list format for consistency\n```","ref":"errors-validation-error-usage-rules.html#anti-patterns"},{"type":"extras","title":"Testing - Funx.Errors.ValidationError Usage Rules","doc":"```elixir\ntest \"validation error accumulation\" do\n  validators = [\n    fn x -> if x > 0, do: Either.right(x), \n            else: Either.left(ValidationError.new([\"must be positive\"])) end,\n    fn x -> if rem(x, 2) == 0, do: Either.right(x), \n            else: Either.left(ValidationError.new([\"must be even\"])) end\n  ]\n  \n  case Either.validate(-3, validators) do\n    %Left{left: %ValidationError{errors: errors}} ->\n      assert \"must be positive\" in errors\n      assert \"must be even\" in errors\n      assert length(errors) == 2\n    _ -> flunk(\"Expected validation errors\")\n  end\nend\n\ntest \"ValidationError composition\" do\n  ve1 = ValidationError.new([\"error 1\"])\n  ve2 = ValidationError.new([\"error 2\"]) \n  \n  merged = ValidationError.merge(ve1, ve2)\n  assert merged.errors == [\"error 1\", \"error 2\"]\nend\n\ntest \"Exception behavior\" do\n  assert_raise ValidationError, \"must be positive\", fn ->\n    raise ValidationError, errors: [\"must be positive\"]\n  end\nend\n```","ref":"errors-validation-error-usage-rules.html#testing"},{"type":"extras","title":"Core Functions - Funx.Errors.ValidationError Usage Rules","doc":"","ref":"errors-validation-error-usage-rules.html#core-functions"},{"type":"extras","title":"Construction Functions - Funx.Errors.ValidationError Usage Rules","doc":"```elixir\n# Create from list of error messages\nValidationError.new([\"must be positive\", \"must be even\"])\n\n# Create from single error message  \nValidationError.new(\"must be positive\")\n# Result: %ValidationError{errors: [\"must be positive\"]}\n\n# Empty validation error (identity for composition)\nValidationError.empty()\n# Result: %ValidationError{errors: []}\n\n# Convert from tagged error tuple\nValidationError.from_tagged({:error, [\"field errors\"]})\n```","ref":"errors-validation-error-usage-rules.html#construction-functions"},{"type":"extras","title":"Composition Functions - Funx.Errors.ValidationError Usage Rules","doc":"```elixir\n# Merge two ValidationError structs\nve1 = ValidationError.new([\"error 1\"])\nve2 = ValidationError.new([\"error 2\"])\nValidationError.merge(ve1, ve2)\n# Result: %ValidationError{errors: [\"error 1\", \"error 2\"]}\n\n# Appendable protocol (automatic with Either.validate/2)\nimport Funx.Appendable\nappend(ve1, ve2)  # Same as merge/2\n```","ref":"errors-validation-error-usage-rules.html#composition-functions"},{"type":"extras","title":"Exception Functions - Funx.Errors.ValidationError Usage Rules","doc":"```elixir\n# Raise as exception with error list\nraise ValidationError, errors: [\"critical validation failure\"]\n\n# Raise as exception with single message\nraise ValidationError, \"critical validation failure\"  \n\n# Get exception message\nException.message(%ValidationError{errors: [\"a\", \"b\"]})\n# Result: \"a, b\"\n```","ref":"errors-validation-error-usage-rules.html#exception-functions"},{"type":"extras","title":"Integration with Either - Funx.Errors.ValidationError Usage Rules","doc":"","ref":"errors-validation-error-usage-rules.html#integration-with-either"},{"type":"extras","title":"Validation Chains - Funx.Errors.ValidationError Usage Rules","doc":"```elixir\n# Sequential validation (fails on first error)\nEither.right(user_input)\n|> bind(&parse_user_data/1)\n|> bind(&validate_business_rules/1)  # Returns Either with ValidationError\n|> bind(&save_to_database/1)\n\n# Comprehensive validation (collects all errors)  \nEither.validate(user_data, [\n  &validate_name/1,     # Each returns Either Left(ValidationError) or Right\n  &validate_email/1,\n  &validate_age/1\n])\n```","ref":"errors-validation-error-usage-rules.html#validation-chains"},{"type":"extras","title":"Converting Simple Errors to ValidationError - Funx.Errors.ValidationError Usage Rules","doc":"```elixir\n# Wrap simple error messages\nsimple_validator = fn data ->\n  if valid?(data) do\n    Either.right(data)\n  else\n    Either.left(\"Invalid data\")\n  end\nend\n\n# Convert to ValidationError format\nenhanced_validator = fn data ->\n  simple_validator.(data)\n  |> Either.map_left(&ValidationError.new/1)\nend\n\n# Or use lift_predicate with map_left\nvalidate_positive = fn x ->\n  Either.lift_predicate(x, &(&1 > 0), \"Must be positive\")\n  |> Either.map_left(&ValidationError.new/1)\nend\n```","ref":"errors-validation-error-usage-rules.html#converting-simple-errors-to-validationerror"},{"type":"extras","title":"Form Validation Pattern - Funx.Errors.ValidationError Usage Rules","doc":"```elixir\ndef validate_registration_form(form_data) do\n  validators = [\n    create_name_validator(form_data),\n    create_email_validator(form_data), \n    create_password_validator(form_data)\n  ]\n  \n  Either.validate(form_data, validators)\n  |> case do\n    %Right{right: validated_data} -> \n      {:ok, validated_data}\n    %Left{left: %ValidationError{errors: errors}} ->\n      {:error, %{validation_errors: errors}}\n  end\nend\n\ndefp create_name_validator(form_data) do\n  fn _data ->\n    if String.length(form_data.name) > 0 do\n      Either.right(form_data.name)\n    else\n      Either.left(ValidationError.new([\"Name is required\"]))\n    end\n  end\nend\n```","ref":"errors-validation-error-usage-rules.html#form-validation-pattern"},{"type":"extras","title":"Protocol Implementations - Funx.Errors.ValidationError Usage Rules","doc":"","ref":"errors-validation-error-usage-rules.html#protocol-implementations"},{"type":"extras","title":"String.Chars - Funx.Errors.ValidationError Usage Rules","doc":"```elixir\nto_string(ValidationError.new([\"error 1\", \"error 2\"]))\n# Result: \"ValidationError(error 1, error 2)\"\n\nto_string(ValidationError.empty())\n# Result: \"ValidationError()\"\n```","ref":"errors-validation-error-usage-rules.html#string-chars"},{"type":"extras","title":"Funx.Eq and Funx.Ord - Funx.Errors.ValidationError Usage Rules","doc":"```elixir\n# Comparison based on errors list\nve1 = ValidationError.new([\"a\"])\nve2 = ValidationError.new([\"b\"])\n\nEq.eq?(ve1, ve1)        # true  \nEq.eq?(ve1, ve2)        # false\nOrd.lt?(ve1, ve2)       # true (\"a\" < \"b\")\n```","ref":"errors-validation-error-usage-rules.html#funx-eq-and-funx-ord"},{"type":"extras","title":"Funx.Appendable - Funx.Errors.ValidationError Usage Rules","doc":"```elixir\n# Automatic composition in Either.validate/2\nimport Funx.Appendable\n\nve1 = ValidationError.new([\"error 1\"])\nve2 = ValidationError.new([\"error 2\"])\n\nappend(ve1, ve2)\n# Result: %ValidationError{errors: [\"error 1\", \"error 2\"]}\n```","ref":"errors-validation-error-usage-rules.html#funx-appendable"},{"type":"extras","title":"Advanced Patterns - Funx.Errors.ValidationError Usage Rules","doc":"","ref":"errors-validation-error-usage-rules.html#advanced-patterns"},{"type":"extras","title":"Curried Validation Functions - Funx.Errors.ValidationError Usage Rules","doc":"```elixir\n# Create reusable validators with currying\nvalidate_height = curry_r(&ensure_height/2)\nvalidate_age = curry_r(&ensure_age/2)\n\n# Apply to specific context\npatron\n|> Either.validate([\n  validate_height.(ride),\n  validate_age.(ride) \n])\n```","ref":"errors-validation-error-usage-rules.html#curried-validation-functions"},{"type":"extras","title":"Fallback Validation with or_else - Funx.Errors.ValidationError Usage Rules","doc":"```elixir\n# Try primary validation, fallback to secondary  \ndef ensure_vip_or_fast_pass(patron, ride) do\n  patron\n  |> Either.lift_predicate(&Patron.vip?/1, \"#{Patron.get_name(patron)} is not a VIP\")\n  |> Either.map_left(&ValidationError.new/1)\n  |> Either.or_else(fn -> ensure_fast_pass(patron, ride) end)\nend\n```","ref":"errors-validation-error-usage-rules.html#fallback-validation-with-or_else"},{"type":"extras","title":"Sequential vs Comprehensive Validation - Funx.Errors.ValidationError Usage Rules","doc":"```elixir\n# Sequential: stop on first failure (bind)\ndef ensure_eligibility(patron, ride) do\n  validate_height = curry_r(&ensure_height/2)\n  \n  patron\n  |> ensure_age(ride)\n  |> bind(validate_height.(ride))\nend\n\n# Comprehensive: collect all failures (validate)\ndef validate_eligibility(patron, ride) do\n  validate_height = curry_r(&ensure_height/2)\n  validate_age = curry_r(&ensure_age/2)\n  \n  patron\n  |> Either.validate([\n    validate_height.(ride),\n    validate_age.(ride)\n  ])\nend\n```","ref":"errors-validation-error-usage-rules.html#sequential-vs-comprehensive-validation"},{"type":"extras","title":"Error Message Transformation - Funx.Errors.ValidationError Usage Rules","doc":"```elixir\n# Transform detailed errors to user-friendly messages\nvalidate_eligibility = curry_r(fn patron, ride ->\n  validate_eligibility(patron, ride)\n  |> Either.map_left(fn _ -> \n    \"#{Patron.get_name(patron)} is not eligible for this ride\"\n  end)\nend)\n\n# Select first error from comprehensive validation\nEither.validate(patron, validators)\n|> Either.map_left(fn [first | _] -> first end)\n```","ref":"errors-validation-error-usage-rules.html#error-message-transformation"},{"type":"extras","title":"List Validation Patterns - Funx.Errors.ValidationError Usage Rules","doc":"```elixir\n# Fail-fast list validation (traverse)\ndef ensure_group_eligibility(patrons, ride) do\n  eligible_for_ride = curry_r(&ensure_eligibility/2)\n  \n  Either.traverse(patrons, eligible_for_ride.(ride))\nend\n\n# Comprehensive list validation (traverse_a)\ndef validate_group_eligibility(patrons, ride) do  \n  validate_eligibility = curry_r(&validate_eligibility/2)\n  \n  Either.traverse_a(patrons, validate_eligibility.(ride))\nend\n```","ref":"errors-validation-error-usage-rules.html#list-validation-patterns"},{"type":"extras","title":"Common Patterns - Funx.Errors.ValidationError Usage Rules","doc":"","ref":"errors-validation-error-usage-rules.html#common-patterns"},{"type":"extras","title":"API Validation Response - Funx.Errors.ValidationError Usage Rules","doc":"```elixir\ndef validate_api_request(request) do\n  validators = [\n    &validate_authentication/1,\n    &validate_authorization/1,\n    &validate_request_format/1,\n    &validate_business_rules/1\n  ]\n  \n  case Either.validate(request, validators) do\n    %Right{right: valid_request} ->\n      {:ok, valid_request}\n    %Left{left: %ValidationError{errors: errors}} ->\n      {:error, %{\n        status: :validation_failed,\n        errors: errors,\n        timestamp: DateTime.utc_now()\n      }}\n  end\nend\n```","ref":"errors-validation-error-usage-rules.html#api-validation-response"},{"type":"extras","title":"Multi-Step Validation - Funx.Errors.ValidationError Usage Rules","doc":"```elixir\ndef validate_user_registration(data) do\n  # Step 1: Format validation\n  format_result = Either.validate(data, [\n    &validate_email_format/1,\n    &validate_password_format/1\n  ])\n  \n  # Step 2: Business rules validation (only if format is valid)\n  case format_result do\n    %Right{right: _} ->\n      Either.validate(data, [\n        &validate_email_unique/1,\n        &validate_password_strength/1\n      ])\n    error -> error\n  end\nend\n```","ref":"errors-validation-error-usage-rules.html#multi-step-validation"},{"type":"extras","title":"Error Recovery - Funx.Errors.ValidationError Usage Rules","doc":"```elixir\ndef process_with_validation(data) do\n  case validate_strict_rules(data) do\n    %Right{right: valid_data} -> \n      {:ok, valid_data}\n    %Left{left: %ValidationError{errors: errors}} ->\n      # Try lenient validation on failure\n      if recoverable_errors?(errors) do\n        validate_lenient_rules(data)\n      else\n        {:error, errors}\n      end\n  end\nend\n```","ref":"errors-validation-error-usage-rules.html#error-recovery"},{"type":"extras","title":"Performance Considerations - Funx.Errors.ValidationError Usage Rules","doc":"- ValidationError creation is lightweight (just list wrapping)\n- Error message concatenation happens lazily in `Exception.message/1` \n- `merge/2` uses simple list concatenation - efficient for typical error counts\n- Appendable protocol enables efficient accumulation in Either.validate/2\n- String formatting only happens when converting to string representation","ref":"errors-validation-error-usage-rules.html#performance-considerations"},{"type":"extras","title":"Best Practices - Funx.Errors.ValidationError Usage Rules","doc":"- Use ValidationError for user-facing validation only\n- Always wrap in Either.Left, never return bare ValidationError\n- Prefer list format for errors even for single messages  \n- Use Either.validate/2 for comprehensive validation\n- Structure error messages consistently across your application\n- Include context in error messages (field names, values, constraints)\n- Test both successful validation and error accumulation paths\n- Consider internationalization when designing error messages","ref":"errors-validation-error-usage-rules.html#best-practices"},{"type":"extras","title":"Error Message Guidelines - Funx.Errors.ValidationError Usage Rules","doc":"```elixir\n# Good: Specific, actionable error messages\n\"Email field is required\"\n\"Password must be at least 8 characters\"\n\"Age must be between 13 and 120\"\n\n# Avoid: Vague or technical error messages  \n\"Invalid input\"\n\"Validation failed\"  \n\"Error in field processing\"\n\n# Good: Include context and constraints\nValidationError.new([\"Username '#{username}' is already taken\"])\nValidationError.new([\"Price #{price} must be greater than $0.00\"])\n\n# Good: Use Either.lift_predicate for simple validation\ndef validate_required_field(value, field_name) do\n  Either.lift_predicate(value, &present?/1, \"#{field_name} is required\")\n  |> Either.map_left(&ValidationError.new/1)\nend\n```","ref":"errors-validation-error-usage-rules.html#error-message-guidelines"},{"type":"extras","title":"Funx.List Usage Rules","doc":"# `Funx.List` Usage Rules","ref":"list-usage-rules.html"},{"type":"extras","title":"Quick Reference - Funx.List Usage Rules","doc":"* All functions operate on Elixir lists (`[term()]`).\n* `Eq` is used for: `uniq/2`, `union/3`, `intersection/3`, `difference/3`, `symmetric_difference/3`, `subset?/3`, and `superset?/3`.\n* `Ord` is used for: `sort/2` and `strict_sort/2`.\n* `strict_sort/2` combines `Ord` (for sorting) and `Eq` (for deduplication).\n* All functions default to protocol dispatch; no wiring needed if instances exist.\n* Ad-hoc comparators can be passed using `Eq.Utils.contramap/1` or `Ord.Utils.contramap/1`.","ref":"list-usage-rules.html#quick-reference"},{"type":"extras","title":"Overview - Funx.List Usage Rules","doc":"The `Funx.List` module provides equality- and ordering-aware utilities for working with lists.\nIt supports deduplication, sorting, and set-like behavior using `Eq` and `Ord` instances.\n\nThis allows logic like \"unique cars by VIN\" or \"sort by price, then mileage\" to be clean, composable, and domain-aware.","ref":"list-usage-rules.html#overview"},{"type":"extras","title":"Eq-Based Operations - Funx.List Usage Rules","doc":"### `uniq/2`\n\nRemoves duplicates using `Eq`.\n\n```elixir\nFunx.List.uniq([%Car{vin: \"A\"}, %Car{vin: \"A\"}])\n# => [%Car{vin: \"A\"}]\n```\n\nWith custom comparator:\n\n```elixir\neq = Eq.Utils.contramap(& &1.make)\nFunx.List.uniq(cars, eq)\n```\n\n### `union/3`\n\nCombines two lists, removing duplicates using `Eq`.\n\n```elixir\nFunx.List.union([1, 2], [2, 3])\n# => [1, 2, 3]\n```\n\n### `intersection/3`\n\nReturns the elements common to both lists.\n\n```elixir\nFunx.List.intersection([1, 2, 3], [2, 3, 4])\n# => [2, 3]\n```\n\n### `difference/3`\n\nReturns elements from the first list that are not in the second.\n\n```elixir\nFunx.List.difference([1, 2, 3], [2])\n# => [1, 3]\n```\n\n### `symmetric_difference/3`\n\nReturns elements that appear in only one of the two lists.\n\n```elixir\nFunx.List.symmetric_difference([1, 2], [2, 3])\n# => [1, 3]\n```\n\n### `subset?/3` and `superset?/3`\n\nChecks for inclusion using `Eq`.\n\n```elixir\nFunx.List.subset?([1, 2], [1, 2, 3])\n# => true\n\nFunx.List.superset?([1, 2, 3], [1, 2])\n# => true\n```","ref":"list-usage-rules.html#eq-based-operations"},{"type":"extras","title":"Ord-Based Operations - Funx.List Usage Rules","doc":"### `sort/2`\n\nSorts the list using `Ord`. Defaults to protocol dispatch.\n\n```elixir\nFunx.List.sort([3, 1, 2])\n# => [1, 2, 3]\n```\n\nWith ad-hoc ordering:\n\n```elixir\nord = Ord.Utils.contramap(& &1.price)\nFunx.List.sort(cars, ord)\n```\n\n### `strict_sort/2`\n\nSorts the list and removes duplicates. Uses `Ord` for sorting and derives `Eq` from ordering.\n\n```elixir\nFunx.List.strict_sort([3, 1, 3, 2])\n# => [1, 2, 3]\n```","ref":"list-usage-rules.html#ord-based-operations"},{"type":"extras","title":"Concatenation - Funx.List Usage Rules","doc":"### `concat/1`\n\nConcatenates a list of lists left-to-right using the `ListConcat` monoid.\n\n```elixir\nFunx.List.concat([[1], [2, 3], [4]])\n# => [1, 2, 3, 4]\n```","ref":"list-usage-rules.html#concatenation"},{"type":"extras","title":"Good Patterns - Funx.List Usage Rules","doc":"* Use `uniq/2`, `intersection/3`, and related functions instead of manual deduplication.\n* Use `contramap/1` to lift equality or ordering by projecting key fields.\n* Use `strict_sort/2` when you need sorted unique results.\n* Define protocol instances for domain types to remove the need for custom comparator logic.","ref":"list-usage-rules.html#good-patterns"},{"type":"extras","title":"Anti-Patterns - Funx.List Usage Rules","doc":"* Using `==` in list operations instead of `Eq`:\n\n  ```elixir\n  # BAD\n  Enum.uniq_by(users, & &1.id)  # not composable or testable\n  ```\n\n* Sorting maps or structs without defining `Ord`:\n\n  ```elixir\n  # BAD\n  Enum.sort([%User{}])  # may raise\n  ```\n\n* Mixing raw and protocol-based comparison:\n\n  ```elixir\n  # BAD\n  if user1.id == user2.id and Eq.eq?(user1, user2), do: ...\n  ```","ref":"list-usage-rules.html#anti-patterns"},{"type":"extras","title":"When to Use - Funx.List Usage Rules","doc":"Use `Funx.List` when:\n\n* You want list operations that follow your domain's equality or ordering rules.\n* You need composable set logic like `union` or `difference`.\n* You want deterministic, extensible sorting.\n* You're working with domain types (e.g., `User`, `Car`, `Ticket`) and want safe behavior.","ref":"list-usage-rules.html#when-to-use"},{"type":"extras","title":"Funx.Monad Usage Rules","doc":"# `Funx.Monad` Usage Rules","ref":"monad-usage-rules.html"},{"type":"extras","title":"LLM Functional Programming Foundation - Funx.Monad Usage Rules","doc":"**Key Concepts for LLMs:**\n\n**Monad**: A design pattern that provides a structured way to handle computations with context\n\n- **Bind operation**: Chains computations that might fail, transform, or have side effects\n- **Map operation**: Transforms the wrapped value with a regular function\n- **Mathematical foundation**: Satisfies identity and associativity laws\n- **Three fundamental operations**: `bind/2`, `map/2`, and `ap/2`\n\n**Kleisli Functions**: Functions that return values wrapped in a monadic context\n\n- Type signature: `a -> M ` (takes regular value, returns monadic value)\n- Compose with `bind/2` rather than regular function composition\n- Enable chaining of operations that might fail or transform context\n- Example: `fn x -> {:ok, x * 2} end` is a Kleisli function for Result monad\n\n**Monadic vs. Applicative**: Different styles for handling multiple wrapped values\n\n- **Monadic (sequential)**: Later computations depend on earlier results\n- **Applicative (independent)**: All computations are independent and can run in parallel\n- **Rule**: Use monadic when you need the result of one computation to determine the next\n\n**Bind vs. Map**: Different operations for different transformations\n\n- **Map**: Transform the value inside the monad (`a -> b` functions)\n- **Bind**: Chain monadic operations (`a -> M ` functions)\n- **Key insight**: Bind flattens nested monads, map doesn't\n\n**Context Preservation**: Monads maintain computational context through transformations\n\n- **Maybe monad**: Preserves presence/absence context\n- **Either monad**: Preserves success/failure with error information\n- **Identity monad**: Transparent context for learning and composition\n- **Context flows**: Through bind chains automatically","ref":"monad-usage-rules.html#llm-functional-programming-foundation"},{"type":"extras","title":"LLM Decision Guide: When to Use Monad Protocol - Funx.Monad Usage Rules","doc":"**✅ Use Monad Protocol when:**\n\n- Building generic functions that work with any monad\n- Creating monad-agnostic algorithms\n- Need to compose different monadic operations\n- Want polymorphic code that works with Maybe, Either, Identity, etc.\n- User says: \"generic\", \"polymorphic\", \"works with any monad\", \"monad-agnostic\"\n\n**❌ Don't use Protocol when:**\n\n- Working with specific monad types only\n- Performance is critical (protocol dispatch has overhead)\n- Simple transformations that don't need genericity\n- User is asking for specific Maybe or Either operations\n\n**⚡ Protocol vs. Direct Module Decision:**\n\n- **Protocol**: Generic code that works with multiple monad types\n- **Direct module**: Type-specific optimized operations\n- **Rule**: Start with direct modules, extract to protocol when you need genericity\n\n**⚙️ Operation Choice Guide:**\n\n- **bind/2**: Chain operations that return monadic values\n- **map/2**: Transform values inside the monadic context\n- **ap/2**: Apply functions in monadic context to values in monadic context\n- **Law verification**: Always test monad laws in generic code","ref":"monad-usage-rules.html#llm-decision-guide-when-to-use-monad-protocol"},{"type":"extras","title":"LLM Context Clues - Funx.Monad Usage Rules","doc":"**User language → Monad protocol patterns:**\n\n- \"generic monad function\" → Use protocol operations\n- \"works with any monad\" → Protocol-based implementation\n- \"polymorphic over monads\" → Protocol with type constraints\n- \"chain operations\" → `bind/2` sequences\n- \"transform value\" → `map/2`\n- \"apply function\" → `ap/2`\n- \"sequence computations\" → Bind chains with error handling\n- \"monad laws\" → Identity and associativity verification","ref":"monad-usage-rules.html#llm-context-clues"},{"type":"extras","title":"Quick Reference - Funx.Monad Usage Rules","doc":"- Use `bind/2` to chain Kleisli functions (operations returning monadic values)\n- Use `map/2` to transform values inside the monadic context\n- Use `ap/2` for applicative style when computations are independent\n- Use constructor functions like `Maybe.just/1`, `Either.right/1` to create monadic values\n- Use `bind/2` to naturally flatten nested monads through composition\n- All monads support `map/2` and `ap/2` via protocol or import\n- Monad laws: left identity, right identity, associativity\n- Protocol enables polymorphic functions working across monad types","ref":"monad-usage-rules.html#quick-reference"},{"type":"extras","title":"Overview - Funx.Monad Usage Rules","doc":"`Funx.Monad` defines the core protocol for monadic operations in Elixir. It provides the essential operations that all monads must implement: `bind/2`, `map/2`, and `ap/2`. This protocol enables writing generic, reusable functions that work with any monadic type.\n\nThe protocol is the foundation for functional composition patterns, enabling you to chain computations while preserving context (whether that's handling optional values, errors, transformations, or other computational contexts).","ref":"monad-usage-rules.html#overview"},{"type":"extras","title":"Protocol Operations - Funx.Monad Usage Rules","doc":"| Operation    | Type Signature              | Purpose                                    |\n| ------------ | --------------------------- | ------------------------------------------ |\n| `bind/2`     | `M  -> (a -> M ) -> M ` | Chain monadic computations                 |\n| `map/2`      | `M  -> (a -> b) -> M `  | Transform the wrapped value                |\n| `ap/2`       | `M<(a -> b)> -> M  -> M ` | Apply a wrapped function to wrapped value |\n\nThe protocol requires implementing three operations: `bind/2` for chaining monadic functions, `map/2` for transforming wrapped values, and `ap/2` for applicative-style function application.","ref":"monad-usage-rules.html#protocol-operations"},{"type":"extras","title":"LLM Monad Laws Foundation - Funx.Monad Usage Rules","doc":"**Mathematical Requirements:**\n\nAll monad implementations must satisfy three fundamental laws:\n\n**Left Identity**: `Constructor.new(a) |> bind(f) == f.(a)`\n\n- Creating a monad then binding should equal direct application\n- The monadic wrapper doesn't interfere with computation\n\n**Right Identity**: `m |> bind(fn x -> Constructor.new(x) end) == m`  \n\n- Binding with constructor should leave the monad unchanged\n- Constructor functions are neutral elements for bind\n\n**Associativity**: `(m |> bind(f)) |> bind(g) == m |> bind(fn x -> bind(f.(x), g) end)`\n\n- Order of binding operations doesn't matter\n- Enables reliable composition and refactoring\n\n**Why Laws Matter for LLMs:**\n\n- **Predictability**: Laws ensure consistent behavior across implementations\n- **Composition safety**: Can refactor and compose without breaking semantics  \n- **Generic algorithms**: Enable writing functions that work with any lawful monad\n- **Debugging confidence**: Law violations indicate implementation bugs","ref":"monad-usage-rules.html#llm-monad-laws-foundation"},{"type":"extras","title":"Usage Patterns - Funx.Monad Usage Rules","doc":"","ref":"monad-usage-rules.html#usage-patterns"},{"type":"extras","title":"Basic Monadic Pipeline - Funx.Monad Usage Rules","doc":"```elixir\n# Generic function working with any monad\ndef transform_generically(monad_value) do\n  monad_value\n  |> Monad.bind(fn x -> SpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.x * 2) end)\n  |> Monad.bind(fn x -> SpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.x + 1) end)\n  |> Monad.bind(fn x -> \n    if x > 10 do\n      SpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.\"large: #{x}\")\n    else\n      SpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.\"small: #{x}\")\n    end\n  end)\nend\n\n# Works with Maybe\ntransform_generically(Maybe.just(5))    # => Just(\"large: 11\") \ntransform_generically(Maybe.nothing())  # => Nothing\n\n# Works with Either  \ntransform_generically(Either.right(5))  # => Right(\"large: 11\")\ntransform_generically(Either.left(\"error\")) # => Left(\"error\")\n```","ref":"monad-usage-rules.html#basic-monadic-pipeline"},{"type":"extras","title":"Kleisli Function Composition - Funx.Monad Usage Rules","doc":"```elixir\n# Kleisli functions for various monads\ndef safe_divide(a, b) do\n  if b != 0 do\n    Maybe.just(a / b)\n  else\n    Maybe.nothing()\n  end\nend\n\ndef validate_positive(x) do\n  if x > 0 do\n    Either.right(x)\n  else\n    Either.left(\"must be positive\")\n  end\nend\n\n# Generic composition using protocol\ndef compose_kleisli(value, kleisli_fns) do\n  Enum.reduce(kleisli_fns, SpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.value), fn f, acc ->\n    Monad.bind(acc, f)\n  end)\nend\n\n# Use with different monads\ncompose_kleisli(10, [safe_divide(20), &Maybe.just(&1 + 1)])\ncompose_kleisli(10, [validate_positive, fn x -> Either.right(x * 2) end])\n```","ref":"monad-usage-rules.html#kleisli-function-composition"},{"type":"extras","title":"Map for Transforming Values - Funx.Monad Usage Rules","doc":"```elixir\n# Transform values inside monadic context\nimport Funx.Monad\n\n# Works with any monad\nMaybe.just(5) |> map(&(&1 * 2))      # Just(10)\nEither.right(5) |> map(&(&1 * 2))    # Right(10)\nIdentity.identity(5) |> map(&(&1 * 2)) # Identity(10)\n\n# Chain transformations\nMaybe.just(\"hello\")\n|> map(&String.upcase/1)              # Just(\"HELLO\")\n|> map(&String.length/1)              # Just(5)\n```","ref":"monad-usage-rules.html#map-for-transforming-values"},{"type":"extras","title":"Ap for Applying Wrapped Functions - Funx.Monad Usage Rules","doc":"Applies a monadic function (e.g., `M<(a -> b)>`) to a monadic argument (`M `), returning `M `. This enables applicative style when computations are independent.\n\n```elixir\nimport Funx.Monad\n\n# Basic function application\nadd = fn x -> fn y -> x + y end end\n\nreturn(add)\n|> ap(return(3))\n|> ap(return(4))                     # Works with any monad\n\n# With Maybe\nMaybe.just(add)\n|> ap(Maybe.just(3))\n|> ap(Maybe.just(4))                 # Just(7)\n\n# With Either\nEither.right(add)\n|> ap(Either.right(3))\n|> ap(Either.right(4))               # Right(7)\n\n# String concatenation\nconcat3 = fn a -> fn b -> fn c -> a <> b <> c end end end\n\nMaybe.just(concat3)\n|> ap(Maybe.just(\"Hello, \"))\n|> ap(Maybe.just(\"World\"))\n|> ap(Maybe.just(\"!\"))               # Just(\"Hello, World!\")\n```","ref":"monad-usage-rules.html#ap-for-applying-wrapped-functions"},{"type":"extras","title":"Flattening Nested Monads - Funx.Monad Usage Rules","doc":"```elixir\n# When you have nested monads - use bind to flatten naturally\nnested_maybe = Maybe.just(Maybe.just(42))\nflattened = Monad.bind(nested_maybe, fn inner -> inner end)  # => Just(42)\n\nnested_either = Either.right(Either.right(\"success\"))\nflattened = Monad.bind(nested_either, fn inner -> inner end)  # => Right(\"success\")\n```","ref":"monad-usage-rules.html#flattening-nested-monads"},{"type":"extras","title":"Guidelines for Generic Monad Functions - Funx.Monad Usage Rules","doc":"When writing functions that work with any monad:\n\n- **Use protocol operations only**: `Monad.bind/2`, `Monad.map/2`, `Monad.ap/2`\n- **Avoid specific monad constructors**: Don't use `Maybe.just/1` in generic code\n- **Choose the right operation**: `map` for transforming, `bind` for chaining, `ap` for independent computations\n- **Test monad laws**: Verify your functions preserve monadic structure  \n- **Consider performance**: Protocol dispatch has overhead vs direct module calls\n- **Document type constraints**: Make clear which monads your function supports\n- **Handle all cases**: Generic code should work correctly with all monadic types","ref":"monad-usage-rules.html#guidelines-for-generic-monad-functions"},{"type":"extras","title":"LLM Code Templates - Funx.Monad Usage Rules","doc":"","ref":"monad-usage-rules.html#llm-code-templates"},{"type":"extras","title":"Basic Monadic Pipeline Template - Funx.Monad Usage Rules","doc":"```elixir\ndef build_monadic_pipeline() do\n  fn initial_value, monad_type ->\n    initial_value\n    |> monad_type.return()\n    |> Monad.bind(fn x -> \n      # First transformation (returns monadic value)\n      transformed = transform_step_1(x)\n      monad_type.return(transformed)\n    end)\n    |> Monad.bind(fn x ->\n      # Second transformation with possible failure\n      case validate_step_2(x) do\n        :ok -> monad_type.return(x)\n        {:error, reason} -> monad_type.error(reason)  # Assumes error constructor\n      end\n    end)\n    |> Monad.bind(fn x ->\n      # Final transformation\n      result = finalize_step(x)\n      monad_type.return(result)\n    end)\n  end\nend\n\n# Usage with different monads\npipeline = build_monadic_pipeline()\npipeline.(42, Maybe)   # Works with Maybe monad\npipeline.(42, Either)  # Works with Either monad\n```","ref":"monad-usage-rules.html#basic-monadic-pipeline-template"},{"type":"extras","title":"Monad Law Verification Template - Funx.Monad Usage Rules","doc":"```elixir\ndef verify_monad_laws(monad_module, test_value, test_function) do\n  # Left Identity Law: return(a) >>= f === f(a)\n  left_identity = fn ->\n    left = monad_module.return(test_value) |> Monad.bind(test_function)\n    right = test_function.(test_value)\n    left == right\n  end\n  \n  # Right Identity Law: m >>= return === m  \n  right_identity = fn ->\n    test_monad = monad_module.return(test_value)\n    left = test_monad |> Monad.bind(&monad_module.return/1)\n    right = test_monad\n    left == right\n  end\n  \n  # Associativity Law: (m >>= f) >>= g === m >>= (\\x -> f(x) >>= g)\n  associativity = fn ->\n    test_monad = monad_module.return(test_value)\n    second_function = fn x -> monad_module.return(x * 3) end\n    \n    left = test_monad\n           |> Monad.bind(test_function) \n           |> Monad.bind(second_function)\n    \n    right = test_monad |> Monad.bind(fn x ->\n      test_function.(x) |> Monad.bind(second_function)\n    end)\n    \n    left == right\n  end\n  \n  %{\n    left_identity: left_identity.(),\n    right_identity: right_identity.(),\n    associativity: associativity.()\n  }\nend\n\n# Test all laws for a monad\ndef test_monad_implementation(monad_module) do\n  test_fn = fn x -> monad_module.return(x + 1) end\n  results = verify_monad_laws(monad_module, 42, test_fn)\n  \n  all_passed = Enum.all?(Map.values(results))\n  {all_passed, results}\nend\n```","ref":"monad-usage-rules.html#monad-law-verification-template"},{"type":"extras","title":"Kleisli Function Factory Template - Funx.Monad Usage Rules","doc":"```elixir\ndef build_kleisli_factory(monad_module) do\n  %{\n    # Safe mathematical operations\n    safe_divide: fn a, b ->\n      if b != 0 do\n        monad_module.return(a / b)\n      else\n        monad_module.error(\"division by zero\")\n      end\n    end,\n    \n    safe_sqrt: fn x ->\n      if x >= 0 do\n        monad_module.return(:math.sqrt(x))\n      else\n        monad_module.error(\"negative square root\")\n      end\n    end,\n    \n    # Validation operations\n    validate_range: fn min, max ->\n      fn value ->\n        if value >= min and value <= max do\n          monad_module.return(value)\n        else\n          monad_module.error(\"value #{value} not in range #{min}-#{max}\")\n        end\n      end\n    end,\n    \n    # Transformation operations\n    transform_with: fn transformer ->\n      fn value ->\n        try do\n          result = transformer.(value)\n          monad_module.return(result)\n        rescue\n          error -> monad_module.error(\"transformation failed: #{inspect(error)}\")\n        end\n      end\n    end,\n    \n    # Conditional operations\n    when_condition: fn predicate, then_fn, else_fn ->\n      fn value ->\n        if predicate.(value) do\n          then_fn.(value)\n        else\n          else_fn.(value)\n        end\n      end\n    end\n  }\nend\n\n# Usage with different monads\nmaybe_ops = build_kleisli_factory(Maybe)\neither_ops = build_kleisli_factory(Either)\n\n# Chain operations\n42\n|> maybe_ops.safe_divide.(6)\n|> Monad.bind(maybe_ops.safe_sqrt)\n|> Monad.bind(maybe_ops.validate_range.(0, 10))\n```","ref":"monad-usage-rules.html#kleisli-function-factory-template"},{"type":"extras","title":"Applicative vs. Monadic Style Template - Funx.Monad Usage Rules","doc":"```elixir\ndef comparison_template() do\n  import Funx.Monad\n  \n  # Sample data\n  maybe_a = Maybe.just(5)\n  maybe_b = Maybe.just(10)\n  maybe_c = Maybe.just(2)\n  \n  # Applicative style - all computations are independent\n  add3 = fn a -> fn b -> fn c -> a + b + c end end end\n  applicative_result = \n    return(add3)\n    |> ap(maybe_a)\n    |> ap(maybe_b)\n    |> ap(maybe_c)  # Just(17)\n  \n  # Monadic style - later computations depend on earlier ones\n  monadic_result = \n    maybe_a\n    |> bind(fn a ->\n      maybe_b |> bind(fn b ->\n        # This computation depends on both a and b\n        if a + b > 10 do\n          maybe_c |> bind(fn c ->\n            return(a + b + c + 100)  # Bonus for large values\n          end)\n        else\n          maybe_c |> bind(fn c ->\n            return(a + b + c)\n          end)\n        end\n      end)\n    end)\n  \n  # When to use each:\n  # - Applicative: When operations are independent (use ap)\n  # - Monadic: When later operations depend on earlier results (use bind)\n  \n  %{\n    applicative: applicative_result,  # Just(17)\n    monadic: monadic_result          # Just(117) - includes bonus\n  }\nend\n```","ref":"monad-usage-rules.html#applicative-vs-monadic-style-template"},{"type":"extras","title":"Monad Transformer Pattern Template - Funx.Monad Usage Rules","doc":"```elixir\ndef build_transformer_stack() do\n  # Example: Maybe + IO monad transformer\n  # MaybeT IO a = IO (Maybe a)\n  \n  # Basic operations for the transformer\n  def lift_io(io_action) do\n    fn -> \n      result = io_action.()\n      Maybe.just(result)\n    end\n  end\n  \n  def lift_maybe(maybe_value) do\n    fn -> maybe_value end\n  end\n  \n  # Bind for the transformer stack\n  def bind_transformer(transformer_action, kleisli_fn) do\n    fn ->\n      case transformer_action.() do\n        Maybe.Nothing -> Maybe.nothing()\n        Maybe.Just(value) ->\n          next_action = kleisli_fn.(value)\n          next_action.()\n      end\n    end\n  end\n  \n  # Example usage\n  def fetch_and_process_user(user_id) do\n    # This would be a complex operation involving both IO and Maybe\n    lift_io(fn -> fetch_user_from_db(user_id) end)\n    |> bind_transformer(fn user ->\n      if user.active do\n        lift_maybe(Maybe.just(user))\n      else\n        lift_maybe(Maybe.nothing())\n      end\n    end)\n    |> bind_transformer(fn user ->\n      lift_io(fn -> \n        processed_user = process_user_data(user)\n        Maybe.just(processed_user)\n      end)\n    end)\n  end\n  \n  # Run the transformer stack\n  user_result = fetch_and_process_user(123)\n  final_result = user_result.()  # IO (Maybe User)\nend\n```","ref":"monad-usage-rules.html#monad-transformer-pattern-template"},{"type":"extras","title":"Utils Integration Template - Funx.Monad Usage Rules","doc":"```elixir\ndef build_utils_integration() do\n  # Combine Monad protocol with Utils currying\n  \n  # Curry monadic operations for pipeline use\n  bind_with = Funx.Utils.curry_r(&Monad.bind/2)\n  \n  # Create reusable monadic operations\n  def create_monadic_validators() do\n    %{\n      positive: bind_with.(fn x ->\n        if x > 0 do\n          Maybe.just(x)\n        else\n          Maybe.nothing()\n        end\n      end),\n      \n      even: bind_with.(fn x ->\n        if rem(x, 2) == 0 do\n          Either.right(x)\n        else\n          Either.left(\"must be even\")\n        end\n      end),\n      \n      in_range: fn min, max ->\n        bind_with.(fn x ->\n          if x >= min and x <= max do\n            Maybe.just(x)\n          else\n            Maybe.nothing()\n          end\n        end)\n      end\n    }\n  end\n  \n  # Use in pipelines\n  validators = create_monadic_validators()\n  \n  # Pipeline with curried monadic operations\n  result = Maybe.just(42)\n           |> validators.positive.()\n           |> bind_with.(fn x -> Maybe.just(x * 2) end).()\n           |> validators.in_range.(50, 100).()\n  \n  # Compose multiple validators\n  validate_positive_even = fn monad_value ->\n    monad_value\n    |> validators.positive.()\n    |> validators.even.()\n  end\n  \n  Either.right(20) |> validate_positive_even.()\nend\n```","ref":"monad-usage-rules.html#utils-integration-template"},{"type":"extras","title":"LLM Testing Guidance - Funx.Monad Usage Rules","doc":"","ref":"monad-usage-rules.html#llm-testing-guidance"},{"type":"extras","title":"Test Protocol Implementation - Funx.Monad Usage Rules","doc":"```elixir\ndefmodule MonadLawTest do\n  use ExUnit.Case\n  \n  # Test that a monad implementation satisfies the laws\n  def test_monad_laws(monad_module, sample_values, sample_functions) do\n    Enum.each(sample_values, fn value ->\n      Enum.each(sample_functions, fn f ->\n        test_left_identity(monad_module, value, f)\n        test_right_identity(monad_module, value)\n        test_associativity(monad_module, value, f)\n      end)\n    end)\n  end\n  \n  defp test_left_identity(monad_module, value, kleisli_fn) do\n    # return(a) >>= f === f(a)\n    left = monad_module.return(value) |> Monad.bind(kleisli_fn)\n    right = kleisli_fn.(value)\n    \n    assert left == right, \"\"\"\n    Left identity law failed for #{inspect(monad_module)}\n    Value: #{inspect(value)}\n    Function: #{inspect(kleisli_fn)}\n    \"\"\"\n  end\n  \n  defp test_right_identity(monad_module, value) do\n    # m >>= return === m\n    monad_value = monad_module.return(value)\n    left = monad_value |> Monad.bind(&monad_module.return/1)\n    right = monad_value\n    \n    assert left == right, \"\"\"\n    Right identity law failed for #{inspect(monad_module)}\n    Value: #{inspect(value)}\n    \"\"\"\n  end\n  \n  defp test_associativity(monad_module, value, f) do\n    # (m >>= f) >>= g === m >>= (\\x -> f(x) >>= g)\n    g = fn x -> monad_module.return(x * 3) end\n    m = monad_module.return(value)\n    \n    left = m |> Monad.bind(f) |> Monad.bind(g)\n    right = m |> Monad.bind(fn x -> f.(x) |> Monad.bind(g) end)\n    \n    assert left == right, \"\"\"\n    Associativity law failed for #{inspect(monad_module)}\n    Value: #{inspect(value)}\n    \"\"\"\n  end\n  \n  test \"Maybe satisfies monad laws\" do\n    sample_values = [1, 2, 0, -1, 100]\n    sample_functions = [\n      fn x -> Maybe.just(x + 1) end,\n      fn x -> if x > 0, do: Maybe.just(x), else: Maybe.nothing() end,\n      fn x -> Maybe.just(x * 2) end\n    ]\n    \n    test_monad_laws(Maybe, sample_values, sample_functions)\n  end\n  \n  test \"Either satisfies monad laws\" do\n    sample_values = [1, 2, 0, -1]\n    sample_functions = [\n      fn x -> Either.right(x + 1) end,\n      fn x -> if x >= 0, do: Either.right(x), else: Either.left(\"negative\") end,\n      fn x -> Either.right(x * 2) end\n    ]\n    \n    test_monad_laws(Either, sample_values, sample_functions)\n  end\nend\n```","ref":"monad-usage-rules.html#test-protocol-implementation"},{"type":"extras","title":"Test Generic Monadic Functions - Funx.Monad Usage Rules","doc":"```elixir\ndefmodule GenericMonadTest do\n  use ExUnit.Case\n  \n  # Test that generic functions work with multiple monad types\n  def generic_double_and_add(monad_value, amount) do\n    monad_value\n    |> Monad.bind(fn x -> SpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.x * 2) end)\n    |> Monad.bind(fn x -> SpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.x + amount) end)\n  end\n  \n  test \"generic functions work with Maybe\" do\n    result = generic_double_and_add(Maybe.just(5), 10)\n    assert result == Maybe.just(20)\n    \n    result = generic_double_and_add(Maybe.nothing(), 10)\n    assert result == Maybe.nothing()\n  end\n  \n  test \"generic functions work with Either\" do\n    result = generic_double_and_add(Either.right(5), 10)\n    assert result == Either.right(20)\n    \n    result = generic_double_and_add(Either.left(\"error\"), 10)\n    assert result == Either.left(\"error\")\n  end\n  \n  test \"generic functions work with Identity\" do\n    result = generic_double_and_add(Identity.new(5), 10)\n    assert result == Identity.new(20)\n  end\nend\n```","ref":"monad-usage-rules.html#test-generic-monadic-functions"},{"type":"extras","title":"Test Join Operation - Funx.Monad Usage Rules","doc":"```elixir\ndefmodule MonadJoinTest do\n  use ExUnit.Case\n  \n  test \"join flattens nested Maybe\" do\n    nested = Maybe.just(Maybe.just(42))\n    flattened = Monad.bind(nested, fn inner -> inner end)\n    assert flattened == Maybe.just(42)\n    \n    nested_nothing_inner = Maybe.just(Maybe.nothing())\n    flattened = Monad.bind(nested_nothing_inner, fn inner -> inner end)\n    assert flattened == Maybe.nothing()\n    \n    nothing_outer = Maybe.nothing()\n    flattened = Monad.bind(nothing_outer, fn inner -> inner end)\n    assert flattened == Maybe.nothing()\n  end\n  \n  test \"join flattens nested Either\" do\n    nested_right = Either.right(Either.right(\"success\"))\n    flattened = Monad.bind(nested_right, fn inner -> inner end)\n    assert flattened == Either.right(\"success\")\n    \n    nested_left_inner = Either.right(Either.left(\"inner error\"))\n    flattened = Monad.bind(nested_left_inner, fn inner -> inner end)\n    assert flattened == Either.left(\"inner error\")\n    \n    left_outer = Either.left(\"outer error\")\n    flattened = Monad.bind(left_outer, fn inner -> inner end)\n    assert flattened == Either.left(\"outer error\")\n  end\nend\n```","ref":"monad-usage-rules.html#test-join-operation"},{"type":"extras","title":"LLM Debugging Tips - Funx.Monad Usage Rules","doc":"","ref":"monad-usage-rules.html#llm-debugging-tips"},{"type":"extras","title":"Trace Monadic Operations - Funx.Monad Usage Rules","doc":"```elixir\ndef trace_monad_operations(monad_value, operations) do\n  IO.puts(\"Starting with: #{inspect(monad_value)}\")\n  \n  result = Enum.reduce(operations, {monad_value, 0}, fn operation, {current, step} ->\n    IO.puts(\"Step #{step}: Input = #{inspect(current)}\")\n    \n    next = case operation do\n      {:bind, f} -> \n        result = Monad.bind(current, f)\n        IO.puts(\"Step #{step}: bind -> #{inspect(result)}\")\n        result\n      {:map, f} ->\n        result = Monad.bind(current, fn x -> SpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.f.(x)) end)\n        IO.puts(\"Step #{step}: map -> #{inspect(result)}\")\n        result\n    end\n    \n    {next, step + 1}\n  end)\n  \n  {traced_result, _} = result\n  IO.puts(\"Final result: #{inspect(traced_result)}\")\n  traced_result\nend\n\n# Usage\ntrace_monad_operations(Maybe.just(10), [\n  {:bind, fn x -> Maybe.just(x * 2) end},\n  {:map, fn x -> x + 5 end},\n  {:bind, fn x -> if x > 20, do: Maybe.just(x), else: Maybe.nothing() end}\n])\n```","ref":"monad-usage-rules.html#trace-monadic-operations"},{"type":"extras","title":"Verify Law Compliance - Funx.Monad Usage Rules","doc":"```elixir\ndef debug_monad_laws(monad_module, value, function) do\n  IO.puts(\"Testing monad laws for #{inspect(monad_module)} with value #{inspect(value)}\")\n  \n  # Left Identity\n  left_identity_left = monad_module.return(value) |> Monad.bind(function)\n  left_identity_right = function.(value)\n  left_identity_ok = left_identity_left == left_identity_right\n  \n  IO.puts(\"Left Identity: #{left_identity_ok}\")\n  IO.puts(\"  return(#{inspect(value)}) >>= f = #{inspect(left_identity_left)}\")\n  IO.puts(\"  f(#{inspect(value)}) = #{inspect(left_identity_right)}\")\n  \n  # Right Identity\n  m = monad_module.return(value)\n  right_identity_left = m |> Monad.bind(&monad_module.return/1)\n  right_identity_right = m\n  right_identity_ok = right_identity_left == right_identity_right\n  \n  IO.puts(\"Right Identity: #{right_identity_ok}\")\n  IO.puts(\"  m >>= return = #{inspect(right_identity_left)}\")\n  IO.puts(\"  m = #{inspect(right_identity_right)}\")\n  \n  # Associativity\n  g = fn x -> monad_module.return(x + 100) end\n  assoc_left = m |> Monad.bind(function) |> Monad.bind(g)\n  assoc_right = m |> Monad.bind(fn x -> function.(x) |> Monad.bind(g) end)\n  associativity_ok = assoc_left == assoc_right\n  \n  IO.puts(\"Associativity: #{associativity_ok}\")\n  IO.puts(\"  (m >>= f) >>= g = #{inspect(assoc_left)}\")\n  IO.puts(\"  m >>= (\\\\x -> f(x) >>= g) = #{inspect(assoc_right)}\")\n  \n  %{\n    left_identity: left_identity_ok,\n    right_identity: right_identity_ok,\n    associativity: associativity_ok,\n    all_pass: left_identity_ok and right_identity_ok and associativity_ok\n  }\nend\n```","ref":"monad-usage-rules.html#verify-law-compliance"},{"type":"extras","title":"Monitor Performance - Funx.Monad Usage Rules","doc":"```elixir\ndef benchmark_monadic_operations() do\n  # Compare protocol vs direct module performance\n  test_value = Maybe.just(42)\n  iterations = 100_000\n  \n  # Protocol-based version\n  protocol_time = :timer.tc(fn ->\n    for _ <- 1..iterations do\n      test_value\n      |> Monad.bind(fn x -> SpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.x + 1) end)\n      |> Monad.bind(fn x -> SpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.x * 2) end)\n    end\n  end)\n  \n  # Direct module version\n  direct_time = :timer.tc(fn ->\n    for _ <- 1..iterations do\n      test_value\n      |> Maybe.bind(fn x -> Maybe.just(x + 1) end)\n      |> Maybe.bind(fn x -> Maybe.just(x * 2) end)\n    end\n  end)\n  \n  IO.puts(\"Protocol time: #{elem(protocol_time, 0)} microseconds\")\n  IO.puts(\"Direct time: #{elem(direct_time, 0)} microseconds\")\n  IO.puts(\"Overhead: #{(elem(protocol_time, 0) / elem(direct_time, 0) - 1) * 100}%\")\nend\n```","ref":"monad-usage-rules.html#monitor-performance"},{"type":"extras","title":"LLM Common Mistakes to Avoid - Funx.Monad Usage Rules","doc":"","ref":"monad-usage-rules.html#llm-common-mistakes-to-avoid"},{"type":"extras","title":"❌ Don't Mix Protocol and Direct Calls - Funx.Monad Usage Rules","doc":"```elixir\n# ❌ Wrong: mixing protocol and module-specific calls\ndef bad_generic_function(monad_value) do\n  monad_value\n  |> Monad.bind(fn x -> SpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.x + 1) end)\n  |> Maybe.map(fn x -> x * 2 end)  # Breaks genericity!\n  |> Monad.bind(fn x -> SpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.x - 1) end)\nend\n\n# ✅ Correct: use protocol operations consistently  \ndef good_generic_function(monad_value) do\n  monad_value\n  |> Monad.bind(fn x -> SpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.x + 1) end)\n  |> Monad.bind(fn x -> SpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.x * 2) end)  # Map via bind + return\n  |> Monad.bind(fn x -> SpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.x - 1) end)\nend\n```","ref":"monad-usage-rules.html#don-t-mix-protocol-and-direct-calls"},{"type":"extras","title":"❌ Don't Assume Specific Monad Constructors - Funx.Monad Usage Rules","doc":"```elixir\n# ❌ Wrong: using specific constructors in generic code\ndef bad_validate_positive(monad_value) do\n  Monad.bind(monad_value, fn x ->\n    if x > 0 do\n      Maybe.just(x)  # Assumes Maybe monad!\n    else\n      Maybe.nothing()\n    end\n  end)\nend\n\n# ✅ Correct: use protocol operations and pass monad module\ndef good_validate_positive(monad_value, monad_module) do\n  Monad.bind(monad_value, fn x ->\n    if x > 0 do\n      monad_module.return(x)\n    else\n      monad_module.empty()  # Assumes empty/error constructor\n    end\n  end)\nend\n```","ref":"monad-usage-rules.html#don-t-assume-specific-monad-constructors"},{"type":"extras","title":"❌ Don't Ignore Monad Laws - Funx.Monad Usage Rules","doc":"```elixir\n# ❌ Wrong: implementing bind that violates laws\ndefmodule BadMonad do\n  defstruct [:value, :extra]\n  \n  defimpl Funx.Monad do\n    def bind(%BadMonad{value: value, extra: extra}, f) do\n      # This breaks associativity by adding extra each time!\n      result = f.(value)\n      %{result | extra: extra + 1}\n    end\n    \n    def return(value), do: %BadMonad{value: value, extra: 0}\n    def join(%BadMonad{value: %BadMonad{} = inner}), do: inner\n  end\nend\n\n# ✅ Correct: law-abiding implementation\ndefmodule GoodMonad do\n  defstruct [:value]\n  \n  defimpl Funx.Monad do\n    def bind(%GoodMonad{value: value}, f) do\n      f.(value)  # Simple, law-abiding bind\n    end\n    \n    def return(value), do: %GoodMonad{value: value}\n    def join(%GoodMonad{value: %GoodMonad{} = inner}), do: inner\n  end\nend\n```","ref":"monad-usage-rules.html#don-t-ignore-monad-laws"},{"type":"extras","title":"❌ Don't Use Return Inside Bind Unnecessarily - Funx.Monad Usage Rules","doc":"```elixir\n# ❌ Wrong: unnecessary return wrapping\ndef bad_chain(monad_value) do\n  monad_value\n  |> Monad.bind(fn x ->\n    result = x + 1\n    SpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.result)  # This is just map!\n  end)\nend\n\n# ✅ Better: recognize this is mapping, not binding\ndef good_chain(monad_value) do\n  # If your monad has map, use it\n  monad_value |> SomeMonad.map(fn x -> x + 1 end)\n  \n  # Or if you need generic protocol:\n  monad_value |> Monad.bind(fn x -> SpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.x + 1) end)\nend\n\n# ✅ Best: only use bind when you need to flatten\ndef best_chain(monad_value) do\n  monad_value\n  |> Monad.bind(fn x ->\n    # This function returns a monad, so bind is correct\n    if x > 0 do\n      SomeSpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.x)\n    else\n      SomeMonad.empty()\n    end\n  end)\nend\n```","ref":"monad-usage-rules.html#don-t-use-return-inside-bind-unnecessarily"},{"type":"extras","title":"❌ Don't Nest Binds When You Can Chain - Funx.Monad Usage Rules","doc":"```elixir\n# ❌ Wrong: nested bind calls (hard to read)\ndef bad_nested_operations(monad_value) do\n  Monad.bind(monad_value, fn x ->\n    Monad.bind(SomeSpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.x + 1), fn y ->\n      Monad.bind(SomeSpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.y * 2), fn z ->\n        SomeSpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.z - 1)\n      end)\n    end)\n  end)\nend\n\n# ✅ Correct: chain bind operations with pipe\ndef good_chained_operations(monad_value) do\n  monad_value\n  |> Monad.bind(fn x -> SomeSpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.x + 1) end)\n  |> Monad.bind(fn y -> SomeSpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.y * 2) end) \n  |> Monad.bind(fn z -> SomeSpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.z - 1) end)\nend\n```","ref":"monad-usage-rules.html#don-t-nest-binds-when-you-can-chain"},{"type":"extras","title":"❌ Don't Forget Error Propagation - Funx.Monad Usage Rules","doc":"```elixir\n# ❌ Wrong: not handling error cases in generic code\ndef bad_error_handling(monad_value) do\n  Monad.bind(monad_value, fn x ->\n    # What if this operation can fail?\n    result = risky_operation(x)  # Might raise exception\n    SpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.result)\n  end)\nend\n\n# ✅ Correct: handle errors appropriately\ndef good_error_handling(monad_value, monad_module) do\n  Monad.bind(monad_value, fn x ->\n    try do\n      result = risky_operation(x)\n      monad_module.return(result)\n    rescue\n      error -> monad_module.error(\"operation failed: #{inspect(error)}\")\n    end\n  end)\nend\n```","ref":"monad-usage-rules.html#don-t-forget-error-propagation"},{"type":"extras","title":"LLM Integration with Other Modules - Funx.Monad Usage Rules","doc":"","ref":"monad-usage-rules.html#llm-integration-with-other-modules"},{"type":"extras","title":"With Predicate Logic - Funx.Monad Usage Rules","doc":"```elixir\ndef build_predicate_monadic_filters() do\n  # Combine predicates with monadic validation\n  \n  # Create monadic validators from predicates\n  def predicate_to_monad_validator(predicate, error_msg) do\n    fn value ->\n      if Predicate.test(predicate, value) do\n        Maybe.just(value)\n      else\n        Either.left(error_msg)\n      end\n    end\n  end\n  \n  # Build complex validation chains\n  age_predicate = Predicate.Utils.and_all([\n    Predicate.Utils.greater_than(0),\n    Predicate.Utils.less_than(150)\n  ])\n  \n  email_predicate = Predicate.Utils.matches(~r/@/)\n  \n  validators = %{\n    age: predicate_to_monad_validator(age_predicate, \"invalid age\"),\n    email: predicate_to_monad_validator(email_predicate, \"invalid email\")\n  }\n  \n  # Use in monadic pipeline\n  def validate_user(user_data) do\n    {:ok, user_data}\n    |> Either.from_result()\n    |> Monad.bind(fn data ->\n      validators.age.(data.age)\n      |> Monad.bind(fn _ -> validators.email.(data.email))\n      |> Monad.bind(fn _ -> Either.right(data))\n    end)\n  end\n  \n  validate_user(%{age: 25, email: \"user@example.com\"})\nend\n```","ref":"monad-usage-rules.html#with-predicate-logic"},{"type":"extras","title":"With Utils Currying - Funx.Monad Usage Rules","doc":"```elixir\ndef build_curried_monadic_operations() do\n  # Create curried monadic operations for pipeline use\n  \n  # Curry bind for different argument orders\n  bind_with_fn = Funx.Utils.curry_r(&Monad.bind/2)\n  bind_with_monad = Funx.Utils.curry(&Monad.bind/2)\n  \n  # Create reusable monadic transformations\n  def create_transformers() do\n    %{\n      validate_positive: bind_with_fn.(fn x ->\n        if x > 0 do\n          Maybe.just(x)\n        else\n          Maybe.nothing()\n        end\n      end),\n      \n      safe_divide_by: fn divisor ->\n        bind_with_fn.(fn x ->\n          if divisor != 0 do\n            Maybe.just(x / divisor)\n          else\n            Maybe.nothing()\n          end\n        end)\n      end,\n      \n      transform_with: fn transformer ->\n        bind_with_fn.(fn x ->\n          try do\n            result = transformer.(x)\n            Maybe.just(result)\n          rescue\n            _ -> Maybe.nothing()\n          end\n        end)\n      end\n    }\n  end\n  \n  # Use in functional pipelines\n  transformers = create_transformers()\n  \n  Maybe.just(42)\n  |> transformers.validate_positive.()\n  |> transformers.safe_divide_by.(6).()\n  |> transformers.transform_with.(&round/1).()\nend\n```","ref":"monad-usage-rules.html#with-utils-currying"},{"type":"extras","title":"With Eq for Custom Equality - Funx.Monad Usage Rules","doc":"```elixir\ndef build_monadic_equality_operations() do\n  # Use custom Eq instances in monadic contexts\n  \n  # Create monadic equality testers\n  def create_equality_validators(eq_instance) do\n    %{\n      equals: fn expected_value ->\n        fn monad_value ->\n          Monad.bind(monad_value, fn actual_value ->\n            if Eq.Utils.eq?(actual_value, expected_value, eq_instance) do\n              Maybe.just(actual_value)\n            else\n              Maybe.nothing()\n            end\n          end)\n        end\n      end,\n      \n      not_equals: fn forbidden_value ->\n        fn monad_value ->\n          Monad.bind(monad_value, fn actual_value ->\n            if Eq.Utils.not_eq?(actual_value, forbidden_value, eq_instance) do\n              Maybe.just(actual_value)\n            else\n              Maybe.nothing()\n            end\n          end)\n        end\n      end\n    }\n  end\n  \n  # Use with custom Eq instances\n  by_id_eq = Eq.Utils.contramap(fn user -> user.id end)\n  validators = create_equality_validators(by_id_eq)\n  \n  target_user = %{id: 123, name: \"Alice\"}\n  forbidden_user = %{id: 999, name: \"Admin\"}\n  \n  Maybe.just(%{id: 123, name: \"Alice Updated\"})\n  |> validators.equals.(target_user).()  # Passes (same ID)\n  |> validators.not_equals.(forbidden_user).()  # Passes (different ID)\nend\n```","ref":"monad-usage-rules.html#with-eq-for-custom-equality"},{"type":"extras","title":"Cross-Module Composition - Funx.Monad Usage Rules","doc":"```elixir\ndef build_comprehensive_pipeline() do\n  # Combine Monad, Predicate, Utils, and Eq in one pipeline\n  \n  # Setup components\n  age_predicate = Predicate.Utils.between(18, 65)\n  email_predicate = Predicate.Utils.matches(~r/\\A[^@\\s]+@[^@\\s]+\\z/)\n  user_eq = Eq.Utils.contramap(fn user -> {user.id, user.email} end)\n  \n  # Curried operations\n  validate_with = Funx.Utils.curry_r(fn predicate, value ->\n    if Predicate.test(predicate, value) do\n      Either.right(value)\n    else\n      Either.left(\"validation failed\")\n    end\n  end)\n  \n  transform_with = Funx.Utils.curry_r(fn transformer, monad_value ->\n    Monad.bind(monad_value, fn value ->\n      Either.right(transformer.(value))\n    end)\n  end)\n  \n  # Build comprehensive validation pipeline\n  def validate_and_transform_user(user_data, existing_users) do\n    user_data\n    |> Either.right()\n    |> Monad.bind(validate_with.(age_predicate).(user_data.age))\n    |> Monad.bind(validate_with.(email_predicate).(user_data.email))\n    |> transform_with.(fn data -> \n      %{data | name: String.upcase(data.name)}\n    end).()\n    |> Monad.bind(fn processed_user ->\n      # Check for duplicates using custom Eq\n      duplicate = Enum.find(existing_users, fn existing ->\n        Eq.Utils.eq?(processed_user, existing, user_eq)\n      end)\n      \n      if duplicate do\n        Either.left(\"duplicate user\")\n      else\n        Either.right(processed_user)\n      end\n    end)\n  end\n  \n  # Usage\n  new_user = %{id: 123, name: \"alice\", age: 25, email: \"alice@example.com\"}\n  existing = [%{id: 456, name: \"bob\", age: 30, email: \"bob@example.com\"}]\n  \n  validate_and_transform_user(new_user, existing)\nend\n```","ref":"monad-usage-rules.html#cross-module-composition"},{"type":"extras","title":"Performance Considerations - Funx.Monad Usage Rules","doc":"","ref":"monad-usage-rules.html#performance-considerations"},{"type":"extras","title":"Protocol Overhead - Funx.Monad Usage Rules","doc":"Protocol dispatch has performance overhead compared to direct module calls:\n\n```elixir\n# Benchmark protocol vs direct calls\ndef benchmark_monad_operations() do\n  test_value = Maybe.just(42)\n  iterations = 100_000\n  \n  # Protocol version\n  protocol_fun = fn ->\n    Enum.reduce(1..iterations, test_value, fn _, acc ->\n      acc |> Monad.bind(fn x -> SpecificMonad.new(  # Use constructor like Maybe.just(, Either.right(, etc.x + 1) end)\n    end)\n  end\n  \n  # Direct version  \n  direct_fun = fn ->\n    Enum.reduce(1..iterations, test_value, fn _, acc ->\n      acc |> Maybe.bind(fn x -> Maybe.just(x + 1) end)\n    end)\n  end\n  \n  {protocol_time, _} = :timer.tc(protocol_fun)\n  {direct_time, _} = :timer.tc(direct_fun)\n  \n  overhead_percent = (protocol_time / direct_time - 1) * 100\n  IO.puts(\"Protocol overhead: #{overhead_percent}%\")\nend\n```\n\nUse protocols when:\n\n- **Genericity is valuable**: Function works with multiple monad types\n- **Performance is acceptable**: Not in critical hot paths  \n- **Code reuse matters**: Avoiding duplication across monad types\n\nUse direct module calls when:\n\n- **Performance is critical**: Hot paths or tight loops\n- **Single monad type**: Only working with one specific monad\n- **Simple operations**: Basic transformations that don't benefit from genericity","ref":"monad-usage-rules.html#protocol-overhead"},{"type":"extras","title":"Anti-Patterns - Funx.Monad Usage Rules","doc":"Avoid these common mistakes when working with the Monad protocol:\n\n- **Mixing protocol and module calls** in the same generic function\n- **Using specific constructors** like `Maybe.just/1` in protocol-based code  \n- **Ignoring monad laws** when implementing custom monads\n- **Overusing protocol** when direct module calls would be more efficient\n- **Nested bind calls** instead of chaining with pipe operator\n- **Not testing law compliance** for custom monad implementations","ref":"monad-usage-rules.html#anti-patterns"},{"type":"extras","title":"When to Use - Funx.Monad Usage Rules","doc":"Use the Monad protocol when you want to:\n\n- Write generic functions that work with multiple monad types\n- Create reusable algorithms independent of specific monad implementation  \n- Build libraries that support various monadic computations\n- Ensure your code follows mathematical monad laws\n- Enable composition patterns that work across different contexts\n- Abstract over computational patterns (error handling, optional values, etc.)","ref":"monad-usage-rules.html#when-to-use"},{"type":"extras","title":"Built-in Behavior - Funx.Monad Usage Rules","doc":"- **Protocol dispatch**: Runtime type-based method selection\n- **Law enforcement**: Implementations should satisfy monad laws\n- **Composition support**: Operations designed for chaining and nesting\n- **Type flexibility**: Works with any type implementing the protocol","ref":"monad-usage-rules.html#built-in-behavior"},{"type":"extras","title":"Summary - Funx.Monad Usage Rules","doc":"`Funx.Monad` provides the essential protocol for monadic programming in Elixir. It enables writing generic, reusable functions that work with any monadic type while preserving the mathematical properties that make monads reliable and composable.\n\nThe protocol supports three core operations - `bind`, `return`, and `join` - that together provide a foundation for functional composition patterns. When combined with other Funx modules like Utils, Predicate, and Eq, it enables powerful functional programming abstractions.\n\n**Key Points**:\n\n- **Generic programming**: Write functions that work with any monad\n- **Mathematical foundation**: Based on category theory laws for reliability  \n- **Composition patterns**: Chain computations while preserving context\n- **Cross-module integration**: Combines with other Funx utilities\n- **Performance trade-offs**: Consider overhead vs. genericity benefits\n- **Law compliance**: Always verify implementations satisfy monad laws\n\n**Canon**: Use for generic monadic algorithms, test law compliance, prefer direct modules for performance-critical code.","ref":"monad-usage-rules.html#summary"},{"type":"extras","title":"Funx.Monad.Either Usage Rules","doc":"# `Funx.Monad.Either` Usage Rules","ref":"monad-either-usage-rules.html"},{"type":"extras","title":"LLM Functional Programming Foundation - Funx.Monad.Either Usage Rules","doc":"**Key Concepts for LLMs:**\n\n**CRITICAL Elixir Implementation**: All monadic operations are under `Funx.Monad` protocol\n\n- **NO separate Functor/Applicative protocols** - Elixir protocols cannot be extended after definition\n- Always use `Monad.map/2`, `Monad.bind/2`, `Monad.ap/2` or import `Funx.Monad`\n- Different from Haskell's separate Functor, Applicative, Monad typeclasses\n\n**Either**: Represents success/failure with detailed error context\n\n- `left(error)` represents failure with error information\n- `right(value)` represents success with the actual value\n- **Right-biased**: Operations work on the Right (success) path\n\n**Right-biased Monad**: Operations transform Right values, preserve Left errors\n\n- `map/2`, `bind/2`, `ap/2` only operate on Right values\n- Left values (errors) pass through unchanged\n- Similar to Maybe but with error context preserved\n\n**Validation vs Error-handling**: Two distinct patterns\n\n- **Validation**: Use `traverse_a/2` to collect ALL errors\n- **Error-handling**: Use `bind/2` chains that stop on first error\n- **Critical difference**: validation accumulates, error-handling short-circuits\n\n**Kleisli Functions**: Functions `a -> Either e b` (unwrapped input, wrapped output)\n\n- **Primary use**: `traverse/2`, `traverse_a/2`, and `concat_map/2` for list operations\n- **Individual use**: `bind/2` for single Either values\n- Example: `validate_email :: String -> Either ValidationError Email`\n\n**Key List Operation Patterns:**\n\n- `concat([Either e a])` → `[a]` (extract all Right values, ignore Left)\n- `concat_map([a], kleisli_fn)` → `[b]` (apply Kleisli, collect Right results)\n- `traverse([a], kleisli_fn)` → `Either e [b]` (apply Kleisli, all succeed or first Left)\n- `traverse_a([a], kleisli_fn)` → `Either [e] [b]` (apply Kleisli, all succeed or collect all Left)\n- `sequence([Either e a])` → `Either e [a]` (like traverse with identity, first Left or all Right)\n\n**Sequence (Category Theory)**: Transform type constructor order\n\n- `[Either e a]` → `Either e [a]` (list of Either becomes Either of list)\n- Fails fast: first Left value becomes the result\n- Success: all Right values collected into Right list","ref":"monad-either-usage-rules.html#llm-functional-programming-foundation"},{"type":"extras","title":"LLM Decision Guide: When to Use Either - Funx.Monad.Either Usage Rules","doc":"**✅ Use Either when:**\n\n- Need specific error context/details\n- Multiple validation steps with different error types  \n- Business logic with detailed failure messages\n- Error recovery or different handling per error type\n- User says: \"validate\", \"check\", \"ensure\", \"verify\", \"error details\"\n\n**❌ Use Maybe when:**\n\n- Simple presence/absence (no error context needed)\n- \"Not found\" is sufficient error information\n- Optional fields where missing is normal\n\n**⚡ Either Strategy Decision:**\n\n- **Single operation error-handling**: Use `bind/2` chains\n- **Multi-field validation**: Use `validate/2` to collect all errors\n- **Transform success values**: Use `map/2` with regular functions\n- **Combine Either values**: Use `ap/2` for applicative patterns\n- **Convert from Maybe**: Use `maybe_to_either/2` with error message\n- **Pattern match results**: Use `%Left{left: error}` and `%Right{right: value}` struct patterns\n\n**⚙️ Function Choice Guide (Mathematical Purpose):**\n\n- **Chain error-prone operations**: `bind/2` with Kleisli functions\n- **Transform success values**: `map/2` with regular functions\n- **Validate multiple fields**: `validate/2` for comprehensive error collection\n- **Apply functions to multiple Either**: `ap/2` for combining contexts\n- **Convert lists**: `sequence/1` to collect successes or first failure\n- **Handle specific errors**: Pattern match Left values for recovery","ref":"monad-either-usage-rules.html#llm-decision-guide-when-to-use-either"},{"type":"extras","title":"LLM Context Clues - Funx.Monad.Either Usage Rules","doc":"**User language → Either patterns:**\n\n- \"validate user input\" → Use Either for validation with specific error messages\n- \"parse and validate\" → Chain with `bind/2` for step-by-step validation\n- \"check all fields\" → Use `validate/2` to collect all validation errors\n- \"detailed error messages\" → Left values contain specific error information\n- \"stop on first error\" → Use `bind/2` chains for fail-fast behavior\n- \"collect all errors\" → Use `validate/2` for comprehensive validation","ref":"monad-either-usage-rules.html#llm-context-clues"},{"type":"extras","title":"Quick Reference - Funx.Monad.Either Usage Rules","doc":"- Use `right(value)` for success, `left(error)` for failure\n- Chain operations with `bind/2` - stops on first Left (error)\n- Transform success values with `map/2` - leaves Left unchanged  \n- Use `bind/2` with identity to flatten nested Either values\n- Validate data comprehensively with `validate/2` - collects all errors\n- **Prefer `fold_l/3` over pattern matching** for functional case analysis\n- Import `Funx.Monad` for `map`, `bind`, `ap` and `Funx.Foldable` for `fold_l`\n- Convert from Maybe with error context using helper functions","ref":"monad-either-usage-rules.html#quick-reference"},{"type":"extras","title":"Overview - Funx.Monad.Either Usage Rules","doc":"`Funx.Monad.Either` handles success/failure scenarios with detailed error context.\n\nUse Either for:\n\n- Parsing and validation with specific error messages\n- Operations that can fail in multiple ways\n- Business logic where error details matter for recovery\n- API responses where clients need error specifics\n\n**Key insight**: Either represents \"success or failure\" with the failure carrying detailed information. Right-biased operations focus on the success path while preserving any errors encountered.","ref":"monad-either-usage-rules.html#overview"},{"type":"extras","title":"Constructors - Funx.Monad.Either Usage Rules","doc":"### `right/1` - Wrap a Success Value\n\nCreates an Either representing success:\n\n```elixir\nEither.right(42)           # Success: contains 42\nEither.right(\"valid\")      # Success: contains \"valid\"\nEither.right([1, 2, 3])    # Success: contains [1, 2, 3]\n```\n\n### `left/1` - Wrap an Error Value\n\nCreates an Either representing failure:\n\n```elixir\nEither.left(\"error\")                    # Failure: contains error message\nEither.left({:validation, \"invalid\"})   # Failure: structured error\nEither.left(%ValidationError{})         # Failure: error struct\n```\n\n### `pure/1` - Alias for `right/1`\n\nAlternative constructor for success values:\n\n```elixir\nEither.pure(42)    # Same as Either.right(42)\n```","ref":"monad-either-usage-rules.html#constructors"},{"type":"extras","title":"Core Operations - Funx.Monad.Either Usage Rules","doc":"### `map/2` - Transform Success Values\n\nApplies a function to Right values, leaves Left values unchanged:\n\n```elixir\nimport Funx.Monad\nimport Funx.Foldable\n\nEither.right(\"hello\")\n|> map(&String.upcase/1)        # right(\"HELLO\")\n\nEither.left(\"error\")  \n|> map(&String.upcase/1)        # left(\"error\") - function never runs\n```\n\n**Use `map` when:**\n\n- You want to transform the success value\n- The transformation function returns a plain value (not wrapped in Either)\n- You want to preserve the Either structure\n\n### `bind/2` - Chain Error-Prone Operations\n\nChains operations that return Either values, for fail-fast error handling:\n\n```elixir\nimport Funx.Monad\nimport Funx.Foldable\n\n# These functions return Either values\nparse_int = fn s -> \n  case Integer.parse(s) do\n    {int, \"\"} -> Either.right(int)\n    _ -> Either.left(\"Invalid integer: #{s}\")\n  end\nend\n\nvalidate_positive = fn n ->\n  if n > 0 do\n    Either.right(n)\n  else \n    Either.left(\"Must be positive: #{n}\")\n  end\nend\n\nEither.right(\"42\")\n|> bind(parse_int)           # right(42)\n|> bind(validate_positive)   # right(42)\n\nEither.right(\"invalid\")\n|> bind(parse_int)           # left(\"Invalid integer: invalid\") - chain stops\n|> bind(validate_positive)   # left(\"Invalid integer: invalid\") - never runs\n```\n\n**Use `bind` when:**\n\n- You're chaining operations that each can fail\n- Each step depends on the success of the previous step\n- You want fail-fast behavior (stop on first error)\n\n**Common bind pattern:**\n\n```elixir\ndef process_user_input(input) do\n  Either.right(input)\n  |> bind(&parse_user_data/1)      # String -> Either Error UserData\n  |> bind(&validate_user_data/1)   # UserData -> Either Error ValidUser\n  |> bind(&save_user/1)            # ValidUser -> Either Error SavedUser\nend\n```\n\n### `ap/2` - Apply Functions Across Either Values\n\nApplies a function in an Either to a value in an Either:\n\n```elixir\nimport Funx.Monad\nimport Funx.Foldable\n\n# Apply a wrapped function to wrapped values\nEither.right(fn x -> x + 10 end)\n|> ap(Either.right(5))          # right(15)\n\n# Combine multiple Either values\nadd = fn x -> fn y -> x + y end end\n\nEither.right(add)\n|> ap(Either.right(3))          # right(fn y -> 3 + y end)  \n|> ap(Either.right(4))          # right(7)\n\n# If any value is left, result is left\nEither.right(add)\n|> ap(Either.left(\"error1\"))    # left(\"error1\")\n|> ap(Either.right(4))          # left(\"error1\")\n```\n\n**Use `ap` when:**\n\n- You want to apply a function to multiple Either values\n- You need all values to be Right for the operation to succeed\n- You're implementing applicative patterns","ref":"monad-either-usage-rules.html#core-operations"},{"type":"extras","title":"Flattening Nested Either Values with `bind` - Funx.Monad.Either Usage Rules","doc":"Since there's no `join/1` function, use `bind/2` with the identity function to flatten nested Either values:\n\n```elixir\nimport Funx.Monad\nimport Funx.Foldable\n\n# Flatten nested Right using bind\nnested_right = Either.right(Either.right(42))\nbind(nested_right, fn inner -> inner end)    # right(42)\n\n# Left in outer - stays Left\nouter_left = Either.left(\"outer error\")\nbind(outer_left, fn inner -> inner end)      # left(\"outer error\")\n\n# Left in inner - becomes Left\ninner_left = Either.right(Either.left(\"inner error\"))\nbind(inner_left, fn inner -> inner end)      # left(\"inner error\")\n```\n\n**Use this pattern when:**\n\n- You have nested Either values that need flattening\n- You're implementing monadic operations manually\n- You're working with higher-order Either computations","ref":"monad-either-usage-rules.html#flattening-nested-either-values-with-bind"},{"type":"extras","title":"List Operations - Funx.Monad.Either Usage Rules","doc":"### `concat/1` - Extract All Right Values\n\nRemoves all Left values and unwraps Right values from a list:\n\n```elixir\nEither.concat([\n  Either.right(1),\n  Either.left(\"error1\"),\n  Either.right(3),\n  Either.left(\"error2\")\n])                              # [1, 3]\n```\n\n### `validate/2` - Comprehensive Data Validation\n\nThe high-level validation function that collects ALL errors from multiple validators:\n\n```elixir\n# Basic validation with error lists\nvalidate_positive = fn n ->\n  if n > 0, do: Either.right(n), else: Either.left([\"Must be positive\"])\nend\n\nvalidate_even = fn n ->\n  if rem(n, 2) == 0, do: Either.right(n), else: Either.left([\"Must be even\"])\nend\n\nEither.validate(3, [validate_positive, validate_even])\n# left([\"Must be even\"])\n\nEither.validate(-2, [validate_positive, validate_even])  \n# left([\"Must be positive\"])\n```\n\n**Use `validate` when:**\n\n- You need comprehensive validation with ALL error details\n- You're validating forms or user input\n- You want to show users all validation problems at once\n- You need to apply multiple validation rules to a single value","ref":"monad-either-usage-rules.html#list-operations"},{"type":"extras","title":"Validation with ValidationError - Funx.Monad.Either Usage Rules","doc":"For comprehensive domain validation with structured error handling, use `Funx.Errors.ValidationError`:\n\n```elixir\nalias Funx.Errors.ValidationError\n\n# Wrap simple errors in ValidationError\nvalidate_age = fn age ->\n  Either.lift_predicate(age, &(&1 >= 18), \"Must be 18 or older\")\n  |> Either.map_left(&ValidationError.new/1)\nend\n\nEither.validate(user, [validate_age])\n# left(ValidationError{errors: [\"Must be 18 or older\"]})\n```\n\n**See `ValidationError` usage rules for advanced patterns:**\n\n- Curried validation functions with `curry_r/1`\n- Fallback validation with `Either.or_else/2`\n- Error message transformation techniques\n- Group validation with `traverse/2` and `traverse_a/2`\n- Sequential vs comprehensive validation strategies\n\n### `concat_map/2` - Apply Function and Collect Rights\n\nApplies a function to each element, collecting only Right results:\n\n### `traverse/2` - Apply Kleisli to List (First Error or All Success)\n\nApplies a Kleisli function to each element, stopping at first Left:\n\n```elixir\nimport Funx.Monad\nimport Funx.Foldable\n\n# Kleisli function: String -> Either String Integer\nparse_number = fn str ->\n  case Integer.parse(str) do\n    {num, \"\"} -> Either.right(num)\n    _ -> Either.left(\"Invalid number: #{str}\")\n  end\nend\n\n# All succeed - get Either list\nEither.traverse([\"1\", \"2\", \"3\"], parse_number)  # right([1, 2, 3])\n\n# First failure stops processing\nEither.traverse([\"1\", \"invalid\", \"3\"], parse_number)  \n# left(\"Invalid number: invalid\")\n```\n\n**Use `traverse` when:**\n\n- All operations must succeed for meaningful result\n- You want fail-fast behavior on lists\n- Converting `[a]` to `Either e [b]` with validation\n\n### `traverse_a/2` - Apply Kleisli to List (Collect All Errors)\n\nApplies a Kleisli function to each element, collecting ALL errors:\n\n```elixir\n# Same Kleisli function as above, but returns error lists for accumulation\nvalidate_number = fn str ->\n  case Integer.parse(str) do\n    {num, \"\"} -> Either.right(num)\n    _ -> Either.left([\"Invalid number: #{str}\"])  # List for accumulation\n  end\nend\n\n# Collect ALL errors\nEither.traverse_a([\"1\", \"invalid\", \"3\", \"bad\"], validate_number)\n# left([\"Invalid number: invalid\", \"Invalid number: bad\"])\n\n# All succeed - get Right list\nEither.traverse_a([\"1\", \"2\", \"3\"], validate_number)  # right([1, 2, 3])\n```\n\n**Use `traverse_a` when:**\n\n- You want to collect ALL errors from validation\n- You need comprehensive error reporting\n- You're implementing validation that shows all problems at once\n\n### `concat_map/2` - Apply Kleisli to List (Collect Successes)\n\nApplies a Kleisli function to each element, collecting only successful results:\n\n```elixir\n# Collect only successes - get plain list\nEither.concat_map([\"1\", \"invalid\", \"3\", \"bad\"], parse_number)  # [1, 3]\n\n# All succeed - get all results\nEither.concat_map([\"1\", \"2\", \"3\"], parse_number)  # [1, 2, 3]\n\n# All fail - get empty list\nEither.concat_map([\"bad\", \"invalid\", \"error\"], parse_number)  # []\n```\n\n**Use `concat_map` when:**\n\n- Partial success is acceptable\n- You want to collect all valid results\n- You need resilient processing that continues on failure\n\n### `sequence/1` - Convert List of Either to Either List\n\nConverts `[Either e a]` to `Either e [a]` - equivalent to `traverse` with identity function:\n\n```elixir\n# All success - collect values\nEither.sequence([\n  Either.right(1),\n  Either.right(2),\n  Either.right(3)\n])                              # right([1, 2, 3])\n\n# First failure stops and returns that error\nEither.sequence([\n  Either.right(1),\n  Either.left(\"error2\"),\n  Either.left(\"error3\")\n])                              # left(\"error2\")\n\n# Relationship to traverse\nEither.sequence(either_list) == Either.traverse(either_list, fn x -> x end)\n```\n\n**Use `sequence` when:**\n\n- You have a list of Either values from previous computations\n- You want all to succeed, or the first failure\n- You're collecting results from multiple operations","ref":"monad-either-usage-rules.html#validation-with-validationerror"},{"type":"extras","title":"Operation Comparison - Funx.Monad.Either Usage Rules","doc":"```elixir\nuser_data = [\"valid@email.com\", \"invalid-email\", \"another@valid.com\", \"bad-format\"]\n\n# traverse: Stop at first error\nEither.traverse(user_data, &validate_email/1)\n# left(\"Invalid email format: invalid-email\")\n\n# traverse_a: Collect all errors  \nEither.traverse_a(user_data, &validate_email_with_list_error/1)\n# left([\"Invalid email format: invalid-email\", \"Invalid email format: bad-format\"])\n\n# concat_map: Collect successes, ignore failures\nEither.concat_map(user_data, &validate_email/1)\n# [\"valid@email.com\", \"another@valid.com\"]\n```","ref":"monad-either-usage-rules.html#operation-comparison"},{"type":"extras","title":"Validation - Funx.Monad.Either Usage Rules","doc":"Validation is a specialized use of Either for comprehensive error collection.\n\nSee the `validate/2` function in the List Operations section above.","ref":"monad-either-usage-rules.html#validation"},{"type":"extras","title":"Lifting - Funx.Monad.Either Usage Rules","doc":"### `lift_predicate/3` - Convert Predicate to Either\n\nConverts a predicate function into Either-returning validation:\n\n```elixir\nvalidate_positive = Either.lift_predicate(&(&1 > 0), \"Must be positive\")\n\nvalidate_positive.(5)   # right(5)\nvalidate_positive.(-1)  # left(\"Must be positive\")\n```\n\n### `lift_maybe/2` - Convert Maybe to Either\n\nConverts a Maybe to Either with error context:\n\n```elixir\nmaybe_user = Maybe.just(%{name: \"Alice\"})\nEither.lift_maybe(maybe_user, \"User not found\")  # right(%{name: \"Alice\"})\n\nMaybe.nothing() |> Either.lift_maybe(\"User not found\")  # left(\"User not found\")\n```\n\n### `lift_eq/1` and `lift_ord/1` - Lift Comparison Functions\n\nLifts comparison functions for use in Either context:\n\n```elixir\n# Lift equality for Either values\nEither.lift_eq(&==/2)\n\n# Lift ordering for Either values  \nEither.lift_ord(&compare/2)\n```","ref":"monad-either-usage-rules.html#lifting"},{"type":"extras","title":"Elixir Interoperability - Funx.Monad.Either Usage Rules","doc":"### `from_result/1` - Convert from Result Tuples\n\n```elixir\n# Convert from {:ok, value} | {:error, reason} tuples\nEither.from_result({:ok, 42})         # right(42)\nEither.from_result({:error, \"fail\"})  # left(\"fail\")\n```\n\n### `to_result/1` - Convert to Result Tuples\n\n```elixir\n# Convert to {:ok, value} | {:error, reason} tuples\nEither.to_result(Either.right(42))        # {:ok, 42}\nEither.to_result(Either.left(\"fail\"))     # {:error, \"fail\"}\n```\n\n### `from_try/1` - Safe Function Execution\n\n```elixir\n# Run function safely, catching exceptions\nEither.from_try(fn -> 42 / 0 end)  # left(%ArithmeticError{})\nEither.from_try(fn -> 42 / 2 end)  # right(21.0)\n```\n\n### `to_try!/1` - Unwrap or Raise\n\n```elixir\nEither.to_try!(Either.right(42))       # 42\nEither.to_try!(Either.left(\"error\"))   # raises RuntimeError: \"error\"\n```","ref":"monad-either-usage-rules.html#elixir-interoperability"},{"type":"extras","title":"Folding Either Values - Funx.Monad.Either Usage Rules","doc":"**Core Concept**: Both `Left` and `Right` implement the `Funx.Foldable` protocol, providing `fold_l/3` for catamorphism (breaking down data structures).\n\n### `fold_l/3` - Functional Case Analysis\n\nThe fundamental operation for handling Either values without pattern matching:\n\n```elixir\nimport Funx.Foldable\n\n# fold_l(either_value, right_function, left_function)\nresult = fold_l(either_value, \n  fn success_value -> \"Success: #{success_value}\" end,  # Right case\n  fn error_value -> \"Error: #{error_value}\" end        # Left case\n)\n\n# Examples\nfold_l(Either.right(42), \n  fn value -> value * 2 end,     # Runs this: 84\n  fn error -> 0 end              # Never runs\n)\n\nfold_l(Either.left(\"failed\"), \n  fn value -> value * 2 end,     # Never runs\n  fn error -> \"Got: #{error}\" end # Runs this: \"Got: failed\"\n)\n```\n\n**Use `fold_l` when:**\n\n- You need to convert Either to a different type\n- You want functional case analysis without pattern matching\n- You're implementing higher-level combinators\n- You need to handle both success and error cases","ref":"monad-either-usage-rules.html#folding-either-values"},{"type":"extras","title":"Folding vs Pattern Matching - Funx.Monad.Either Usage Rules","doc":"```elixir\n# ❌ Imperative pattern matching\ncase either_result do\n  %Right{right: value} -> \"Success: #{value}\"\n  %Left{left: error} -> \"Error: #{error}\"\nend\n\n# ✅ Functional folding\nfold_l(either_result,\n  fn value -> \"Success: #{value}\" end,\n  fn error -> \"Error: #{error}\" end\n)\n```","ref":"monad-either-usage-rules.html#folding-vs-pattern-matching"},{"type":"extras","title":"Advanced Folding Patterns - Funx.Monad.Either Usage Rules","doc":"```elixir\n# Convert Either to Result tuple\nto_result = fn either ->\n  fold_l(either,\n    fn value -> {:ok, value} end,\n    fn error -> {:error, error} end\n  )\nend\n\n# Extract value with default\nget_or_default = fn either, default ->\n  fold_l(either,\n    fn value -> value end,\n    fn _error -> default end\n  )\nend\n\n# Conditional processing based on Either state\nprocess_conditionally = fn either ->\n  fold_l(either,\n    fn value -> expensive_success_operation(value) end,\n    fn error -> log_error_and_return_default(error) end\n  )\nend\n```\n\n**When pattern matching is still appropriate:**\n\n```elixir\n# Complex data destructuring that fold_l can't handle elegantly\ncase either_result do\n  %Right{right: %User{name: name, role: :admin, permissions: perms}} -> \n    handle_admin(name, perms)\n  %Right{right: %User{role: :user} = user} -> \n    handle_regular_user(user)\n  %Left{left: %ValidationError{field: field, message: msg}} -> \n    handle_validation_error(field, msg)\n  %Left{left: error} -> \n    handle_generic_error(error)\nend\n```","ref":"monad-either-usage-rules.html#advanced-folding-patterns"},{"type":"extras","title":"Validation Patterns - Funx.Monad.Either Usage Rules","doc":"","ref":"monad-either-usage-rules.html#validation-patterns"},{"type":"extras","title":"Error-handling (Fail Fast) - Funx.Monad.Either Usage Rules","doc":"Use `bind/2` for operations that should stop on the first error:\n\n```elixir\ndef process_payment(payment_data) do\n  Either.right(payment_data)\n  |> bind(&validate_card_number/1)     # Stop if card invalid\n  |> bind(&validate_expiry_date/1)     # Stop if expiry invalid  \n  |> bind(&validate_cvv/1)             # Stop if CVV invalid\n  |> bind(&charge_card/1)              # Stop if charge fails\nend\n```","ref":"monad-either-usage-rules.html#error-handling-fail-fast"},{"type":"extras","title":"Validation (Collect All Errors) - Funx.Monad.Either Usage Rules","doc":"Use `traverse_a/2` to collect all validation errors:\n\n```elixir\ndef validate_user_registration(data) do\n  fields = [data.name, data.email, data.password, data.age]\n  validators = [\n    &validate_name/1,\n    &validate_email/1, \n    &validate_password/1,\n    &validate_age/1\n  ]\n  \n  Either.traverse_a(fields, validators)\n  |> fold_l(\n    fn [name, email, password, age] -> \n      {:ok, %User{name: name, email: email, password: password, age: age}}\n    end,\n    fn errors -> {:error, List.flatten(errors)} end\n  )\nend\n```","ref":"monad-either-usage-rules.html#validation-collect-all-errors"},{"type":"extras","title":"Refinement - Funx.Monad.Either Usage Rules","doc":"### `right?/1` and `left?/1` - Type Checks\n\n```elixir\nEither.right?(Either.right(42))      # true\nEither.right?(Either.left(\"err\"))    # false\n\nEither.left?(Either.left(\"err\"))     # true\nEither.left?(Either.right(42))       # false\n```","ref":"monad-either-usage-rules.html#refinement"},{"type":"extras","title":"Fallback and Extraction - Funx.Monad.Either Usage Rules","doc":"### `get_or_else/2` - Extract Value with Default\n\n```elixir\nEither.right(42) |> Either.get_or_else(0)        # 42\nEither.left(\"error\") |> Either.get_or_else(0)    # 0\n```\n\n### `or_else/2` - Fallback on Left\n\n```elixir\nEither.right(42) |> Either.or_else(fn -> Either.right(0) end)     # right(42)\nEither.left(\"error\") |> Either.or_else(fn -> Either.right(0) end) # right(0)\n```\n\n### `map_left/2` - Transform Left Values\n\n```elixir\n# Transform error without affecting success\nEither.right(42) |> Either.map_left(&String.upcase/1)     # right(42)\nEither.left(\"error\") |> Either.map_left(&String.upcase/1) # left(\"ERROR\")\n```\n\n### `flip/1` - Swap Left and Right\n\n```elixir\nEither.flip(Either.right(42))           # left(42)\nEither.flip(Either.left(\"error\"))       # right(\"error\")\n```\n\n### `filter_or_else/3` - Conditional Left Conversion\n\n```elixir\n# Convert Right to Left if predicate fails\nEither.right(42) |> Either.filter_or_else(&(&1 > 50), \"too small\")  # left(\"too small\")\nEither.right(100) |> Either.filter_or_else(&(&1 > 50), \"too small\") # right(100)\n```","ref":"monad-either-usage-rules.html#fallback-and-extraction"},{"type":"extras","title":"Combining Two Either Values with `ap/2` - Funx.Monad.Either Usage Rules","doc":"Use the applicative pattern with `ap/2` to combine two Either values with a binary function:\n\n```elixir\nimport Funx.Monad\nimport Funx.Foldable\n\n# Combine two Either values using ap\nadd_fn = Either.right(&+/2)\nap(add_fn, Either.right(3)) |> ap(Either.right(4))     # right(7)\nap(add_fn, Either.right(3)) |> ap(Either.left(\"error\"))   # left(\"error\")\nap(add_fn, Either.left(\"error\")) |> ap(Either.right(4))   # left(\"error\")\n\n# More concise with helper function\ncombine_either = fn ma, mb, f ->\n  Either.right(f) |> ap(ma) |> ap(mb)\nend\n\ncombine_either.(Either.right(3), Either.right(4), &+/2)         # right(7)\ncombine_either.(Either.right(3), Either.left(\"error\"), &+/2)    # left(\"error\")\n\n# String concatenation\ncombine_either.(Either.right(\"Hello, \"), Either.right(\"World!\"), &<>/2)  # right(\"Hello, World!\")\n\n# Validation combining\ncombine_either.(\n  validate_name(\"Alice\"),\n  validate_age(30),\n  fn name, age -> %{name: name, age: age} end\n)  # right(%{name: \"Alice\", age: 30}) or left(error)\n```\n\n**Use this pattern when:**\n\n- You need to combine exactly two Either values with a binary function\n- You want applicative-style combination that fails fast on first Left\n- You're implementing patterns similar to liftA2 from other functional languages","ref":"monad-either-usage-rules.html#combining-two-either-values-with-ap-2"},{"type":"extras","title":"Common Patterns - Funx.Monad.Either Usage Rules","doc":"","ref":"monad-either-usage-rules.html#common-patterns"},{"type":"extras","title":"API Response Handling - Funx.Monad.Either Usage Rules","doc":"```elixir\ndef fetch_user_profile(user_id) do\n  Either.right(user_id)\n  |> bind(&validate_user_id/1)        # Validate ID format\n  |> bind(&fetch_from_database/1)     # Database lookup\n  |> bind(&check_permissions/1)       # Authorization check\n  |> bind(&format_profile/1)          # Format response\n  |> fold_l(\n    fn profile -> {:ok, profile} end,\n    fn error -> {:error, error} end\n  )\nend\n```","ref":"monad-either-usage-rules.html#api-response-handling"},{"type":"extras","title":"Form Validation with Comprehensive Error Collection - Funx.Monad.Either Usage Rules","doc":"```elixir\n# Create individual field validators that work on the whole form\nvalidate_name_field = fn form_data ->\n  if String.length(form_data.name) > 0 do\n    Either.right(form_data.name)\n  else\n    Either.left([\"Name is required\"])\n  end\nend\n\nvalidate_email_field = fn form_data ->\n  if String.contains?(form_data.email, \"@\") and String.length(form_data.email) > 5 do\n    Either.right(form_data.email)\n  else\n    Either.left([\"Email must be valid\"])\n  end\nend\n\nvalidate_password_field = fn form_data ->\n  if String.length(form_data.password) >= 8 do\n    Either.right(form_data.password)\n  else\n    Either.left([\"Password must be at least 8 characters\"])\n  end\nend\n\n# Validate the entire form - collects ALL validation errors\ndef validate_registration_form(form_data) do\n  validators = [\n    validate_name_field,\n    validate_email_field,\n    validate_password_field\n  ]\n  \n  Either.validate(form_data, validators)\n  |> fold_l(\n    fn validated_form ->\n      {:ok, %{\n        name: validated_form.name,\n        email: validated_form.email,\n        password: validated_form.password\n      }}\n    end,\n    fn all_errors -> \n      {:error, \"Registration failed: #{Enum.join(List.flatten(all_errors), \", \")}\"}\n    end\n  )\nend\n\n# Example usage\nform_data = %{name: \"\", email: \"invalid\", password: \"123\"}\n\nvalidate_registration_form(form_data)\n# {:error, \"Registration failed: Name is required, Email must be valid, Password must be at least 8 characters\"}\n\nvalid_form = %{name: \"Alice\", email: \"alice@example.com\", password: \"securepass123\"}\nvalidate_registration_form(valid_form)\n# {:ok, %{name: \"Alice\", email: \"alice@example.com\", password: \"securepass123\"}}\n```","ref":"monad-either-usage-rules.html#form-validation-with-comprehensive-error-collection"},{"type":"extras","title":"Configuration Loading - Funx.Monad.Either Usage Rules","doc":"```elixir\ndef load_config(config_path) do\n  Either.right(config_path)\n  |> bind(&read_config_file/1)         # File -> Either Error String\n  |> bind(&parse_json/1)               # String -> Either Error Map\n  |> bind(&validate_schema/1)          # Map -> Either Error ValidConfig\n  |> bind(&apply_defaults/1)           # ValidConfig -> Either Error FinalConfig\nend\n\ndefp read_config_file(path) do\n  File.read(path)\n  |> Either.from_result()\n  |> Either.map_left(fn reason -> \"Failed to read #{path}: #{reason}\" end)\nend\n\ndefp parse_json(content) do\n  Jason.decode(content)\n  |> Either.from_result()\n  |> Either.map_left(fn %Jason.DecodeError{data: data} -> \"Invalid JSON: #{data}\" end)\nend\n```","ref":"monad-either-usage-rules.html#configuration-loading"},{"type":"extras","title":"Integration with Other Modules - Funx.Monad.Either Usage Rules","doc":"","ref":"monad-either-usage-rules.html#integration-with-other-modules"},{"type":"extras","title":"With Funx.Utils - Funx.Monad.Either Usage Rules","doc":"```elixir\n# Curry validation functions\nvalidate_range = Utils.curry(fn min, max, value ->\n  cond do\n    value   Either.left(\"Value #{value} below minimum #{min}\")\n    value > max -> Either.left(\"Value #{value} above maximum #{max}\")  \n    true -> Either.right(value)\n  end\nend)\n\nvalidate_age = validate_range.(0, 150)\nvalidate_percentage = validate_range.(0, 100)\n\nEither.right(25) |> bind(validate_age)        # right(25)\nEither.right(-5) |> bind(validate_age)        # left(\"Value -5 below minimum 0\")\n```","ref":"monad-either-usage-rules.html#with-funx-utils"},{"type":"extras","title":"Conversion from Maybe - Funx.Monad.Either Usage Rules","doc":"```elixir\n# Convert Maybe to Either with error context\ndef maybe_to_either(maybe_value, error_message) do\n  Maybe.fold_l(maybe_value, \n    fn value -> Either.right(value) end,\n    fn -> Either.left(error_message) end\n  )\nend\n\n# Usage in pipeline\ndef find_and_validate_user(user_id) do\n  user_id\n  |> find_user()                    # Returns Maybe User\n  |> maybe_to_either(\"User not found\")\n  |> bind(&validate_user_active/1)  # Continue with Either validation\nend\n```","ref":"monad-either-usage-rules.html#conversion-from-maybe"},{"type":"extras","title":"With Predicate Logic - Funx.Monad.Either Usage Rules","doc":"```elixir\n# Convert predicates to Either validators\ndef predicate_to_either(predicate, error_message) do\n  fn value ->\n    if predicate.(value) do\n      Either.right(value)\n    else\n      Either.left(error_message)\n    end\n  end\nend\n\n# Use with validation\nis_adult = fn user -> user.age >= 18 end\nvalidate_adult = predicate_to_either(is_adult, \"Must be 18 or older\")\n\nEither.right(%{age: 25})\n|> bind(validate_adult)             # right(%{age: 25})\n\nEither.right(%{age: 16})\n|> bind(validate_adult)             # left(\"Must be 18 or older\")\n```","ref":"monad-either-usage-rules.html#with-predicate-logic"},{"type":"extras","title":"Advanced Patterns - Funx.Monad.Either Usage Rules","doc":"","ref":"monad-either-usage-rules.html#advanced-patterns"},{"type":"extras","title":"Error Recovery - Funx.Monad.Either Usage Rules","doc":"```elixir\ndef process_with_fallback(data) do\n  data\n  |> process_primary_method()\n  |> fold_l(\n    fn result -> Either.right(result) end,\n    fn _error -> data |> process_fallback_method() end\n  )\nend\n\n# Or using a helper function\ndef either_or_else(either_result, fallback_fn) do\n  fold_l(either_result, &Either.right/1, fn _error -> fallback_fn.() end)\nend\n\ndata\n|> process_primary_method()\n|> either_or_else(fn -> process_fallback_method(data) end)\n```","ref":"monad-either-usage-rules.html#error-recovery"},{"type":"extras","title":"Error Mapping - Funx.Monad.Either Usage Rules","doc":"```elixir\ndef map_error(either_value, error_mapper) do\n  fold_l(either_value, \n    &Either.right/1,\n    fn error -> Either.left(error_mapper.(error)) end\n  )\nend\n\n# Usage: Convert database errors to user-friendly messages\ndef friendly_database_error(db_error) do\n  case db_error do\n    {:constraint, _} -> \"Data validation failed\"\n    {:connection, _} -> \"Database temporarily unavailable\"\n    _ -> \"An unexpected error occurred\"\n  end\nend\n\ndatabase_operation()\n|> map_error(&friendly_database_error/1)\n```","ref":"monad-either-usage-rules.html#error-mapping"},{"type":"extras","title":"Testing Strategies - Funx.Monad.Either Usage Rules","doc":"","ref":"monad-either-usage-rules.html#testing-strategies"},{"type":"extras","title":"Unit Testing Validation Logic - Funx.Monad.Either Usage Rules","doc":"```elixir\ndefmodule ValidationTest do\n  use ExUnit.Case\n  import Funx.Monad\n\n  test \"email validation with detailed errors\" do\n    # Valid email\n    assert validate_email(\"user@example.com\") == Either.right(\"user@example.com\")\n    \n    # Invalid formats\n    assert validate_email(\"\") == Either.left(\"Email cannot be empty\")\n    assert validate_email(\"invalid\") == Either.left(\"Email must contain @\")\n    assert validate_email(\"user@\") == Either.left(\"Invalid domain\")\n  end\n\n  test \"chaining validations with bind\" do\n    # Successful chain\n    result = Either.right(\"123\")\n    |> bind(&parse_integer/1)\n    |> bind(&validate_positive/1)\n    \n    assert result == Either.right(123)\n    \n    # Chain breaks on first error\n    result = Either.right(\"invalid\")\n    |> bind(&parse_integer/1)        # Fails here\n    |> bind(&validate_positive/1)    # Never runs\n    \n    assert {:left, _error} = result\n  end\n\n  test \"collecting validation errors with traverse_a\" do\n    invalid_data = [\"\", \"not-email\", \"invalid-age\"]\n    validators = [&validate_name/1, &validate_email/1, &validate_age/1]\n    \n    case Either.traverse_a(invalid_data, validators) do\n      {:left, errors} ->\n        assert length(errors) == 3  # All three validations failed\n        assert \"Name cannot be empty\" in errors\n      {:right, _} ->\n        flunk(\"Expected validation errors\")\n    end\n  end\nend\n```","ref":"monad-either-usage-rules.html#unit-testing-validation-logic"},{"type":"extras","title":"Performance Considerations - Funx.Monad.Either Usage Rules","doc":"","ref":"monad-either-usage-rules.html#performance-considerations"},{"type":"extras","title":"Short-Circuiting - Funx.Monad.Either Usage Rules","doc":"```elixir\n# bind chains short-circuit on first Left\n# This makes error-handling very efficient\n\nexpensive_validation = fn data ->\n  # This never runs if earlier validation failed\n  Process.sleep(1000)\n  Either.right(data)\nend\n\nEither.left(\"early error\")\n|> bind(&some_validation/1)\n|> bind(expensive_validation)      # Never executes\n|> bind(&another_validation/1)\n# Result: left(\"early error\"), computed instantly\n```","ref":"monad-either-usage-rules.html#short-circuiting"},{"type":"extras","title":"Memory Usage - Funx.Monad.Either Usage Rules","doc":"```elixir\n# Either uses minimal memory overhead\n# right(value) stores value plus small wrapper\n# left(error) stores error plus small wrapper\n\n# Efficient for error handling\nvalidation_result = %{\n  user: Either.right(%User{id: 1}),    # Small overhead\n  error: Either.left(\"Validation failed\")  # Small overhead\n}\n```","ref":"monad-either-usage-rules.html#memory-usage"},{"type":"extras","title":"Troubleshooting Common Issues - Funx.Monad.Either Usage Rules","doc":"","ref":"monad-either-usage-rules.html#troubleshooting-common-issues"},{"type":"extras","title":"Issue: Nested Either Values - Funx.Monad.Either Usage Rules","doc":"```elixir\n# ❌ Problem: Manual nesting creates Either (Either a)\nresult = Either.right(user_data)\n|> map(&validate_user/1)  # validate_user returns Either\n# Result: Either (Either User) - nested!\n\n# ✅ Solution: Use bind for functions that return Either\nresult = Either.right(user_data)\n|> bind(&validate_user/1)  # Automatically flattens to Either User\n```","ref":"monad-either-usage-rules.html#issue-nested-either-values"},{"type":"extras","title":"Issue: Mixing Validation Strategies - Funx.Monad.Either Usage Rules","doc":"```elixir\n# ❌ Problem: Inconsistent error handling approach\ndef mixed_validation(data) do\n  Either.right(data)\n  |> bind(&validate_required_field/1)    # Stops on first error\n  |> Either.validate([&validate_format/1])  # But this tries to collect all\nend\n\n# ✅ Solution: Pick one strategy consistently\ndef fail_fast_validation(data) do\n  Either.right(data)\n  |> bind(&validate_required_field/1)\n  |> bind(&validate_format/1)\n  |> bind(&validate_business_rules/1)\nend\n\ndef collect_all_errors_validation(data) do\n  fields = [data.field1, data.field2, data.field3]\n  validators = [&validate_field1/1, &validate_field2/1, &validate_field3/1]\n  Either.traverse_a(fields, validators)\nend\n```","ref":"monad-either-usage-rules.html#issue-mixing-validation-strategies"},{"type":"extras","title":"Issue: Pattern Matching Confusion - Funx.Monad.Either Usage Rules","doc":"```elixir\n# ❌ Problem: Imperative pattern matching instead of functional folding\ncase either_value do\n  %Right{right: value} -> process_success(value)\n  %Left{left: error} -> handle_error(error)\nend\n\n# ✅ Solution: Use functional folding instead  \neither_value\n|> fold_l(\n  fn value -> process_success(value) end,\n  fn error -> handle_error(error) end\n)\n```","ref":"monad-either-usage-rules.html#issue-pattern-matching-confusion"},{"type":"extras","title":"Issue: Over-using Pattern Matching - Funx.Monad.Either Usage Rules","doc":"```elixir\n# ❌ Problem: Manual unwrapping defeats the purpose\ncase either_value do\n  %Right{right: value} ->\n    new_value = transform(value)\n    Either.right(new_value)\n  %Left{left: error} -> Either.left(error)\nend\n\n# ✅ Solution: Use map to stay in Either context\neither_value |> map(&transform/1)\n```","ref":"monad-either-usage-rules.html#issue-over-using-pattern-matching"},{"type":"extras","title":"When Not to Use Either - Funx.Monad.Either Usage Rules","doc":"","ref":"monad-either-usage-rules.html#when-not-to-use-either"},{"type":"extras","title":"Use Maybe Instead When - Funx.Monad.Either Usage Rules","doc":"```elixir\n# ❌ Either with generic errors loses its advantage\ndef find_user(id) do\n  case get_user(id) do\n    nil -> Either.left(\"not found\")  # Generic error\n    user -> Either.right(user)\n  end\nend\n\n# ✅ Maybe is simpler for basic presence/absence\ndef find_user(id) do\n  case get_user(id) do\n    nil -> Maybe.nothing()\n    user -> Maybe.just(user)\n  end\nend\n```","ref":"monad-either-usage-rules.html#use-maybe-instead-when"},{"type":"extras","title":"Use Plain Values When - Funx.Monad.Either Usage Rules","doc":"```elixir\n# ❌ Either overhead for operations that can't fail\ndef calculate_tax(amount) do\n  Either.right(amount)\n  |> map(fn amt -> amt * 0.1 end)\nend\n\n# ✅ Plain calculation for guaranteed operations\ndef calculate_tax(amount) do\n  amount * 0.1\nend\n```","ref":"monad-either-usage-rules.html#use-plain-values-when"},{"type":"extras","title":"Use Exceptions When - Funx.Monad.Either Usage Rules","doc":"```elixir\n# ❌ Either for truly exceptional conditions\ndef divide(a, b) do\n  if b == 0 do\n    Either.left(\"Division by zero\")\n  else\n    Either.right(a / b)\n  end\nend\n\n# ✅ Exception for programmer errors\ndef divide(a, b) when b != 0 do\n  a / b\nend\n# Let it crash on division by zero - it's a programming error\n```","ref":"monad-either-usage-rules.html#use-exceptions-when"},{"type":"extras","title":"Summary - Funx.Monad.Either Usage Rules","doc":"Either provides error-safe computation with detailed failure context:\n\n**Core Operations:**\n\n- `right/1`: Wrap success values\n- `left/1`: Wrap error values with context\n- `map/2`: Transform success values, preserve errors\n- `bind/2`: Chain Either-returning operations with fail-fast behavior\n- `ap/2`: Apply functions across multiple Either values\n- `traverse_a/2`: Validate with error accumulation\n- `sequence/1`: Convert `[Either e a]` to `Either e [a]` with fail-fast\n\n**Key Patterns:**\n\n- Chain error-prone operations with `bind/2` for fail-fast\n- Validate multiple fields with `traverse_a/2` for error collection\n- Transform success values with `map/2`\n- Pattern match for specific error handling and recovery\n- Convert from {:ok, value} | {:error, reason} tuples\n\n**Mathematical Properties:**\n\n- **Functor**: `map` preserves structure (Right-biased)\n- **Applicative**: `ap` applies functions in context (fails if any Left)\n- **Monad**: `bind` enables dependent sequencing with error propagation\n\nRemember: Either represents \"success or detailed failure\" - use it when error context matters for debugging, user feedback, or recovery strategies.","ref":"monad-either-usage-rules.html#summary"},{"type":"extras","title":"Funx.Monad.Identity Usage Rules","doc":"# `Funx.Monad.Identity` Usage Rules","ref":"monad-identity-usage-rules.html"},{"type":"extras","title":"LLM Guidance - Funx.Monad.Identity Usage Rules","doc":"","ref":"monad-identity-usage-rules.html#llm-guidance"},{"type":"extras","title":"Functional Programming Foundation - Funx.Monad.Identity Usage Rules","doc":"**CRITICAL Elixir Implementation**: All monadic operations are under `Funx.Monad` protocol\n\n- **NO separate Functor/Applicative protocols** - Elixir protocols cannot be extended after definition\n- Always use `Monad.map/2`, `Monad.bind/2`, `Monad.ap/2` or import `Funx.Monad`\n- Different from Haskell's separate Functor, Applicative, Monad typeclasses\n\n**Identity**: The simplest possible monad - a transparent wrapper\n\n- `identity(value)` - wraps any value with no additional behavior\n- **No side effects**: Unlike Maybe (absence) or Either (errors)\n- **Transparent operations**: All operations work directly on the wrapped value\n- **Foundation monad**: Used for learning, testing, and building other monads\n- **Laws satisfied trivially**: All monad laws hold automatically","ref":"monad-identity-usage-rules.html#functional-programming-foundation"},{"type":"extras","title":"When to Use Identity - Funx.Monad.Identity Usage Rules","doc":"**✅ Use Identity for:**\n\n- **Testing monadic code**: Simplest monad for unit tests\n- **Learning FP concepts**: Understand map/bind/ap without side effects\n- **Polymorphic functions**: Code that works with any monad\n- **Prototyping**: Placeholder before choosing real monad\n\n**❌ Don't use Identity for:**\n\n- **Production business logic**: Usually need Maybe/Either semantics\n- **Error handling**: Identity has no failure concept\n- **Optional values**: Identity wraps everything, no absence","ref":"monad-identity-usage-rules.html#when-to-use-identity"},{"type":"extras","title":"Context Clues - Funx.Monad.Identity Usage Rules","doc":"**User language → Identity patterns:**\n\n- \"simplest monad\" → Identity is the canonical minimal monad\n- \"test my monad code\" → Use Identity for predictable testing\n- \"works with any monad\" → Write polymorphic code using Identity for examples\n- \"learning functional programming\" → Start with Identity to understand concepts","ref":"monad-identity-usage-rules.html#context-clues"},{"type":"extras","title":"Quick Reference - Funx.Monad.Identity Usage Rules","doc":"- Use `identity(value)` to wrap any value transparently\n- All operations work directly on the wrapped value with no special behavior\n- `run_identity(wrapped_value)` to extract the value\n- Import `Funx.Monad` for `map`, `bind`, `ap` operations\n- Perfect for testing, learning, and polymorphic programming\n- Satisfies all monad laws trivially due to its simplicity","ref":"monad-identity-usage-rules.html#quick-reference"},{"type":"extras","title":"Overview - Funx.Monad.Identity Usage Rules","doc":"`Funx.Monad.Identity` is the simplest monad - a transparent wrapper with no additional behavior.\n\nUse Identity for:\n- Learning monadic operations without complexity\n- Testing monadic code with predictable behavior\n- Writing polymorphic functions that work with any monad\n- Building and understanding more complex monads\n\n**Key insight**: Identity is \"just a wrapper\" - it provides the monadic interface while doing absolutely nothing else. This makes it perfect for understanding what the interface itself provides.","ref":"monad-identity-usage-rules.html#overview"},{"type":"extras","title":"Constructor - Funx.Monad.Identity Usage Rules","doc":"### `identity/1` - Wrap Any Value\n\nCreates an Identity monad containing a value:\n\n```elixir\nIdentity.identity(42)              # Identity(42)\nIdentity.identity(\"hello\")         # Identity(\"hello\")\nIdentity.identity([1, 2, 3])       # Identity([1, 2, 3])\nIdentity.identity(%{key: :value})  # Identity(%{key: :value})\n```\n\n### `run_identity/1` - Extract the Value\n\nExtracts the wrapped value from an Identity:\n\n```elixir\nIdentity.identity(42) |> Identity.run_identity()     # 42\nIdentity.identity(\"hello\") |> Identity.run_identity() # \"hello\"\n```","ref":"monad-identity-usage-rules.html#constructor"},{"type":"extras","title":"Core Operations - Funx.Monad.Identity Usage Rules","doc":"### `map/2` - Transform the Wrapped Value\n\nApplies a function to the wrapped value:\n\n```elixir\nimport Funx.Monad\n\nIdentity.identity(5)\n|> map(fn x -> x * 2 end)    # Identity(10)\n\nIdentity.identity(\"hello\")\n|> map(&String.upcase/1)     # Identity(\"HELLO\")\n\nIdentity.identity([1, 2, 3])\n|> map(&Enum.sum/1)          # Identity(6)\n```\n\n**Identity map behavior:**\n\n- Function is always applied (no short-circuiting like Maybe)\n- Result is always wrapped in Identity\n- No side effects or special cases\n\n### `bind/2` - Chain Identity Operations\n\nChains operations that return Identity values:\n\n```elixir\nimport Funx.Monad\n\n# Functions that return Identity\ndouble_wrapped = fn x -> Identity.identity(x * 2) end\nstringify_wrapped = fn x -> Identity.identity(to_string(x)) end\nupcase_wrapped = fn s -> Identity.identity(String.upcase(s)) end\n\nIdentity.identity(5)\n|> bind(double_wrapped)        # Identity(10)\n|> bind(stringify_wrapped)     # Identity(\"10\")\n|> bind(upcase_wrapped)        # Identity(\"10\")\n```\n\n**Identity bind behavior:**\n\n- Always applies the function (no conditional logic)\n- Automatically flattens nested Identity values\n- Perfect for demonstrating monadic composition\n\n### `ap/2` - Apply Functions Across Identity Values\n\nApplies a wrapped function to a wrapped value:\n\n```elixir\nimport Funx.Monad\n\n# Function wrapped in Identity\nIdentity.identity(fn x -> x + 10 end)\n|> ap(Identity.identity(5))          # Identity(15)\n\n# Multiple arguments with curried function\nadd = fn x -> fn y -> x + y end end\n\nIdentity.identity(add)\n|> ap(Identity.identity(3))          # Identity(fn y -> 3 + y end)\n|> ap(Identity.identity(4))          # Identity(7)\n\n# String concatenation\nconcat = fn x -> fn y -> x <> y end end\n\nIdentity.identity(concat)\n|> ap(Identity.identity(\"Hello, \"))\n|> ap(Identity.identity(\"World!\"))   # Identity(\"Hello, World!\")\n```\n\n**Identity ap behavior:**\n\n- Always applies function to value (no failure cases)\n- Demonstrates applicative functor pattern clearly\n- Perfect for learning function application in context","ref":"monad-identity-usage-rules.html#core-operations"},{"type":"extras","title":"Testing with Identity - Funx.Monad.Identity Usage Rules","doc":"","ref":"monad-identity-usage-rules.html#testing-with-identity"},{"type":"extras","title":"Unit Testing Monad Laws - Funx.Monad.Identity Usage Rules","doc":"```elixir\ndefmodule IdentityLawsTest do\n  use ExUnit.Case\n  import Funx.Monad\n  \n  test \"left identity law\" do\n    value = 42\n    f = fn x -> Identity.identity(x * 2) end\n    \n    # Left identity: pure(x) |> bind(f) == f.(x)\n    # Wrapping a value then binding should equal direct application\n    left = bind(Identity.identity(value), f)\n    right = f.(value)\n    \n    assert left == right\n  end\n  \n  test \"right identity law\" do\n    m = Identity.identity(42)\n    \n    # Right identity: m |> bind(pure) == m\n    # Binding with pure should leave the monad unchanged\n    result = bind(m, &Identity.identity/1)\n    \n    assert result == m\n  end\n  \n  test \"associativity law\" do\n    m = Identity.identity(42)\n    f = fn x -> Identity.identity(x * 2) end\n    g = fn x -> Identity.identity(x + 10) end\n    \n    # Associativity: (m |> bind(f)) |> bind(g) == m |> bind(fn x -> bind(f.(x), g) end)\n    # Order of binding operations doesn't matter\n    left = bind(bind(m, f), g)\n    right = bind(m, fn x -> bind(f.(x), g) end)\n    \n    assert left == right\n  end\n  \n  test \"functor laws\" do\n    m = Identity.identity(42)\n    f = fn x -> x * 2 end\n    g = fn x -> x + 10 end\n    \n    # map(id, m) == m\n    assert map(m, &Function.identity/1) == m\n    \n    # map(f . g, m) == map(f, map(g, m))\n    composed = fn x -> f.(g.(x)) end\n    assert map(m, composed) == map(map(m, g), f)\n  end\nend\n```","ref":"monad-identity-usage-rules.html#unit-testing-monad-laws"},{"type":"extras","title":"Testing Polymorphic Functions - Funx.Monad.Identity Usage Rules","doc":"```elixir\ndefmodule PolymorphicTest do\n  use ExUnit.Case\n  import Funx.Monad\n  \n  # A function that works with any monad\n  def process_data(monad_value) do\n    monad_value\n    |> map(&to_string/1)\n    |> bind(fn s -> \n      if String.length(s) > 3 do\n        # Return appropriate monad type\n        case monad_value do\n          %Identity{} -> Identity.identity(String.upcase(s))\n          %Maybe{} -> Maybe.just(String.upcase(s))\n          %Either{} -> Either.right(String.upcase(s))\n        end\n      else\n        case monad_value do\n          %Identity{} -> Identity.identity(\"TOO SHORT\")\n          %Maybe{} -> Maybe.nothing()\n          %Either{} -> Either.left(\"String too short\")\n        end\n      end\n    end)\n  end\n  \n  test \"polymorphic function with Identity\" do\n    # Test with long string\n    result = process_data(Identity.identity(12345))\n    assert result == Identity.identity(\"12345\")\n    \n    # Test with short string  \n    result = process_data(Identity.identity(42))\n    assert result == Identity.identity(\"TOO SHORT\")\n  end\nend\n```","ref":"monad-identity-usage-rules.html#testing-polymorphic-functions"},{"type":"extras","title":"Polymorphic Programming - Funx.Monad.Identity Usage Rules","doc":"Identity is perfect for learning and testing polymorphic monad code:\n\n```elixir\n# Generic function that works with any monad\ndef transform_and_chain(monad_value) do\n  monad_value\n  |> Monad.map(&(&1 + 5))              # Add 5\n  |> Monad.bind(fn x -> \n    case monad_value do                  # Return appropriate type\n      %Identity{} -> Identity.identity(x * 2)\n      %Maybe{} -> Maybe.just(x * 2)\n      %Either{} -> Either.right(x * 2)\n    end\n  end)\nend\n\n# Test with Identity - predictable, simple behavior\nIdentity.identity(10)\n|> transform_and_chain()  # Identity(30)\n\n# Same function works with other monads\nMaybe.just(10)\n|> transform_and_chain()  # Just(30)\n```","ref":"monad-identity-usage-rules.html#polymorphic-programming"},{"type":"extras","title":"Custom Monad Implementation Example - Funx.Monad.Identity Usage Rules","doc":"```elixir\n# Identity shows how to implement monads from scratch\ndefmodule CustomMonad do\n  defstruct [:value]\n  \n  # Note: pure/1 is the convention used in Haskell/FP literature\n  # It maps to identity/1 in this codebase\n  def pure(value), do: %CustomMonad{value: value}\n  \n  defimpl Funx.Monad do\n    def map(%CustomMonad{value: v}, f), do: CustomMonad.pure(f.(v))\n    \n    def bind(%CustomMonad{value: v}, f), do: f.(v)\n    \n    def ap(%CustomMonad{value: f}, %CustomMonad{value: v}) do\n      CustomMonad.pure(f.(v))\n    end\n  end\nend\n\n# This custom monad behaves exactly like Identity\nCustomMonad.pure(42)\n|> Monad.map(&(&1 * 2))  # %CustomMonad{value: 84}\n```","ref":"monad-identity-usage-rules.html#custom-monad-implementation-example"},{"type":"extras","title":"Performance Characteristics - Funx.Monad.Identity Usage Rules","doc":"","ref":"monad-identity-usage-rules.html#performance-characteristics"},{"type":"extras","title":"Minimal Overhead - Funx.Monad.Identity Usage Rules","doc":"```elixir\n# Identity has almost no runtime overhead\n# It's essentially a tagged tuple with one element\n\ndefmodule PerformanceTest do\n  def identity_operations(n) do\n    # These operations are very fast\n    1..n\n    |> Enum.reduce(Identity.identity(0), fn i, acc ->\n      acc\n      |> Monad.map(&(&1 + i))\n      |> Monad.bind(fn x -> Identity.identity(x * 2) end)\n      |> Monad.map(&rem(&1, 1000))\n    end)\n  end\n  \n  def plain_operations(n) do\n    # Compare with plain operations\n    1..n\n    |> Enum.reduce(0, fn i, acc ->\n      (acc + i)\n      |> (&(&1 * 2)).()\n      |> rem(1000)\n    end)\n  end\nend\n\n# The Identity version will be only slightly slower than plain operations\n# due to the minimal wrapping/unwrapping overhead\n```","ref":"monad-identity-usage-rules.html#minimal-overhead"},{"type":"extras","title":"Memory Usage - Funx.Monad.Identity Usage Rules","doc":"```elixir\n# Identity uses minimal memory - just a wrapper struct\nidentity_value = Identity.identity(\"Hello, World!\")\n\n# Memory layout is approximately:\n# %Identity{value: \"Hello, World!\"}\n# Just the string plus a small struct wrapper\n\n# Compare with other monads:\nmaybe_value = Maybe.just(\"Hello, World!\")     # Similar overhead\neither_value = Either.right(\"Hello, World!\")  # Similar overhead\n```","ref":"monad-identity-usage-rules.html#memory-usage"},{"type":"extras","title":"String Representation - Funx.Monad.Identity Usage Rules","doc":"Identity implements String.Chars for easy IEx interaction:\n\n```elixir\nIdentity.identity(42) |> to_string()     # \"Identity(42)\"\nIdentity.identity(\"hello\") |> to_string() # \"Identity(\\\"hello\\\")\"\n```","ref":"monad-identity-usage-rules.html#string-representation"},{"type":"extras","title":"Learning Patterns - Funx.Monad.Identity Usage Rules","doc":"","ref":"monad-identity-usage-rules.html#learning-patterns"},{"type":"extras","title":"Understanding Monad Interface - Funx.Monad.Identity Usage Rules","doc":"```elixir\ndefmodule MonadTutorial do\n  import Funx.Monad\n  \n  # Identity helps understand what each operation does\n  def demonstrate_map() do\n    # map transforms the value inside\n    result = Identity.identity(5)\n    |> map(fn x -> x * x end)\n    \n    IO.puts(\"map: Identity(5) -> Identity(25)\")\n    result  # Identity(25)\n  end\n  \n  def demonstrate_bind() do\n    # bind chains operations that return wrapped values\n    double_it = fn x -> Identity.identity(x * 2) end\n    \n    result = Identity.identity(5)\n    |> bind(double_it)\n    \n    IO.puts(\"bind: Identity(5) -> Identity(10)\")  \n    result  # Identity(10)\n  end\n  \n  def demonstrate_ap() do\n    # ap applies wrapped functions to wrapped values\n    add_fn = fn x -> fn y -> x + y end end\n    \n    result = Identity.identity(add_fn)\n    |> ap(Identity.identity(3))\n    |> ap(Identity.identity(7))\n    \n    IO.puts(\"ap: Identity(add) + Identity(3) + Identity(7) -> Identity(10)\")\n    result  # Identity(10)\n  end\n  \n  def show_difference_from_maybe() do\n    # Same operations with Maybe show the difference\n    transform = fn x -> x * 2 end\n    \n    # Identity always transforms\n    identity_result = Identity.identity(5) |> map(transform)\n    # Identity(10)\n    \n    # Maybe might not transform (if Nothing)\n    maybe_result1 = Maybe.just(5) |> map(transform)      # Maybe.just(10) \n    maybe_result2 = Maybe.nothing() |> map(transform)    # Maybe.nothing()\n    \n    # Identity is predictable, Maybe depends on presence\n  end\nend\n```\n\nIdentity helps you understand monadic patterns without complexity:\n\n```elixir\n# Pattern recognition: Transform -> Validate -> Chain\ndef learn_pattern(value) do\n  Identity.identity(value)\n  |> map(&(&1 + 10))           # Transform: add 10\n  |> bind(fn x ->              # Validate and chain\n    if x > 15 do\n      Identity.identity(\"large: #{x}\")\n    else\n      Identity.identity(\"small: #{x}\")\n    end\n  end)\nend\n\nlearn_pattern(10)  # Identity(\"large: 20\")\nlearn_pattern(3)   # Identity(\"small: 13\")\n```","ref":"monad-identity-usage-rules.html#understanding-monad-interface"},{"type":"extras","title":"Integration with Utils - Funx.Monad.Identity Usage Rules","doc":"```elixir\n# Identity works seamlessly with Utils functions\nadd_ten = Funx.Utils.curry_r(&+/2).(10)\n\nIdentity.identity(5)\n|> Monad.map(add_ten)        # Identity(15)\n\n# Function composition in monadic context  \nidentity_pipeline = fn value ->\n  Identity.identity(value)\n  |> Monad.map(&(&1 + 1))    # Add 1\n  |> Monad.map(&(&1 * 2))    # Multiply by 2  \n  |> Monad.map(&(&1 - 3))    # Subtract 3\nend\n\nidentity_pipeline.(5)        # Identity(9)\n```","ref":"monad-identity-usage-rules.html#integration-with-utils"},{"type":"extras","title":"Testing Other Monads - Funx.Monad.Identity Usage Rules","doc":"```elixir\ndefmodule MonadTester do\n  import Funx.Monad\n  \n  # Test the same logic across different monads\n  def test_computation(monad_constructor, value) do\n    computation = fn m ->\n      m\n      |> map(&(&1 * 2))\n      |> bind(fn x ->\n        monad_constructor.(x + 5)\n      end)\n      |> map(&to_string/1)\n    end\n    \n    monad_constructor.(value)\n    |> computation.()\n  end\n  \n  def run_tests() do\n    # Test with Identity - always succeeds predictably\n    identity_result = test_computation(&Identity.identity/1, 10)\n    # Identity(\"25\")\n    \n    # Test with Maybe - succeeds with just\n    maybe_result = test_computation(&Maybe.just/1, 10) \n    # Maybe.just(\"25\")\n    \n    # Test with Either - succeeds with right\n    either_result = test_computation(&Either.right/1, 10)\n    # Either.right(\"25\")\n    \n    # Identity gives us the baseline expected behavior\n    %{\n      identity: identity_result,\n      maybe: maybe_result, \n      either: either_result\n    }\n  end\nend\n```","ref":"monad-identity-usage-rules.html#testing-other-monads"},{"type":"extras","title":"Advanced Patterns - Funx.Monad.Identity Usage Rules","doc":"","ref":"monad-identity-usage-rules.html#advanced-patterns"},{"type":"extras","title":"Custom Monad Implementation Guide - Funx.Monad.Identity Usage Rules","doc":"```elixir\n# Identity shows the minimal implementation needed for a monad\n\ndefmodule CustomMonad do\n  defstruct [:value]\n  \n  # Constructor (like Identity.identity/1)\n  def pure(value), do: %__MODULE__{value: value}\n  \n  # Functor implementation (like map)\n  def fmap(%__MODULE__{value: v}, f) do\n    %__MODULE__{value: f.(v)}\n  end\n  \n  # Monad implementation (like bind)\n  def bind(%__MODULE__{value: v}, f) do\n    f.(v)  # f should return another CustomMonad\n  end\n  \n  # Extractor (like run_identity)\n  def extract(%__MODULE__{value: v}), do: v\nend\n\n# This follows the same pattern as Identity but could add behavior\n# For example, logging, counting operations, etc.\n\ndefimpl Funx.Monad, for: CustomMonad do\n  def map(monad, f), do: CustomMonad.fmap(monad, f)\n  def bind(monad, f), do: CustomMonad.bind(monad, f)\n  def ap(monad_f, monad_x) do\n    # Standard applicative implementation\n    CustomMonad.bind(monad_f, fn f ->\n      CustomMonad.fmap(monad_x, f)\n    end)\n  end\nend\n```","ref":"monad-identity-usage-rules.html#custom-monad-implementation-guide"},{"type":"extras","title":"Monad Stack Exploration - Funx.Monad.Identity Usage Rules","doc":"```elixir\n# Identity at the bottom of monad transformer stacks\n\n# MaybeT Identity a ≅ Maybe a\n# EitherT e Identity a ≅ Either e a  \n# StateT s Identity a ≅ State s a\n\n# Identity is often the \"base\" monad in transformer stacks\n# Understanding Identity helps understand how transformers work\n\ndefmodule StackExample do\n  # Simulate MaybeT Identity (which is just Maybe)\n  def maybe_t_identity_example(value) do\n    # This is conceptually MaybeT Identity, but it's just Maybe\n    case value do\n      nil -> Maybe.nothing()\n      x when x > 0 -> Maybe.just(x * 2)\n      _ -> Maybe.nothing()\n    end\n  end\n  \n  # If we had a real MaybeT Identity, it would look like:\n  # newtype MaybeT Identity a = Identity (Maybe a)\n  # But since Identity is transparent, it's just Maybe a\nend\n```","ref":"monad-identity-usage-rules.html#monad-stack-exploration"},{"type":"extras","title":"Common Patterns and Use Cases - Funx.Monad.Identity Usage Rules","doc":"","ref":"monad-identity-usage-rules.html#common-patterns-and-use-cases"},{"type":"extras","title":"Educational Sequencing - Funx.Monad.Identity Usage Rules","doc":"```elixir\n# Use Identity to learn sequence/traverse patterns\ndefmodule SequenceExample do\n  import Funx.Monad\n  \n  def sequence_identities(list_of_identities) do\n    # This is educational - sequence([Identity a]) -> Identity [a]\n    values = list_of_identities |> Enum.map(&Identity.run_identity/1)\n    Identity.identity(values)\n  end\n  \n  def traverse_with_identity(list, f) do\n    # Apply f to each element, collect in Identity\n    results = list |> Enum.map(f) |> Enum.map(&Identity.run_identity/1)\n    Identity.identity(results)\n  end\n  \n  # Examples\n  def examples() do\n    identities = [Identity.identity(1), Identity.identity(2), Identity.identity(3)]\n    sequenced = sequence_identities(identities)\n    # Identity([1, 2, 3])\n    \n    numbers = [1, 2, 3]\n    traversed = traverse_with_identity(numbers, fn x -> Identity.identity(x * 2) end)\n    # Identity([2, 4, 6])\n  end\nend\n```","ref":"monad-identity-usage-rules.html#educational-sequencing"},{"type":"extras","title":"Debugging Monad Chains - Funx.Monad.Identity Usage Rules","doc":"```elixir\n# Identity for debugging complex monad chains\ndefmodule DebugMonad do\n  import Funx.Monad\n  \n  def debug_chain(value) do\n    # Use Identity to debug logic without side effects\n    Identity.identity(value)\n    |> map(fn x -> \n      IO.puts(\"Step 1: #{x}\")\n      x * 2\n    end)\n    |> bind(fn x ->\n      IO.puts(\"Step 2: #{x}\")\n      Identity.identity(x + 10)\n    end)\n    |> map(fn x ->\n      IO.puts(\"Step 3: #{x}\")\n      to_string(x)\n    end)\n  end\n  \n  # Once logic is correct, switch to real monad\n  def production_chain(value) do\n    Maybe.just(value)  # or Either.right(value)\n    |> map(fn x -> x * 2 end)\n    |> bind(fn x -> \n      if x > 0 do\n        Maybe.just(x + 10)\n      else\n        Maybe.nothing()\n      end\n    end)\n    |> map(&to_string/1)\n  end\nend\n```","ref":"monad-identity-usage-rules.html#debugging-monad-chains"},{"type":"extras","title":"Summary - Funx.Monad.Identity Usage Rules","doc":"Identity provides the foundation for understanding monadic programming:\n\n**Core Operations:**\n\n- `identity/1`: Wrap any value transparently\n- `run_identity/1`: Extract the wrapped value\n- `map/2`: Transform wrapped values with no side effects\n- `bind/2`: Chain Identity-returning operations with automatic flattening\n- `ap/2`: Apply wrapped functions to wrapped values\n\n**Key Uses:**\n\n- **Learning**: Understand monad interface without complexity\n- **Testing**: Predictable behavior for unit tests\n- **Polymorphism**: Write generic code that works with any monad\n- **Prototyping**: Placeholder before choosing real monad\n- **Debugging**: Validate monad chain logic\n\n**Mathematical Properties:**\n\n- **Functor**: `map` applies function directly to wrapped value\n- **Applicative**: `ap` applies function with no failure cases\n- **Monad**: `bind` chains operations with trivial flattening\n- **Laws**: All monad laws satisfied automatically due to simplicity\n\nRemember: Identity is \"just a wrapper\" - it provides the monadic interface while being completely transparent. This makes it perfect for learning what monads are and testing monadic code without the complexity of real-world side effects.","ref":"monad-identity-usage-rules.html#summary"},{"type":"extras","title":"Funx.Monad.Maybe Usage Rules","doc":"# `Funx.Monad.Maybe` Usage Rules","ref":"monad-maybe-usage-rules.html"},{"type":"extras","title":"LLM Functional Programming Foundation - Funx.Monad.Maybe Usage Rules","doc":"**Key Concepts for LLMs:**\n\n**CRITICAL Elixir Implementation**: All monadic operations are under `Funx.Monad` protocol\n\n- **NO separate Functor/Applicative protocols** - Elixir protocols cannot be extended after definition\n- Always use `Monad.map/2`, `Monad.bind/2`, `Monad.ap/2` or import `Funx.Monad`\n- Different from Haskell's separate Functor, Applicative, Monad typeclasses\n\n**Kleisli Function**: A function `a -> Maybe b` (takes unwrapped value, returns wrapped value)\n\n- **Primary use**: `traverse/2` and `concat_map/2` for list operations\n- **Individual use**: `Monad.bind/2` for single Maybe values\n- Example: `find_user :: UserId -> Maybe User`\n\n**Key List Operation Patterns:**\n\n- `concat([Maybe a])` → `[a]` (extract all Just values, ignore Nothing)\n- `concat_map([a], kleisli_fn)` → `[b]` (apply Kleisli, collect Just results)\n- `traverse([a], kleisli_fn)` → `Maybe [b]` (apply Kleisli, all succeed or Nothing)\n- `sequence([Maybe a])` → `Maybe [a]` (like traverse with identity function)\n\n**Functor**: Something you can `map` over while preserving structure\n\n- `Monad.map/2 :: (a -> b) -> Maybe a -> Maybe b`\n- Transforms the present value, leaves Nothing unchanged\n\n**Applicative**: Allows applying functions inside a context\n\n- `Monad.ap/2 :: Maybe (a -> b) -> Maybe a -> Maybe b`  \n- Can combine multiple Maybe values\n\n**Monad**: Supports `bind` for chaining dependent computations\n\n- `Monad.bind/2 :: Maybe a -> (a -> Maybe b) -> Maybe b`\n- Flattens nested Maybe values automatically\n\n**Sequence (Category Theory)**: Swap the order of two type constructors\n\n- `[Maybe a]` → `Maybe [a]` (list of Maybe becomes Maybe of list)\n- Not about sequential processing - about type transformation\n\n**Presence vs Absence**:\n\n- Presence: Value exists and is usable\n- Absence: Value is missing, incomplete, or unavailable","ref":"monad-maybe-usage-rules.html#llm-functional-programming-foundation"},{"type":"extras","title":"LLM Decision Guide: When to Use Maybe - Funx.Monad.Maybe Usage Rules","doc":"**✅ Use Maybe when:**\n\n- Simple presence/absence (user profile, config value)\n- No error context needed (\"not found\" is sufficient)\n- Chaining operations that should skip on absence\n- Optional fields or nullable database columns\n- User says: \"optional\", \"might not exist\", \"could be missing\"\n\n**❌ Use Either when:**\n\n- Need specific error context (\"user not found\", \"validation failed\")\n- Multiple error types or recovery strategies\n- Business validation with detailed failure messages\n- User says: \"validate\", \"check requirements\", \"ensure valid\"\n\n**⚡ Maybe Strategy Decision:**\n\n- **Simple presence check**: Use `just/1` and `nothing/0` constructors\n- **Chain operations**: Use `bind/2` for individual Maybe sequencing\n- **Transform present values**: Use `map/2` with regular functions\n- **Combine multiple Maybe values**: Use `ap/2` for applicative pattern\n- **Apply Kleisli to lists**: Use `traverse/2` (all must succeed) or `concat_map/2` (collect successes)\n- **Convert lists**: Use `sequence/1` to flip `[Maybe a]` to `Maybe [a]`\n- **Pattern match results**: Use `case` with `%Just{value: value}` and `%Nothing{}`\n\n**⚙️ Function Choice Guide (Mathematical Purpose):**\n\n- **Chain dependent lookups**: `bind/2` with functions returning Maybe\n- **Transform present values**: `map/2` with functions returning plain values  \n- **Apply functions to multiple Maybe values**: `ap/2` for combining contexts\n- **Handle missing values**: Pattern match or use `from_nil/1`, `to_nil/1`\n- **Work with lists**: `sequence/1`, `traverse/2`, `traverse_a/2`","ref":"monad-maybe-usage-rules.html#llm-decision-guide-when-to-use-maybe"},{"type":"extras","title":"LLM Context Clues - Funx.Monad.Maybe Usage Rules","doc":"**User language → Maybe patterns:**\n\n- \"optional user profile\" → `find_user/1` returning Maybe User\n- \"might not have email\" → Maybe String for optional email field\n- \"chain lookups\" → `bind/2` with multiple Maybe-returning functions\n- \"transform if present\" → `map/2` to modify just the value\n- \"combine optional values\" → `ap/2` to apply function across Maybe values\n- \"list of optional items\" → `sequence/1` to collect all present values","ref":"monad-maybe-usage-rules.html#llm-context-clues"},{"type":"extras","title":"Quick Reference - Funx.Monad.Maybe Usage Rules","doc":"- Use `just(value)` for present values, `nothing()` for absence\n- Chain operations with `bind/2` - they skip automatically on `nothing`\n- Transform values with `map/2` - leaves `nothing` unchanged\n- Combine multiple Maybe values with `ap/2`\n- Use `bind/2` with identity to flatten nested Maybes: `bind(nested_maybe, fn x -> x end)`\n- Convert `[Maybe a]` to `Maybe [a]` with `sequence/1`\n- **Prefer `fold_l/3` over pattern matching** for functional case analysis\n- **Note**: Maybe values are structs `%Just{value: ...}` or `%Nothing{}`, not tagged tuples\n- Import `Funx.Monad` for `map`, `bind`, `ap` and `Funx.Foldable` for `fold_l`","ref":"monad-maybe-usage-rules.html#quick-reference"},{"type":"extras","title":"Overview - Funx.Monad.Maybe Usage Rules","doc":"`Funx.Monad.Maybe` handles presence and absence without explicit null checks.\n\nUse Maybe for:\n\n- Optional fields and nullable database columns\n- Operations that might not return a value\n- Chaining computations that should skip on missing data\n- Simple presence/absence (no detailed error context needed)\n\n**Key insight**: Maybe represents \"optional\" - either there's a value (`just`) or there isn't (`nothing`). All operations respect this, automatically skipping work when there's nothing to work with.","ref":"monad-maybe-usage-rules.html#overview"},{"type":"extras","title":"Constructors - Funx.Monad.Maybe Usage Rules","doc":"### `just/1` - Wrap a Present Value\n\nCreates a Maybe containing a value:\n\n```elixir\nMaybe.just(42)        # Present: contains 42\nMaybe.just(\"hello\")   # Present: contains \"hello\"\nMaybe.just([1, 2, 3]) # Present: contains [1, 2, 3]\n```\n\n### `nothing/0` - Represent Absence\n\nCreates a Maybe representing absence:\n\n```elixir\nMaybe.nothing()       # Absent: contains no value\n```\n\n### `pure/1` - Alias for `just/1`\n\nAlternative constructor for present values:\n\n```elixir\nMaybe.pure(42)    # Same as Maybe.just(42)\n```","ref":"monad-maybe-usage-rules.html#constructors"},{"type":"extras","title":"Core Operations - Funx.Monad.Maybe Usage Rules","doc":"### `map/2` - Transform Present Values\n\nApplies a function to the value inside a `just`, leaves `nothing` unchanged:\n\n```elixir\nimport Funx.Monad\nimport Funx.Foldable\n\nMaybe.just(5)\n|> map(fn x -> x * 2 end)    # just(10)\n\nMaybe.nothing()\n|> map(fn x -> x * 2 end)    # nothing() - function never runs\n```\n\n**Use `map` when:**\n\n- You want to transform the value if it exists\n- The transformation function returns a plain value (not wrapped in Maybe)\n- You want to preserve the Maybe structure\n\n### `bind/2` - Chain Dependent Operations\n\nChains operations that return Maybe values, automatically flattening nested Maybe:\n\n```elixir\nimport Funx.Monad\nimport Funx.Foldable\n\n# These functions return Maybe values\nfind_user = fn id -> if id > 0, do: Maybe.just(%{id: id}), else: Maybe.nothing() end\nget_email = fn user -> if user.id == 1, do: Maybe.just(\"user@example.com\"), else: Maybe.nothing() end\n\nMaybe.just(1)\n|> bind(find_user)    # just(%{id: 1})\n|> bind(get_email)    # just(\"user@example.com\")\n\nMaybe.just(-1)\n|> bind(find_user)    # nothing() - chain stops here\n|> bind(get_email)    # nothing() - this never runs\n```\n\n**Use `bind` when:**\n\n- You're chaining operations that each return Maybe\n- Each step depends on the result of the previous step\n- You want automatic short-circuiting on `nothing`\n\n**Common bind pattern:**\n\n```elixir\ndef process_user_id(user_id) do\n  Maybe.just(user_id)\n  |> bind(&find_user/1)         # UserId -> Maybe User\n  |> bind(&get_user_profile/1)  # User -> Maybe Profile  \n  |> bind(&format_name/1)       # Profile -> Maybe String\nend\n```\n\n### `ap/2` - Apply Functions Across Maybe Values\n\nApplies a function in a Maybe to a value in a Maybe:\n\n```elixir\nimport Funx.Monad\nimport Funx.Foldable\n\n# Apply a wrapped function to wrapped values\nMaybe.just(fn x -> x + 10 end)\n|> ap(Maybe.just(5))          # just(15)\n\n# Combine multiple Maybe values\nadd = fn x -> fn y -> x + y end end\n\nMaybe.just(add)\n|> ap(Maybe.just(3))          # just(fn y -> 3 + y end)\n|> ap(Maybe.just(4))          # just(7)\n\n# If any value is nothing, result is nothing\nMaybe.just(add)\n|> ap(Maybe.nothing())        # nothing()\n|> ap(Maybe.just(4))          # nothing()\n```\n\n**Use `ap` when:**\n\n- You want to apply a function to multiple Maybe values\n- You need all values to be present for the operation to succeed\n- You're implementing applicative patterns","ref":"monad-maybe-usage-rules.html#core-operations"},{"type":"extras","title":"Folding Maybe Values - Funx.Monad.Maybe Usage Rules","doc":"**Core Concept**: Both `Just` and `Nothing` implement the `Funx.Foldable` protocol, providing `fold_l/3` for catamorphism (breaking down data structures).\n\n### `fold_l/3` - Functional Case Analysis\n\nThe fundamental operation for handling Maybe values without pattern matching:\n\n```elixir\nimport Funx.Foldable\n\n# fold_l(maybe_value, just_function, nothing_function)\nresult = fold_l(maybe_value, \n  fn value -> \"Found: #{value}\" end,  # Just case\n  fn -> \"Not found\" end               # Nothing case\n)\n\n# Examples\nfold_l(Maybe.just(42), \n  fn value -> value * 2 end,    # Runs this: 84\n  fn -> 0 end                   # Never runs\n)\n\nfold_l(Maybe.nothing(), \n  fn value -> value * 2 end,    # Never runs\n  fn -> \"No value\" end          # Runs this: \"No value\"\n)\n```\n\n**Use `fold_l` when:**\n\n- You need to convert Maybe to a different type\n- You want functional case analysis without pattern matching\n- You're implementing higher-level combinators\n- You need to handle both present and absent cases","ref":"monad-maybe-usage-rules.html#folding-maybe-values"},{"type":"extras","title":"Folding vs Pattern Matching - Funx.Monad.Maybe Usage Rules","doc":"```elixir\n# ❌ Imperative pattern matching\ncase maybe_value do\n  %Just{value: value} -> \"Found: #{value}\"\n  %Nothing{} -> \"Not found\"\nend\n\n# ✅ Functional folding\nfold_l(maybe_value,\n  fn value -> \"Found: #{value}\" end,\n  fn -> \"Not found\" end\n)\n```","ref":"monad-maybe-usage-rules.html#folding-vs-pattern-matching"},{"type":"extras","title":"Advanced Folding Patterns - Funx.Monad.Maybe Usage Rules","doc":"```elixir\n# Extract value with default\nget_or_default = fn maybe, default ->\n  fold_l(maybe,\n    fn value -> value end,\n    fn -> default end\n  )\nend\n\n# Convert Maybe to result tuple\nto_result = fn maybe ->\n  fold_l(maybe,\n    fn value -> {:ok, value} end,\n    fn -> {:error, :not_found} end\n  )\nend\n\n# Conditional processing\nprocess_if_present = fn maybe ->\n  fold_l(maybe,\n    fn value -> expensive_operation(value) end,\n    fn -> :skipped end\n  )\nend\n```","ref":"monad-maybe-usage-rules.html#advanced-folding-patterns"},{"type":"extras","title":"Flattening Nested Maybe Values with `bind` - Funx.Monad.Maybe Usage Rules","doc":"Since there's no `join/1` function, use `bind/2` with the identity function to flatten nested Maybe values:\n\n```elixir\nimport Funx.Monad\n\n# Flatten nested Maybe using bind\nnested = Maybe.just(Maybe.just(42))\nbind(nested, fn inner -> inner end)    # just(42)\n\n# Nothing in outer - stays nothing\nouter_nothing = Maybe.nothing()\nbind(outer_nothing, fn inner -> inner end)    # nothing()\n\n# Nothing in inner - becomes nothing  \ninner_nothing = Maybe.just(Maybe.nothing())\nbind(inner_nothing, fn inner -> inner end)    # nothing()\n```\n\n**Use this pattern when:**\n\n- You have nested Maybe values that need flattening\n- You're implementing monadic operations manually\n- You're working with higher-order Maybe computations","ref":"monad-maybe-usage-rules.html#flattening-nested-maybe-values-with-bind"},{"type":"extras","title":"Functional Error Handling - Funx.Monad.Maybe Usage Rules","doc":"**Important**: Maybe values are structs `%Just{value: ...}` or `%Nothing{}`, not tagged tuples. Pattern matching must respect this shape.\n\nMaybe values are best handled with functional folding:\n\n```elixir\nfold_l(maybe_value,\n  fn value -> \"Found: #{value}\" end,\n  fn -> \"Not found\" end\n)\n```\n\n**Common patterns:**\n\n```elixir\n# Extract with default\nvalue = fold_l(maybe_user,\n  fn user -> user.name end,\n  fn -> \"Guest\" end\n)\n\n# Process only if present\nfold_l(maybe_config,\n  fn config -> apply_config(config) end,\n  fn -> :ok end\n)\n```","ref":"monad-maybe-usage-rules.html#functional-error-handling"},{"type":"extras","title":"Refinement - Funx.Monad.Maybe Usage Rules","doc":"### `just?/1` and `nothing?/1` - Type Checks\n\n```elixir\nMaybe.just?(Maybe.just(42))      # true\nMaybe.just?(Maybe.nothing())     # false\n\nMaybe.nothing?(Maybe.nothing())  # true\nMaybe.nothing?(Maybe.just(42))   # false\n```","ref":"monad-maybe-usage-rules.html#refinement"},{"type":"extras","title":"Fallback and Extraction - Funx.Monad.Maybe Usage Rules","doc":"### `get_or_else/2` - Extract Value with Default\n\n```elixir\nMaybe.just(42) |> Maybe.get_or_else(0)        # 42\nMaybe.nothing() |> Maybe.get_or_else(0)       # 0\n```\n\n### `or_else/2` - Fallback on Nothing\n\n```elixir\nMaybe.just(42) |> Maybe.or_else(fn -> Maybe.just(0) end)     # just(42)\nMaybe.nothing() |> Maybe.or_else(fn -> Maybe.just(0) end)    # just(0)\n```","ref":"monad-maybe-usage-rules.html#fallback-and-extraction"},{"type":"extras","title":"Combining Two Maybe Values with `ap/2` - Funx.Monad.Maybe Usage Rules","doc":"Use the applicative pattern with `ap/2` to combine two Maybe values with a binary function:\n\n```elixir\nimport Funx.Monad\n\n# Combine two Maybe values using ap\nadd_fn = Maybe.just(&+/2)\nap(add_fn, Maybe.just(3)) |> ap(Maybe.just(4))     # just(7)\nap(add_fn, Maybe.just(3)) |> ap(Maybe.nothing())   # nothing()\nap(add_fn, Maybe.nothing()) |> ap(Maybe.just(4))   # nothing()\n\n# More concise with helper function\ncombine_maybe = fn ma, mb, f ->\n  Maybe.just(f) |> ap(ma) |> ap(mb)\nend\n\ncombine_maybe.(Maybe.just(3), Maybe.just(4), &+/2)         # just(7)\ncombine_maybe.(Maybe.just(3), Maybe.nothing(), &+/2)       # nothing()\n\n# String concatenation\ncombine_maybe.(Maybe.just(\"Hello, \"), Maybe.just(\"World!\"), &<>/2)  # just(\"Hello, World!\")\n\n# Working with structs\ncombine_maybe.(\n  Maybe.just(%{name: \"Alice\"}),\n  Maybe.just(%{age: 30}),\n  fn user, age_info -> Map.merge(user, age_info) end\n)  # just(%{name: \"Alice\", age: 30})\n```\n\n**Use this pattern when:**\n\n- You need to combine exactly two Maybe values with a binary function\n- You want applicative-style combination that fails fast on first Nothing\n- You're implementing patterns similar to liftA2 from other functional languages","ref":"monad-maybe-usage-rules.html#combining-two-maybe-values-with-ap-2"},{"type":"extras","title":"Common Patterns - Funx.Monad.Maybe Usage Rules","doc":"","ref":"monad-maybe-usage-rules.html#common-patterns"},{"type":"extras","title":"Safe Navigation - Funx.Monad.Maybe Usage Rules","doc":"Instead of nested null checks:\n\n```elixir\n# Imperative style with null checks\ndef get_user_city(user_id) do\n  fold_l(find_user(user_id),\n    fn user ->\n      fold_l(get_address(user),\n        fn address -> address.city end,\n        fn -> nil end\n      )\n    end,\n    fn -> nil end\n  )\nend\n\n# Functional style with Maybe\ndef get_user_city(user_id) do\n  Maybe.just(user_id)\n  |> bind(&find_user_maybe/1)     # Returns Maybe User\n  |> bind(&get_address_maybe/1)   # Returns Maybe Address  \n  |> map(& &1.city)               # Extract city if present\nend\n```","ref":"monad-maybe-usage-rules.html#safe-navigation"},{"type":"extras","title":"Optional Field Processing - Funx.Monad.Maybe Usage Rules","doc":"```elixir\n# Process optional email field\ndef send_welcome_email(user) do\n  user.email\n  |> Maybe.from_nil()\n  |> map(&normalize_email/1)\n  |> bind(&validate_email/1)      # Returns Maybe valid_email\n  |> map(&send_email/1)           # Send if valid\n  |> Either.lift_maybe(\"No valid email\")\nend\n```","ref":"monad-maybe-usage-rules.html#optional-field-processing"},{"type":"extras","title":"Collecting Optional Values - Funx.Monad.Maybe Usage Rules","doc":"```elixir\n# Gather optional settings\ndef load_user_preferences(user_id) do\n  preferences = [\n    get_theme_preference(user_id),      # Maybe String\n    get_language_preference(user_id),   # Maybe String  \n    get_timezone_preference(user_id)    # Maybe String\n  ]\n  \n  Maybe.sequence(preferences)\n  |> map(fn [theme, lang, tz] -> \n    %{theme: theme, language: lang, timezone: tz}\n  end)\nend\n```","ref":"monad-maybe-usage-rules.html#collecting-optional-values"},{"type":"extras","title":"Integration with Other Modules - Funx.Monad.Maybe Usage Rules","doc":"","ref":"monad-maybe-usage-rules.html#integration-with-other-modules"},{"type":"extras","title":"With Funx.Utils - Funx.Monad.Maybe Usage Rules","doc":"```elixir\n# Curry functions for Maybe operations\nfind_by_id = Utils.curry(&find_user/1)\nuser_finder = find_by_id.(42)\n\nMaybe.just(database)\n|> bind(user_finder)\n\n# Compose Maybe-returning functions\ncompose_maybe = Utils.compose([\n  &Maybe.from_nil/1,\n  &get_user_profile/1,  # Returns Maybe\n  &format_display_name/1\n])\n```","ref":"monad-maybe-usage-rules.html#with-funx-utils"},{"type":"extras","title":"With Predicate Logic - Funx.Monad.Maybe Usage Rules","doc":"```elixir\n# Convert predicates to Maybe values\ndef predicate_to_maybe(predicate, value) do\n  if predicate.(value) do\n    Maybe.just(value)\n  else\n    Maybe.nothing()\n  end\nend\n\n# Use with validation\nis_adult = fn user -> user.age >= 18 end\n\nMaybe.just(user)\n|> bind(fn u -> predicate_to_maybe(is_adult, u) end)\n|> map(&process_adult_user/1)\n```","ref":"monad-maybe-usage-rules.html#with-predicate-logic"},{"type":"extras","title":"Conversions Between Types - Funx.Monad.Maybe Usage Rules","doc":"","ref":"monad-maybe-usage-rules.html#conversions-between-types"},{"type":"extras","title":"Conversion to Either - Funx.Monad.Maybe Usage Rules","doc":"```elixir\n# Convert Maybe to Either with error context using the built-in function\nEither.lift_maybe(maybe_value, \"Error message\")\n\n# Usage in validation pipeline\nMaybe.just(user_input)\n|> bind(&parse_user_id/1)\n|> maybe_to_either(\"Invalid user ID\")\n|> Either.bind(&detailed_validation/1)\n```","ref":"monad-maybe-usage-rules.html#conversion-to-either"},{"type":"extras","title":"List Operations - Funx.Monad.Maybe Usage Rules","doc":"### `concat/1` - Extract All Just Values\n\nRemoves all Nothing values and unwraps Just values from a list:\n\n```elixir\nMaybe.concat([\n  Maybe.just(1),\n  Maybe.nothing(),\n  Maybe.just(3),\n  Maybe.nothing()\n])                              # [1, 3]\n```\n\n### `concat_map/2` - Apply Function and Collect Just Results\n\n### `traverse/2` - Apply Kleisli to List (All Must Succeed)\n\nApplies a Kleisli function to each element, requiring all operations to succeed:\n\n```elixir\nimport Funx.Monad\nimport Funx.Foldable\n\n# Kleisli function: String -> Maybe Integer\nparse_number = fn str ->\n  case Integer.parse(str) do\n    {num, \"\"} -> Maybe.just(num)\n    _ -> Maybe.nothing()\n  end\nend\n\n# All succeed - get Maybe list\nMaybe.traverse([\"1\", \"2\", \"3\"], parse_number)  # just([1, 2, 3])\n\n# Any fail - get Nothing\nMaybe.traverse([\"1\", \"invalid\", \"3\"], parse_number)  # nothing()\n```\n\n**Use `traverse` when:**\n\n- All operations must succeed for meaningful result\n- You need fail-fast behavior on lists\n- Converting `[a]` to `Maybe [b]` with validation\n\n### `concat_map/2` - Apply Kleisli to List (Collect Successes)\n\nApplies a Kleisli function to each element, collecting only successful results:\n\n```elixir\n# Same Kleisli function as above\nparse_number = fn str ->\n  case Integer.parse(str) do\n    {num, \"\"} -> Maybe.just(num)\n    _ -> Maybe.nothing()\n  end\nend\n\n# Collect only successes - get plain list\nMaybe.concat_map([\"1\", \"invalid\", \"3\", \"bad\"], parse_number)  # [1, 3]\n\n# All succeed - get all results\nMaybe.concat_map([\"1\", \"2\", \"3\"], parse_number)  # [1, 2, 3]\n\n# All fail - get empty list\nMaybe.concat_map([\"bad\", \"invalid\", \"error\"], parse_number)  # []\n```\n\n**Use `concat_map` when:**\n\n- Partial success is acceptable\n- You want to collect all valid results\n- You need resilient processing that continues on failure\n\n### `sequence/1` - Convert List of Maybe to Maybe List\n\nConverts `[Maybe a]` to `Maybe [a]` - equivalent to `traverse` with identity function:\n\n```elixir\n# All present - success\nMaybe.sequence([\n  Maybe.just(1),\n  Maybe.just(2), \n  Maybe.just(3)\n])                            # just([1, 2, 3])\n\n# Any absent - failure  \nMaybe.sequence([\n  Maybe.just(1),\n  Maybe.nothing(),\n  Maybe.just(3)  \n])                            # nothing()\n\n# Relationship to traverse  \nMaybe.sequence(maybe_list) == Maybe.traverse(maybe_list, fn x -> x end)\n```\n\n**Use `sequence` when:**\n\n- You have a list of Maybe values from previous computations\n- You want all values to be present, or nothing at all\n- You're collecting results from multiple optional operations","ref":"monad-maybe-usage-rules.html#list-operations"},{"type":"extras","title":"List Operations Comparison - Funx.Monad.Maybe Usage Rules","doc":"```elixir\nuser_ids = [1, 2, 999, 4]  # 999 is invalid ID\n\n# traverse: All must succeed or nothing\nMaybe.traverse(user_ids, &find_user/1)\n# nothing() - because user 999 doesn't exist\n\n# concat_map: Collect successes, ignore failures  \nMaybe.concat_map(user_ids, &find_user/1)\n# [user1, user2, user4] - got the valid users\n\n# sequence: All existing values must be present\nexisting_maybes = [Maybe.just(user1), Maybe.nothing(), Maybe.just(user3)]\nMaybe.sequence(existing_maybes)  # nothing() - because one is Nothing\n```","ref":"monad-maybe-usage-rules.html#list-operations-comparison"},{"type":"extras","title":"Lifting - Funx.Monad.Maybe Usage Rules","doc":"### `lift_predicate/2` - Convert Value Based on Predicate\n\nConverts a value to Just if it meets a predicate, otherwise Nothing:\n\n```elixir\nvalidate_positive = Maybe.lift_predicate(&(&1 > 0))\n\nvalidate_positive.(5)   # just(5)\nvalidate_positive.(-1)  # nothing()\n```\n\n### `lift_either/1` - Convert Either to Maybe\n\nConverts an Either to Maybe, discarding Left error information:\n\n```elixir\nMaybe.lift_either(Either.right(42))    # just(42)\nMaybe.lift_either(Either.left(\"error\")) # nothing()\n```\n\n### `lift_identity/1` - Convert Identity to Maybe\n\nConverts an Identity monad to Maybe:\n\n```elixir\nMaybe.lift_identity(Identity.pure(42))  # just(42)\n```\n\n### `lift_eq/1` and `lift_ord/1` - Lift Comparison Functions\n\nLifts comparison functions for use in Maybe context:\n\n```elixir\n# Lift equality for Maybe values\nMaybe.lift_eq(&==/2)\n\n# Lift ordering for Maybe values  \nMaybe.lift_ord(&compare/2)\n```","ref":"monad-maybe-usage-rules.html#lifting"},{"type":"extras","title":"Elixir Interoperability - Funx.Monad.Maybe Usage Rules","doc":"### `from_nil/1` - Convert Nil to Maybe\n\n```elixir\nMaybe.from_nil(42)      # just(42)\nMaybe.from_nil(nil)     # nothing()\n```\n\n### `to_nil/1` - Convert Maybe to Nil\n\n```elixir\nMaybe.to_nil(Maybe.just(42))    # 42\nMaybe.to_nil(Maybe.nothing())   # nil\n```\n\n### `from_result/1` - Convert Result Tuple to Maybe\n\n```elixir\nMaybe.from_result({:ok, 42})        # just(42)\nMaybe.from_result({:error, \"fail\"}) # nothing()\n```\n\n### `to_result/1` - Convert Maybe to Result Tuple\n\n```elixir\nMaybe.to_result(Maybe.just(42))    # {:ok, 42}\nMaybe.to_result(Maybe.nothing())   # {:error, nil}\n```\n\n### `from_try/1` - Safe Function Execution\n\n```elixir\n# Run function safely, returning Nothing on exception\nMaybe.from_try(fn -> 42 / 0 end)  # nothing()\nMaybe.from_try(fn -> 42 / 2 end)  # just(21.0)\n```\n\n### `to_try!/2` - Unwrap or Raise with Custom Error\n\n```elixir\nMaybe.to_try!(Maybe.just(42), \"No value\")     # 42\nMaybe.to_try!(Maybe.nothing(), \"No value\")   # raises RuntimeError: \"No value\"\n```","ref":"monad-maybe-usage-rules.html#elixir-interoperability"},{"type":"extras","title":"Testing Strategies - Funx.Monad.Maybe Usage Rules","doc":"","ref":"monad-maybe-usage-rules.html#testing-strategies"},{"type":"extras","title":"Property-Based Testing - Funx.Monad.Maybe Usage Rules","doc":"```elixir\ndefmodule MaybePropertyTest do\n  use ExUnit.Case\n  use StreamData\n\n  property \"map preserves just structure\" do\n    check all value <- term(),\n              f <- StreamData.constant(fn x -> x + 1 end) do\n      result = Maybe.just(value) |> Monad.map(f)\n      assert Maybe.just?(result)\n    end\n  end\n\n  property \"map on nothing returns nothing\" do\n    check all f <- StreamData.constant(fn x -> x + 1 end) do\n      result = Maybe.nothing() |> Monad.map(f)\n      assert result == Maybe.nothing()\n    end\n  end\n\n  property \"bind with just applies function\" do\n    check all value <- integer(),\n              result_value <- integer() do\n      f = fn _x -> Maybe.just(result_value) end\n      result = Maybe.just(value) |> Monad.bind(f)\n      assert result == Maybe.just(result_value)\n    end\n  end\nend\n```","ref":"monad-maybe-usage-rules.html#property-based-testing"},{"type":"extras","title":"Unit Testing Common Patterns - Funx.Monad.Maybe Usage Rules","doc":"```elixir\ndefmodule MaybeTest do\n  use ExUnit.Case\n  import Funx.Monad\n\n  test \"chaining operations with bind\" do\n    # Successful chain\n    result = Maybe.just(5)\n    |> bind(fn x -> Maybe.just(x * 2) end)\n    |> bind(fn x -> Maybe.just(x + 1) end)\n    \n    assert result == Maybe.just(11)\n    \n    # Chain breaks on nothing\n    result = Maybe.just(5)\n    |> bind(fn _x -> Maybe.nothing() end)\n    |> bind(fn x -> Maybe.just(x + 1) end)  # Never executed\n    \n    assert result == Maybe.nothing()\n  end\n\n  test \"combining values with ap\" do\n    add = fn x -> fn y -> x + y end end\n    \n    result = Maybe.just(add)\n    |> ap(Maybe.just(10))\n    |> ap(Maybe.just(5))\n    \n    assert result == Maybe.just(15)\n    \n    # Fails if any value is nothing\n    result = Maybe.just(add)\n    |> ap(Maybe.nothing())\n    |> ap(Maybe.just(5))\n    \n    assert result == Maybe.nothing()\n  end\n\n  test \"sequence converts list of Maybe to Maybe list\" do\n    # All present\n    result = Maybe.sequence([\n      Maybe.just(1),\n      Maybe.just(2),\n      Maybe.just(3)\n    ])\n    assert result == Maybe.just([1, 2, 3])\n    \n    # Any absent\n    result = Maybe.sequence([\n      Maybe.just(1),\n      Maybe.nothing(),\n      Maybe.just(3)\n    ])\n    assert result == Maybe.nothing()\n  end\nend\n```","ref":"monad-maybe-usage-rules.html#unit-testing-common-patterns"},{"type":"extras","title":"Performance Considerations - Funx.Monad.Maybe Usage Rules","doc":"","ref":"monad-maybe-usage-rules.html#performance-considerations"},{"type":"extras","title":"Lazy Evaluation - Funx.Monad.Maybe Usage Rules","doc":"```elixir\n# Operations on nothing are essentially no-ops\n# This makes Maybe chains very efficient when they short-circuit early\n\nexpensive_computation = fn x ->\n  # This never runs if we start with nothing\n  Process.sleep(1000)\n  x * 2\nend\n\nMaybe.nothing()\n|> map(expensive_computation)    # Returns immediately\n|> bind(fn x -> Maybe.just(x + 1) end)\n# Result: nothing(), computed instantly\n```","ref":"monad-maybe-usage-rules.html#lazy-evaluation"},{"type":"extras","title":"Memory Usage - Funx.Monad.Maybe Usage Rules","doc":"```elixir\n# Maybe uses minimal memory overhead\n# just(value) stores the value plus a small wrapper\n# nothing() is a singleton, shared across all nothing instances\n\n# Efficient for optional fields\nuser = %{\n  id: 1,\n  name: \"Alice\",\n  email: Maybe.just(\"alice@example.com\"),  # Small overhead\n  phone: Maybe.nothing()                   # Shared singleton\n}\n```","ref":"monad-maybe-usage-rules.html#memory-usage"},{"type":"extras","title":"Troubleshooting Common Issues - Funx.Monad.Maybe Usage Rules","doc":"","ref":"monad-maybe-usage-rules.html#troubleshooting-common-issues"},{"type":"extras","title":"Issue: Nested Maybe Values - Funx.Monad.Maybe Usage Rules","doc":"```elixir\n# ❌ Problem: Manual nesting creates Maybe Maybe a\nresult = Maybe.just(user_id)\n|> map(&find_user/1)  # find_user returns Maybe User\n# Result: Maybe (Maybe User) - nested!\n\n# ✅ Solution: Use bind for functions that return Maybe\nresult = Maybe.just(user_id) \n|> bind(&find_user/1)  # Automatically flattens to Maybe User\n```","ref":"monad-maybe-usage-rules.html#issue-nested-maybe-values"},{"type":"extras","title":"Issue: Mixing Maybe with Nil - Funx.Monad.Maybe Usage Rules","doc":"```elixir\n# ❌ Problem: Inconsistent nil/Maybe usage\ndef process_data(data) do\n  fold_l(get_user(data),\n    fn user -> Maybe.just(user) end,\n    fn -> Maybe.nothing() end\n  )\n  |> map(&transform_user/1)\nend\n\n# ✅ Solution: Convert early, stay in Maybe context\ndef process_data(data) do\n  get_user(data)\n  |> Maybe.from_nil()      # Convert nil -> Maybe early\n  |> map(&transform_user/1)\nend\n```","ref":"monad-maybe-usage-rules.html#issue-mixing-maybe-with-nil"},{"type":"extras","title":"Issue: Pattern Matching Confusion - Funx.Monad.Maybe Usage Rules","doc":"```elixir\n# ❌ Problem: Imperative pattern matching instead of functional folding\ncase maybe_user do\n  %Just{value: user} -> process_user(user)\n  %Nothing{} -> handle_missing()\nend\n\n# ✅ Solution: Use functional folding\nfold_l(maybe_user,\n  fn user -> process_user(user) end,\n  fn -> handle_missing() end\n)\n```","ref":"monad-maybe-usage-rules.html#issue-pattern-matching-confusion"},{"type":"extras","title":"Issue: Over-using Pattern Matching - Funx.Monad.Maybe Usage Rules","doc":"```elixir\n# ❌ Problem: Manual unwrapping defeats the purpose\nfold_l(maybe_value,\n  fn value -> \n    new_value = transform(value)\n    Maybe.just(new_value)\n  end,\n  fn -> Maybe.nothing() end\n)\n\n# ✅ Solution: Use map to stay in Maybe context\nmaybe_value |> map(&transform/1)\n```","ref":"monad-maybe-usage-rules.html#issue-over-using-pattern-matching"},{"type":"extras","title":"When Not to Use Maybe - Funx.Monad.Maybe Usage Rules","doc":"","ref":"monad-maybe-usage-rules.html#when-not-to-use-maybe"},{"type":"extras","title":"Use Either Instead When - Funx.Monad.Maybe Usage Rules","doc":"```elixir\n# ❌ Maybe loses error context\ndef validate_email(email) do\n  if valid_email_format?(email) do\n    Maybe.just(email)\n  else\n    Maybe.nothing()  # Lost: why did validation fail?\n  end\nend\n\n# ✅ Either preserves error context  \ndef validate_email(email) do\n  cond do\n    String.length(email) == 0 -> Either.left(\"Email cannot be empty\")\n    not String.contains?(email, \"@\") -> Either.left(\"Email must contain @\")\n    not valid_domain?(email) -> Either.left(\"Invalid email domain\")\n    true -> Either.right(email)\n  end\nend\n```","ref":"monad-maybe-usage-rules.html#use-either-instead-when"},{"type":"extras","title":"Use Plain Values When - Funx.Monad.Maybe Usage Rules","doc":"```elixir\n# ❌ Maybe overhead for always-present values\ndef calculate_tax(amount) do\n  # Tax rate is always known, no need for Maybe\n  Maybe.just(amount)\n  |> map(fn amt -> amt * 0.1 end)\nend\n\n# ✅ Plain calculation for guaranteed values\ndef calculate_tax(amount) do\n  amount * 0.1\nend\n```","ref":"monad-maybe-usage-rules.html#use-plain-values-when"},{"type":"extras","title":"Summary - Funx.Monad.Maybe Usage Rules","doc":"Maybe provides null-safe computation for optional values:\n\n**Core Operations:**\n\n- `just/1`: Wrap present values\n- `nothing/0`: Represent absence  \n- `map/2`: Transform present values, skip absent\n- `bind/2`: Chain Maybe-returning operations with automatic flattening\n- `ap/2`: Apply functions across multiple Maybe values\n- `sequence/1`: Convert `[Maybe a]` to `Maybe [a]`\n\n**Key Patterns:**\n\n- Chain dependent lookups with `bind/2`\n- Transform values with `map/2`\n- Combine multiple optional values with `ap/2`\n- Collect all-or-nothing results with `sequence/1`\n- Pattern match for final handling\n\n**Mathematical Properties:**\n\n- **Functor**: `map` preserves structure\n- **Applicative**: `ap` applies functions in context\n- **Monad**: `bind` enables dependent sequencing with flattening\n\nRemember: Maybe represents \"optional\" - use it when absence is a valid state that should be handled gracefully, without needing specific error information.","ref":"monad-maybe-usage-rules.html#summary"},{"type":"extras","title":"Funx.Monad.Reader Usage Rules","doc":"# `Funx.Monad.Reader` Usage Rules","ref":"monad-reader-usage-rules.html"},{"type":"extras","title":"LLM Functional Programming Foundation - Funx.Monad.Reader Usage Rules","doc":"**Key Concepts for LLMs:**\n\n**CRITICAL Elixir Implementation**: All monadic operations are under `Funx.Monad` protocol\n\n- **NO separate Functor/Applicative protocols** - Elixir protocols cannot be extended after definition\n- Always use `Monad.map/2`, `Monad.bind/2`, `Monad.ap/2` or import `Funx.Monad`\n- Different from Haskell's separate Functor, Applicative, Monad typeclasses\n\n**Reader**: Represents deferred computation with read-only environment access\n\n- `pure(value)` creates a Reader that ignores environment, returns value\n- `run(reader, env)` executes the deferred computation with environment\n- `asks/1` extracts and transforms environment data\n- `ask/0` extracts full environment unchanged\n\n**Deferred Computation**: Define now, run later with environment\n\n- Reader describes computation steps but doesn't execute until `run/2`\n- **Lazy evaluation**: Nothing happens until environment is supplied\n- **Thunk pattern**: Functions that defer computation until needed\n\n**Environment Threading**: Read-only context passed through computation chain\n\n- Environment flows through `map/2`, `bind/2`, `ap/2` automatically\n- Each step can access environment via `asks/1` without explicit passing\n- **Key insight**: Eliminates prop drilling and explicit parameter passing","ref":"monad-reader-usage-rules.html#llm-functional-programming-foundation"},{"type":"extras","title":"LLM Decision Guide: When to Use Reader - Funx.Monad.Reader Usage Rules","doc":"","ref":"monad-reader-usage-rules.html#llm-decision-guide-when-to-use-reader"},{"type":"extras","title":"Use Reader For - Funx.Monad.Reader Usage Rules","doc":"- **Dependency injection** - swap implementations without changing logic\n- **Configuration access** - shared settings across computation chain\n- **Avoiding prop drilling** - deep access without threading parameters\n- **Environment-dependent logic** - computation that varies by context","ref":"monad-reader-usage-rules.html#use-reader-for"},{"type":"extras","title":"Don't Use Reader For - Funx.Monad.Reader Usage Rules","doc":"- **State modification** - Reader is read-only (use Writer or State)\n- **Error handling** - Reader doesn't short-circuit (use Either)\n- **Optional values** - Reader always requires environment (use Maybe)\n- **Simple value transformation** - Reader adds unnecessary complexity","ref":"monad-reader-usage-rules.html#don-t-use-reader-for"},{"type":"extras","title":"Core Patterns - Funx.Monad.Reader Usage Rules","doc":"","ref":"monad-reader-usage-rules.html#core-patterns"},{"type":"extras","title":"Construction and Execution - Funx.Monad.Reader Usage Rules","doc":"```elixir\nimport Funx.Monad, only: [map: 2, bind: 2, ap: 2]\n\n# Create Reader with pure value\nreader = Reader.pure(42)\nReader.run(reader, env)  # 42\n\n# Create Reader that uses environment  \nreader = Reader.asks(fn env -> env.api_key end)\nReader.run(reader, %{api_key: \"secret\"})  # \"secret\"\n\n# Access full environment\nreader = Reader.ask()\nReader.run(reader, %{foo: \"bar\"})  # %{foo: \"bar\"}\n```","ref":"monad-reader-usage-rules.html#construction-and-execution"},{"type":"extras","title":"Dependency Injection Pattern - Funx.Monad.Reader Usage Rules","doc":"```elixir\n# Define services\nprod_service = fn name -> \"Hello #{name} from production!\" end\ntest_service = fn name -> \"Hello #{name} from test!\" end\n\n# Create computation that depends on injected service\ngreet_user = fn user ->\n  Reader.asks(fn service -> service.(user.name) end)\nend\n\n# Build deferred computation\nuser = %{name: \"Alice\"}\ngreeting = greet_user.(user)\n\n# Inject different services\nReader.run(greeting, prod_service)  # \"Hello Alice from production!\"\nReader.run(greeting, test_service)  # \"Hello Alice from test!\"\n```","ref":"monad-reader-usage-rules.html#dependency-injection-pattern"},{"type":"extras","title":"Configuration Access Pattern - Funx.Monad.Reader Usage Rules","doc":"```elixir\n# Configuration-dependent computation\ncreate_api_client = Reader.asks(fn config ->\n  %ApiClient{\n    endpoint: config.api_endpoint,\n    timeout: config.timeout,\n    retries: config.max_retries\n  }\nend)\n\n# Use configuration\nconfig = %{api_endpoint: \"https://api.example.com\", timeout: 5000, max_retries: 3}\nclient = Reader.run(create_api_client, config)\n```","ref":"monad-reader-usage-rules.html#configuration-access-pattern"},{"type":"extras","title":"Avoid Prop Drilling Pattern - Funx.Monad.Reader Usage Rules","doc":"```elixir\n# Without Reader (prop drilling)\nsquare_tunnel = fn {n, user} -> {n * user} end\nformat_result = fn {n, user} -> \"#{user.name} has #{n}\" end\n\n{4, user} |> square_tunnel.() |> format_result.()\n\n# With Reader (clean separation)\nsquare = fn n -> n * n end\nformat_with_user = fn n ->\n  Reader.asks(fn user -> \"#{user.name} has #{n}\" end)\nend\n\nReader.pure(4)\n|> map(square)\n|> bind(format_with_user)\n|> Reader.run(user)  # \"Alice has 16\"\n```","ref":"monad-reader-usage-rules.html#avoid-prop-drilling-pattern"},{"type":"extras","title":"Key Rules - Funx.Monad.Reader Usage Rules","doc":"- **PURE for values** - Use `Reader.pure/1` for environment-independent values\n- **ASKS for environment** - Use `Reader.asks/1` to access and transform environment\n- **RUN to execute** - Always call `Reader.run/2` to resolve deferred computation\n- **LAZY execution** - Reader describes steps, nothing happens until run\n- **READ-ONLY access** - Environment cannot be modified, only read\n- **NO comparison** - Reader doesn't implement Eq/Ord (no meaningful comparison of deferred computations)","ref":"monad-reader-usage-rules.html#key-rules"},{"type":"extras","title":"Monadic Composition - Funx.Monad.Reader Usage Rules","doc":"","ref":"monad-reader-usage-rules.html#monadic-composition"},{"type":"extras","title":"Sequential Computation (bind) - Funx.Monad.Reader Usage Rules","doc":"```elixir\n# Chain Reader computations that depend on previous results\nfetch_user_config = fn user_id ->\n  Reader.asks(fn db -> Database.get_user_config(db, user_id) end)\nend\n\napply_defaults = fn config ->\n  Reader.asks(fn defaults -> Map.merge(defaults, config) end)\nend\n\n# Chain operations\nuser_id = 123\nfinal_config = Reader.pure(user_id)\n|> bind(fetch_user_config)\n|> bind(apply_defaults)\n\n# Execute with environment\nenv = %{db: database, defaults: %{theme: \"dark\", lang: \"en\"}}\nconfig = Reader.run(final_config, env)\n```","ref":"monad-reader-usage-rules.html#sequential-computation-bind"},{"type":"extras","title":"Parallel Computation (ap) - Funx.Monad.Reader Usage Rules","doc":"**Note**: `ap/2` applies a wrapped function to a wrapped value, threading environment through both.\n\n```elixir\n# Combine multiple Reader computations\nget_name = Reader.asks(fn user -> user.name end)\nget_email = Reader.asks(fn user -> user.email end)\nformat_contact = Reader.pure(fn name -> fn email -> \"#{name} <#{email}>\" end end)\n\n# Apply pattern for parallel access\ncontact = format_contact\n|> ap(get_name)\n|> ap(get_email)\n\nuser = %{name: \"Alice\", email: \"alice@example.com\"}\nReader.run(contact, user)  # \"Alice  \"\n```","ref":"monad-reader-usage-rules.html#parallel-computation-ap"},{"type":"extras","title":"Transformation (map) - Funx.Monad.Reader Usage Rules","doc":"```elixir\n# Transform Reader results\nget_age = Reader.asks(fn user -> user.age end)\ncategorize_age = fn age ->\n  cond do\n    age < 18 -> :minor\n    age < 65 -> :adult\n    true -> :senior\n  end\nend\n\nage_category = get_age |> map(categorize_age)\nReader.run(age_category, %{age: 25})  # :adult\n```","ref":"monad-reader-usage-rules.html#transformation-map"},{"type":"extras","title":"Advanced Patterns - Funx.Monad.Reader Usage Rules","doc":"","ref":"monad-reader-usage-rules.html#advanced-patterns"},{"type":"extras","title":"Nested Environment Access - Funx.Monad.Reader Usage Rules","doc":"```elixir\n# Access nested configuration\nget_db_config = Reader.asks(fn env -> env.database.connection_string end)\nget_cache_config = Reader.asks(fn env -> env.cache.redis_url end)\n\n# Combine nested access\nsetup_services = ap(\n  Reader.pure(fn db -> fn cache -> %{database: db, cache: cache} end end),\n  get_db_config\n) |> ap(get_cache_config)\n\nenv = %{\n  database: %{connection_string: \"postgres://...\"},\n  cache: %{redis_url: \"redis://...\"}\n}\nservices = Reader.run(setup_services, env)\n```","ref":"monad-reader-usage-rules.html#nested-environment-access"},{"type":"extras","title":"Conditional Logic with Environment - Funx.Monad.Reader Usage Rules","doc":"```elixir\n# Environment-dependent branching\nget_feature_flag = fn feature ->\n  Reader.asks(fn env -> Map.get(env.features, feature, false) end)\nend\n\nconditional_processing = fn data ->\n  get_feature_flag.(:use_new_algorithm)\n  |> bind(fn enabled ->\n    if enabled do\n      Reader.pure(new_algorithm(data))\n    else  \n      Reader.pure(legacy_algorithm(data))\n    end\n  end)\nend\n\n# Usage\nenv = %{features: %{use_new_algorithm: true}}\nresult = conditional_processing.(data) |> Reader.run(env)\n```","ref":"monad-reader-usage-rules.html#conditional-logic-with-environment"},{"type":"extras","title":"Reader Composition - Funx.Monad.Reader Usage Rules","doc":"```elixir\n# Compose Readers for complex workflows\nauthenticate_user = fn credentials ->\n  Reader.asks(fn auth_service -> auth_service.verify(credentials) end)\nend\n\nauthorize_action = fn user, action ->\n  Reader.asks(fn authz_service -> authz_service.can?(user, action) end)\nend\n\nfetch_data = fn query ->\n  Reader.asks(fn db -> db.query(query) end)\nend\n\n# Compose into workflow\nsecure_data_access = fn credentials, action, query ->\n  authenticate_user.(credentials)\n  |> bind(fn user -> authorize_action.(user, action))\n  |> bind(fn _authorized -> fetch_data.(query))\nend\n\n# Execute with services\nservices = %{\n  auth_service: auth_service,\n  authz_service: authz_service, \n  db: database\n}\ndata = Reader.run(secure_data_access.(creds, :read, \"SELECT * FROM users\"), services)\n```","ref":"monad-reader-usage-rules.html#reader-composition"},{"type":"extras","title":"Integration with Other Monads - Funx.Monad.Reader Usage Rules","doc":"","ref":"monad-reader-usage-rules.html#integration-with-other-monads"},{"type":"extras","title":"Reader + Either (Error Handling) - Funx.Monad.Reader Usage Rules","doc":"```elixir\n# Reader that might fail\nsafe_divide = fn x, y ->\n  Reader.asks(fn precision ->\n    if y == 0 do\n      Either.left(\"Division by zero\")\n    else\n      Either.right(Float.round(x / y, precision))\n    end\n  end)\nend\n\n# Chain Reader and Either\nresult = Reader.run(safe_divide.(10, 3), 2)  # Either.right(3.33)\n```","ref":"monad-reader-usage-rules.html#reader-either-error-handling"},{"type":"extras","title":"Reader + Maybe (Optional Values) - Funx.Monad.Reader Usage Rules","doc":"```elixir\n# Reader with optional results\nlookup_config = fn key ->\n  Reader.asks(fn config ->\n    case Map.get(config, key) do\n      nil -> Maybe.nothing()\n      value -> Maybe.just(value)\n    end\n  end)\nend\n\n# Usage\nconfig = %{timeout: 5000}\ntimeout = Reader.run(lookup_config.(:timeout), config)  # Maybe.just(5000)\nmissing = Reader.run(lookup_config.(:retries), config)  # Maybe.nothing()\n```","ref":"monad-reader-usage-rules.html#reader-maybe-optional-values"},{"type":"extras","title":"Testing Patterns - Funx.Monad.Reader Usage Rules","doc":"```elixir\n# Test Reader computations by providing mock environments\ntest \"dependency injection with Reader\" do\n  mock_service = fn name -> \"Mock greeting for #{name}\" end\n  real_service = fn name -> \"Real greeting for #{name}\" end\n  \n  greet = fn name ->\n    Reader.asks(fn service -> service.(name) end)\n  end\n  \n  greeting_reader = greet.(\"Alice\")\n  \n  # Test with mock\n  assert Reader.run(greeting_reader, mock_service) == \"Mock greeting for Alice\"\n  \n  # Test with real service  \n  assert Reader.run(greeting_reader, real_service) == \"Real greeting for Alice\"\nend\n\n# Test configuration access\ntest \"configuration-dependent behavior\" do\n  process_data = fn data ->\n    Reader.asks(fn config ->\n      if config.debug do\n        \"Debug: processing #{inspect(data)}\"\n      else\n        \"Processing data\"\n      end\n    end)\n  end\n  \n  processor = process_data.(%{id: 1})\n  \n  debug_config = %{debug: true}\n  prod_config = %{debug: false}\n  \n  assert Reader.run(processor, debug_config) == \"Debug: processing %{id: 1}\"\n  assert Reader.run(processor, prod_config) == \"Processing data\"\nend\n```","ref":"monad-reader-usage-rules.html#testing-patterns"},{"type":"extras","title":"Anti-Patterns - Funx.Monad.Reader Usage Rules","doc":"```elixir\n# L Don't modify environment (Reader is read-only)\nbad_reader = Reader.asks(fn env -> \n  Map.put(env, :modified, true)  # Environment change won't persist!\nend)\n\n# L Don't use Reader for error handling\nbad_error_handling = Reader.asks(fn env ->\n  if env.error?, do: raise(\"Error!\"), else: \"Success\"  # Use Either instead\nend)\n\n# L Don't nest Reader.run calls unnecessarily\nbad_nesting = fn env ->\n  inner = Reader.pure(42)\n  Reader.run(inner, env)  # Unnecessary - just use 42 directly\nend\n\n# L Don't compare Readers directly\nreader1 = Reader.pure(42)  \nreader2 = Reader.pure(42)\n# reader1 == reader2  # Won't work - Readers don't implement Eq\n\n# \u0005 Compare results instead\nenv = %{}\nReader.run(reader1, env) == Reader.run(reader2, env)  # true\n```","ref":"monad-reader-usage-rules.html#anti-patterns"},{"type":"extras","title":"Performance Considerations - Funx.Monad.Reader Usage Rules","doc":"- Reader computations are lazy - no work until `run/2`\n- Environment is passed through entire computation chain\n- Large environments may impact memory usage\n- Consider using focused `asks/1` to extract only needed data\n- Reader composition creates nested function calls - deep nesting may affect stack","ref":"monad-reader-usage-rules.html#performance-considerations"},{"type":"extras","title":"Best Practices - Funx.Monad.Reader Usage Rules","doc":"- Use Reader for read-only environment access, not state modification\n- Keep environments focused - avoid passing entire application state\n- Prefer `asks/1` with specific extractors over `ask/0` with full environment\n- Test Reader computations by providing different environments\n- Combine Reader with Either/Maybe for error handling and optional values\n- Use dependency injection pattern to swap implementations for testing\n- Document expected environment structure for Reader computations","ref":"monad-reader-usage-rules.html#best-practices"},{"type":"extras","title":"Common Use Cases - Funx.Monad.Reader Usage Rules","doc":"","ref":"monad-reader-usage-rules.html#common-use-cases"},{"type":"extras","title":"Web Application Configuration - Funx.Monad.Reader Usage Rules","doc":"```elixir\n# Request processing with configuration\nprocess_request = fn request ->\n  Reader.asks(fn config ->\n    %{\n      max_upload_size: config.upload.max_size,\n      allowed_types: config.upload.allowed_types,\n      timeout: config.request.timeout\n    }\n  end)\n  |> bind(fn settings -> validate_request(request, settings) end)\nend\n\n# Execute with app config\napp_config = %{\n  upload: %{max_size: 10_000_000, allowed_types: [\"jpg\", \"png\"]},\n  request: %{timeout: 30_000}\n}\nresult = Reader.run(process_request.(request), app_config)\n```","ref":"monad-reader-usage-rules.html#web-application-configuration"},{"type":"extras","title":"Database Operations - Funx.Monad.Reader Usage Rules","doc":"```elixir\n# Database operations with connection\nfetch_user = fn user_id ->\n  Reader.asks(fn db -> Database.get_user(db, user_id) end)\nend\n\nfetch_user_posts = fn user ->\n  Reader.asks(fn db -> Database.get_posts_by_user(db, user.id) end)\nend\n\n# Compose database operations\nget_user_data = fn user_id ->\n  fetch_user.(user_id)\n  |> bind(fetch_user_posts)\nend\n\n# Execute with database connection\ndb_connection = Database.connect()\nuser_data = Reader.run(get_user_data.(123), db_connection)\n```","ref":"monad-reader-usage-rules.html#database-operations"},{"type":"extras","title":"Feature Flag Systems - Funx.Monad.Reader Usage Rules","doc":"```elixir\n# Feature-dependent behavior\nrender_component = fn component_type ->\n  Reader.asks(fn features ->\n    if features.new_ui_enabled do\n      render_new_component(component_type)\n    else\n      render_legacy_component(component_type)\n    end\n  end)\nend\n\n# Usage with feature flags\nfeatures = %{new_ui_enabled: true, analytics_enabled: false}\ncomponent = Reader.run(render_component.(:navigation), features)\n```","ref":"monad-reader-usage-rules.html#feature-flag-systems"},{"type":"extras","title":"Summary - Funx.Monad.Reader Usage Rules","doc":"`Funx.Monad.Reader` provides **deferred computation with read-only environment access**:\n\n- **Deferred execution** - describe computation steps, execute later with environment\n- **Environment threading** - automatic context passing without prop drilling\n- **Dependency injection** - swap implementations without changing logic\n- **Configuration access** - shared settings across computation chains\n- **Lazy evaluation** - nothing happens until `Reader.run/2`\n- **Read-only access** - environment cannot be modified, only accessed\n- **Monadic composition** - chain environment-dependent computations cleanly\n\n**Canon**: Use Reader for dependency injection, configuration access, and avoiding prop drilling. Always `run/2` to execute deferred computations.","ref":"monad-reader-usage-rules.html#summary"},{"type":"extras","title":"Funx.Monoid Usage Rules","doc":"# `Funx.Monoid` Usage Rules","ref":"monoid-usage-rules.html"},{"type":"extras","title":"LLM Functional Programming Foundation - Funx.Monoid Usage Rules","doc":"**Key Concepts for LLMs:**\n\n**CRITICAL Elixir Implementation**: All monoid operations are under `Funx.Monoid` protocol\n\n- **NO separate Semigroup protocol** - Elixir protocols cannot be extended after definition  \n- Always use `Monoid.empty/1`, `Monoid.append/2` or import `Funx.Monoid`\n- Different from Haskell's separate Semigroup and Monoid typeclasses\n\n**Monoid Protocol**: Mathematical structure for associative combination with identity\n\n- `empty/1`: Returns the identity element for the monoid (like 0 for addition, [] for lists)\n- `append/2`: Associative binary operation that combines two values\n- `wrap/2` / `unwrap/1`: Infrastructure functions to convert between raw values and monoid wrappers\n- Example: `Monoid.append(%Sum{}, 5, 3)` combines numbers using addition\n\n**Monoid Laws**: Mathematical guarantees that ensure predictable behavior  \n\n- **Left Identity**: `append(empty(m), x) === x`\n- **Right Identity**: `append(x, empty(m)) === x`  \n- **Associativity**: `append(append(a, b), c) === append(a, append(b, c))`\n- These laws enable safe composition and parallel computation\n- Example: Summing `[1,2,3,4]` can be computed as `(1+2)+(3+4)` or `1+(2+(3+4))`\n\n**Algebraic Data Combination**: Monoids represent ways to combine data\n\n- **Sum**: Numbers with addition (`0` identity, `+` operation)  \n- **Product**: Numbers with multiplication (`1` identity, `*` operation)\n- **Max/Min**: Numbers with comparison (`-∞/+∞` identity, `max/min` operation)\n- **List**: Collections with concatenation (`[]` identity, `++` operation)\n- **All/Any**: Booleans with AND/OR (`true/false` identity, `&&/||` operation)\n- Example: Combining user preferences uses monoid to merge settings\n\n**Higher-Level Abstractions**: Monoids power utility functions\n\n- `Math.sum/1`, `Math.product/1` use numeric monoids internally\n- `Eq.Utils.concat_all/1` uses All monoid for AND-ing equality checks\n- `Predicate.p_all/1` uses All monoid for combining boolean predicates  \n- Example: `Math.sum([1,2,3])` internally uses Sum monoid but hides the complexity","ref":"monoid-usage-rules.html#llm-functional-programming-foundation"},{"type":"extras","title":"LLM Decision Guide: When to Use Monoid Protocol - Funx.Monoid Usage Rules","doc":"**✅ Use Monoid Protocol when:**\n\n- Need associative combination with identity (merging, accumulating, folding)\n- Building reusable combination logic for custom data types\n- Want parallel/distributed computation guarantees  \n- Creating utility functions that combine multiple values\n- User says: \"combine\", \"merge\", \"accumulate\", \"fold\", \"reduce\"\n\n**❌ Don't use Monoid Protocol when:**\n\n- Simple one-off combinations (use direct operations like `+`, `++`)\n- Non-associative operations (like subtraction or division)\n- No meaningful identity element exists\n- Operations have side effects or are non-deterministic\n\n**⚡ Monoid Strategy Decision:**\n\n- **Built-in types**: Use existing monoids (Sum, Product, Max, Min, ListConcat)\n- **Custom combination**: Define new monoid struct and protocol implementation  \n- **Application code**: Use high-level utilities (`Math`, `Eq.Utils`, `Ord.Utils`)\n- **Library code**: Expose monoids through utility functions, not raw protocol\n\n**⚙️ Function Choice Guide (Mathematical Purpose):**\n\n- **Identity element**: `empty/1` to get neutral value for combination\n- **Binary combination**: `append/2` to combine two values associatively\n- **Multiple combination**: `m_concat/2` to combine a list of values\n- **Utility helpers**: `m_append/3` for low-level monoid operations","ref":"monoid-usage-rules.html#llm-decision-guide-when-to-use-monoid-protocol"},{"type":"extras","title":"LLM Context Clues - Funx.Monoid Usage Rules","doc":"**User language → Monoid patterns:**\n\n- \"combine all these values\" → Use `m_concat/2` or utility functions\n- \"merge with defaults\" → Use monoid with appropriate identity element\n- \"accumulate results\" → Use monoid for associative accumulation  \n- \"parallel computation\" → Monoids enable safe parallelization\n- \"sum/product/max/min\" → Use `Math` utilities backed by monoids\n- \"AND/OR logic\" → Use `All/Any` monoids for boolean combination","ref":"monoid-usage-rules.html#llm-context-clues"},{"type":"extras","title":"Quick Reference - Funx.Monoid Usage Rules","doc":"- A monoid = `empty/1` (identity) + `append/2` (associative).  \n- Identities must be true identities (e.g. `0` for sum, `1` for product, `[]` for concatenation).  \n- `wrap/2` and `unwrap/1` exist for infrastructure, not daily use.  \n- `m_append/3` and `m_concat/2` are low-level helpers that power higher abstractions.  \n- Application code should prefer helpers in `Math`, `Eq.Utils`, `Ord.Utils`, or `Predicate`.","ref":"monoid-usage-rules.html#quick-reference"},{"type":"extras","title":"Overview - Funx.Monoid Usage Rules","doc":"`Funx.Monoid` defines how values combine under an associative operation with an identity.  \nEach monoid is represented by a struct (e.g. `%Sum{}`, `%Product{}`, `%Eq.All{}`, `%Ord{}`) and implements:\n\n- `Monoid.empty/1` → the identity element  \n- `Monoid.append/2` → associative combination  \n- `wrap/2` / `unwrap/1` → convert between raw values and monoid structs  \n\n**Important Implementation Detail**: Unlike Haskell's separate Semigroup and Monoid typeclasses, Elixir's protocol system limitations require all operations under the single `Funx.Monoid` protocol.\n\nMonoids are rarely used directly in application code. Instead, they support utilities like `Math.sum/1`, `Eq.Utils.concat_all/1`, and `Ord.Utils.concat/1`.","ref":"monoid-usage-rules.html#overview"},{"type":"extras","title":"Protocol Rules - Funx.Monoid Usage Rules","doc":"- Provide all four functions: `empty/1`, `append/2`, `wrap/2`, `unwrap/1`.  \n- Identity: `append(empty(m), x) == x == append(x, empty(m))`.  \n- Associativity: `append(append(a, b), c) == append(a, append(b, c))`.  \n- Purity: results must be deterministic and side-effect free.\n\n**Note**: While not typically needed, you can define a `join/1` operation for monoids that flattens nested monoid values (e.g., combining lists of lists) using `m_concat/2`. This provides symmetry with Monad operations for flattening nested structures.","ref":"monoid-usage-rules.html#protocol-rules"},{"type":"extras","title":"Preferred Usage - Funx.Monoid Usage Rules","doc":"","ref":"monoid-usage-rules.html#preferred-usage"},{"type":"extras","title":"Go Through Utilities - Funx.Monoid Usage Rules","doc":"Use high-level helpers instead of wiring monoids manually:\n\n- **Numbers** → `Math.sum/1`, `Math.product/1`, `Math.max/1`, `Math.min/1`  \n- **Equality** → `Eq.Utils.concat_all/1`, `Eq.Utils.concat_any/1`  \n- **Ordering** → `Ord.Utils.concat/1`, `Ord.Utils.append/2`  \n- **Predicates** → `Predicate.p_and/2`, `Predicate.p_or/2`, `Predicate.p_all/1`, `Predicate.p_any/1`\n\nThese functions already call `m_concat/2` and `m_append/3`.  \nYou don't need to construct `%Monoid.*{}` by hand.","ref":"monoid-usage-rules.html#go-through-utilities"},{"type":"extras","title":"Examples - Funx.Monoid Usage Rules","doc":"#### Equality Composition\n\n```elixir\nalias Funx.Eq.Utils, as: EqU\n\nname_eq = EqU.contramap(& &1.name)\nage_eq  = EqU.contramap(& &1.age)\n\nEqU.concat_all([name_eq, age_eq])  # AND semantics\nEqU.concat_any([name_eq, age_eq])  # OR semantics\n```\n\n#### Ordering Composition\n\n```elixir\nalias Funx.Ord.Utils, as: OrdU\n\nage  = OrdU.contramap(& &1.age)\nname = OrdU.contramap(& &1.name)\n\nOrdU.concat([age, name])  # lexicographic ordering\n```\n\n#### Math Helpers\n\n```elixir\nalias Funx.Math\n\nMath.sum([1, 2, 3])     # => 6\nMath.product([2, 3, 4]) # => 24\nMath.max([7, 3, 5])     # => 7\nMath.min([7, 3, 5])     # => 3\n```","ref":"monoid-usage-rules.html#examples"},{"type":"extras","title":"Interop - Funx.Monoid Usage Rules","doc":"- `Eq.Utils` relies on `Eq.All` and `Eq.Any` monoids for composition.\n- `Ord.Utils` uses the `Ord` monoid for lexicographic comparison.\n- `Math` uses monoids for numeric folds.\n\n**Rule of thumb:** application code never wires `%Monoid.*{}` directly—always go through the utility combinators.","ref":"monoid-usage-rules.html#interop"},{"type":"extras","title":"Stability Contract - Funx.Monoid Usage Rules","doc":"- Identities must be stable and input-independent.\n- `append/2` must be associative for all valid values.\n- `wrap/2` and `unwrap/1` must be inverses.","ref":"monoid-usage-rules.html#stability-contract"},{"type":"extras","title":"Anti-Patterns - Funx.Monoid Usage Rules","doc":"- Hand-wiring `%Monoid.*{}` in application code.\n- Mixing different monoid types in one `append/2`.\n- Using fake identities (`nil` instead of `0` for sum).\n- Hiding side effects inside protocol functions.\n\n**Type Safety Warning**: Always ensure values passed to `append/2` are of the same wrapped monoid type:\n\n```elixir\n# ❌ Wrong - mixing types\nappend(%Sum{}, 1, %Product{value: 2})  # Invalid - type mismatch\n\n# ✅ Right - consistent types  \nappend(%Sum{}, 1, 2)                   # OK: both values are integers\n```","ref":"monoid-usage-rules.html#anti-patterns"},{"type":"extras","title":"Good Patterns - Funx.Monoid Usage Rules","doc":"- Use `Math`, `Eq.Utils`, `Ord.Utils`, or `Predicate` instead of raw monoids.\n- Keep identities explicit in library code (`0`, `1`, `[]`, `Float.min_finite()` / `Float.max_finite()`).\n- Let `m_concat/2` and `m_append/3` handle the wrapping/combining logic.","ref":"monoid-usage-rules.html#good-patterns"},{"type":"extras","title":"When to Define a New Monoid - Funx.Monoid Usage Rules","doc":"Define a monoid struct if you need associative combination + identity:\n\n- Counters, tallies, or scores\n- Config merges (e.g. left-biased / right-biased maps)\n- \"Best-of\" or \"min-by/max-by\" selections\n- Predicate or decision combination\n\nExpose it through a utility module—application code should not use it raw.","ref":"monoid-usage-rules.html#when-to-define-a-new-monoid"},{"type":"extras","title":"Built-in Instances - Funx.Monoid Usage Rules","doc":"- `%Funx.Monoid.Sum{}` — numeric sum (`0`)\n- `%Funx.Monoid.Product{}` — numeric product (`1`)\n- `%Funx.Monoid.Max{}` — maximum (`Float.min_finite()`)\n- `%Funx.Monoid.Min{}` — minimum (`Float.max_finite()`)\n- `%Funx.Monoid.ListConcat{}` — list concatenation (`[]`)\n- `%Funx.Monoid.StringConcat{}` — string concatenation (`\"\"`)\n- `%Funx.Monoid.Predicate.All{}` — predicate AND composition (identity: `fn _ -> true end`)\n- `%Funx.Monoid.Predicate.Any{}` — predicate OR composition (identity: `fn _ -> false end`)\n- `%Funx.Monoid.Eq.All{}` / `%Funx.Monoid.Eq.Any{}` — equality composition\n- `%Funx.Monoid.Ord{}` — ordering composition\n\nThese back the higher-level helpers. Use `Math`, `Eq.Utils`, `Ord.Utils`, or `Predicate` instead.","ref":"monoid-usage-rules.html#built-in-instances"},{"type":"extras","title":"LLM Code Templates - Funx.Monoid Usage Rules","doc":"","ref":"monoid-usage-rules.html#llm-code-templates"},{"type":"extras","title":"Basic Monoid Usage Template - Funx.Monoid Usage Rules","doc":"```elixir\ndefmodule DataAggregator do\n  import Funx.Monoid\n  alias Funx.Math\n  \n  # Use high-level utilities instead of raw monoids\n  def analyze_numbers(numbers) do\n    %{\n      sum: Math.sum(numbers),           # Uses Sum monoid internally\n      product: Math.product(numbers),   # Uses Product monoid internally  \n      maximum: Math.max(numbers),       # Uses Max monoid internally\n      minimum: Math.min(numbers)        # Uses Min monoid internally\n    }\n  end\n  \n  # Custom combination using monoid utilities\n  def combine_stats(stat_list) do\n    stat_list\n    |> Enum.map(&extract_numbers/1)\n    |> Enum.reduce(fn nums1, nums2 ->\n      %{\n        sum: Math.sum([nums1.sum, nums2.sum]),\n        product: Math.product([nums1.product, nums2.product]),\n        max: Math.max([nums1.max, nums2.max]),\n        min: Math.min([nums1.min, nums2.min])\n      }\n    end)\n  end\nend\n```","ref":"monoid-usage-rules.html#basic-monoid-usage-template"},{"type":"extras","title":"Custom Monoid Implementation Template - Funx.Monoid Usage Rules","doc":"```elixir\ndefmodule UserPreferences do\n  defstruct theme: :light, notifications: true, language: \"en\"\nend\n\n# Custom monoid for merging user preferences (right-biased)\ndefmodule Funx.Monoid.UserPreferences do\n  defstruct []\n  \n  defimpl Funx.Monoid do\n    def empty(_), do: %UserPreferences{}\n    \n    def append(_, prefs1, prefs2) do\n      # Right-biased merge: prefs2 overwrites prefs1 for non-nil values\n      %UserPreferences{\n        theme: prefs2.theme || prefs1.theme,\n        notifications: if(is_nil(prefs2.notifications), do: prefs1.notifications, else: prefs2.notifications),\n        language: prefs2.language || prefs1.language\n      }\n    end\n    \n    def wrap(_, prefs), do: prefs\n    def unwrap(prefs), do: prefs\n  end\nend\n\ndefmodule PreferencesManager do\n  alias Funx.Monoid.Utils, as: MU\n  \n  def merge_user_preferences(preference_list) do\n    # Use monoid to combine multiple preference objects\n    MU.m_concat(%Funx.Monoid.UserPreferences{}, preference_list)\n  end\n  \n  def merge_with_defaults(user_prefs, defaults) do\n    # Combine with defaults using monoid\n    MU.m_append(%Funx.Monoid.UserPreferences{}, defaults, user_prefs)\n  end\nend\n```","ref":"monoid-usage-rules.html#custom-monoid-implementation-template"},{"type":"extras","title":"Monoid Law Verification Template - Funx.Monoid Usage Rules","doc":"```elixir\ndefmodule MonoidLawTester do\n  import Funx.Monoid\n  \n  # Generic test for any monoid implementation\n  def verify_monoid_laws(monoid_module, test_values) do\n    [a, b, c] = test_values\n    m = struct(monoid_module)\n    \n    # Left Identity: empty + a = a\n    left_identity = append(m, empty(m), a) == a\n    \n    # Right Identity: a + empty = a  \n    right_identity = append(m, a, empty(m)) == a\n    \n    # Associativity: (a + b) + c = a + (b + c)\n    left_assoc = append(m, append(m, a, b), c)\n    right_assoc = append(m, a, append(m, b, c))\n    associativity = left_assoc == right_assoc\n    \n    %{\n      left_identity: left_identity,\n      right_identity: right_identity,\n      associativity: associativity,\n      all_laws_hold: left_identity && right_identity && associativity\n    }\n  end\n  \n  # Test built-in monoids\n  def test_built_in_monoids() do\n    # Test Sum monoid\n    sum_result = verify_monoid_laws(Funx.Monoid.Sum, [5, 3, 8])\n    IO.inspect(sum_result, label: \"Sum monoid laws\")\n    \n    # Test Product monoid  \n    product_result = verify_monoid_laws(Funx.Monoid.Product, [2, 3, 4])\n    IO.inspect(product_result, label: \"Product monoid laws\")\n    \n    # Test List concatenation\n    list_result = verify_monoid_laws(Funx.Monoid.ListConcat, [[1, 2], [3], [4, 5]])\n    IO.inspect(list_result, label: \"ListConcat monoid laws\")\n  end\nend\n```","ref":"monoid-usage-rules.html#monoid-law-verification-template"},{"type":"extras","title":"Parallel Computation with Monoids Template - Funx.Monoid Usage Rules","doc":"```elixir\ndefmodule ParallelProcessor do\n  alias Funx.Math\n  \n  # Monoids enable safe parallel computation due to associativity\n  def parallel_sum(large_list) do\n    large_list\n    |> Enum.chunk_every(1000)  # Split into chunks\n    |> Task.async_stream(&Math.sum/1, max_concurrency: System.schedulers())\n    |> Enum.map(fn {:ok, partial_sum} -> partial_sum end)\n    |> Math.sum()  # Combine partial results\n  end\n  \n  def parallel_statistics(data_chunks) do\n    # Process chunks in parallel, then combine results\n    stats = data_chunks\n    |> Task.async_stream(fn chunk ->\n      %{\n        count: length(chunk),\n        sum: Math.sum(chunk),\n        max: Math.max(chunk),\n        min: Math.min(chunk)\n      }\n    end, max_concurrency: System.schedulers())\n    |> Enum.map(fn {:ok, stat} -> stat end)\n    \n    # Combine partial statistics using monoid properties\n    %{\n      total_count: Math.sum(Enum.map(stats, & &1.count)),\n      total_sum: Math.sum(Enum.map(stats, & &1.sum)),\n      overall_max: Math.max(Enum.map(stats, & &1.max)),\n      overall_min: Math.min(Enum.map(stats, & &1.min))\n    }\n  end\nend\n```","ref":"monoid-usage-rules.html#parallel-computation-with-monoids-template"},{"type":"extras","title":"Utils Integration Template - Funx.Monoid Usage Rules","doc":"```elixir\ndefmodule MonoidWithUtils do\n  alias Funx.Utils\n  alias Funx.Math\n  \n  # Create curried monoid operations\n  def build_aggregators() do\n    # Curry math operations for reuse\n    sum_reducer = Utils.curry_r(&Math.sum/1)\n    product_reducer = Utils.curry_r(&Math.product/1)\n    max_finder = Utils.curry_r(&Math.max/1)\n    \n    # Create specialized aggregators\n    sum_by = fn key ->\n      fn data_list ->\n        data_list\n        |> Enum.map(&Map.get(&1, key))\n        |> Math.sum()\n      end\n    end\n    \n    product_by = fn key ->\n      fn data_list ->\n        data_list\n        |> Enum.map(&Map.get(&1, key))  \n        |> Math.product()\n      end\n    end\n    \n    %{\n      sum_reducer: sum_reducer,\n      product_reducer: product_reducer,\n      max_finder: max_finder,\n      sum_by: sum_by,\n      product_by: product_by\n    }\n  end\n  \n  def analyze_grouped_data(grouped_data) do\n    aggregators = build_aggregators()\n    \n    # Apply different aggregations to different groups\n    for {group, data} <- grouped_data do\n      {group, %{\n        total_score: aggregators.sum_by.(:score).(data),\n        multiplied_weights: aggregators.product_by.(:weight).(data),\n        count: length(data)\n      }}\n    end\n  end\nend\n```","ref":"monoid-usage-rules.html#utils-integration-template"},{"type":"extras","title":"Predicate Integration Template - Funx.Monoid Usage Rules","doc":"```elixir\ndefmodule MonoidPredicateIntegration do\n  alias Funx.Predicate\n  alias Funx.Monoid.Utils, as: MU\n  alias Funx.Monoid.Predicate.{All, Any}\n  \n  # Predicates use specific monoids internally for combination\n  def build_complex_validators() do\n    # Individual predicates  \n    is_adult = fn person -> person.age >= 18 end\n    has_email = fn person -> String.contains?(person.email, \"@\") end\n    has_name = fn person -> String.length(person.name) > 0 end\n    is_verified = fn person -> person.verified end\n    \n    # Combine using predicate utilities (which use Predicate.All/Any monoids internally)\n    # p_all uses m_concat with %All{} monoid\n    strict_validator = Predicate.p_all([is_adult, has_email, has_name, is_verified])\n    basic_validator = Predicate.p_all([has_email, has_name])\n    \n    # p_any uses m_concat with %Any{} monoid  \n    flexible_validator = Predicate.p_any([is_adult, is_verified])\n    \n    %{\n      strict: strict_validator,\n      basic: basic_validator,\n      flexible: flexible_validator\n    }\n  end\n  \n  # Show how predicates compose via specific monoid types\n  def demonstrate_predicate_monoid_connection() do\n    # These predicates use Predicate.All/Any monoids internally\n    predicate1 = fn x -> x > 0 end\n    predicate2 = fn x -> x < 100 end  \n    predicate3 = fn x -> rem(x, 2) == 0 end\n    \n    # p_all uses m_concat(%All{}, predicates) for AND combination\n    all_validator = Predicate.p_all([predicate1, predicate2, predicate3])\n    \n    # p_any uses m_concat(%Any{}, predicates) for OR combination  \n    any_validator = Predicate.p_any([predicate1, predicate2, predicate3])\n    \n    # You could also use monoids directly (though predicates are cleaner)\n    manual_all = MU.m_concat(%All{}, [predicate1, predicate2, predicate3])\n    manual_any = MU.m_concat(%Any{}, [predicate1, predicate2, predicate3])\n    \n    # Test values\n    test_value = 42\n    \n    %{\n      predicate_all: all_validator.(test_value),  # true (42 > 0 AND 42 < 100 AND even)\n      predicate_any: any_validator.(test_value),  # true (42 > 0 OR 42 < 100 OR even)\n      manual_all: manual_all.(test_value),        # Same result as predicate_all\n      manual_any: manual_any.(test_value)         # Same result as predicate_any\n    }\n  end\n  \n  # Show the monoid identities that predicates rely on\n  def demonstrate_predicate_monoid_laws() do\n    import Funx.Monoid\n    \n    # All monoid: identity is function that always returns true\n    all_identity = empty(%All{})\n    IO.inspect(all_identity.(:anything), label: \"All monoid identity\")  # true\n    \n    # Any monoid: identity is function that always returns false  \n    any_identity = empty(%Any{})\n    IO.inspect(any_identity.(:anything), label: \"Any monoid identity\")  # false\n    \n    # This is why p_all([]) returns true and p_any([]) returns false\n    empty_all = Predicate.p_all([])\n    empty_any = Predicate.p_any([])\n    \n    %{\n      empty_all_result: empty_all.(:test),  # true (All identity)\n      empty_any_result: empty_any.(:test)   # false (Any identity)\n    }\n  end\nend\n```","ref":"monoid-usage-rules.html#predicate-integration-template"},{"type":"extras","title":"LLM Testing Guidance - Funx.Monoid Usage Rules","doc":"","ref":"monoid-usage-rules.html#llm-testing-guidance"},{"type":"extras","title":"Test Monoid Laws - Funx.Monoid Usage Rules","doc":"```elixir\ndefmodule MonoidTest do\n  use ExUnit.Case\n  import Funx.Monoid\n  \n  # Test that custom monoids satisfy laws\n  test \"UserPreferences monoid satisfies laws\" do\n    prefs1 = %UserPreferences{theme: :dark, language: \"en\"}\n    prefs2 = %UserPreferences{notifications: false}\n    prefs3 = %UserPreferences{theme: :light, language: \"es\"}\n    \n    monoid = %Funx.Monoid.UserPreferences{}\n    \n    # Test left identity: empty + a = a\n    assert append(monoid, empty(monoid), prefs1) == prefs1\n    \n    # Test right identity: a + empty = a\n    assert append(monoid, prefs1, empty(monoid)) == prefs1\n    \n    # Test associativity: (a + b) + c = a + (b + c)\n    left_assoc = append(monoid, append(monoid, prefs1, prefs2), prefs3)\n    right_assoc = append(monoid, prefs1, append(monoid, prefs2, prefs3))\n    assert left_assoc == right_assoc\n  end\n  \n  test \"Math utilities use monoids correctly\" do\n    numbers = [1, 2, 3, 4, 5]\n    \n    # These should be equivalent to manual monoid operations\n    assert Math.sum(numbers) == 15\n    assert Math.product(numbers) == 120\n    \n    # Test empty list behavior (should return identity)\n    assert Math.sum([]) == 0\n    assert Math.product([]) == 1\n  end\nend\n```","ref":"monoid-usage-rules.html#test-monoid-laws"},{"type":"extras","title":"Test Higher-Level Utilities - Funx.Monoid Usage Rules","doc":"```elixir\ntest \"utility functions hide monoid complexity\" do\n  # Test that utilities work without exposing monoid details\n  data = [\n    %{score: 10, weight: 0.5},\n    %{score: 20, weight: 1.0},  \n    %{score: 15, weight: 0.8}\n  ]\n  \n  total_score = data |> Enum.map(& &1.score) |> Math.sum()\n  assert total_score == 45\n  \n  total_weight = data |> Enum.map(& &1.weight) |> Math.sum()\n  assert total_weight == 2.3\nend\n```","ref":"monoid-usage-rules.html#test-higher-level-utilities"},{"type":"extras","title":"LLM Debugging Tips - Funx.Monoid Usage Rules","doc":"","ref":"monoid-usage-rules.html#llm-debugging-tips"},{"type":"extras","title":"Debug Monoid Operations - Funx.Monoid Usage Rules","doc":"```elixir\ndef debug_monoid_combination(monoid, values) do\n  IO.puts(\"Debugging monoid: #{inspect(monoid)}\")\n  IO.puts(\"Identity: #{inspect(empty(monoid))}\")\n  \n  # Show step-by-step combination\n  Enum.reduce(values, empty(monoid), fn value, acc ->\n    result = append(monoid, acc, value)\n    IO.puts(\"#{inspect(acc)} + #{inspect(value)} = #{inspect(result)}\")\n    result\n  end)\nend\n\n# Usage:\n# debug_monoid_combination(%Funx.Monoid.Sum{}, [1, 2, 3, 4])\n```","ref":"monoid-usage-rules.html#debug-monoid-operations"},{"type":"extras","title":"Verify Associativity for Parallel Computing - Funx.Monoid Usage Rules","doc":"```elixir\ndef verify_parallel_safety(operation, data, chunk_size) do\n  # Sequential computation\n  sequential_result = operation.(data)\n  \n  # Parallel computation (different groupings)\n  parallel_result1 = data\n  |> Enum.chunk_every(chunk_size)\n  |> Enum.map(operation)\n  |> operation.()\n  \n  parallel_result2 = data\n  |> Enum.chunk_every(chunk_size * 2)  # Different chunk size\n  |> Enum.map(operation)\n  |> operation.()\n  \n  %{\n    sequential: sequential_result,\n    parallel1: parallel_result1,\n    parallel2: parallel_result2,\n    results_match: sequential_result == parallel_result1 && \n                   parallel_result1 == parallel_result2\n  }\nend\n\n# Test with Math.sum (which uses Sum monoid)\n# verify_parallel_safety(&Math.sum/1, [1,2,3,4,5,6,7,8], 3)\n```","ref":"monoid-usage-rules.html#verify-associativity-for-parallel-computing"},{"type":"extras","title":"LLM Common Mistakes to Avoid - Funx.Monoid Usage Rules","doc":"**❌ Don't use raw monoids in application code**\n\n```elixir\n# ❌ Wrong: manually constructing monoids\ndef sum_values(numbers) do\n  sum_monoid = %Funx.Monoid.Sum{}\n  Enum.reduce(numbers, Monoid.empty(sum_monoid), fn num, acc ->\n    Monoid.append(sum_monoid, acc, num)\n  end)\nend\n\n# ✅ Correct: use utility functions\ndef sum_values(numbers) do\n  Math.sum(numbers)  # Much simpler and clearer\nend\n```\n\n**❌ Don't ignore monoid laws**\n\n```elixir\n# ❌ Wrong: non-associative operation\ndefmodule BrokenMonoid do\n  defstruct []\n  \n  defimpl Funx.Monoid do\n    def empty(_), do: 0\n    def append(_, a, b), do: a - b  # Subtraction is NOT associative!\n    def wrap(_, x), do: x\n    def unwrap(x), do: x\n  end\nend\n\n# ✅ Correct: ensure associativity\ndefmodule CorrectMonoid do\n  defstruct []\n  \n  defimpl Funx.Monoid do\n    def empty(_), do: 0\n    def append(_, a, b), do: a + b  # Addition IS associative\n    def wrap(_, x), do: x\n    def unwrap(x), do: x\n  end\nend\n```\n\n**❌ Don't use wrong identity elements**\n\n```elixir\n# ❌ Wrong: nil is not identity for addition\ndefmodule BadSumMonoid do  \n  defstruct []\n  \n  defimpl Funx.Monoid do\n    def empty(_), do: nil  # Wrong! nil + 5 != 5\n    def append(_, a, b), do: (a || 0) + (b || 0)\n    def wrap(_, x), do: x  \n    def unwrap(x), do: x\n  end\nend\n\n# ✅ Correct: 0 is the true identity for addition\ndefmodule GoodSumMonoid do\n  defstruct []\n  \n  defimpl Funx.Monoid do\n    def empty(_), do: 0  # Correct! 0 + x = x\n    def append(_, a, b), do: a + b\n    def wrap(_, x), do: x\n    def unwrap(x), do: x\n  end\nend\n```","ref":"monoid-usage-rules.html#llm-common-mistakes-to-avoid"},{"type":"extras","title":"Summary - Funx.Monoid Usage Rules","doc":"`Funx.Monoid` provides the mathematical foundation for associative combination with identity. Use it to:\n\n- **Build reusable combination logic**: Define monoids for custom data types that need merging\n- **Enable parallel computation**: Monoid laws guarantee safe parallelization and chunking\n- **Power utility functions**: `Math`, `Eq.Utils`, `Ord.Utils`, and `Predicate` all use monoids internally\n- **Compose complex operations**: Chain monoid operations for sophisticated data processing\n- **Ensure mathematical correctness**: Monoid laws provide guarantees about behavior\n\n**Key Implementation Detail**: Unlike Haskell's separate Semigroup and Monoid typeclasses, all operations are under the single `Funx.Monoid` protocol due to Elixir's protocol limitations.\n\n**Best Practice**: Use high-level utilities (`Math.sum/1`, `Eq.Utils.concat_all/1`) instead of raw monoid operations. Define custom monoids for domain-specific combination needs, but expose them through utility modules rather than direct protocol usage.\n\nRemember: Monoids are about **predictable combination**. If your operation is associative and has a true identity element, it's probably a monoid and can leverage all the mathematical guarantees and optimizations that come with that structure.","ref":"monoid-usage-rules.html#summary"},{"type":"extras","title":"Funx.Ord Usage Rules","doc":"# `Funx.Ord` Usage Rules","ref":"ord-usage-rules.html"},{"type":"extras","title":"Core Concepts - Funx.Ord Usage Rules","doc":"**Protocol + Custom Ord Pattern**: Use both together for maximum flexibility\n\n- **Protocol implementation** = domain's default ordering (whatever makes business sense)\n- **Custom Ord injection** = context-specific ordering when needed\n- **Key insight**: Protocol provides sensible defaults, custom Ord provides flexibility\n\n**Contramap**: Contravariant functor - transforms inputs before comparison\n\n- `contramap(&String.length/1, Ord)` compares by string length only\n- Mathematical dual of `map` - transforms \"backwards\" through the data flow  \n- Key pattern: transform the input, not the comparison result\n\n**Utils Pattern**: Inject custom Ord logic or default to protocol\n\n- `Ord.Utils.compare(a, b, custom_ord)` - uses custom_ord\n- `Ord.Utils.compare(a, b)` - uses protocol dispatch\n\n**Monoid Composition**: Combine ordering logic lexicographically\n\n- `append(ord1, ord2)` - combine two (ord1 then ord2)\n- `concat([ord1, ord2, ord3])` - combine list (in sequence)","ref":"ord-usage-rules.html#core-concepts"},{"type":"extras","title":"Quick Patterns - Funx.Ord Usage Rules","doc":"```elixir\n# STEP 1: Implement protocol for domain's default ordering\ndefimpl Funx.Ord, for: User do\n  def lt?(%User{joined_at: a}, %User{joined_at: b}), do: Funx.Ord.lt?(a, b)\n  def le?(a, b), do: lt?(a, b) or eq?(a, b)\n  def gt?(a, b), do: not le?(a, b)  \n  def ge?(a, b), do: not lt?(a, b)\nend\n\n# STEP 2: Use protocol directly for default ordering\nOrd.lt?(user1, user2)  # Uses protocol (by joined_at)\nList.sort(users)       # Uses protocol default\n\n# STEP 3: Inject custom Ord for specific contexts\nby_age = Ord.Utils.contramap(& &1.age)\nOrd.Utils.compare(user1, user2, by_age)  # Compare by age instead\nList.sort(users, by_age)                 # Sort by age, not joined_at\n\n# Combine fields lexicographically\nage_then_name = Ord.Utils.concat([\n  Ord.Utils.contramap(& &1.age),\n  Ord.Utils.contramap(& &1.name)\n])\n\n# Use with Funx.List\nFunx.List.sort(users, by_age)\nFunx.List.strict_sort(users, age_then_name)  # removes duplicates\n```","ref":"ord-usage-rules.html#quick-patterns"},{"type":"extras","title":"Key Rules - Funx.Ord Usage Rules","doc":"- **IMPLEMENT PROTOCOL** for domain's default ordering (whatever makes business sense)\n- **USE CUSTOM ORD** when you need different ordering for specific operations\n- **MUST implement all four** `lt?/2`, `le?/2`, `gt?/2`, `ge?/2` (no optional defaults)\n- **Must define total order**: antisymmetric, transitive, connex\n- Use `contramap/2` to transform inputs before comparison\n- Use monoid functions for composition: `append/2`, `concat/1`  \n- Pattern: Protocol for defaults, Utils injection for flexibility\n- Keep `Ord` and `Eq` consistent: `compare(a,b) == :eq <=> Eq.eq?(a,b)`","ref":"ord-usage-rules.html#key-rules"},{"type":"extras","title":"When to Use - Funx.Ord Usage Rules","doc":"- **Protocol implementation**: When you need domain's default ordering (whatever makes business sense)\n- **Custom Ord injection**: When you need different ordering for specific contexts\n- Custom sort with `Funx.List.sort/2` (protocol default or custom)\n- Range operations (`min`, `max`, `clamp`, `between`)\n- Multi-field lexicographic sorting and complex ordering logic","ref":"ord-usage-rules.html#when-to-use"},{"type":"extras","title":"Anti-Patterns - Funx.Ord Usage Rules","doc":"```elixir\n# ❌ Don't use raw operators on structs\nif user1   not result end)  # Wrong!\n\n# ❌ Don't mix protocols inconsistently\ndef process(a, b) do\n  if a < b do  # Raw operator\n    Ord.Utils.max(a, b)  # Protocol-based\n  end\nend\n```","ref":"ord-usage-rules.html#anti-patterns"},{"type":"extras","title":"Testing - Funx.Ord Usage Rules","doc":"```elixir\ntest \"Ord laws hold\" do\n  # Antisymmetry: a <= b and b <= a implies a == b\n  assert Ord.le?(user1, user2) and Ord.le?(user2, user1) \n    implies Ord.Utils.compare(user1, user2) == :eq\n  \n  # Transitivity: a <= b and b <= c implies a <= c\n  assert Ord.le?(user1, user2) and Ord.le?(user2, user3)\n    implies Ord.le?(user1, user3)\n  \n  # Connexity: either a <= b or b <= a\n  assert Ord.le?(user1, user2) or Ord.le?(user2, user1)\nend\n\ntest \"contramap preserves Ord laws\" do\n  by_age = Ord.Utils.contramap(& &1.age)\n  user1 = %User{age: 25, name: \"Alice\"}\n  user2 = %User{age: 30, name: \"Bob\"}\n  \n  # Contramap projection maintains ordering laws\n  assert by_age.lt?.(user1, user2)  # 25 < 30\n  assert not by_age.lt?.(user1, user1)  # Anti-reflexive\nend\n\ntest \"monoid composition laws\" do\n  ord1 = Ord.Utils.contramap(& &1.age)\n  ord2 = Ord.Utils.contramap(& &1.name)\n  \n  # Lexicographic: age first, then name\n  combined = Ord.Utils.append(ord1, ord2)\n  \n  # Same age, different names\n  alice = %User{age: 30, name: \"Alice\"}\n  bob = %User{age: 30, name: \"Bob\"}\n  assert combined.lt?.(alice, bob)  # Alice < Bob by name\nend\n```","ref":"ord-usage-rules.html#testing"},{"type":"extras","title":"Core Functions - Funx.Ord Usage Rules","doc":"","ref":"ord-usage-rules.html#core-functions"},{"type":"extras","title":"Protocol Functions - Funx.Ord Usage Rules","doc":"```elixir\n# Direct protocol calls\nOrd.lt?(a, b)    # less than\nOrd.le?(a, b)    # less than or equal  \nOrd.gt?(a, b)    # greater than\nOrd.ge?(a, b)    # greater than or equal\n\n# These delegate to implementations or fallback to Elixir operators\nOrd.lt?(5, 10)              # true (fallback)\nOrd.lt?(user1, user2)       # uses User implementation\n```","ref":"ord-usage-rules.html#protocol-functions"},{"type":"extras","title":"Utils Functions - Funx.Ord Usage Rules","doc":"```elixir\n# Comparison and utilities\nOrd.Utils.compare(a, b)           # :lt | :eq | :gt\nOrd.Utils.min(a, b)               # minimum value\nOrd.Utils.max(a, b)               # maximum value\nOrd.Utils.clamp(value, min, max)  # bound value within range\nOrd.Utils.between(value, min, max) # check if in range\n\n# For Enum.sort/2 compatibility  \ncomparator = Ord.Utils.comparator(custom_ord)\nEnum.sort(list, comparator)\n```","ref":"ord-usage-rules.html#utils-functions"},{"type":"extras","title":"Transformation Functions - Funx.Ord Usage Rules","doc":"```elixir\n# Transform inputs before comparison\nby_length = Ord.Utils.contramap(&String.length/1)\nOrd.Utils.max(\"cat\", \"zebra\", by_length)  # \"zebra\" (longer)\n\n# Reverse ordering\ndesc = Ord.Utils.reverse()\nOrd.Utils.min(3, 7, desc)  # 7 (max in normal order)\n\n# Convert to equality\neq = Ord.Utils.to_eq()\neq.eq?.(5, 5)  # true (compare(5,5) == :eq)\n```","ref":"ord-usage-rules.html#transformation-functions"},{"type":"extras","title":"Composition Functions - Funx.Ord Usage Rules","doc":"```elixir\n# Combine orderings lexicographically\nage_then_name = Ord.Utils.append(\n  Ord.Utils.contramap(& &1.age),\n  Ord.Utils.contramap(& &1.name)\n)\n\n# Combine list of orderings\nmulti_sort = Ord.Utils.concat([\n  Ord.Utils.contramap(& &1.priority),\n  Ord.Utils.contramap(& &1.created_at), \n  Ord.Utils.contramap(& &1.id)\n])\n```","ref":"ord-usage-rules.html#composition-functions"},{"type":"extras","title":"Integration with Funx.List - Funx.Ord Usage Rules","doc":"```elixir\n# Basic sorting\nFunx.List.sort([3, 1, 4])  # [1, 3, 4]\n\n# Custom ordering\nusers = [%User{age: 30}, %User{age: 25}]\nby_age = Ord.Utils.contramap(& &1.age)\nFunx.List.sort(users, by_age)\n\n# Sort and remove duplicates\nFunx.List.strict_sort(users, by_age)  # uses Ord.Utils.to_eq for dedup\n\n# Multi-field sort\nby_age_then_name = Ord.Utils.concat([\n  Ord.Utils.contramap(& &1.age),\n  Ord.Utils.contramap(& &1.name)\n])\nFunx.List.sort(users, by_age_then_name)\n```","ref":"ord-usage-rules.html#integration-with-funx-list"},{"type":"extras","title":"Built-in Implementations - Funx.Ord Usage Rules","doc":"","ref":"ord-usage-rules.html#built-in-implementations"},{"type":"extras","title":"Temporal Types - Funx.Ord Usage Rules","doc":"```elixir\n# DateTime, Date, Time, NaiveDateTime all have safe implementations\nevents = [%Event{occurred_at: ~U[2024-01-02 10:00:00Z]}, \n          %Event{occurred_at: ~U[2024-01-01 10:00:00Z]}]\n\nby_time = Ord.Utils.contramap(& &1.occurred_at)\nFunx.List.sort(events, by_time)  # chronological order\n```","ref":"ord-usage-rules.html#temporal-types"},{"type":"extras","title":"Fallback (Any) - Funx.Ord Usage Rules","doc":"```elixir\n# Safe with basic types\nOrd.lt?(1, 2)        # true\nOrd.lt?(\"a\", \"b\")    # true  \nOrd.lt?([1], [1,2])  # true\n\n# Unsafe with structs/maps - define explicit implementations\n# Ord.lt?(%User{}, %User{})  # May raise ArgumentError\n```","ref":"ord-usage-rules.html#fallback-any"},{"type":"extras","title":"Common Patterns - Funx.Ord Usage Rules","doc":"","ref":"ord-usage-rules.html#common-patterns"},{"type":"extras","title":"Multi-field Sorting - Funx.Ord Usage Rules","doc":"```elixir\n# Sort by priority (high first), then by created date (old first)\ntask_ordering = Ord.Utils.concat([\n  Ord.Utils.reverse(Ord.Utils.contramap(& &1.priority)),\n  Ord.Utils.contramap(& &1.created_at)\n])\n\nFunx.List.sort(tasks, task_ordering)\n```","ref":"ord-usage-rules.html#multi-field-sorting"},{"type":"extras","title":"Range Operations - Funx.Ord Usage Rules","doc":"```elixir\n# Clamp values within bounds\nscore = Ord.Utils.clamp(user_score, 0, 100)\n\n# Check if value is in acceptable range  \nvalid = Ord.Utils.between(temperature, min_temp, max_temp)\n\n# Find extreme values\noldest_user = Enum.reduce(users, &Ord.Utils.min(&1, &2, by_age))\n```","ref":"ord-usage-rules.html#range-operations"},{"type":"extras","title":"Domain-Specific Ordering - Funx.Ord Usage Rules","doc":"```elixir\ndefmodule Priority do\n  @priorities [:low, :medium, :high, :critical]\n  \n  def to_index(priority), do: Enum.find_index(@priorities, &(&1 == priority))\nend\n\n# Order by priority level\nby_priority = Ord.Utils.contramap(&Priority.to_index/1)\nFunx.List.sort(tasks, by_priority)\n```","ref":"ord-usage-rules.html#domain-specific-ordering"},{"type":"extras","title":"Performance Considerations - Funx.Ord Usage Rules","doc":"- Protocol dispatch has minimal overhead\n- `contramap` creates new functions - avoid in tight loops\n- Composition with `concat` chains multiple comparisons\n- `Funx.List.sort` is optimized for custom comparators\n- Built-in temporal comparisons are efficient","ref":"ord-usage-rules.html#performance-considerations"},{"type":"extras","title":"Best Practices - Funx.Ord Usage Rules","doc":"- Define `Ord` for domain types, not just structs\n- Keep `Ord` and `Eq` implementations consistent  \n- Use `Utils` functions rather than direct protocol calls\n- Prefer composition over custom implementations\n- Test ordering laws in your implementations\n- Document the ordering semantics for domain types","ref":"ord-usage-rules.html#best-practices"},{"type":"extras","title":"Funx.Predicate Usage Rules","doc":"# `Funx.Predicate` Usage Rules","ref":"predicate-usage-rules.html"},{"type":"extras","title":"LLM Functional Programming Foundation - Funx.Predicate Usage Rules","doc":"**Key Concepts for LLMs:**\n\n**Predicate**: A function that tests conditions and returns boolean values\n\n- **Type signature**: `a -> boolean` (takes a value, returns true/false)\n- **Purpose**: Enable composable, reusable validation and filtering logic\n- **Mathematical foundation**: Based on Boolean algebra with logical operations\n- **Composition**: Predicates can be combined using AND, OR, NOT operations\n\n**Monoid Backing**: Predicates are backed by monoid operations for composition\n\n- **All monoid (AND-based)**: Short-circuits on first false, requires all conditions to be true\n- **Any monoid (OR-based)**: Short-circuits on first true, succeeds if any condition is true\n- **Identity elements**: `always_true` for All, `always_false` for Any\n- **Associativity**: Order of composition doesn't affect result\n\n**Logical Laws**: Predicates follow Boolean algebra laws\n\n- **Identity**: `p AND true = p`, `p OR false = p`\n- **Commutativity**: `p AND q = q AND p`, `p OR q = q OR p`\n- **Associativity**: `(p AND q) AND r = p AND (q AND r)`\n- **De Morgan's Laws**: `NOT(p AND q) = NOT p OR NOT q`\n\n**Short-Circuiting**: Efficient evaluation stops at first definitive result\n\n- **AND operations**: Stop at first false predicate\n- **OR operations**: Stop at first true predicate\n- **Performance benefit**: Avoid expensive later computations\n\n**Composition Patterns**: Build complex logic from simple predicates\n\n- **Layered validation**: Basic checks before expensive operations\n- **Business rules**: Combine multiple conditions into domain logic\n- **Filtering pipelines**: Chain predicates for data processing","ref":"predicate-usage-rules.html#llm-functional-programming-foundation"},{"type":"extras","title":"LLM Decision Guide: When to Use Predicates - Funx.Predicate Usage Rules","doc":"**✅ Use Predicates when:**\n\n- Need reusable validation logic\n- Building complex conditional logic from simple parts\n- Want to compose boolean conditions\n- Need to filter collections based on multiple criteria\n- User says: \"validate\", \"filter\", \"condition\", \"check if\", \"business rules\"\n\n**❌ Don't use Predicates when:**\n\n- Simple one-off boolean expressions\n- Single validation that won't be reused\n- Performance is absolutely critical (function call overhead)\n- Logic is too complex for boolean composition\n\n**⚡ Predicate vs. Direct Boolean Decision:**\n\n- **Predicates**: Reusable, composable, testable validation logic\n- **Direct booleans**: Simple, one-off conditional checks\n- **Rule**: Use predicates when logic will be reused or composed\n\n**⚙️ Function Choice Guide:**\n\n- **`and_all/1`**: All conditions must be true (short-circuits on false)\n- **`or_any/1`**: Any condition can be true (short-circuits on true)\n- **`not/1`**: Invert a predicate (logical negation)\n- **`test/2`**: Apply predicate to value with error handling","ref":"predicate-usage-rules.html#llm-decision-guide-when-to-use-predicates"},{"type":"extras","title":"LLM Context Clues - Funx.Predicate Usage Rules","doc":"**User language → Predicate patterns:**\n\n- \"validate multiple conditions\" → `and_all` composition\n- \"any of these conditions\" → `or_any` composition\n- \"opposite of\" or \"not\" → `not/1` negation\n- \"business rules\" → Complex predicate composition\n- \"filter by conditions\" → Predicate with Enum.filter\n- \"access control\" → Role-based predicate composition\n- \"data validation\" → Layered predicate pipelines\n- \"conditional logic\" → Predicate composition with Utils","ref":"predicate-usage-rules.html#llm-context-clues"},{"type":"extras","title":"Quick Reference - Funx.Predicate Usage Rules","doc":"- **Core concepts**: Functions returning boolean values for conditions\n- **Monoid backing**: Uses All (AND) and Any (OR) monoids for composition\n- **Main operations**: `and_all/1`, `or_any/1`, `not/1`, `test/2`\n- **Performance**: Short-circuiting evaluation for efficiency\n- **Composition**: Build complex logic from simple predicate functions","ref":"predicate-usage-rules.html#quick-reference"},{"type":"extras","title":"Overview - Funx.Predicate Usage Rules","doc":"`Funx.Predicate` provides utilities for building and composing predicate functions (functions that return boolean values). Predicates are essential for validation, filtering, and conditional logic in functional programming.\n\nThe module is backed by monoid operations, enabling composable boolean logic with proper short-circuiting behavior. This makes it efficient and mathematically sound for building complex conditional systems.","ref":"predicate-usage-rules.html#overview"},{"type":"extras","title":"Composition Rules - Funx.Predicate Usage Rules","doc":"| Function     | Type Signature                    | Purpose                                     |\n| ------------ | --------------------------------- | ------------------------------------------- |\n| `and_all/1`  | `[a -> boolean] -> a -> boolean`  | All predicates must be true (AND)          |\n| `or_any/1`   | `[a -> boolean] -> a -> boolean`  | Any predicate can be true (OR)             |\n| `not/1`      | `(a -> boolean) -> a -> boolean`  | Logical negation of predicate               |\n| `test/2`     | `(a -> boolean) -> a -> boolean`  | Apply predicate to value, ensuring boolean result |\n\nThese functions enable building complex boolean logic from simple predicate functions while maintaining performance through short-circuiting.\n\n**Monoid Law Guarantees**: Because predicate composition is built on monoids (All and Any), it inherits mathematical guarantees:\n\n- **Associativity**: Grouping doesn't matter - `(p1 AND p2) AND p3 = p1 AND (p2 AND p3)`\n- **Identity**: Neutral elements - `and_all([])` returns `fn _ -> true end`, `or_any([])` returns `fn _ -> false end`\n- **Short-circuiting**: Efficient evaluation - `and_all` stops at first false, `or_any` stops at first true\n\n**Predicate Arity**: Predicates used in `and_all/1` and `or_any/1` must be unary (1-arity). If more context is needed, use partially applied closures or higher-order predicate factories.","ref":"predicate-usage-rules.html#composition-rules"},{"type":"extras","title":"Correct Usage Patterns - Funx.Predicate Usage Rules","doc":"","ref":"predicate-usage-rules.html#correct-usage-patterns"},{"type":"extras","title":"Combining Predicates - Funx.Predicate Usage Rules","doc":"```elixir\n# Individual predicates\nis_adult = fn user -> user.age >= 18 end\nhas_email = fn user -> String.contains?(user.email, \"@\") end  \nis_active = fn user -> user.active == true end\n\n# Combine with AND (all must be true)\nvalid_user = Predicate.and_all([is_adult, has_email, is_active])\n\n# Combine with OR (any can be true)  \nadmin_or_moderator = Predicate.or_any([\n  fn user -> user.role == :admin end,\n  fn user -> user.role == :moderator end\n])\n\n# Test the composed predicates\nuser = %{age: 25, email: \"user@example.com\", active: true}\nvalid_user.(user)  # => true\n```","ref":"predicate-usage-rules.html#combining-predicates"},{"type":"extras","title":"Working with Lists and Filtering - Funx.Predicate Usage Rules","doc":"```elixir\nusers = [\n  %{name: \"Alice\", age: 30, active: true},\n  %{name: \"Bob\", age: 17, active: true}, \n  %{name: \"Carol\", age: 25, active: false}\n]\n\n# Create filtering predicates\nadult_filter = fn user -> user.age >= 18 end\nactive_filter = fn user -> user.active == true end\n\n# Combine filters\nvalid_user_filter = Predicate.and_all([adult_filter, active_filter])\n\n# Apply to collection\nvalid_users = Enum.filter(users, valid_user_filter)\n# => [%{name: \"Alice\", age: 30, active: true}]\n```","ref":"predicate-usage-rules.html#working-with-lists-and-filtering"},{"type":"extras","title":"Negation - Funx.Predicate Usage Rules","doc":"```elixir\n# Original predicate\nis_admin = fn user -> user.role == :admin end\n\n# Negated predicate\nnot_admin = Predicate.not(is_admin)\n\n# Use for filtering\nregular_users = Enum.filter(all_users, not_admin)\n```","ref":"predicate-usage-rules.html#negation"},{"type":"extras","title":"Compositional Guidelines - Funx.Predicate Usage Rules","doc":"Follow these patterns when generating or working with predicates:\n\n- **Build from simple parts**: Start with basic predicates and compose them\n- **Use descriptive names**: Name intermediate predicates for clarity\n- **Layer validations**: Put cheap checks before expensive ones\n- **Short-circuit efficiently**: Use `and_all` and `or_any` for performance\n- **Avoid side effects**: Keep predicates pure (no IO, mutations, etc.)\n- **Test compositions**: Verify complex predicates work as expected","ref":"predicate-usage-rules.html#compositional-guidelines"},{"type":"extras","title":"Stability Contract - Funx.Predicate Usage Rules","doc":"Ensure that predicate functions maintain:\n\n- **Purity**: No side effects, same input produces same output\n- **Short-circuiting**: `and_all` stops at first false, `or_any` stops at first true  \n- **Logical identity**: Follow Boolean algebra laws and De Morgan's laws\n- **Type consistency**: All predicates in a composition should accept same type\n- **Unary predicates**: All predicates must be single-argument functions for composition","ref":"predicate-usage-rules.html#stability-contract"},{"type":"extras","title":"Anti-Patterns - Funx.Predicate Usage Rules","doc":"Avoid generating or emitting:\n\n- **Side effects in predicates**: No IO, logging, or mutations\n- **Expensive operations early**: Put cheap validations first\n- **Non-boolean returns**: Predicates must return true/false\n- **Mixed input types**: Keep predicates type-consistent within compositions\n- **Multi-arity predicates**: Don't use predicates requiring multiple arguments in composition\n- **Deep nesting**: Use intermediate named predicates instead","ref":"predicate-usage-rules.html#anti-patterns"},{"type":"extras","title":"Good Patterns - Funx.Predicate Usage Rules","doc":"Encourage completions like:\n\n```elixir\n# Named intermediate predicates for clarity\nhas_permission = fn user -> user.permissions |> Enum.member?(:read) end\nwithin_rate_limit = fn user -> user.requests_today < 100 end\naccount_active = fn user -> user.status == :active end\n\n# Composed authorization predicate\ncan_access = Predicate.and_all([has_permission, within_rate_limit, account_active])\n```\n\n```elixir\n# Proper arity handling for multi-context predicates\n# ❌ Wrong: multi-arity predicate\nbad_access_check = fn resource, user -> resource.owner_id == user.id end\n\n# ✅ Right: use closure or factory pattern\nis_owner = fn resource ->\n  fn user -> resource.owner_id == user.id end\nend\n\n# ✅ Right: partially applied closure\nresource = %{owner_id: 123}\nowner_check = is_owner.(resource)  # Returns unary predicate\n\n# Use in composition\naccess_predicates = Predicate.and_all([\n  owner_check,                    # Unary predicate\n  fn user -> user.active end,     # Unary predicate\n  fn user -> not user.banned end  # Unary predicate\n])\n```\n\n```elixir\n# Efficient layered validation (cheap checks first)\nbasic_validation = Predicate.and_all([\n  fn data -> not is_nil(data.id) end,        # Cheap null check\n  fn data -> String.length(data.name) > 0 end # String length check\n])\n\nexpensive_validation = fn data ->\n  # Expensive database check only after basic validation passes\n  not Database.user_exists?(data.id)\nend\n\nfull_validation = Predicate.and_all([basic_validation, expensive_validation])\n```","ref":"predicate-usage-rules.html#good-patterns"},{"type":"extras","title":"LLM Code Templates - Funx.Predicate Usage Rules","doc":"","ref":"predicate-usage-rules.html#llm-code-templates"},{"type":"extras","title":"Basic Validation Template - Funx.Predicate Usage Rules","doc":"```elixir\ndef build_user_validator() do\n  # Define individual validation predicates\n  validations = %{\n    has_name: fn user -> \n      not is_nil(user.name) and String.length(user.name) > 0 \n    end,\n    \n    valid_email: fn user ->\n      String.contains?(user.email, \"@\") and String.contains?(user.email, \".\")\n    end,\n    \n    adult_age: fn user ->\n      is_integer(user.age) and user.age >= 18\n    end,\n    \n    active_status: fn user ->\n      user.status in [:active, :verified]\n    end\n  }\n  \n  # Compose basic validation (cheap checks)\n  basic_validation = Predicate.and_all([\n    validations.has_name,\n    validations.adult_age,\n    validations.active_status\n  ])\n  \n  # Compose expensive validation\n  expensive_validation = Predicate.and_all([\n    validations.valid_email,\n    fn user -> not UserRepo.email_exists?(user.email) end  # Database check\n  ])\n  \n  # Final composed validator\n  complete_validator = Predicate.and_all([basic_validation, expensive_validation])\n  \n  # Usage function\n  fn user ->\n    case complete_validator.(user) do\n      true -> {:ok, user}\n      false -> {:error, \"User validation failed\"}\n    end\n  end\nend\n\n# Usage\nvalidator = build_user_validator()\nvalidator.(%{name: \"Alice\", email: \"alice@example.com\", age: 25, status: :active})\n```","ref":"predicate-usage-rules.html#basic-validation-template"},{"type":"extras","title":"Access Control Template - Funx.Predicate Usage Rules","doc":"```elixir\ndef build_access_control_system() do\n  # Role-based predicates\n  roles = %{\n    is_admin: fn user -> user.role == :admin end,\n    is_moderator: fn user -> user.role == :moderator end,\n    is_owner: fn resource, user -> resource.owner_id == user.id end,\n    is_collaborator: fn resource, user -> \n      Enum.member?(resource.collaborator_ids, user.id)\n    end\n  }\n  \n  # Permission predicates\n  permissions = %{\n    can_read: fn resource, user ->\n      resource.visibility == :public or\n      Predicate.or_any([\n        roles.is_admin,\n        roles.is_owner.(resource),\n        roles.is_collaborator.(resource)\n      ]).(user)\n    end,\n    \n    can_write: fn resource, user ->\n      Predicate.or_any([\n        roles.is_admin,\n        roles.is_moderator,\n        roles.is_owner.(resource)\n      ]).(user)\n    end,\n    \n    can_delete: fn resource, user ->\n      Predicate.or_any([\n        roles.is_admin,\n        roles.is_owner.(resource)\n      ]).(user)\n    end\n  }\n  \n  # Context-aware validation\n  def authorize_action(action, resource, user) do\n    action_predicate = case action do\n      :read -> permissions.can_read.(resource, user)\n      :write -> permissions.can_write.(resource, user)\n      :delete -> permissions.can_delete.(resource, user)\n    end\n    \n    # Additional context checks\n    context_checks = Predicate.and_all([\n      fn _ -> user.status == :active end,\n      fn _ -> not user.banned end,\n      fn _ -> resource.status != :archived end\n    ])\n    \n    final_check = Predicate.and_all([\n      fn _ -> action_predicate end,\n      context_checks\n    ])\n    \n    final_check.(user)\n  end\n  \n  %{authorize: &authorize_action/3, permissions: permissions, roles: roles}\nend\n```","ref":"predicate-usage-rules.html#access-control-template"},{"type":"extras","title":"Filtering Pipeline Template - Funx.Predicate Usage Rules","doc":"```elixir\ndef build_data_filtering_pipeline() do\n  # Stage 1: Basic data quality filters\n  quality_filters = %{\n    not_nil: fn item -> not is_nil(item) end,\n    has_required_fields: fn item -> \n      [:id, :name, :created_at] |> Enum.all?(fn field -> \n        Map.has_key?(item, field) and not is_nil(item[field])\n      end)\n    end,\n    valid_timestamps: fn item ->\n      is_struct(item.created_at, DateTime) and \n      DateTime.compare(item.created_at, DateTime.utc_now()) == :lt\n    end\n  }\n  \n  # Stage 2: Business logic filters  \n  business_filters = %{\n    active_status: fn item -> item.status in [:active, :published] end,\n    within_date_range: fn start_date, end_date ->\n      fn item ->\n        DateTime.compare(item.created_at, start_date) != :lt and\n        DateTime.compare(item.created_at, end_date) != :gt\n      end\n    end,\n    meets_threshold: fn threshold_field, min_value ->\n      fn item ->\n        Map.get(item, threshold_field, 0) >= min_value\n      end\n    end\n  }\n  \n  # Stage 3: User-specific filters\n  user_filters = %{\n    user_can_see: fn user ->\n      fn item ->\n        item.visibility == :public or \n        item.owner_id == user.id or\n        user.role in [:admin, :moderator]\n      end\n    end,\n    not_blocked_by_user: fn user ->\n      fn item ->\n        not Enum.member?(user.blocked_ids || [], item.owner_id)\n      end\n    end\n  }\n  \n  # Compose filtering pipeline\n  def create_filter_pipeline(user, options \\\\ %{}) do\n    # Basic quality checks (always applied)\n    basic_quality = Predicate.and_all([\n      quality_filters.not_nil,\n      quality_filters.has_required_fields,\n      quality_filters.valid_timestamps\n    ])\n    \n    # Business logic filters\n    business_logic = [\n      business_filters.active_status,\n      business_filters.within_date_range.(\n        options[:start_date] || DateTime.add(DateTime.utc_now(), -30, :day),\n        options[:end_date] || DateTime.utc_now()\n      ),\n      business_filters.meets_threshold.(:score, options[:min_score] || 0)\n    ] |> Predicate.and_all()\n    \n    # User-specific filters\n    user_specific = Predicate.and_all([\n      user_filters.user_can_see.(user),\n      user_filters.not_blocked_by_user.(user)\n    ])\n    \n    # Complete pipeline\n    Predicate.and_all([basic_quality, business_logic, user_specific])\n  end\n  \n  # Usage helper\n  def filter_data(data_list, user, options \\\\ %{}) do\n    pipeline = create_filter_pipeline(user, options)\n    Enum.filter(data_list, pipeline)\n  end\n  \n  %{\n    create_pipeline: &create_filter_pipeline/2,\n    filter_data: &filter_data/3,\n    individual_filters: %{\n      quality: quality_filters,\n      business: business_filters,\n      user: user_filters\n    }\n  }\nend\n```","ref":"predicate-usage-rules.html#filtering-pipeline-template"},{"type":"extras","title":"Business Rules Template - Funx.Predicate Usage Rules","doc":"```elixir\ndef build_business_rules_engine() do\n  # Domain-specific predicates\n  customer_rules = %{\n    is_premium: fn customer -> customer.tier == :premium end,\n    account_in_good_standing: fn customer -> \n      customer.balance >= 0 and customer.past_due_count < 3\n    end,\n    region_eligible: fn allowed_regions ->\n      fn customer -> Enum.member?(allowed_regions, customer.region) end\n    end,\n    loyalty_member: fn min_months ->\n      fn customer ->\n        months_active = DateTime.diff(DateTime.utc_now(), customer.signup_date, :day) / 30\n        months_active >= min_months\n      end\n    end\n  }\n  \n  order_rules = %{\n    within_limits: fn customer ->\n      fn order ->\n        daily_total = CustomerService.daily_order_total(customer.id)\n        (daily_total + order.amount) <= customer.daily_limit\n      end\n    end,\n    valid_items: fn order ->\n      Enum.all?(order.items, fn item ->\n        item.quantity > 0 and item.price > 0 and not item.discontinued\n      end)\n    end,\n    shipping_available: fn order ->\n      ShippingService.can_ship_to?(order.shipping_address)\n    end\n  }\n  \n  # Compose complex business rules\n  def create_order_validation_rules(promotions \\\\ []) do\n    # Base eligibility rules\n    customer_eligible = Predicate.and_all([\n      customer_rules.account_in_good_standing,\n      customer_rules.region_eligible.([:us, :ca, :uk])\n    ])\n    \n    # Order validation rules\n    order_valid = Predicate.and_all([\n      order_rules.valid_items,\n      order_rules.shipping_available\n    ])\n    \n    # Dynamic promotion rules\n    promotion_rules = promotions\n    |> Enum.map(fn promo ->\n      case promo.type do\n        :loyalty -> \n          customer_rules.loyalty_member.(promo.min_months)\n        :premium -> \n          customer_rules.is_premium\n        :volume ->\n          fn customer -> \n            fn order -> \n              order.amount >= promo.min_amount\n            end\n          end\n      end\n    end)\n    |> Predicate.or_any()  # Any promotion can apply\n    \n    # Combine all rules\n    %{\n      can_place_order: fn customer, order ->\n        basic_rules = Predicate.and_all([\n          fn _ -> customer_eligible.(customer) end,\n          fn _ -> order_valid.(order) end,\n          order_rules.within_limits.(customer)\n        ])\n        basic_rules.(order)\n      end,\n      \n      eligible_for_promotions: fn customer, order ->\n        promotion_check = promotion_rules.(customer)\n        promotion_check.(order)\n      end,\n      \n      complete_validation: fn customer, order ->\n        all_rules = Predicate.and_all([\n          fn _ -> customer_eligible.(customer) end,\n          fn _ -> order_valid.(order) end,\n          order_rules.within_limits.(customer)\n        ])\n        \n        {all_rules.(order), promotion_rules.(customer).(order)}\n      end\n    }\n  end\n  \n  %{\n    customer_rules: customer_rules,\n    order_rules: order_rules,\n    create_validation: &create_order_validation_rules/1\n  }\nend\n```","ref":"predicate-usage-rules.html#business-rules-template"},{"type":"extras","title":"LLM Performance Considerations - Funx.Predicate Usage Rules","doc":"","ref":"predicate-usage-rules.html#llm-performance-considerations"},{"type":"extras","title":"Short-Circuiting Behavior - Funx.Predicate Usage Rules","doc":"```elixir\n# ✅ Good: Cheap predicates first\nefficient_validation = Predicate.and_all([\n  fn user -> not is_nil(user.id) end,           # Very fast\n  fn user -> String.length(user.email) > 5 end, # Fast\n  fn user -> Database.user_exists?(user.id) end  # Expensive - last\n])\n\n# ❌ Less efficient: Expensive predicate first\ninefficient_validation = Predicate.and_all([\n  fn user -> Database.user_exists?(user.id) end, # Expensive - runs every time\n  fn user -> not is_nil(user.id) end            # Fast - but too late\n])\n```","ref":"predicate-usage-rules.html#short-circuiting-behavior"},{"type":"extras","title":"Predicate Memoization - Funx.Predicate Usage Rules","doc":"```elixir\n# For expensive predicates that are reused\ndef create_memoized_predicate(expensive_fn) do\n  cache = Agent.start_link(fn -> %{} end)\n  \n  fn input ->\n    Agent.get_and_update(cache, fn state ->\n      case Map.get(state, input) do\n        nil -> \n          result = expensive_fn.(input)\n          {result, Map.put(state, input, result)}\n        cached_result -> \n          {cached_result, state}\n      end\n    end)\n  end\nend\n\n# Usage\nexpensive_check = create_memoized_predicate(fn user -> \n  # Expensive operation here\n  ExternalAPI.validate_user(user.id)\nend)\n\nvalidation = Predicate.and_all([basic_checks, expensive_check])\n```","ref":"predicate-usage-rules.html#predicate-memoization"},{"type":"extras","title":"LLM Interop Patterns - Funx.Predicate Usage Rules","doc":"","ref":"predicate-usage-rules.html#llm-interop-patterns"},{"type":"extras","title":"With Funx.Utils - Funx.Predicate Usage Rules","doc":"```elixir\ndef build_utils_integration() do\n  # Create predicate functions for pipeline use\n  # Note: Predicates are functions that can be called directly\n  \n  # Create reusable predicates\n  test_adult = fn user -> user.age >= 18 end\n  test_active = fn user -> user.status == :active end\n  test_verified = fn user -> user.verified == true end\n  \n  # Use in pipelines\n  users = [%{age: 25, status: :active, verified: true}, %{age: 17, status: :inactive, verified: false}]\n  \n  adults = users |> Enum.filter(test_adult)\n  active_users = users |> Enum.filter(test_active)\n  \n  # Compose with other Utils functions\n  filter_by = Funx.Utils.flip(&Enum.filter/2)\n  \n  # Create specialized filters\n  filter_adults = filter_by.(test_adult)\n  filter_active = filter_by.(test_active)\n  \n  users \n  |> filter_adults.()\n  |> filter_active.()\nend\n```","ref":"predicate-usage-rules.html#with-funx-utils"},{"type":"extras","title":"With Maybe/Either Bind - Funx.Predicate Usage Rules","doc":"```elixir\ndef build_monadic_validation() do\n  # Convert predicates to Maybe-returning validators\n  def predicate_to_maybe(predicate, error_msg) do\n    fn value ->\n      if predicate.(value) do\n        Maybe.just(value)\n      else\n        Maybe.nothing()\n      end\n    end\n  end\n  \n  # Convert predicates to Either-returning validators\n  def predicate_to_either(predicate, error_msg) do\n    fn value ->\n      if predicate.(value) do\n        Either.right(value)\n      else\n        Either.left(error_msg)\n      end\n    end\n  end\n  \n  # Create validators\n  age_predicate = fn user -> user.age >= 18 end\n  email_predicate = fn user -> String.contains?(user.email, \"@\") end\n  \n  age_validator = predicate_to_either(age_predicate, \"Must be adult\")\n  email_validator = predicate_to_either(email_predicate, \"Invalid email\")\n  \n  # Use in monadic pipeline\n  def validate_user(user) do\n    Either.right(user)\n    |> Either.bind(age_validator)\n    |> Either.bind(email_validator)\n  end\n  \n  validate_user(%{age: 25, email: \"user@example.com\"})  # Right(user)\n  validate_user(%{age: 16, email: \"invalid\"})          # Left(\"Must be adult\")\nend\n```","ref":"predicate-usage-rules.html#with-maybe-either-bind"},{"type":"extras","title":"With Enum Functions - Funx.Predicate Usage Rules","doc":"```elixir\ndef build_enum_integration() do\n  # Predicate-based collection operations\n  \n  users = [\n    %{name: \"Alice\", role: :admin, active: true},\n    %{name: \"Bob\", role: :user, active: false}, \n    %{name: \"Carol\", role: :moderator, active: true}\n  ]\n  \n  # Create predicates\n  is_admin = fn user -> user.role == :admin end\n  is_active = fn user -> user.active == true end\n  is_staff = Predicate.or_any([\n    fn user -> user.role == :admin end,\n    fn user -> user.role == :moderator end\n  ])\n  \n  # Use with Enum functions\n  active_users = Enum.filter(users, is_active)\n  staff_members = Enum.filter(users, is_staff)\n  \n  # Combine predicates for complex filtering\n  active_staff = Enum.filter(users, Predicate.and_all([is_staff, is_active]))\n  \n  # Partition based on predicates\n  {staff, regular_users} = Enum.split_with(users, is_staff)\n  \n  # Count matching items\n  staff_count = Enum.count(users, is_staff)\n  \n  # Find items\n  first_admin = Enum.find(users, is_admin)\n  all_active = Enum.all?(users, is_active)\n  any_admins = Enum.any?(users, is_admin)\n  \n  %{\n    active_users: active_users,\n    staff_members: staff_members,\n    active_staff: active_staff,\n    counts: %{staff: staff_count},\n    checks: %{all_active: all_active, any_admins: any_admins}\n  }\nend\n```","ref":"predicate-usage-rules.html#with-enum-functions"},{"type":"extras","title":"With Case Statements - Funx.Predicate Usage Rules","doc":"```elixir\ndef build_case_integration() do\n  # Use predicates in case statement guards\n  \n  is_admin = fn user -> user.role == :admin end\n  is_owner = fn resource, user -> resource.owner_id == user.id end\n  is_collaborator = fn resource, user -> \n    Enum.member?(resource.collaborators, user.id)\n  end\n  \n  def authorize_action(action, resource, user) do\n    case {action, is_admin.(user)} do\n      {_, true} -> \n        # Admins can do anything\n        :authorized\n        \n      {:read, false} ->\n        # Non-admins need specific read permissions\n        case Predicate.or_any([is_owner.(resource), is_collaborator.(resource)]).(user) do\n          true -> :authorized\n          false -> {:unauthorized, \"No read access\"}\n        end\n        \n      {:write, false} ->\n        # Non-admins need ownership for writes\n        case is_owner.(resource).(user) do\n          true -> :authorized\n          false -> {:unauthorized, \"Must be owner to modify\"}\n        end\n        \n      {:delete, false} ->\n        # Only owners and admins can delete\n        {:unauthorized, \"Insufficient permissions for delete\"}\n    end\n  end\n  \n  %{authorize: &authorize_action/3}\nend\n```","ref":"predicate-usage-rules.html#with-case-statements"},{"type":"extras","title":"With Guard Clauses - Funx.Predicate Usage Rules","doc":"```elixir\ndef build_guard_integration() do\n  # Convert predicates to guard-compatible expressions\n  \n  # Note: These need to be guard-safe functions\n  def process_user(user) when user.age >= 18 and user.active == true do\n    {:ok, \"Processing adult active user: #{user.name}\"}\n  end\n  \n  def process_user(user) when user.role == :admin do\n    {:ok, \"Processing admin user: #{user.name}\"}\n  end\n  \n  def process_user(_user) do\n    {:error, \"User does not meet processing criteria\"}\n  end\n  \n  # For more complex predicates, use function heads\n  def handle_request(request, user) do\n    cond do\n      is_admin_user().(user) ->\n        handle_admin_request(request, user)\n        \n      is_premium_user().(user) ->\n        handle_premium_request(request, user)\n        \n      basic_user_requirements().(user) ->\n        handle_basic_request(request, user)\n        \n      true ->\n        {:error, \"User not authorized for any request type\"}\n    end\n  end\n  \n  defp is_admin_user(), do: fn user -> user.role == :admin end\n  defp is_premium_user(), do: fn user -> user.subscription == :premium end\n  defp basic_user_requirements() do\n    Predicate.and_all([\n      fn user -> user.verified == true end,\n      fn user -> user.status == :active end\n    ])\n  end\n  \n  %{process_user: &process_user/1, handle_request: &handle_request/2}\nend\n```","ref":"predicate-usage-rules.html#with-guard-clauses"},{"type":"extras","title":"LLM Testing Guidance - Funx.Predicate Usage Rules","doc":"","ref":"predicate-usage-rules.html#llm-testing-guidance"},{"type":"extras","title":"Test Individual Predicates - Funx.Predicate Usage Rules","doc":"```elixir\ndefmodule PredicateTest do\n  use ExUnit.Case\n  \n  test \"individual predicates work correctly\" do\n    is_adult = fn user -> user.age >= 18 end\n    has_email = fn user -> String.contains?(user.email, \"@\") end\n    \n    adult_user = %{age: 25, email: \"user@example.com\"}\n    minor_user = %{age: 16, email: \"teen@example.com\"}\n    \n    assert is_adult.(adult_user) == true\n    assert is_adult.(minor_user) == false\n    \n    assert has_email.(adult_user) == true\n    assert has_email.(%{age: 25, email: \"invalid\"}) == false\n  end\n  \n  test \"predicate composition works\" do\n    is_adult = fn user -> user.age >= 18 end\n    has_email = fn user -> String.contains?(user.email, \"@\") end\n    is_active = fn user -> user.active == true end\n    \n    # Test AND composition\n    valid_user = Predicate.and_all([is_adult, has_email, is_active])\n    \n    fully_valid = %{age: 25, email: \"user@example.com\", active: true}\n    invalid_email = %{age: 25, email: \"invalid\", active: true}\n    inactive_user = %{age: 25, email: \"user@example.com\", active: false}\n    \n    assert valid_user.(fully_valid) == true\n    assert valid_user.(invalid_email) == false\n    assert valid_user.(inactive_user) == false\n    \n    # Test OR composition  \n    admin_or_owner = Predicate.or_any([\n      fn user -> user.role == :admin end,\n      fn user -> user.owner == true end\n    ])\n    \n    admin_user = %{role: :admin, owner: false}\n    owner_user = %{role: :user, owner: true}\n    regular_user = %{role: :user, owner: false}\n    \n    assert admin_or_owner.(admin_user) == true\n    assert admin_or_owner.(owner_user) == true\n    assert admin_or_owner.(regular_user) == false\n  end\n  \n  test \"predicate negation works\" do\n    is_admin = fn user -> user.role == :admin end\n    is_not_admin = Predicate.not(is_admin)\n    \n    admin_user = %{role: :admin}\n    regular_user = %{role: :user}\n    \n    assert is_admin.(admin_user) == true\n    assert is_not_admin.(admin_user) == false\n    \n    assert is_admin.(regular_user) == false\n    assert is_not_admin.(regular_user) == true\n  end\nend\n```","ref":"predicate-usage-rules.html#test-individual-predicates"},{"type":"extras","title":"Test Composed Predicates - Funx.Predicate Usage Rules","doc":"```elixir\ndefmodule ComposedPredicateTest do\n  use ExUnit.Case\n  \n  setup do\n    users = [\n      %{name: \"Alice\", age: 30, role: :admin, active: true, verified: true},\n      %{name: \"Bob\", age: 17, role: :user, active: true, verified: false},\n      %{name: \"Carol\", age: 25, role: :moderator, active: false, verified: true},\n      %{name: \"Dave\", age: 35, role: :user, active: true, verified: true}\n    ]\n    \n    {:ok, users: users}\n  end\n  \n  test \"complex business rule validation\", %{users: users} do\n    # Build complex business rules\n    basic_requirements = Predicate.and_all([\n      fn user -> user.age >= 18 end,\n      fn user -> user.active == true end,\n      fn user -> user.verified == true end\n    ])\n    \n    elevated_access = Predicate.or_any([\n      fn user -> user.role == :admin end,\n      fn user -> user.role == :moderator end\n    ])\n    \n    can_moderate = Predicate.and_all([basic_requirements, elevated_access])\n    \n    # Test against known data\n    [alice, bob, carol, dave] = users\n    \n    assert can_moderate.(alice) == true   # Admin, meets requirements\n    assert can_moderate.(bob) == false    # Minor, unverified\n    assert can_moderate.(carol) == false  # Inactive\n    assert can_moderate.(dave) == false   # No elevated role\n  end\n  \n  test \"filtering with composed predicates\", %{users: users} do\n    # Create filtering predicates\n    is_adult = fn user -> user.age >= 18 end\n    is_staff = Predicate.or_any([\n      fn user -> user.role == :admin end,\n      fn user -> user.role == :moderator end\n    ])\n    \n    active_staff = Predicate.and_all([\n      is_adult,\n      is_staff,\n      fn user -> user.active == true end\n    ])\n    \n    result = Enum.filter(users, active_staff)\n    \n    # Only Alice should match (adult, admin, active)\n    assert length(result) == 1\n    assert hd(result).name == \"Alice\"\n  end\n  \n  test \"short-circuiting behavior\" do\n    call_count = Agent.start_link(fn -> 0 end, name: :test_counter)\n    \n    expensive_predicate = fn _user ->\n      Agent.update(:test_counter, &(&1 + 1))\n      true\n    end\n    \n    # This should short-circuit after the first false\n    short_circuit_predicate = Predicate.and_all([\n      fn _user -> false end,  # Always false - should short-circuit here\n      expensive_predicate    # Should not be called\n    ])\n    \n    user = %{name: \"Test\"}\n    result = short_circuit_predicate.(user)\n    call_count_after = Agent.get(:test_counter, & &1)\n    \n    assert result == false\n    assert call_count_after == 0  # Expensive predicate was not called\n  end\nend\n```","ref":"predicate-usage-rules.html#test-composed-predicates"},{"type":"extras","title":"Test Edge Cases - Funx.Predicate Usage Rules","doc":"```elixir\ndefmodule PredicateEdgeCaseTest do\n  use ExUnit.Case\n  \n  test \"empty predicate lists\" do\n    # Empty and_all should return true (identity element)\n    always_true = Predicate.and_all([])\n    assert always_true.(:anything) == true\n    \n    # Empty or_any should return false (identity element)\n    always_false = Predicate.or_any([])\n    assert always_false.(:anything) == false\n  end\n  \n  test \"single predicate in composition\" do\n    single_pred = fn x -> x > 5 end\n    \n    and_single = Predicate.and_all([single_pred])\n    or_single = Predicate.or_any([single_pred])\n    \n    assert and_single.(10) == true\n    assert or_single.(10) == true\n    assert and_single.(3) == false\n    assert or_single.(3) == false\n  end\n  \n  test \"nested composition\" do\n    # Build nested predicate structure\n    inner_and = Predicate.and_all([\n      fn x -> x > 0 end,\n      fn x -> x < 100 end\n    ])\n    \n    inner_or = Predicate.or_any([\n      fn x -> x == -1 end,  # Special case\n      inner_and             # Or within normal range\n    ])\n    \n    outer_predicate = Predicate.and_all([\n      fn x -> is_integer(x) end,\n      inner_or\n    ])\n    \n    assert outer_predicate.(50) == true    # Integer in range\n    assert outer_predicate.(-1) == true    # Special case\n    assert outer_predicate.(150) == false  # Out of range\n    assert outer_predicate.(5.5) == false  # Not integer\n  end\n  \n  test \"nil and error handling\" do\n    safe_predicate = fn user ->\n      # Safely handle potential nil values\n      not is_nil(user) and \n      Map.has_key?(user, :age) and \n      not is_nil(user.age) and\n      user.age >= 18\n    end\n    \n    assert safe_predicate.(%{age: 25}) == true\n    assert safe_predicate.(%{}) == false\n    assert safe_predicate.(nil) == false\n  end\nend\n```","ref":"predicate-usage-rules.html#test-edge-cases"},{"type":"extras","title":"LLM Debugging Tips - Funx.Predicate Usage Rules","doc":"","ref":"predicate-usage-rules.html#llm-debugging-tips"},{"type":"extras","title":"Named Predicates for Clarity - Funx.Predicate Usage Rules","doc":"```elixir\ndef build_debuggable_predicates() do\n  # Create named predicates for easier debugging\n  predicates = %{\n    is_adult: fn user -> \n      result = user.age >= 18\n      IO.puts(\"is_adult(#{user.name}): #{result}\")\n      result\n    end,\n    \n    has_valid_email: fn user ->\n      result = String.contains?(user.email, \"@\")\n      IO.puts(\"has_valid_email(#{user.name}): #{result}\")\n      result\n    end,\n    \n    is_active: fn user ->\n      result = user.active == true\n      IO.puts(\"is_active(#{user.name}): #{result}\")  \n      result\n    end\n  }\n  \n  # Compose with logging\n  user_validator = Predicate.and_all([\n    predicates.is_adult,\n    predicates.has_valid_email,\n    predicates.is_active\n  ])\n  \n  # Test user\n  test_user = %{name: \"Alice\", age: 25, email: \"alice@test.com\", active: true}\n  \n  IO.puts(\"Testing user validation:\")\n  result = user_validator.(test_user)\n  IO.puts(\"Final result: #{result}\")\n  \n  result\nend\n```","ref":"predicate-usage-rules.html#named-predicates-for-clarity"},{"type":"extras","title":"Component Testing - Funx.Predicate Usage Rules","doc":"```elixir\ndef debug_predicate_composition() do\n  # Test individual components first\n  predicates = [\n    {\"age_check\", fn user -> user.age >= 18 end},\n    {\"email_check\", fn user -> String.contains?(user.email, \"@\") end},\n    {\"active_check\", fn user -> user.active == true end}\n  ]\n  \n  test_user = %{name: \"Bob\", age: 17, email: \"bob@test.com\", active: false}\n  \n  IO.puts(\"Individual predicate results:\")\n  individual_results = predicates\n  |> Enum.map(fn {name, pred} ->\n    result = pred.(test_user)\n    IO.puts(\"#{name}: #{result}\")\n    {name, result}\n  end)\n  \n  # Test composition\n  composed = predicates |> Enum.map(fn {_, pred} -> pred end) |> Predicate.p_all()\n  composed_result = composed.(test_user)\n  \n  IO.puts(\"Composed result: #{composed_result}\")\n  \n  # Analyze results\n  failing_predicates = individual_results \n  |> Enum.filter(fn {_, result} -> not result end)\n  |> Enum.map(fn {name, _} -> name end)\n  \n  IO.puts(\"Failing predicates: #{inspect(failing_predicates)}\")\n  \n  %{individual: individual_results, composed: composed_result, failing: failing_predicates}\nend\n```","ref":"predicate-usage-rules.html#component-testing"},{"type":"extras","title":"LLM Error Message Design - Funx.Predicate Usage Rules","doc":"","ref":"predicate-usage-rules.html#llm-error-message-design"},{"type":"extras","title":"Providing Context for Failures - Funx.Predicate Usage Rules","doc":"```elixir\ndef build_descriptive_validation() do\n  # Create predicates with error context\n  def create_validating_predicate(predicate_fn, description) do\n    fn value ->\n      case predicate_fn.(value) do\n        true -> {:ok, value}\n        false -> {:error, \"#{description} failed for #{inspect(value)}\"}\n      end\n    end\n  end\n  \n  # Build contextual validators\n  validators = %{\n    age_validator: create_validating_predicate(\n      fn user -> user.age >= 18 end,\n      \"Age requirement (>=18)\"\n    ),\n    \n    email_validator: create_validating_predicate(\n      fn user -> String.contains?(user.email, \"@\") end,\n      \"Email format validation\"\n    ),\n    \n    status_validator: create_validating_predicate(\n      fn user -> user.status == :active end,\n      \"Active status requirement\"\n    )\n  }\n  \n  # Compose with error accumulation\n  def validate_user_with_errors(user) do\n    results = [\n      validators.age_validator.(user),\n      validators.email_validator.(user),\n      validators.status_validator.(user)\n    ]\n    \n    errors = results \n    |> Enum.filter(fn result -> elem(result, 0) == :error end)\n    |> Enum.map(fn {:error, msg} -> msg end)\n    \n    case errors do\n      [] -> {:ok, user}\n      error_list -> {:error, \"Validation failed: \" <> Enum.join(error_list, \", \")}\n    end\n  end\n  \n  %{validate: &validate_user_with_errors/1}\nend\n```","ref":"predicate-usage-rules.html#providing-context-for-failures"},{"type":"extras","title":"LLM Common Mistakes to Avoid - Funx.Predicate Usage Rules","doc":"","ref":"predicate-usage-rules.html#llm-common-mistakes-to-avoid"},{"type":"extras","title":"❌ Don't Use Side Effects in Predicates - Funx.Predicate Usage Rules","doc":"```elixir\n# ❌ Wrong: predicates with side effects\nbad_predicate = fn user ->\n  Logger.info(\"Checking user #{user.id}\")  # Side effect!\n  Database.log_access(user.id)             # Side effect!\n  user.age >= 18\nend\n\n# ✅ Correct: pure predicates, side effects elsewhere\ngood_predicate = fn user -> user.age >= 18 end\n\ndef validate_and_log(user) do\n  Logger.info(\"Checking user #{user.id}\")    # Side effects separate\n  is_valid = good_predicate.(user)\n  if is_valid, do: Database.log_access(user.id)\n  is_valid\nend\n```","ref":"predicate-usage-rules.html#don-t-use-side-effects-in-predicates"},{"type":"extras","title":"❌ Don't Put Expensive Operations First - Funx.Predicate Usage Rules","doc":"```elixir\n# ❌ Wrong: expensive check first\ninefficient_validation = Predicate.and_all([\n  fn user -> ExternalAPI.verify_identity(user.ssn) end,  # Expensive!\n  fn user -> not is_nil(user.name) end,                  # Cheap\n  fn user -> String.length(user.email) > 0 end          # Cheap  \n])\n\n# ✅ Correct: cheap checks first, expensive last\nefficient_validation = Predicate.and_all([\n  fn user -> not is_nil(user.name) end,                  # Cheap first\n  fn user -> String.length(user.email) > 0 end,         # Still cheap\n  fn user -> ExternalAPI.verify_identity(user.ssn) end  # Expensive last\n])\n```","ref":"predicate-usage-rules.html#don-t-put-expensive-operations-first"},{"type":"extras","title":"❌ Don't Return Non-Boolean Values - Funx.Predicate Usage Rules","doc":"```elixir\n# ❌ Wrong: returning non-boolean\nbad_predicate = fn user ->\n  case user.age do\n    age when age >= 18 -> :adult\n    age when age >= 13 -> :teen  \n    _ -> :child\n  end\nend\n\n# ✅ Correct: always return boolean\ngood_adult_predicate = fn user -> user.age >= 18 end\ngood_teen_predicate = fn user -> user.age >= 13 and user.age < 18 end\n\n# If you need the classification, use a separate function\ndef classify_user(user) do\n  cond do\n    good_adult_predicate.(user) -> :adult\n    good_teen_predicate.(user) -> :teen\n    true -> :child\n  end\nend\n```","ref":"predicate-usage-rules.html#don-t-return-non-boolean-values"},{"type":"extras","title":"❌ Don't Mix Types in Composition - Funx.Predicate Usage Rules","doc":"```elixir\n# ❌ Wrong: predicates expecting different types  \nmixed_predicates = Predicate.and_all([\n  fn user -> user.age >= 18 end,           # Expects user struct\n  fn name -> String.length(name) > 0 end   # Expects string\n])\n\n# ✅ Correct: consistent input types\nuser_predicates = Predicate.and_all([\n  fn user -> user.age >= 18 end,\n  fn user -> String.length(user.name) > 0 end,  # Extract field first\n  fn user -> not is_nil(user.email) end\n])\n```","ref":"predicate-usage-rules.html#don-t-mix-types-in-composition"},{"type":"extras","title":"❌ Don't Ignore Error Cases - Funx.Predicate Usage Rules","doc":"```elixir\n# ❌ Wrong: not handling potential errors\nunsafe_predicate = fn user ->\n  user.profile.preferences.notifications.email == true  # Could crash!\nend\n\n# ✅ Correct: safe field access\nsafe_predicate = fn user ->\n  get_in(user, [:profile, :preferences, :notifications, :email]) == true\nend\n\n# ✅ Even better: with nil checks\nbetter_predicate = fn user ->\n  case get_in(user, [:profile, :preferences, :notifications, :email]) do\n    true -> true\n    _ -> false\n  end\nend\n```","ref":"predicate-usage-rules.html#don-t-ignore-error-cases"},{"type":"extras","title":"❌ Don't Create Overly Complex Single Predicates - Funx.Predicate Usage Rules","doc":"```elixir\n# ❌ Wrong: overly complex single predicate\ncomplex_predicate = fn user ->\n  user.age >= 18 and \n  user.active == true and\n  user.verified == true and\n  String.contains?(user.email, \"@\") and\n  user.role in [:admin, :moderator, :user] and\n  length(user.permissions) > 0 and\n  not is_nil(user.last_login) and\n  DateTime.diff(DateTime.utc_now(), user.last_login, :day) <= 30\nend\n\n# ✅ Correct: break down into composable parts\nbasic_checks = Predicate.and_all([\n  fn user -> user.age >= 18 end,\n  fn user -> user.active == true end,\n  fn user -> user.verified == true end\n])\n\naccount_checks = Predicate.and_all([\n  fn user -> String.contains?(user.email, \"@\") end,\n  fn user -> user.role in [:admin, :moderator, :user] end,\n  fn user -> length(user.permissions) > 0 end\n])\n\nactivity_checks = Predicate.and_all([\n  fn user -> not is_nil(user.last_login) end,\n  fn user -> DateTime.diff(DateTime.utc_now(), user.last_login, :day) <= 30 end\n])\n\ncomplete_validation = Predicate.and_all([basic_checks, account_checks, activity_checks])\n```","ref":"predicate-usage-rules.html#don-t-create-overly-complex-single-predicates"},{"type":"extras","title":"LLM Integration with Monoids - Funx.Predicate Usage Rules","doc":"Understanding the monoid connection helps with advanced predicate composition:\n\n```elixir\n# Predicates use All and Any monoids internally\ndef demonstrate_monoid_connection() do\n  # All monoid (AND behavior) - identity is true\n  all_monoid_example = Predicate.and_all([\n    fn x -> x > 0 end,    # First check\n    fn x -> x < 100 end   # Second check  \n  ])\n  # Equivalent to: All.concat([predicate1, predicate2])\n  \n  # Any monoid (OR behavior) - identity is false  \n  any_monoid_example = Predicate.or_any([\n    fn x -> x == :admin end,     # First check\n    fn x -> x == :moderator end  # Second check\n  ])\n  # Equivalent to: Any.concat([predicate1, predicate2])\n  \n  # Direct monoid usage (advanced)\n  alias Funx.Monoid.All\n  alias Funx.Monoid.Any\n  \n  # Build using monoids directly\n  manual_all = All.concat([\n    All.new(fn x -> x > 0 end),\n    All.new(fn x -> x < 100 end)\n  ])\n  \n  manual_any = Any.concat([\n    Any.new(fn x -> x == :admin end),\n    Any.new(fn x -> x == :moderator end)\n  ])\n  \n  # Extract predicates from monoids\n  all_pred = All.get_value(manual_all)\n  any_pred = Any.get_value(manual_any)\n  \n  %{\n    standard_and: all_monoid_example,\n    standard_or: any_monoid_example,\n    manual_all: all_pred,\n    manual_any: any_pred\n  }\nend\n```","ref":"predicate-usage-rules.html#llm-integration-with-monoids"},{"type":"extras","title":"Summary - Funx.Predicate Usage Rules","doc":"`Funx.Predicate` provides composable boolean logic for validation, filtering, and conditional operations. It's built on solid mathematical foundations with monoid backing for efficient composition.\n\n**Key capabilities:**\n\n- **Composable validation**: Build complex logic from simple predicates\n- **Monoid-backed operations**: Mathematically sound with proper identity elements\n- **Short-circuiting evaluation**: Efficient `and_all` and `or_any` operations\n- **Cross-module integration**: Works seamlessly with Utils, Maybe, Either, and Enum\n- **Performance optimization**: Put cheap predicates first for efficiency\n\n**Core patterns:**\n\n- Use `and_all/1` when all conditions must be true\n- Use `or_any/1` when any condition can be true  \n- Use `not/1` for logical negation\n- Compose predicates rather than building complex single functions\n- Order predicates from cheapest to most expensive\n\n**Integration points:**\n\n- **Utils**: Curry predicates for pipeline use\n- **Monads**: Convert predicates to Maybe/Either validators\n- **Collections**: Use with Enum filtering and testing functions\n- **Monoids**: Direct monoid usage for advanced composition patterns\n\n**Canon**: Build from simple predicates, compose with monoid operations, optimize with short-circuiting, integrate across functional abstractions.","ref":"predicate-usage-rules.html#summary"},{"type":"extras","title":"Funx.Utils Usage Rules","doc":"# `Funx.Utils` Usage Rules","ref":"utils-usage-rules.html"},{"type":"extras","title":"LLM Functional Programming Foundation - Funx.Utils Usage Rules","doc":"**Key Concepts for LLMs:**\n\n**Currying**: Converting a multi-argument function into a chain of single-argument functions\n\n- `curry_r/1`: Curries arguments from right to left, allowing data argument to be applied last (pipeline-friendly)\n- `curry/1` & `curry_l/1`: Left-to-right currying (traditional functional style)\n- Example: `f(a, b, c)` → `curry(f).(a).(b).(c)`\n- **Edge case**: Currying a unary function returns the original function (no-op)\n\n**Partial Application**: Fixing some arguments of a function, creating a new function\n\n- Result of currying: each step returns a function waiting for remaining args\n- Enables configuration-first, data-last patterns\n- Example: `add = curry_r(+).(5)` creates function that adds 5\n\n**Point-Free Style**: Writing functions without explicitly mentioning arguments\n\n- Compose functions without intermediate variables\n- More declarative and reusable\n- Example: `process = transform |> validate |> save`\n\n**Function Flipping**: Reversing argument order for better composition\n\n- `flip/1`: Swaps arguments of binary functions (arity = 2 only)\n- Useful when argument order doesn't match pipeline needs\n- Example: `flip(div).(2, 10)` → `10 / 2`\n- **Invalid**: `flip/1` cannot be applied to unary or 3+ arity functions\n\n**Arity Independence**: Works with functions of any number of arguments\n\n- Dynamically inspects function arity via `:erlang.fun_info/2`\n- Returns as many nested unary functions as the original function has parameters\n- No need to know function arity in advance - curry supports arbitrary arity","ref":"utils-usage-rules.html#llm-functional-programming-foundation"},{"type":"extras","title":"LLM Decision Guide: When to Use Utils - Funx.Utils Usage Rules","doc":"**✅ Use Utils when:**\n\n- Building reusable, composable functions\n- Need partial application for configuration\n- Want point-free programming style\n- Adapting functions for pipeline use\n- User says: \"configure then apply\", \"reuse with different parameters\", \"point-free\"\n\n**❌ Don't use Utils when:**\n\n- Simple one-off function calls\n- Performance is absolutely critical\n- Argument order is already correct\n- Functions are already curried\n\n**⚡ Currying Strategy Decision:**\n\n- **Pipeline-friendly**: Use `curry_r/1` (data flows left-to-right, config right-to-left)\n- **Traditional FP**: Use `curry/1` or `curry_l/1` (left-to-right application)\n- **Argument reordering**: Use `flip/1` then curry as needed\n\n**⚙️ Function Choice Guide (Mathematical Purpose):**\n\n- **Configuration before data**: `curry_r(fn config, data -> ... end).(config)`\n- **Traditional currying**: `curry(fn a, b, c -> ... end).(a).(b).(c)`\n- **Argument order fix**: `flip(fn a, b -> ... end)`\n- **Point-free composition**: Combine curried functions without variables","ref":"utils-usage-rules.html#llm-decision-guide-when-to-use-utils"},{"type":"extras","title":"LLM Context Clues - Funx.Utils Usage Rules","doc":"**User language → Utils patterns:**\n\n- \"configure then apply\" → `curry_r` for config-first pattern\n- \"reuse with different settings\" → curry for partial application\n- \"flip the arguments\" → `flip/1`\n- \"point-free style\" → curry functions for composition\n- \"pipeline-friendly\" → `curry_r/1`\n- \"traditional currying\" → `curry/1` or `curry_l/1`","ref":"utils-usage-rules.html#llm-context-clues"},{"type":"extras","title":"Quick Reference - Funx.Utils Usage Rules","doc":"- Use `curry_r/1` to curry functions right-to-left—ideal for Elixir's `|>` pipe style.\n- Use `curry/1` or `curry_l/1` to curry left-to-right when needed.\n- Use `flip/1` to reverse arguments in binary functions.\n- All currying functions adapt to any arity and return nested unary functions.","ref":"utils-usage-rules.html#quick-reference"},{"type":"extras","title":"Overview - Funx.Utils Usage Rules","doc":"`Funx.Utils` provides functional utilities for reshaping multi-argument functions to support composition, partial application, and point-free style.\nUse `curry_r/1` by default—it aligns with Elixir’s `|>` operator by shifting configuration to the right and leaving the data position first.\n\nThese tools are especially useful with predicates, monads, and other combinators where composition and reuse are key.","ref":"utils-usage-rules.html#overview"},{"type":"extras","title":"Composition Rules - Funx.Utils Usage Rules","doc":"| Function    | Description                                                  |\n| ----------- | ------------------------------------------------------------ |\n| `curry_r/1` | Curries a function right-to-left (recommended for pipelines) |\n| `curry/1`   | Curries left-to-right                                        |\n| `curry_l/1` | Alias for `curry/1`, makes intent explicit                   |\n| `flip/1`    | Reverses arguments of a binary function                      |\n\nEach function returns a chain of unary functions that accumulate arguments until fully applied.","ref":"utils-usage-rules.html#composition-rules"},{"type":"extras","title":"Usage Patterns - Funx.Utils Usage Rules","doc":"","ref":"utils-usage-rules.html#usage-patterns"},{"type":"extras","title":"Right-to-Left Currying for Pipelines - Funx.Utils Usage Rules","doc":"```elixir\nf = fn prefix, name -> prefix <> name end\ngreet = curry_r(f).(\"Hello, \")\n\"Alice\" |> greet()\n# => \"Hello, Alice\"\n```","ref":"utils-usage-rules.html#right-to-left-currying-for-pipelines"},{"type":"extras","title":"Flip for Reordering Binary Functions - Funx.Utils Usage Rules","doc":"```elixir\ndiv = fn a, b -> a / b end\nflipped = flip(div)\nflipped.(2, 10)  # => 5.0\n```","ref":"utils-usage-rules.html#flip-for-reordering-binary-functions"},{"type":"extras","title":"Left-to-Right Currying (Less Common) - Funx.Utils Usage Rules","doc":"```elixir\nsum = curry(fn a, b, c -> a + b + c end)\nsum.(1).(2).(3)  # => 6\n```","ref":"utils-usage-rules.html#left-to-right-currying-less-common"},{"type":"extras","title":"Guidelines for Composition - Funx.Utils Usage Rules","doc":"Follow these patterns when reshaping or generating function transformations:\n\n- Prefer `curry_r/1` for functions that appear in pipelines.\n- Use `flip/1` when argument order doesn’t match surrounding context.\n- Use `curry/1` or `curry_l/1` when left-to-right application is more natural.\n- Avoid manual `fn` nesting—use the provided helpers instead.\n- Avoid assuming a function has only 2 or 3 arguments—curry_r/1 supports arbitrary arity and returns as many nested unary functions as needed.\n- Avoid capture syntax (`&mod.fun/arity`) when partial application is needed.\n  Capture locks arity and order, and cannot be curried or reordered.\n\nCurrying is often most useful when composed with lifted combinators like `map`, `bind`, `filter`, and so on.","ref":"utils-usage-rules.html#guidelines-for-composition"},{"type":"extras","title":"Stability Contract - Funx.Utils Usage Rules","doc":"Ensure that generated or transformed functions preserve:\n\n- Purity — returned functions are referentially transparent.\n- Laziness — arguments are applied only when provided.\n- Equivalence — full application matches the original function:\n\n```elixir\ncurry_r(f).(b).(a) == f.(a, b)\n```","ref":"utils-usage-rules.html#stability-contract"},{"type":"extras","title":"Anti-Patterns - Funx.Utils Usage Rules","doc":"Avoid generating or emitting:\n\n- Manual currying via nested `fn` chains: `fn a -> fn b -> f.(a, b) end end`\n- Assuming functions have fixed arity (curry supports arbitrary arity dynamically)\n- Argument reordering by hand—prefer `flip/1`\n- Full application immediately after currying\n- Capture syntax (`&fun/2`) when transformation is required","ref":"utils-usage-rules.html#anti-patterns"},{"type":"extras","title":"Good Patterns - Funx.Utils Usage Rules","doc":"Encourage completions like:\n\n```elixir\n# Partial right-to-left application for pipelines\nassign_role = curry_r(fn role, user -> %{user | role: role} end)\nuser |> assign_role.(\"admin\")\n```\n\n```elixir\n# Flipping to enable higher-order composition\ncompare = flip(fn a, b -> a > b end)\nEnum.filter(list, compare.(10))\n```\n\n```elixir\n# Contextual function with partial application\ntransform =\n  curry_r(fn format, name -> format.(\"<\" <> name <> \">\") end)\n\"Alex\" |> transform.(&String.upcase/1)\n```","ref":"utils-usage-rules.html#good-patterns"},{"type":"extras","title":"When to Use - Funx.Utils Usage Rules","doc":"Reach for these utilities when you want to:\n\n- Enable point-free style\n- Compose partial functions within a pipeline\n- Shift configuration before data\n- Adapt argument order to match surrounding combinators\n- Prepare functions before lifting into a monadic or applicative context","ref":"utils-usage-rules.html#when-to-use"},{"type":"extras","title":"Built-in Behavior - Funx.Utils Usage Rules","doc":"- `curry_r/1`, `curry/1`, and `curry_l/1` inspect function arity via `:erlang.fun_info/2`.\n- Returned functions accumulate arguments until fully applied.\n- `flip/1` applies only to functions of arity 2.","ref":"utils-usage-rules.html#built-in-behavior"},{"type":"extras","title":"LLM Code Templates - Funx.Utils Usage Rules","doc":"","ref":"utils-usage-rules.html#llm-code-templates"},{"type":"extras","title":"Configuration-First Pattern Template - Funx.Utils Usage Rules","doc":"```elixir\n# API client with configurable base settings\ndef build_api_client() do\n  request_fn = curry_r(fn headers, auth, url ->\n    HTTPoison.get(url, headers, auth: auth)\n  end)\n  \n  # Pre-configure common settings\n  authenticated_request = request_fn\n    |> apply.([{\"Content-Type\", \"application/json\"}])\n    |> apply.({:bearer, \"token\"})\n  \n  # Now just pass URLs\n  \"/users\" |> authenticated_request.()\n  \"/posts\" |> authenticated_request.()\nend\n```","ref":"utils-usage-rules.html#configuration-first-pattern-template"},{"type":"extras","title":"Data Transformation Pipeline Template - Funx.Utils Usage Rules","doc":"```elixir\ndef build_transformer() do\n  # Curry transformation functions for reuse\n  validate_with = curry_r(fn rules, data ->\n    if Enum.all?(rules, fn rule -> rule.(data) end) do\n      {:ok, data}\n    else\n      {:error, \"validation failed\"}\n    end\n  end)\n  \n  transform_with = curry_r(fn mapper, {:ok, data} -> {:ok, mapper.(data)} end)\n  \n  # Build reusable pipelines\n  user_rules = [&is_adult/1, &has_email/1]\n  user_validator = validate_with.(user_rules)\n  user_transformer = transform_with.(&normalize_user/1)\n  \n  # Apply to data\n  user_data \n  |> user_validator.()\n  |> user_transformer.()\nend\n```","ref":"utils-usage-rules.html#data-transformation-pipeline-template"},{"type":"extras","title":"Function Composition Template - Funx.Utils Usage Rules","doc":"```elixir\ndef build_processors() do\n  # Flip functions to match pipeline argument order\n  filter_by = flip(&Enum.filter/2)\n  map_with = flip(&Enum.map/2)\n  reduce_by = curry_r(&Enum.reduce/3)\n  \n  # Create specialized processors\n  filter_adults = filter_by.(fn user -> user.age >= 18 end)\n  extract_names = map_with.(fn user -> user.name end)\n  count_items = reduce_by.(0, fn _, acc -> acc + 1 end)\n  \n  # Compose into pipeline\n  users\n  |> filter_adults.()\n  |> extract_names.()\n  |> count_items.()\nend\n```","ref":"utils-usage-rules.html#function-composition-template"},{"type":"extras","title":"Predicate Factory Template - Funx.Utils Usage Rules","doc":"```elixir\ndef build_predicates() do\n  # Create configurable predicates\n  field_equals = curry_r(fn value, field, item ->\n    Map.get(item, field) == value\n  end)\n  \n  field_greater = curry_r(fn threshold, field, item ->\n    Map.get(item, field) > threshold\n  end)\n  \n  # Generate specific predicates\n  is_admin = field_equals.(:admin, :role)\n  is_adult = field_greater.(18, :age)\n  is_active = field_equals.(true, :active)\n  \n  # Use with filtering\n  users |> Enum.filter(is_admin)\n  users |> Enum.filter(is_adult)\nend\n```","ref":"utils-usage-rules.html#predicate-factory-template"},{"type":"extras","title":"LLM Performance Considerations - Funx.Utils Usage Rules","doc":"**Currying overhead:**\n\n- Each curried function call has slight overhead\n- Consider performance impact for hot paths\n- Pre-curry functions used repeatedly\n\n**Memory considerations:**\n\n- Curried functions capture arguments in closures\n- Can prevent garbage collection of captured values\n- Use judiciously in long-running processes\n\n**Thread-safety for closures:**\n\n- Curried closures may capture config values\n- In long-running processes, ensure captured values don't include large, stateful, or cyclic data\n- Captured values should be immutable and reasonably sized\n\n**Optimization patterns:**\n\n```elixir\n# ✅ Good: curry once, use many times\ntransformer = curry_r(&String.replace/3).(\"old\", \"new\")\nresults = Enum.map(strings, transformer)\n\n# ❌ Less efficient: curry in loop\nresults = Enum.map(strings, fn s -> \n  curry_r(&String.replace/3).(\"old\", \"new\").(s)\nend)\n```","ref":"utils-usage-rules.html#llm-performance-considerations"},{"type":"extras","title":"LLM Interop Patterns - Funx.Utils Usage Rules","doc":"","ref":"utils-usage-rules.html#llm-interop-patterns"},{"type":"extras","title":"With Enum Functions - Funx.Utils Usage Rules","doc":"```elixir\n# Make Enum functions pipeline-friendly\nmap_with = flip(&Enum.map/2)\nfilter_by = flip(&Enum.filter/2)\nreduce_by = curry_r(&Enum.reduce/3)\n\n# Use in pipelines\ndata\n|> filter_by.(predicate)\n|> map_with.(transformer)\n|> reduce_by.(initial_value, accumulator)\n```","ref":"utils-usage-rules.html#with-enum-functions"},{"type":"extras","title":"With GenServer Calls - Funx.Utils Usage Rules","doc":"```elixir\n# Create configured GenServer callers\ndef build_service_client(server_name) do\n  call_server = curry_r(&GenServer.call/2).(server_name)\n  cast_server = curry_r(&GenServer.cast/2).(server_name)\n  \n  %{\n    get_user: call_server.({:get_user, user_id}),\n    update_user: cast_server.({:update_user, user_data}),\n    delete_user: cast_server.({:delete_user, user_id})\n  }\nend\n```","ref":"utils-usage-rules.html#with-genserver-calls"},{"type":"extras","title":"With Phoenix Contexts - Funx.Utils Usage Rules","doc":"```elixir\n# Create context function factories\ndef build_user_operations(repo) do\n  create_with_repo = curry_r(fn changeset, repo ->\n    Repo.insert(changeset, repo: repo)\n  end).(repo)\n  \n  update_with_repo = curry_r(fn changeset, user, repo ->\n    Repo.update(changeset, repo: repo)\n  end).(repo)\n  \n  %{\n    create_user: create_with_repo,\n    update_user: update_with_repo\n  }\nend\n```","ref":"utils-usage-rules.html#with-phoenix-contexts"},{"type":"extras","title":"LLM Testing Guidance - Funx.Utils Usage Rules","doc":"","ref":"utils-usage-rules.html#llm-testing-guidance"},{"type":"extras","title":"Test Currying Behavior - Funx.Utils Usage Rules","doc":"```elixir\ntest \"curry_r creates proper function chain\" do\n  add3 = fn a, b, c -> a + b + c end\n  curried = Funx.Utils.curry_r(add3)\n  \n  # Test partial application\n  partial1 = curried.(3)\n  partial2 = partial1.(2)\n  result = partial2.(1)\n  \n  assert result == 6\n  assert add3.(1, 2, 3) == curried.(3).(2).(1)\nend\n\ntest \"curry_l creates left-to-right chain\" do\n  multiply3 = fn a, b, c -> a * b * c end\n  curried = Funx.Utils.curry(multiply3)\n  \n  result = curried.(2).(3).(4)\n  assert result == 24\nend\n```","ref":"utils-usage-rules.html#test-currying-behavior"},{"type":"extras","title":"Test Function Flipping - Funx.Utils Usage Rules","doc":"```elixir\ntest \"flip reverses binary function arguments\" do\n  subtract = fn a, b -> a - b end\n  flipped = Funx.Utils.flip(subtract)\n  \n  assert subtract.(10, 3) == 7\n  assert flipped.(3, 10) == 7\nend\n```","ref":"utils-usage-rules.html#test-function-flipping"},{"type":"extras","title":"Test Point-Free Composition - Funx.Utils Usage Rules","doc":"```elixir\ntest \"curried functions compose for point-free style\" do\n  transform = Funx.Utils.curry_r(fn suffix, prefix, text ->\n    prefix <> text <> suffix\n  end)\n  \n  add_brackets = transform.(\"]\", \"[\")\n  add_parens = transform.(\")\", \"(\")\n  \n  assert add_brackets.(\"test\") == \"[test]\"\n  assert add_parens.(\"test\") == \"(test)\"\nend\n```","ref":"utils-usage-rules.html#test-point-free-composition"},{"type":"extras","title":"LLM Debugging Tips - Funx.Utils Usage Rules","doc":"","ref":"utils-usage-rules.html#llm-debugging-tips"},{"type":"extras","title":"Test Individual Steps - Funx.Utils Usage Rules","doc":"```elixir\n# Debug currying by testing each step\nadd3 = fn a, b, c -> a + b + c end\ncurried = curry_r(add3)\n\nstep1 = curried.(3)\nIO.inspect(step1, label: \"after first arg\")\n\nstep2 = step1.(2) \nIO.inspect(step2, label: \"after second arg\")\n\nresult = step2.(1)\nIO.inspect(result, label: \"final result\")\n```","ref":"utils-usage-rules.html#test-individual-steps"},{"type":"extras","title":"Verify Equivalence - Funx.Utils Usage Rules","doc":"```elixir\n# Ensure curried version equals original\noriginal_result = original_fn.(arg1, arg2, arg3)\ncurried_result = curry_r(original_fn).(arg3).(arg2).(arg1)\nassert original_result == curried_result\n```","ref":"utils-usage-rules.html#verify-equivalence"},{"type":"extras","title":"LLM Error Message Design - Funx.Utils Usage Rules","doc":"","ref":"utils-usage-rules.html#llm-error-message-design"},{"type":"extras","title":"Handle Arity Mismatches - Funx.Utils Usage Rules","doc":"```elixir\ndef safe_curry(fun) do\n  case :erlang.fun_info(fun, :arity) do\n    {:arity, 0} -> {:error, \"Cannot curry zero-arity function\"}\n    {:arity, n} when n > 0 -> {:ok, Funx.Utils.curry_r(fun)}\n    _ -> {:error, \"Invalid function\"}\n  end\nend\n```","ref":"utils-usage-rules.html#handle-arity-mismatches"},{"type":"extras","title":"Provide Clear Function Descriptions - Funx.Utils Usage Rules","doc":"```elixir\ndef build_transformer(name, transform_fn) do\n  curried = Funx.Utils.curry_r(transform_fn)\n  \n  # Add metadata for debugging\n  fn config ->\n    fn data ->\n      try do\n        curried.(config).(data)\n      rescue\n        error -> \n          {:error, \"#{name} transformation failed: #{inspect(error)}\"}\n      end\n    end\n  end\nend\n```","ref":"utils-usage-rules.html#provide-clear-function-descriptions"},{"type":"extras","title":"LLM Common Mistakes to Avoid - Funx.Utils Usage Rules","doc":"**❌ Don't use capture syntax with currying**\n\n```elixir\n# ❌ Wrong: capture syntax can't be curried\ncurry_r(&String.replace/3)\n\n# ✅ Correct: use explicit function\ncurry_r(fn str, old, new -> String.replace(str, old, new) end)\n```\n\n**❌ Don't assume argument order**\n\n```elixir\n# ❌ Wrong: assuming curry_r argument order\ndivide = curry_r(fn a, b -> a / b end)\nresult = divide.(10).(2)  # This gives 0.2, not 5\n\n# ✅ Correct: be explicit about order\ndivide = curry_r(fn divisor, dividend -> dividend / divisor end)\nresult = divide.(2).(10)  # This gives 5\n```\n\n**❌ Don't curry already curried functions**\n\n```elixir\n# ❌ Wrong: double currying\ndouble_curried = curry_r(curry_r(fn a, b -> a + b end))\n\n# ✅ Correct: curry once\ncurried = curry_r(fn a, b -> a + b end)\n```\n\n**❌ Don't ignore arity requirements**\n\n```elixir\n# ❌ Wrong: flip only works on binary functions\nflip(fn a, b, c -> a + b + c end)  # Will error\n\n# ✅ Correct: use flip only on binary functions\nflip(fn a, b -> a + b end)\n```","ref":"utils-usage-rules.html#llm-common-mistakes-to-avoid"},{"type":"extras","title":"Summary - Funx.Utils Usage Rules","doc":"`Funx.Utils` enables functional composition through currying and argument manipulation. Use it to build reusable, configurable functions that compose naturally in pipelines.\n\n- **Right-to-left currying**: Use `curry_r/1` for Elixir pipeline style (data-last)\n- **Left-to-right currying**: Use `curry/1` or `curry_l/1` for traditional functional style\n- **Argument flipping**: Use `flip/1` to adapt binary functions for better composition\n- **Point-free style**: Eliminate intermediate variables through function composition\n- **Partial application**: Pre-configure functions with some arguments, apply data later\n- **Arity independence**: Works with functions of any number of arguments dynamically","ref":"utils-usage-rules.html#summary"}],"content_type":"text/markdown","producer":{"name":"ex_doc","version":[48,46,51,52,46,50]}}