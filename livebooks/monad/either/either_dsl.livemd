# Funx.Monad.Either.Dsl

```elixir
Mix.install([
  {:funx, "0.7.0"}
])
```

## Overview

The `Funx.Monad.Either.Dsl` module provides a macro-based DSL for writing declarative pipelines that may fail. Instead of manually chaining `bind`, `map`, and other Either operations, you can express your logic in a clean, readable way.

The DSL automatically:
- Lifts input values into the Either context
- Handles errors by short-circuiting on the first failure
- Provides compile-time warnings for common mistakes
- Supports multiple output formats (Either, tuple, or raise)

## Setup

```elixir
use Funx.Monad.Either
```

## Basic Usage

### Simple Pipeline with `bind`

The `bind` operation is used when your function returns an Either or result tuple.

```elixir
# Helper functions for managing superheroes
defmodule HeroRegistry do
  use Funx.Monad.Either

  def parse_hero_id(input) do
    case Integer.parse(input) do
      {id, ""} when id > 0 -> right(id)
      _ -> left("Invalid hero ID")
    end
  end

  def fetch_hero(id) do
    # Simulate database lookup
    heroes = %{
      1 => %{id: 1, name: "Lightning Bolt", power: "super speed", active: true, level: 10},
      2 => %{id: 2, name: "Iron Shield", power: "invulnerability", active: false, level: 8},
      3 => %{id: 3, name: "Shadow Phantom", power: "invisibility", active: true, level: 7}
    }

    case Map.get(heroes, id) do
      nil -> {:error, "Hero not found"}
      hero -> {:ok, hero}
    end
  end

  def check_active(hero) do
    if hero.active do
      right(hero)
    else
      left("Hero is retired")
    end
  end
end
```

```elixir
# Using the DSL - each step returns Either
either "1" do
  bind HeroRegistry.parse_hero_id()
  bind HeroRegistry.fetch_hero()
  bind HeroRegistry.check_active()
end
```

```elixir
# When any step fails, the pipeline short-circuits (hero not found)
either "999" do
  bind HeroRegistry.parse_hero_id()
  bind HeroRegistry.fetch_hero()
  bind HeroRegistry.check_active()
end
```

```elixir
# Invalid input fails at the first step
either "not-a-number" do
  bind HeroRegistry.parse_hero_id()
  bind HeroRegistry.fetch_hero()
  bind HeroRegistry.check_active()
end
```

```elixir
# Retired hero fails the active check
either "2" do
  bind HeroRegistry.parse_hero_id()
  bind HeroRegistry.fetch_hero()
  bind HeroRegistry.check_active()
end
```

### Using `map` for Transformations

The `map` operation transforms a value without changing the Either context. Use it when your function returns a plain value, not an Either.

```elixir
# Transform hero to display format
either "1" do
  bind HeroRegistry.parse_hero_id()
  bind HeroRegistry.fetch_hero()
  bind HeroRegistry.check_active()
  map fn hero -> "#{hero.name} (#{hero.power})" end
end
```

### Using `tap` for Side Effects

The `tap` operation executes a side-effect function on a Right value and returns the original Either unchanged. This is useful for debugging, logging, or performing side effects without changing the value.

If the Either is Left, the tap function is not called.

```elixir
# Side effect on Right value
either "1" do
  bind HeroRegistry.parse_hero_id()
  tap fn id -> IO.inspect(id, label: "hero id") end
  bind HeroRegistry.fetch_hero()
  tap fn hero -> IO.inspect(hero.name, label: "hero name") end
  bind HeroRegistry.check_active()
  map fn hero -> "#{hero.name} (#{hero.power})" end
end
```

```elixir
# No side effect on Left
either "invalid" do
  bind HeroRegistry.parse_hero_id()
  tap fn id -> IO.inspect(id, label: "should not see this") end
  bind HeroRegistry.fetch_hero()
end
```

### Inline Anonymous Functions

You can use inline anonymous functions at any step:

```elixir
# Parse and validate hero ID inline
either "1" do
  bind fn id_str ->
    case Integer.parse(id_str) do
      {id, ""} when id > 0 -> right(id)
      _ -> left("Invalid hero ID")
    end
  end
  bind HeroRegistry.fetch_hero()
  map fn hero -> hero.name end
end
```

### Using Modules with `tap`, `map_left`, and `filter_or_else`

Just like `bind` and `map`, you can use modules that implement specific monad behaviors with other DSL operations like `tap`, `map_left`, and `filter_or_else`. This is particularly useful for creating reusable logging, error transformation, and validation logic.

#### `tap` with Modules

```elixir
# Example module pattern (works in compiled code):

defmodule HeroLogger do
  @behaviour Funx.Monad.Behaviour.Bind
  use Funx.Monad.Either

  def bind(hero, opts, _env) do
    prefix = Keyword.get(opts, :prefix, "HERO")
    IO.puts("#{prefix}: #{inspect(hero)}")
    right(hero)  # tap uses bind/3, must return Either
  end
end

# Use with bare module:
either "1" do
  bind HeroRegistry.parse_hero_id()
  tap HeroLogger
  bind HeroRegistry.fetch_hero()
end

# Use with module and options:
either "1" do
  bind HeroRegistry.parse_hero_id()
  tap {HeroLogger, prefix: "Parsed ID"}
  bind HeroRegistry.fetch_hero()
  tap {HeroLogger, prefix: "Fetched Hero"}
  map fn hero -> hero.name end
end
```

#### `map_left` with Modules

```elixir
# Example module pattern (works in compiled code):

defmodule ErrorFormatter do
  @behaviour Funx.Monad.Behaviour.Map

  def map(error, opts, _env) do
    context = Keyword.get(opts, :context, "Error")
    severity = Keyword.get(opts, :severity, "ERROR")
    "[#{severity}] #{context}: #{error}"
  end
end

# Use with bare module:
either "invalid" do
  bind HeroRegistry.parse_hero_id()
  map_left ErrorFormatter
end

# Use with module and options:
either "invalid" do
  bind HeroRegistry.parse_hero_id()
  map_left {ErrorFormatter, context: "Hero ID Parsing", severity: "WARN"}
end
```

#### `filter_or_else` with Modules

```elixir
# Example module pattern (works in compiled code):

defmodule IsEliteHero do
  @behaviour Funx.Monad.Behaviour.Predicate

  def predicate(hero, opts, _env) do
    min_level = Keyword.get(opts, :min_level, 10)
    hero.level >= min_level
  end
end

# Use with bare module:
either "1" do
  bind HeroRegistry.parse_hero_id()
  bind HeroRegistry.fetch_hero()
  filter_or_else IsEliteHero, fn -> "Only elite heroes allowed" end
end

# Use with module and options:
either "1" do
  bind HeroRegistry.parse_hero_id()
  bind HeroRegistry.fetch_hero()
  filter_or_else {IsEliteHero, min_level: 8}, fn -> "Hero level too low" end
end
```

## Output Formats

### Default: Either

By default, the DSL returns an Either value:

```elixir
either "1" do
  bind HeroRegistry.parse_hero_id()
  bind HeroRegistry.fetch_hero()
  map fn hero -> hero.name end
end
```

```elixir
either "invalid" do
  bind HeroRegistry.parse_hero_id()
  bind HeroRegistry.fetch_hero()
  map fn hero -> hero.name end
end
```

### Tuple Format

Use `as: :tuple` to get `{:ok, value}` or `{:error, reason}`:

```elixir
either "1", as: :tuple do
  bind HeroRegistry.parse_hero_id()
  bind HeroRegistry.fetch_hero()
  map fn hero -> hero.name end
end
```

```elixir
either "invalid", as: :tuple do
  bind HeroRegistry.parse_hero_id()
  bind HeroRegistry.fetch_hero()
  map fn hero -> hero.name end
end
```

### Raise Format

Use `as: :raise` to unwrap the value or raise an error:

```elixir
either "1", as: :raise do
  bind HeroRegistry.parse_hero_id()
  bind HeroRegistry.fetch_hero()
  map fn hero -> hero.name end
end
```

```elixir
# This will raise a RuntimeError with the error message:
try do
  either "invalid", as: :raise do
    bind HeroRegistry.parse_hero_id()
    bind HeroRegistry.fetch_hero()
    map fn hero -> hero.name end
  end
rescue
  e in RuntimeError -> "Caught error: #{e.message}"
end
```

## Either Functions in the DSL

The DSL supports several Either functions that work on the Either value directly.

### `filter_or_else/3`

Filter the Right value based on a predicate. For example, only allow elite heroes:

```elixir
either "1" do
  bind HeroRegistry.parse_hero_id()
  bind HeroRegistry.fetch_hero()
  filter_or_else fn hero -> hero.level >= 10 end, fn -> "Only elite heroes allowed" end
end
```

```elixir
either "2" do
  bind HeroRegistry.parse_hero_id()
  bind HeroRegistry.fetch_hero()
  filter_or_else fn hero -> hero.level >= 10 end, fn -> "Only elite heroes allowed" end
end
```

```elixir
# Hero 999 doesn't exist, so this fails at fetch
either "999" do
  bind HeroRegistry.parse_hero_id()
  bind HeroRegistry.fetch_hero()
  filter_or_else fn hero -> hero.level >= 10 end, fn -> "Only elite heroes allowed" end
end
```

### `or_else/2`

Provide a fallback if the value is Left:

```elixir
# If hero not found, use a default sidekick
either "999" do
  bind HeroRegistry.parse_hero_id()
  bind HeroRegistry.fetch_hero()
  or_else fn -> right(%{id: 0, name: "Rookie Sidekick", power: "enthusiasm", active: true, level: 1}) end
end
```

### `map_left/2`

Transform the error value in a Left:

```elixir
either "invalid" do
  bind HeroRegistry.parse_hero_id()
  map_left fn error -> "Hero registry error: #{error}" end
end
```

### `flip/1`

Swap Left and Right. This can be useful for inverting logic:

```elixir
# Flip turns success into failure
either "1" do
  bind HeroRegistry.parse_hero_id()
  flip()
end
```

```elixir
# Flip turns failure into success
either "invalid" do
  bind HeroRegistry.parse_hero_id()
  flip()
end
```

## Validation

The DSL supports validation with error accumulation using the `validate/2` function. Validators are modules that implement the `Funx.Validate.Behaviour` with the `validate/3` callback.

```elixir
# Example validator module pattern (works in compiled code):

defmodule PositiveNumber do
  @behaviour Funx.Validate.Behaviour
  use Funx.Monad.Either

  def validate(value, _opts, _env) when is_number(value) and value > 0 do
    right(value)
  end

  def validate(value, _opts, _env) when is_number(value) do
    left("Must be positive: #{value}")
  end

  def validate(value, _opts, _env) do
    left("Expected number, got: #{inspect(value)}")
  end
end

defmodule EvenNumber do
  @behaviour Funx.Validate.Behaviour
  use Funx.Monad.Either

  def validate(value, _opts, _env) when is_number(value) and rem(value, 2) == 0 do
    right(value)
  end

  def validate(value, _opts, _env) when is_number(value) do
    left("Must be even: #{value}")
  end

  def validate(value, _opts, _env) do
    left("Expected number, got: #{inspect(value)}")
  end
end

defmodule RangeValidator do
  @behaviour Funx.Validate.Behaviour
  use Funx.Monad.Either

  def validate(value, opts, _env) when is_number(value) do
    min = Keyword.get(opts, :min, 0)
    max = Keyword.get(opts, :max, 100)

    if value > min and value < max do
      right(value)
    else
      left("Must be between #{min} and #{max}: #{value}")
    end
  end

  def validate(value, _opts, _env) do
    left("Expected number, got: #{inspect(value)}")
  end
end
```

```elixir
# Usage examples (work in compiled code):

# All validations pass - use bare module names
either 4 do
  validate [PositiveNumber, EvenNumber]
end

# Multiple validations fail - errors are accumulated
either -3 do
  validate [PositiveNumber, EvenNumber]
end

# Chain validations
either 4 do
  validate [PositiveNumber, EvenNumber]
  validate {RangeValidator, min: 0, max: 100}
end

# Mix bare modules with modules that have options
either 50 do
  validate [PositiveNumber, {RangeValidator, min: 0, max: 100}]
end
```

## Input Lifting

The DSL automatically lifts various input types into the Either context:

### Plain Values

```elixir
# Plain values are wrapped in Right
either 1 do
  bind HeroRegistry.fetch_hero()
  map fn hero -> hero.name end
end
```

### Result Tuples

```elixir
# {:ok, value} becomes Right - useful when integrating with Elixir code
either {:ok, 1} do
  bind HeroRegistry.fetch_hero()
  map fn hero -> hero.name end
end
```

```elixir
# {:error, reason} becomes Left
either {:error, "Database connection failed"} do
  bind HeroRegistry.fetch_hero()
  map fn hero -> hero.name end
end
```

### Either Values

```elixir
# Either values pass through unchanged
either right(1) do
  bind HeroRegistry.fetch_hero()
  map fn hero -> hero.name end
end
```

```elixir
# Left values short-circuit immediately
either left("Session expired") do
  bind HeroRegistry.fetch_hero()
  map fn hero -> hero.name end
end
```

## Advanced: Module-Based Operations

You can create reusable operations as modules that implement specific behaviors. This is useful for operations you'll use across many pipelines:

```elixir
defmodule FormatHeroName do
  @behaviour Funx.Monad.Behaviour.Map

  def map(hero, opts, _env) do
    case Keyword.get(opts, :style, :normal) do
      :uppercase -> %{hero | name: String.upcase(hero.name)}
      :lowercase -> %{hero | name: String.downcase(hero.name)}
      :normal -> hero
    end
  end
end
```

```elixir
# Use modules in the DSL with options
either "1" do
  bind HeroRegistry.parse_hero_id()
  bind HeroRegistry.fetch_hero()
  map {FormatHeroName, style: :uppercase}
end
```

```elixir
# Without options, uses default behavior
either "1" do
  bind HeroRegistry.parse_hero_id()
  bind HeroRegistry.fetch_hero()
  map FormatHeroName
end
```

## Summary

The Either DSL provides a clean, declarative way to write error-handling pipelines:

- **`bind`** - for operations that return Either or result tuples
- **`map`** - for transformations that return plain values
- **`tap`** - for side effects without changing the value (debugging, logging)
- **Either functions** - `filter_or_else`, `or_else`, `map_left`, `flip`
- **Validation** - `validate` for accumulating multiple errors
- **Module support** - use modules with `bind`, `map`, `tap`, `map_left`, and `filter_or_else` for reusable operations
- **Options support** - pass options to modules using `{Module, opts}` syntax
- **Output formats** - `:either`, `:tuple`, or `:raise`
- **Auto-lifting** - automatic conversion of function calls to work in pipelines
- **Compile-time safety** - warnings for common mistakes

### Module Support Summary

All these operations support modules that implement `run/3`:

- **`bind Module`** - module returns Either or tuple
- **`map Module`** - module returns plain value
- **`tap Module`** - module performs side effect, returns value unchanged
- **`map_left Module`** - module transforms Left value
- **`filter_or_else Module, fallback`** - module returns boolean predicate
- **`validate [Module1, Module2]`** - modules validate and accumulate errors

Use `{Module, key: value}` syntax to pass options to any module's `run/3` function.

This makes error handling explicit, composable, and easy to reason about!
