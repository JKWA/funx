# Funx.Monad.Reader

```elixir
Mix.install([
  {:funx,
    git: "https://github.com/JKWA/funx.git",
    branch: "main"
  }
])
```

## Overview

The `Funx.Monad.Reader` module represents the Reader monad, which allows computations to access
shared, read-only environment values.

This module defines core Reader functions:

  * `pure/1` – Lifts a value into the Reader context.
  * `run/2` – Executes the Reader with a given environment.
  * `asks/1` – Extracts and transforms a value from the environment.
  * `ask/0` – Extracts the full environment.
  * `tap/2` – Executes a side-effect function on the computed value, returning the original `Reader` unchanged.

This module implements the following protocol:

  * `Funx.Monad`: Implements `bind/2`, `map/2`, and `ap/2` for monadic composition.

Note: The Reader monad does not implement `Eq` or `Ord`, since Readers are lazy— they do not actually contain a value until they are run. We only can compare the results of a Reader, not the Reader itself.

## Function Examples

```elixir
import Funx.Monad.Reader
alias Funx.Monad.Reader
```

## Functions

### pure/1

Lifts a value into the `Reader` context.

#### Examples

```elixir
reader = pure(42)
run(reader, %{})
```

### run/2

Runs the `Reader` with the provided environment, returning the computed value.

#### Examples

```elixir
reader = pure(42)
run(reader, %{})
```

### asks/1

Extracts and transforms the value contained in the environment, making it available within the Reader context.

#### Examples

```elixir
reader = asks(fn env -> Map.get(env, :foo) end)
run(reader, %{foo: "bar"})
```

### ask/0

Extracts the value contained in the environment, making it available within the Reader context.

#### Examples

```elixir
reader = ask()
run(reader, %{foo: "bar"})
```

### tap/2

Executes a side-effect function on the computed value and returns the original `Reader` unchanged.
The side effect is **deferred** - it executes when the Reader is run, not when `tap` is called.

Useful for debugging, logging, or performing side effects based on environment data.

#### Examples

```elixir
# Side effect on computed value (deferred until run)
reader =
  pure(42)
  |> Reader.tap(&IO.inspect(&1, label: "value"))

run(reader, %{})
```

```elixir
# With environment access
reader =
  asks(&Map.get(&1, :user_id))
  |> Reader.tap(fn id -> IO.puts("Processing user: #{id}") end)

run(reader, %{user_id: 123})
```