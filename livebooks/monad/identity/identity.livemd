# Funx.Monad.Identity

```elixir
Mix.install([
  {:funx, "0.6.0"}
])
```

## Overview

The `Funx.Monad.Identity` module represents the identity monad, where values are simply wrapped in a structure
and operations are applied directly to those values.

## Functions

  - `pure/1`: Wraps a value in the `Identity` monad.
  - `extract/1`: Extracts the wrapped value from an `Identity`.
  - `tap/2`: Executes a side-effect function on the wrapped value, returning the original `Identity` unchanged.

## Protocols

This module implements the following protocols:
  - `Funx.Monad`: Implements the `bind/2`, `map/2`, and `ap/2` functions for monadic operations.
  - `Funx.Eq`: Defines equality checks for `Identity` values.
  - `Funx.Ord`: Defines ordering logic for `Identity` values.
  - `String.Chars`: Converts an `Identity` value into a string representation.

## Function Examples

```elixir
import Funx.Monad.Identity
alias Funx.Monad.Identity
alias Funx.Tappable
```

### pure/1

Creates a new `Identity` value by wrapping a given value.

```elixir
pure(5)
```

### extract/1

Extracts the value from an `Identity`.

```elixir
extract(pure(5))
```

### tap/2

Executes a side-effect function on the wrapped value and returns the original `Identity` unchanged.

Useful for debugging, logging, or performing side effects without changing the value.

```elixir
# Side effect on wrapped value
pure(42)
|> Tappable.tap(&IO.inspect(&1, label: "debug"))
```

```elixir
# In a pipeline
pure(5)
|> Funx.Monad.map(&(&1 * 2))
|> Tappable.tap(&IO.inspect(&1, label: "after map"))
|> Funx.Monad.map(&(&1 + 1))
```

### Using Monad Protocol

The `Identity` monad implements the `Funx.Monad` protocol:

#### map/2

```elixir
pure(5)
|> Funx.Monad.map(&(&1 * 2))
```

#### bind/2

```elixir
pure(5)
|> Funx.Monad.bind(fn x -> pure(x + 10) end)
```

#### ap/2

```elixir
func = pure(&(&1 * 3))
value = pure(7)
Funx.Monad.ap(func, value)
```

### Using Eq Protocol

The `Identity` monad implements the `Funx.Eq` protocol:

```elixir
Funx.Eq.eq?(pure(5), pure(5))
```

```elixir
Funx.Eq.eq?(pure(5), pure(10))
```

```elixir
Funx.Eq.not_eq?(pure(5), pure(10))
```

### Using Ord Protocol

The `Identity` monad implements the `Funx.Ord` protocol:

```elixir
Funx.Ord.lt?(pure(3), pure(5))
```

```elixir
Funx.Ord.le?(pure(5), pure(5))
```

```elixir
Funx.Ord.gt?(pure(10), pure(3))
```

```elixir
Funx.Ord.ge?(pure(5), pure(5))
```

### String Representation

The `Identity` monad implements `String.Chars`:

```elixir
pure(42) |> to_string()
```

### Lifting Functions

#### lift_eq/1

```elixir
custom_eq = %{
  eq?: fn x, y -> x == y end,
  not_eq?: fn x, y -> x != y end
}
```

```elixir
lifted_eq = lift_eq(custom_eq)
```

```elixir
lifted_eq.eq?.(pure(5), pure(5))
```

#### lift_ord/1

```elixir
custom_ord = %{
  lt?: fn x, y -> x < y end,
  le?: fn x, y -> x <= y end,
  gt?: fn x, y -> x > y end,
  ge?: fn x, y -> x >= y end
}
```

```elixir
lifted_ord = lift_ord(custom_ord)
```

```elixir
lifted_ord.lt?.(pure(3), pure(5))
```