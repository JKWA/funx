# Ord DSL - Interactive Examples

```elixir
Mix.install([
  {:funx, github: "JKWA/funx", ref: "8b54182"}
])
```

## Setup

```elixir
use Funx.Ord.Dsl

alias Funx.Monad.Maybe
alias Funx.Optics.{Lens, Prism}
alias Funx.Ord.Utils
```

```elixir
alias Funx.Optics.Prism
require Logger
use Funx.Monad.Maybe

defmodule CreditCard do
  defstruct [:name, :number, :expiry, :amount]
  alias Funx.Optics.Prism

  def amount_prism do
    Prism.path([{__MODULE__, :amount}])
  end
end

defmodule Check do
  defstruct [:name, :routing_number, :account_number, :amount]
  alias Funx.Optics.Prism

  def amount_prism do
    Prism.path([{__MODULE__, :amount}])
  end
end

defmodule Charge do
  defstruct [:payment]
  alias Funx.Optics.Prism

  def payment_prism do
    Prism.path([{__MODULE__, :payment}])
  end
end

defmodule Refund do
  defstruct [:payment]
  alias Funx.Optics.Prism

  def payment_prism do
    Prism.path([{__MODULE__, :payment}])
  end
end

defmodule Transaction do
  defstruct [:type]
  alias Funx.Optics.Prism

  def type_prism do
    Prism.path([{__MODULE__, :type}])
  end
end
```

```elixir
defmodule Processor do
  def cc_payment_prism do
    Prism.compose([
      Transaction.type_prism,
      Charge.payment_prism,
      CreditCard.amount_prism
    ])
  end

  def check_payment_prism do
    Prism.compose([
      Transaction.type_prism,
      Charge.payment_prism,
      Check.amount_prism
    ])
  end

  def cc_refund_prism do
    Prism.compose([
      Transaction.type_prism,
      Refund.payment_prism,
      CreditCard.amount_prism
    ])
  end

  def check_refund_prism do
    Prism.compose([
      Transaction.type_prism,
      Refund.payment_prism,
      Check.amount_prism
    ])
  end
end
```

```elixir
charge_cc_1 =
  %Transaction{
    type: %Charge{
      payment: %CreditCard{name: "Alice", number: "4111", expiry: "12/26", amount: 1592}
    }
  }

charge_cc_2 =
  %Transaction{
    type: %Charge{
      payment: %CreditCard{name: "Bob", number: "4222", expiry: "11/25", amount: 823}
    }
  }

charge_cc_3 =
  %Transaction{
    type: %Charge{
      payment: %CreditCard{name: "Dave", number: "4444", expiry: "09/26", amount: 191}
    }
  }

refund_cc_1 =
  %Transaction{
    type: %Refund{
      payment: %CreditCard{name: "Carol", number: "4333", expiry: "10/27", amount: 161}
    }
  }

refund_cc_2 =
  %Transaction{
    type: %Refund{
      payment: %CreditCard{name: "Eve", number: "4555", expiry: "08/28", amount: 110}
    }
  }

transactions = [charge_cc_1, charge_cc_2, charge_cc_3, refund_cc_1, refund_cc_2]
```

```elixir
ord_by =
  ord do
    asc &/Processor.cc_payment_prism/0
  end

Enum.sort(transactions, Utils.comparator(ord_by))
```

## Domain Models

Let's define some domain models to work with:

```elixir
defmodule Person do
  defstruct [:name, :age, :score, :email, :bio]
end

defmodule Address do
  defstruct [:street, :city, :state, :zip]
end

defmodule Employee do
  defstruct [:name, :department, :salary, :start_date]
end
```

## Basic Sorting

### Single Field - Ascending

```elixir
people = [
  %Person{name: "Charlie", age: 30},
  %Person{name: "Alice", age: 25},
  %Person{name: "Bob", age: 35}
]

ord_by_name =
  ord do
    asc :name
  end

Enum.sort(people, Utils.comparator(ord_by_name))
```

### Single Field - Descending

```elixir
ord_by_age_desc =
  ord do
    desc :age
  end

Enum.sort(people, Utils.comparator(ord_by_age_desc))
```

### Multi-Field with Tie-Breaking

```elixir
people_complex = [
  %Person{name: "Alice", age: 30, score: 100},
  %Person{name: "Alice", age: 25, score: 90},
  %Person{name: "Bob", age: 30, score: 85},
  %Person{name: "Charlie", age: 30, score: 95}
]

ord_name_then_age =
  ord do
    asc :name
    desc :age
  end

Enum.sort(people_complex, Utils.comparator(ord_name_then_age))
```

## Optional Fields with Defaults

Handle nil values gracefully using the `default:` option:

```elixir
people_with_scores = [
  %Person{name: "Alice", score: 100},
  %Person{name: "Bob", score: nil},
  %Person{name: "Charlie", score: 50},
  %Person{name: "Diana", score: nil}
]

ord_score_with_default =
  ord do
    asc(:score, default: 0)
    asc :name
  end

Enum.sort(people_with_scores, Utils.comparator(ord_score_with_default))
```

## Function Projections

### Anonymous Functions

```elixir
people_with_bios = [
  %Person{name: "Alice", bio: "Software engineer with 10 years experience"},
  %Person{name: "Bob", bio: "Developer"},
  %Person{name: "Charlie", bio: "Senior architect"}
]

ord_by_bio_length =
  ord do
    asc &String.length(&1.bio)
  end

Enum.sort(people_with_bios, Utils.comparator(ord_by_bio_length))
```

### Captured Functions

```elixir
words = ["elephant", "cat", "dog", "butterfly"]

ord_by_length =
  ord do
    asc &String.length/1
    asc &(&1)
  end

Enum.sort(words, Utils.comparator(ord_by_length))
```

### Complex Transformations

```elixir
ord_by_name_length =
  ord do
    desc &String.length(&1.name)
    asc :name
  end

Enum.sort(people, Utils.comparator(ord_by_name_length))
```

## Bare Prisms with Maybe.lift_ord

Bare Prisms return `Maybe` values. With `Maybe.lift_ord`, `Nothing` sorts before `Just`:

```elixir
people_optional = [
  %Person{name: "Alice", score: 100},
  %Person{name: "Bob", score: nil},
  %Person{name: "Charlie", score: 50},
  %Person{name: "Diana", score: nil}
]

ord_bare_prism =
  ord do
    asc Prism.key(:score)
    asc :name
  end

result = Enum.sort(people_optional, Utils.comparator(ord_bare_prism))

IO.puts("With bare Prism (Nothing < Just):")
Enum.each(result, fn p -> IO.puts("  #{p.name}: #{inspect(p.score)}") end)

result
```

Compare with default behavior:

```elixir
ord_with_default =
  ord do
    asc(:score, default: 0)
    asc :name
  end

result_default = Enum.sort(people_optional, Utils.comparator(ord_with_default))

IO.puts("\nWith default value:")
Enum.each(result_default, fn p -> IO.puts("  #{p.name}: #{inspect(p.score)}") end)

result_default
```

## Nested Data with Lenses

```elixir
defmodule PersonWithAddress do
  defstruct [:name, :address]
end
```

```elixir
people_with_addresses = [
  %PersonWithAddress{
    name: "Alice",
    address: %Address{city: "Austin", state: "TX", zip: "78701"}
  },
  %PersonWithAddress{
    name: "Bob",
    address: %Address{city: "Boston", state: "MA", zip: "02101"}
  },
  %PersonWithAddress{
    name: "Charlie",
    address: %Address{city: "Chicago", state: "IL", zip: "60601"}
  }
]

ord_by_city =
  ord do
    asc(Lens.path([:address, :city]))
  end

Enum.sort(people_with_addresses, Utils.comparator(ord_by_city))
```

### Sort by State, then City

```elixir
ord_state_city =
  ord do
    asc(Lens.path([:address, :state]))
    asc(Lens.path([:address, :city]))
  end

Enum.sort(people_with_addresses, Utils.comparator(ord_state_city))
```

## Custom Ord Protocol

Define custom ordering logic for your types:

```elixir
defimpl Funx.Ord, for: Address do
  # Sort by state, then city
  def lt?(a, b), do: {a.state, a.city} < {b.state, b.city}
  def le?(a, b), do: {a.state, a.city} <= {b.state, b.city}
  def gt?(a, b), do: {a.state, a.city} > {b.state, b.city}
  def ge?(a, b), do: {a.state, a.city} >= {b.state, b.city}
end

ord_by_address =
  ord do
    asc :address
  end

Enum.sort(people_with_addresses, Utils.comparator(ord_by_address))
```

## Custom Behaviour Projections

Create reusable projection logic:

```elixir
defmodule NameLength do
  @behaviour Funx.Ord.Dsl.Behaviour

  @impl true
  def project(person, _opts) do
    String.length(person.name)
  end
end
```

```elixir
ord_name_length =
  ord do
    asc NameLength
  end

Enum.sort(people, Utils.comparator(ord_name_length))
```

### Behaviour with Options

```elixir
defmodule WeightedScore do
  @behaviour Funx.Ord.Dsl.Behaviour

  @impl true
  def project(person, opts) do
    weight = Keyword.get(opts, :weight, 1.0)
    (person.score || 0) * weight
  end
end
```

```elixir
people_for_weighted = [
  %Person{name: "Alice", score: 100},
  %Person{name: "Bob", score: 50},
  %Person{name: "Charlie", score: 75}
]

ord_weighted =
  ord do
    desc WeightedScore, weight: 2.0
    asc :name
  end

Enum.sort(people_for_weighted, Utils.comparator(ord_weighted))
```

## Complex Real-World Example

Employee sorting with multiple criteria:

```elixir
employees = [
  %Employee{name: "Alice", department: "Engineering", salary: 120000, start_date: ~D[2020-01-15]},
  %Employee{name: "Bob", department: "Engineering", salary: 110000, start_date: ~D[2021-03-20]},
  %Employee{name: "Charlie", department: "Sales", salary: 95000, start_date: ~D[2019-06-01]},
  %Employee{name: "Diana", department: "Engineering", salary: 125000, start_date: ~D[2018-09-10]},
  %Employee{name: "Eve", department: "Sales", salary: 105000, start_date: ~D[2020-11-05]}
]

ord_employees =
  ord do
    asc :department
    desc :salary
    asc :start_date
  end

Enum.sort(employees, Utils.comparator(ord_employees))
```

## Playground

Try your own examples here!

```elixir
# Define your data
my_people = [
  %Person{name: "Zara", age: 28, score: 85},
  %Person{name: "Alex", age: 32, score: 90},
  %Person{name: "Morgan", age: 28, score: nil}
]

# Define your ordering
my_ord =
  ord do
    # Try different combinations!
    asc :age
    desc :score, default: 0
    asc :name
  end

Enum.sort(my_people, Utils.comparator(my_ord))
```

## Performance Note

The Ord DSL compiles to efficient code at compile-time. Here's what gets generated:

```elixir
# This DSL code:
ord do
  asc :name
  desc :age
end

# Compiles to (approximately):
# Utils.concat([
#   Utils.contramap(fn x -> Lens.view!(x, Lens.key(:name)) end, Funx.Ord),
#   Utils.reverse(Utils.contramap(fn x -> Lens.view!(x, Lens.key(:age)) end, Funx.Ord))
# ])
```

No runtime overhead from the DSL itself!

## Comparison Functions

```elixir
alice = %Person{name: "Alice", age: 30}
bob = %Person{name: "Bob", age: 25}

ord = ord(do: asc :age)

Utils.compare(alice, bob, ord)
```

```elixir
Utils.min(alice, bob, ord)
```

```elixir
Utils.max(alice, bob, ord)
```

## Finding Min/Max in Lists

```elixir
ord_by_score = ord(do: desc(:score, default: 0))

people_scores = [
  %Person{name: "Alice", score: 85},
  %Person{name: "Bob", score: 92},
  %Person{name: "Charlie", score: 78},
  %Person{name: "Diana", score: 95}
]

# Highest score (max with desc ordering)
Utils.max(people_scores, ord_by_score)
```

```elixir
# Lowest score (min with desc ordering)
Utils.min(people_scores, ord_by_score)
```
