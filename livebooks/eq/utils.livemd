# Funx.Eq.Utils

```elixir
Mix.install([
  {:funx,
    git: "https://github.com/JKWA/funx.git",
    branch: "main"
  }
])
```

Utility functions for working with the `Funx.Eq` protocol.
These functions assume that types passed in either support Elixir's equality operator
or implement the `Funx.Eq` protocol.

## Function Examples

```elixir
import Funx.Eq.Utils
```

## contramap/2

Transforms an equality check by applying a function `f` to values before comparison.

The `eq` parameter can be an `Eq` module or a custom comparator map with an `:eq?` function.
If an `Eq` module is provided, it wraps the module's function to apply `f` to each value before invoking the equality check.
If a custom comparator map is provided, it wraps the function in the map to apply `f` to each value.

### Examples

```elixir
eq = contramap(& &1.age)
eq.eq?.(%{age: 30}, %{age: 30})
```

```elixir
eq = contramap(& &1.age)
eq.eq?.(%{age: 30}, %{age: 25})
```

## eq_by?/4

Checks equality of values by applying a projection function, using a specified or default `Eq`.

The `eq` parameter can be an `Eq` module or a custom comparator map with an `:eq?` function.

### Examples

```elixir
eq_by?(& &1.age, %{age: 30}, %{age: 30})
```

```elixir
eq_by?(& &1.age, %{age: 30}, %{age: 25})
```

## eq?/3

Returns true if two values are equal, using a specified or default `Eq`.

### Examples

```elixir
eq?(42, 42)
```

```elixir
eq?("foo", "bar")
```

## not_eq?/3

Returns false if two values are not equal, using a specified or default `Eq`.

### Examples

```elixir
not_eq?(42, 99)
```

```elixir
not_eq?("foo", "foo")
```

## append_all/2

Combines two equality comparators using the `Eq.All` monoid.

This function merges two equality comparisons, requiring **both** to return `true`
for the final result to be considered equal. This enforces a **strict** equality rule,
where all comparators must agree.

### Examples

```elixir
eq1 = contramap(& &1.name)
eq2 = contramap(& &1.age)
combined = append_all(eq1, eq2)
eq?(%{name: "Alice", age: 30}, %{name: "Alice", age: 30}, combined)
```

```elixir
eq1 = contramap(& &1.name)
eq2 = contramap(& &1.age)
combined = append_all(eq1, eq2)
eq?(%{name: "Alice", age: 30}, %{name: "Alice", age: 25}, combined)
```

## append_any/2

Combines two equality comparators using the `Eq.Any` monoid.

This function merges two equality comparisons, where **at least one**
must return `true` for the final result to be considered equal.

### Examples

```elixir
eq1 = contramap(& &1.name)
eq2 = contramap(& &1.age)
combined = append_any(eq1, eq2)
eq?(%{name: "Alice", age: 30}, %{name: "Alice", age: 25}, combined)
```

```elixir
eq1 = contramap(& &1.name)
eq2 = contramap(& &1.age)
combined = append_any(eq1, eq2)
eq?(%{name: "Alice", age: 30}, %{name: "Bob", age: 25}, combined)
```

## concat_all/1

Concatenates a list of equality comparators using the `Eq.All` monoid.

The resulting comparator requires **all** comparators in the list to agree
that two values are equal.

### Examples

```elixir
eq1 = contramap(& &1.name)
eq2 = contramap(& &1.age)
combined = concat_all([eq1, eq2])
eq?(%{name: "Alice", age: 30}, %{name: "Alice", age: 30}, combined)
```

```elixir
eq1 = contramap(& &1.name)
eq2 = contramap(& &1.age)
combined = concat_all([eq1, eq2])
eq?(%{name: "Alice", age: 30}, %{name: "Alice", age: 25}, combined)
```

## concat_any/1

Concatenates a list of equality comparators using the `Eq.Any` monoid.

The resulting comparator allows **any** comparator in the list to determine
equality, making it more permissive.

### Examples

```elixir
eq1 = contramap(& &1.name)
eq2 = contramap(& &1.age)
combined = concat_any([eq1, eq2])
eq?(%{name: "Alice", age: 30}, %{name: "Alice", age: 25}, combined)
```

```elixir
eq1 = contramap(& &1.name)
eq2 = contramap(& &1.age)
combined = concat_any([eq1, eq2])
eq?(%{name: "Alice", age: 30}, %{name: "Bob", age: 25}, combined)
```

## to_predicate/2

Converts an `Eq` comparator into a single-argument predicate function for use in `Enum` functions.

The resulting predicate takes a single element and returns `true` if it matches the `target`
based on the specified `Eq`. If no custom `Eq` is provided, it defaults to `Funx.Eq`.

### Examples

```elixir
eq = contramap(& &1.name)
predicate = to_predicate(%{name: "Alice"}, eq)
Funx.Filterable.filter([%{name: "Alice"}, %{name: "Bob"}], predicate)
```