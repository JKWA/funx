# Funx.Optics.Lens

## Section

```elixir
Mix.install([
  {:funx, github: "JKWA/funx", ref: "bbde4c4", force: true}
])
```

## Reason

If you read through technical papers on lensing, they explain why it is "interesting", but they don't make a case for why we might want to adopt it.

But there are lots of blog posts out there which do try to make the case for why we might want to bring lensing into our code.

### It's tedious

A typical argument for lensing is that manipulating nested data is difficult.

* [Manipulating fields can be tedious.](https://richashworth.com/blog/functional-patterns-in-scala-lenses)

* [Nested data structures are a pain to inspect and change.](https://rockthejvm.com/articles/lenses-prisms-and-optics-in-scala)

* [They can reduce the amount of code we have to write significantly.](https://medium.com/@gcanti/introduction-to-optics-lenses-and-prisms-3230e73bfcfe)

Note, this is certainly true in Scala, but it would be hard to say lensing in Elixir is hard.

* [Lens only exists because the native type system makes that work too hard.](https://elixirforum.com/t/the-complexity-of-haskell-vs-elixirs-simplicity/16366)

And even Haskell devs are not so sure.

* [More trouble than they’re worth.](https://reasonablypolymorphic.com/blog/code-lenses/)

### Composability

Another pitch is that lenses are composable.

* [What makes lenses useful, however, is the fact that they can be composed!](https://medium.com/@heytherewill/functional-programming-optics-in-net-7e1998bfb47e)

But although Lenses are composable, so typically are any sort of projection functions, making it hard to say we should bother.

### Helpful For Hard Problems

Or, yes, they can be a pain, but they are helpful for some specific problems:

* [Optics as proxies.](https://medium.com/%40wigahluk/another-look-through-optics-ffd253336e9c)

Yes, but this suggests you only reach for lensing when you really really need it.

Honestly, these are just incidental "nice to have" arguments, not the real reason you want lensing.

The purpose of lensing isn't convenience, it's legality.

## Elixir's built-in path accessors

Elixir provides `get_in/2`, `put_in/3`, and `update_in/3` which operate on paths - lists like `[:owner, :name]` that describe how to navigate into a structure.

Let’s start with some data:

```elixir
garfield = %{
  name: "Garfield",
  weight: 20,
  owner: %{
    name: "Jon"
  }
}
```

Here is the path into the owner's name:

```elixir
path = [:owner, :name]
```

We can read through the path:

```elixir
get_in(garfield, path)
```

We can write through the path:

```elixir
put_in(garfield, path, "Jonathon")
```

And we can update through the path:

```elixir
update_in(garfield, path, fn name -> String.upcase(name) end)
```

Now let's consider an invalid path:

```elixir
invalid_path = [:owner, :age]
```

If we read:

```elixir
get_in(garfield, invalid_path)
```

We get an ambiguous `nil`. It could mean the `:owner` key is missing or the `:age` key is missing. It could mean both keys exist and the value is `nil`.

When we write:

```elixir
put_in(garfield, invalid_path, 40)
```

This succeeds. Even though the path does not actually point to a valid location in the original structure, Elixir treats the write as a create and silently changes the shape of the data.

And when we update:

```elixir
update_in(garfield, invalid_path, fn curr -> curr + 1 end)
```

Here the fallback breaks down completely, because `curr` is `nil` and the function crashes with an `ArithmeticError`.

At this point the same path has produced three different behaviors depending on which operation you chose: read returns `nil`, write creates new structure, update crashes.

This is convenient, but is not a lawful lens.

## Lawful Lenses: Symmetric, Explicit Contracts

A lens is a contract that guarantees symmetric behavior: if you can read through it, you can write through it, and vice versa. All operations make the same assumptions about the focus. No fallbacks, no auto-creation, no surprises.

Funx provides lawful lenses.

```elixir
import Funx.Optics.Lens
alias Funx.Optics.Lens
```

First, we can use the `path/1` to lift our valid path:

```elixir
valid_lens = Lens.path(path)
```

We *view* to read:

```elixir
Lens.view!(garfield, valid_lens)
```

*Set* to write:

```elixir
Lens.set!(garfield, valid_lens, "Jonathon")
```

And *over* to update:

```elixir
Lens.over!(garfield, valid_lens, fn name -> String.upcase(name) end)
```

Elixir doesn't have a type system to prove whether a lens is valid, so we need two paths. In these cases we have "success" or "raise an error".

Let's start with an invalid path:

```elixir
invalid_lens = Lens.path(invalid_path)
```

Now, like Elixir's `update_in/3` accessor, our update raises an error:

```elixir
Lens.over!(garfield, invalid_lens, fn curr -> curr + 1 end)
```

But instead of an arithmetic error, we get a key error. The lens doesn't apply a function to an invalid focus.

Lets write to an invalid focus:

```elixir
Lens.set!(garfield, invalid_lens, "Jonathon")
```

Again, we get a key error. We cannot write to an invalid focus.

And even if we view:

```elixir
Lens.view!(garfield, invalid_lens)
```

We get a key error.

### Summary

If the focus is valid, you can read it, write it, and update it. If not valid, all operations fail explicitly. There is no fallback, no auto-creation, and no silent fixing.

This is what makes composition safe and refactoring predictable. Behavior depends only on the lens itself, not the runtime shape of the data. Everything makes the same assumptions, and errors stop exactly where an assumption breaks instead of being “cured” into a different, harder-to-find bug downstream.

And now that we have a lawful lens, we can do something Elixir's built-in accessors cannot: lens into structs.

## Structs: A Critical Differentiator

Elixir's `get_in/put_in/update_in` fail on structs entirely, even for valid paths. This is a major limitation since structs are the primary way to model domain data in Elixir.

```elixir
defmodule Owner do
  defstruct [:name]
end

defmodule Cat do
  defstruct [:name, :owner, :weight]
end
```

```elixir
granny = %Owner{name: "Granny"}
sylvester = %Cat{name: "Sylvester", owner: granny, weight: 15}
```

Elixir's accessor cannot lens a struct, even if it is a valid focus:

```elixir
get_in(sylvester, path)
```

But Funx can:

```elixir
Lens.view!(sylvester, valid_lens)
```

```elixir
Lens.set!(sylvester, valid_lens, "Gramps")
```

```elixir
Lens.over!(sylvester, valid_lens, fn name -> String.upcase(name) end)
```

In a legal Lens, an invalid focus will always fail:

```elixir
Lens.view!(sylvester, invalid_lens)
```

```elixir
Lens.set!(sylvester, invalid_lens, "Jonathon")
```

```elixir
Lens.over!(sylvester, invalid_lens, fn name -> String.upcase(name) end)
```

But we don't always have to raise an error, we can return both paths:

```elixir
Lens.over(sylvester, invalid_lens, fn name -> String.upcase(name) end)
```

Our safe read, set, and over functions return Funx's Either.

But we can elect to use Elixir's tuple:

```elixir
Lens.view(sylvester, invalid_lens, as: :tuple)
```

Now we get the typical `{:ok, value}` or `{:error, reason}` tuple.

## Funx.Optics.Lens,

Funx provides lawful lenses that:

* Package viewer and updater logic together
* Enforce symmetric contracts (read and write have same requirements)
* Work uniformly on both maps and structs

A symmetric contract means we can avoid common bugs:

With Elixir's `put_in/3` we get:

```elixir
put_in(garfield, [:owner, :nane], "Dave")
```

A bug.

But with a Lens we get:

```elixir
Lens.set!(sylvester, Lens.path([:owner, :nane]), "Dave")
```

A clear error


## Setup: Superhero Data

We’ll use a superhero domain where some updates must stay in sync.

```elixir
defmodule Powers do
  defstruct [:strength, :speed, :intelligence]

  def total(%Powers{} = p), do: p.strength + p.speed + p.intelligence
end

defmodule Hero do
  defstruct [:name, :alias, :powers]
end

defmodule Headquarters do
  @cities %{
    "New York" => {40.7128, -74.0060},
    "Los Angeles" => {34.0522, -118.2437},
    "San Francisco" => {37.7749, -122.4194}
  }

  defstruct [:city, :latitude, :longitude]

  def relocate(city) when is_map_key(@cities, city) do
    {lat, lon} = Map.fetch!(@cities, city)
    %Headquarters{city: city, latitude: lat, longitude: lon}
  end
end

defmodule Team do
  defstruct [:name, :leader, :base, :founded]
end
```

```elixir
iron_man = %Hero{
  name: "Tony Stark",
  alias: "Iron Man",
  powers: %Powers{
    strength: 85,
    speed: 70,
    intelligence: 100
  }
}

avengers = %Team{
  name: "Avengers",
  leader: %Hero{
    name: "Steve Rogers",
    alias: "Captain America",
    powers: %Powers{
      strength: 90,
      speed: 75,
      intelligence: 80
    }
  },
  base: %Headquarters{
    city: "New York",
    latitude: 40.7128,
    longitude: -74.0060
  },
  founded: 1963
}
```

## Basic Operations

Lenses give you three operations that work uniformly across any field.

```elixir
Lens.view!(iron_man, Lens.key(:name))
```

```elixir
Lens.set!(iron_man, Lens.key(:alias), "The Invincible Iron Man")
```

```elixir
Lens.over!(avengers, Lens.key(:founded), fn year -> year + 1 end)
```

Much cleaner, and predictable - both operations make the same promise about the focus.

## Composition: Reaching Through Layers

Now that we can view, set, and transform individual fields, the next step is composition.

```elixir
leader_lens = Lens.key(:leader)
leader_alias_lens = Lens.compose(leader_lens, Lens.key(:alias))
```

```elixir
avengers
|> Lens.set!(leader_alias_lens, "Cap")
```

Let's make lenses for the leader's powers:

```elixir
powers_lens = Lens.key(:powers)
strength_lens = Lens.compose(powers_lens, Lens.key(:strength))
speed_lens = Lens.compose(powers_lens, Lens.key(:speed))
intelligence_lens = Lens.compose(powers_lens, Lens.key(:intelligence))
```

We can add 100 points to our leader's strength with `over/3`:

```elixir
avengers
|> Lens.over!(
  Lens.compose(leader_lens, strength_lens),
  fn s -> s + 100 end
)
```

Sometimes it's easier to use the `path/1` shorthand:

```elixir

avengers
|> Lens.set!(Lens.path([:leader, :powers, :intelligence]), 195)
|> Lens.view!(Lens.path([:leader, :powers]))
```

Composition scales to arbitrary depth while preserving lawfulness. Whether you use `compose/2` explicitly or `path/1` as shorthand, every lens maintains the same contract: symmetric, total, and type-preserving.

But so far, every lens we've built performs simple structural access. The real power emerges when updates must enforce domain invariants.

## Advanced Lenses

So far we’ve used the `key/1` and `path/1` constructors. Behind the scenes, both are thin wrappers over `make/2` that generate simple structural lenses.

But not every update is a simple structural write.

What happens when a single logical change must update multiple fields together?

Let’s start by defining some basic lenses:

```elixir
base_lens = Lens.key(:base)
city_lens = Lens.compose(base_lens, Lens.key(:city))
```

With this lens, we can change the city:

```elixir
avengers 
|> Lens.set!(city_lens, "Los Angeles") 
|> Lens.view!(base_lens)
```

Structurally, this works. But semantically it is wrong. The city is updated, while the latitude and longitude still point to New York. We have violated a domain invariant with a perfectly legal structural operation.

This is exactly the boundary where `make/2` becomes necessary.

We need a lens whose *focus is still the city*, but whose *update rewrites the entire base atomically*.

```elixir
relocate_lens =
Lens.make(
  fn team ->
    Lens.view!(team, city_lens)
  end,
  fn team, new_city ->
    Lens.set!(team, base_lens, Headquarters.relocate(new_city))
  end
)
```

`make/2` is the core of a lens. It binds two directions:

• how the focus is read
• how the structure is rebuilt when the focus changes

Both sides must agree on the same logical value. Here, that value is the city.

Now relocation is a single lawful operation:

```elixir
avengers
|> Lens.set!(relocate_lens, "Los Angeles")
```

The base, including city, latitude, and longitude, is updated as one atomic rewrite.

Because this is still a lens, it composes like any other:

```elixir
avengers
|> Lens.set!(relocate_lens, "San Francisco")
|> Lens.set!(Lens.key(:name), "West Coast Avengers")
```

At this point, coordinated multi-field updates behave exactly like simple field updates. The difference is not at the call site. The difference is that the invariant is now enforced by construction.

Custom lenses turn coordinated rewrites into single, lawful operations.

### Derived Values as Fields

Not every field we care about is explicitly stored. Some values are *derived* from multiple fields but still behave like a single domain concept.

Here, a hero’s effective power is derived from three fields: `strength`, `speed`, and `intelligence`. We want to observe that value as a single focus before we decide how it should be rewritten.

```elixir
power_level = fn powers ->
  Lens.view!(powers, strength_lens) +
  Lens.view!(powers, speed_lens) +
  Lens.view!(powers, intelligence_lens)
end
```

This function is read-only. It defines how the derived value is computed from the underlying structure, but it has no authority to rewrite anything.

Next, we define the inverse operation: how a new derived value is *redistributed* back into concrete fields as a coordinated rewrite.

```elixir
rebalance = fn level ->
  avg = div(level, 3)
  rem = rem(level, 3)

  %Powers{}
  |> Lens.set!(Lens.key(:strength), avg + rem)
  |> Lens.set!(Lens.key(:speed), avg)
  |> Lens.set!(Lens.key(:intelligence), avg)
end
```

This function never reads from the structure. It only describes how a new derived value is projected back into concrete fields.

Now we bind those two directions into a *single lawful focus* using `make/2`.

```elixir
power_level_lens =
  Lens.make(
    fn hero -> power_level.(hero)
    end,
    fn hero, new_level ->
      Lens.set!(
        hero,
        powers_lens,
        rebalance.(new_level)
      )
    end
  )
```

This lens now behaves exactly like a real field:

• the viewer derives a value
• the setter performs a coordinated multi-field rewrite
• both sides agree on the same logical focus

We can read it:

```elixir
Lens.view!(iron_man, power_level_lens)
```

And we can update it:

```elixir
iron_man
|> Lens.set!(power_level_lens, 50)
|> Lens.view!(power_level_lens)
```

From the call site, there is no distinction between this derived value and a stored field. The difference is not in how it is used. The difference is that the lens enforces a coordinated rewrite instead of a simple assignment.

```elixir
:cat
|> Lens.set!(power_level_lens, 50)
```

Derived values now compose and fail exactly like every other lawful focus.

