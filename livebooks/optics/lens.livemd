# Funx.Optics.Lens

```elixir
Mix.install([
  {:funx, github: "JKWA/funx", ref: "bbde4c4", force: true}
])
```

## Reason

If you read through technical papers on lensing, they explain why it is "interesting", but they don't make a case for why we might want to adopt it.

But there are lots of blog posts out there which do try to make the case for why we might want to bring lensing into our code.

### It's tedious

A typical argument for lensing is that manipulating nested data is difficult.

* [Manipulating fields can be tedious.](https://richashworth.com/blog/functional-patterns-in-scala-lenses)

* [Nested data structures are a pain to inspect and change.](https://rockthejvm.com/articles/lenses-prisms-and-optics-in-scala)

* [They can reduce the amount of code we have to write significantly.](https://medium.com/@gcanti/introduction-to-optics-lenses-and-prisms-3230e73bfcfe)

Note, this is certainly true in Scala, but it would be hard to say lensing in Elixir is hard.

* [Lens only exists because the native type system makes that work too hard.](https://elixirforum.com/t/the-complexity-of-haskell-vs-elixirs-simplicity/16366)

And even Haskell devs are not so sure.

* [More trouble than they’re worth.](https://reasonablypolymorphic.com/blog/code-lenses/)

### Composability

Another pitch is that lenses are composable.

* [What makes lenses useful, however, is the fact that they can be composed!](https://medium.com/@heytherewill/functional-programming-optics-in-net-7e1998bfb47e)

But composability isn't unique to lenses. Projection functions compose just as well, so this alone doesn't justify adoption.

### Helpful For Hard Problems

Or, yes, they can be a pain, but they are helpful for some specific problems:

* [Optics as proxies.](https://medium.com/%40wigahluk/another-look-through-optics-ffd253336e9c)

Yes, but this suggests you only reach for lensing when you really really need it.

Honestly, these are just incidental "nice to have" arguments, not the real reason you want lensing.

The purpose of lensing isn't convenience, it's legality.

## Elixir's Built-in Accessors

Elixir provides `get_in/2`, `put_in/3`, and `update_in/3` which operate on paths - lists like `[:owner, :name]` that describe how to navigate into a structure.

First, we'll start with some data:

```elixir
garfield = %{
  name: "Garfield",
  weight: 20,
  owner: %{
    name: "Jon"
  }
}
```

Here is the path into the owner's name:

```elixir
valid_path = [:owner, :name]
```

We can read through the path:

```elixir
get_in(garfield, valid_path)
```

We can write through the path:

```elixir
put_in(garfield, valid_path, "Jonathon")
```

And we can update through the path:

```elixir
update_in(garfield, valid_path, fn name -> String.upcase(name) end)
```

Now let's consider an invalid path:

```elixir
invalid_path = [:owner, :age]
```

If we read:

```elixir
get_in(garfield, invalid_path)
```

We get an ambiguous `nil`. It could mean the `:owner` key is missing or the `:age` key is missing. It could mean both keys exist and the value is `nil`.

When we write:

```elixir
put_in(garfield, invalid_path, 40)
```

This succeeds. Even though the path does not actually point to a valid location in the original structure, Elixir treats the write as a create and silently changes the shape of the data.

And when we update:

```elixir
update_in(garfield, invalid_path, fn curr -> curr + 1 end)
```

Here the fallback breaks down completely, because `curr` is `nil` and the function crashes with an `ArithmeticError`.

At this point the same path has produced three different behaviors depending on which operation you chose: read returns `nil`, write creates new structure, update crashes.

This is convenient, but is not a lawful lens.

## Lawful Lenses: Symmetric, Explicit Contracts

A lens is a contract that guarantees symmetric behavior: if you can read through it, you can write through it, and vice versa. All operations make the same assumptions about the focus. No fallbacks, no auto-creation, no surprises.

Funx provides lawful lenses.

```elixir
alias Funx.Optics.Lens
```

Let's use `path/1` to lift our valid path:

```elixir
valid_lens = Lens.path(valid_path)
```

With Lens, we *view* to read:

```elixir
Lens.view!(garfield, valid_lens)
```

*Set* to write:

```elixir
Lens.set!(garfield, valid_lens, "Jonathon")
```

And *over* to update:

```elixir
Lens.over!(garfield, valid_lens, fn name -> String.upcase(name) end)
```

Elixir doesn't have a type system to prove whether a lens is valid at compile time, so every operation has two possible outcomes: success or explicit failure.

Let's look at an invalid path:

```elixir
invalid_lens = Lens.path(invalid_path)
```

Like Elixir's `update_in/3` accessor, our update raises an error:

```elixir
Lens.over!(garfield, invalid_lens, fn curr -> curr + 1 end)
```

But instead of an `ArithmeticError`, we get a `KeyError`. The lens won't apply a function to an invalid focus.

Let's write to an invalid focus:

```elixir
Lens.set!(garfield, invalid_lens, "Jonathon")
```

Again, a `KeyError`. A legal lens will not write to an invalid focus.

And if we view:

```elixir
Lens.view!(garfield, invalid_lens)
```

You guessed it, a `KeyError`. A legal lens will not allow us to read an invalid focus.

### A Lens is Lawful

If the focus is valid, you can read it, write it, and update it. If not valid, all operations fail explicitly. There is no fallback, no auto-creation, and no silent fixing.

This is what makes composition safe and refactoring predictable. Behavior depends only on the lens itself, not the runtime shape of the data. Everything makes the same assumptions, and errors stop exactly where an assumption breaks instead of being “cured” into a hard-to-find downstream bug.

Elixir’s structs require a symmetric contract to make updates safe, which is why Elixir’s accessors do not apply to them. With a lawful Lens, that barrier disappears.

## Yes, We Can Lens a Struct

```elixir
defmodule Owner do
  defstruct [:name]
end

defmodule Cat do
  defstruct [:name, :owner, :weight]
end
```

```elixir
granny = %Owner{name: "Granny"}
sylvester = %Cat{name: "Sylvester", owner: granny, weight: 15}
```

Again, Elixir's accessor cannot lens a struct, even with a valid focus:

```elixir
get_in(sylvester, valid_path)
```

But Funx can:

```elixir
Lens.view!(sylvester, valid_lens)
```

```elixir
Lens.set!(sylvester, valid_lens, "Gramps")
```

```elixir
Lens.over!(sylvester, valid_lens, fn name -> String.upcase(name) end)
```

In a legal Lens, an invalid focus will always fail:

```elixir
Lens.view!(sylvester, invalid_lens)
```

```elixir
Lens.set!(sylvester, invalid_lens, "Jonathon")
```

```elixir
Lens.over!(sylvester, invalid_lens, fn name -> String.upcase(name) end)
```

But we don't always have to raise an error. We can use the safe `read/2`, `set/3`, and `over/3`:

```elixir
Lens.over(sylvester, invalid_lens, fn name -> String.upcase(name) end)
```

Here, Funx's default behavior is its `Either`

But we can elect Elixir's tuple:

```elixir
Lens.view(sylvester, invalid_lens, as: :tuple)
```

Where we get the typical `{:ok, value}` or `{:error, reason}` tuple.

## Why Lens?

It is not about avoiding tediousness, or because we can compose, or because it solves some super challenging problem.

We want lenses to solve this problem:

```elixir
put_in(garfield, [:owner, :nane], "Dave")
```

There's your bug.

```elixir
Lens.set!(sylvester, Lens.path([:owner, :nane]), "Dave")
```

There's your error.

## More Complex Examples

We'll use a superhero domain where some updates must stay in sync.

```elixir
defmodule Powers do
  defstruct [:strength, :speed, :intelligence]

  def total(%Powers{} = p), do: p.strength + p.speed + p.intelligence
end

defmodule Hero do
  defstruct [:name, :alias, :powers]
end

defmodule Headquarters do
  @cities %{
    "New York" => {40.7128, -74.0060},
    "Los Angeles" => {34.0522, -118.2437},
    "San Francisco" => {37.7749, -122.4194}
  }

  defstruct [:city, :latitude, :longitude]

  def relocate(city) when is_map_key(@cities, city) do
    {lat, lon} = Map.fetch!(@cities, city)
    %Headquarters{city: city, latitude: lat, longitude: lon}
  end
end

defmodule Team do
  defstruct [:name, :leader, :headquarters, :founded]
end
```

```elixir
iron_man = %Hero{
  name: "Tony Stark",
  alias: "Iron Man",
  powers: %Powers{
    strength: 85,
    speed: 70,
    intelligence: 100
  }
}

avengers = %Team{
  name: "Avengers",
  leader: %Hero{
    name: "Steve Rogers",
    alias: "Captain America",
    powers: %Powers{
      strength: 90,
      speed: 75,
      intelligence: 80
    }
  },
  headquarters: %Headquarters{
    city: "New York",
    latitude: 40.7128,
    longitude: -74.0060
  },
  founded: 1963
}
```

## Constructors

**`key/1`** - single field focus

```elixir
alias_lens = Lens.key(:alias)
Lens.view!(iron_man, alias_lens)
```

**`path/1`** - nested field access

```elixir
leader_name = Lens.path([:leader, :name])
Lens.view!(avengers, leader_name)
```

## Composition

Lenses compose to reach arbitrary depth:

```elixir
leader_lens = Lens.key(:leader)
powers_lens = Lens.key(:powers)
intelligence_lens = Lens.key(:intelligence)

leader_intelligence =
  leader_lens
  |> Lens.compose(powers_lens)
  |> Lens.compose(intelligence_lens)

Lens.view!(avengers, leader_intelligence)
```

```elixir
avengers
|> Lens.set!(leader_intelligence, 195)
|> Lens.view!(Lens.compose(leader_lens, powers_lens))
```

Since lens composition is monoidal, we can also use a `concat/1`:

```elixir
leader_intelligence_concat = Lens.concat([
  Lens.key(:leader),
  Lens.key(:powers),
  Lens.key(:intelligence)
])

Lens.view!(avengers, leader_intelligence_concat)
```

Or use `path/1` as shorthand:

```elixir
Lens.view!(avengers, Lens.path([:leader, :powers, :intelligence]))
```

Composition scales to arbitrary depth while preserving lawfulness. Whether you use `compose/2`, `concat/1`, or `path/1`, every lens maintains the same contract: symmetric, total, and type-preserving.

And honestly, if you know this much, you know enough. Feel free to stop here.

## The Blue Pill: Advanced Lenses

So far we’ve used the `key/1` and `path/1` constructors. Behind the scenes, both are thin wrappers over `make/2` that generate simple structural lenses.

But not every update is a simple structural write.

What happens when a single logical change must update multiple fields together?

Let’s start by defining some basic lenses:

```elixir
headquarters_lens = Lens.key(:headquarters)
city_lens = Lens.compose(headquarters_lens, Lens.key(:city))
```

With this lens, we can change the city:

```elixir
avengers 
|> Lens.set!(city_lens, "Los Angeles") 
|> Lens.view!(headquarters_lens)
```

Structurally, this works, but is semantically wrong. The city is updated, while the latitude and longitude still point to New York. We have violated one of our domain invariants with a perfectly legal structural operation.

We need a lens which *focuses* the city, but atomically sets the entire headquarters.

```elixir
relocate_lens =
Lens.make(
  fn team ->
    Lens.view!(team, city_lens)
  end,
  fn team, new_city ->
    Lens.set!(team, headquarters_lens, Headquarters.relocate(new_city))
  end
)
```

`make/2` is the core of a lens. It binds two directions:

• how the focus is read
• how the structure is rebuilt when the focus changes

Both sides must agree on the same logical value. Here, that value is the city.

Now relocation is a single lawful operation:

```elixir
avengers
|> Lens.set!(relocate_lens, "Los Angeles")
```

The headquarters, including city, latitude, and longitude, is updated as one atomic rewrite.

Because this is still a lens, it composes like any other:

```elixir
avengers
|> Lens.set!(relocate_lens, "San Francisco")
|> Lens.set!(Lens.key(:name), "West Coast Avengers")
```

At this point, coordinated multi-field updates behave exactly like simple field updates. The difference is not at the call site. The difference is that the invariant is now enforced by construction.

Custom lenses turn coordinated rewrites into single, lawful operations.

### Derived Values as Fields

Not every field we care about is explicitly stored. Some values are *derived* from multiple fields but still behave like a single domain concept.

Here, a hero’s effective power is derived from three fields: `strength`, `speed`, and `intelligence`. We want to observe that value as a single focus before we decide how it should be rewritten.

```elixir
strength_lens = Lens.key(:strength)
speed_lens = Lens.key(:speed)
intelligence_lens = Lens.key(:intelligence)

```

```elixir
power_level = fn powers ->
  Lens.view!(powers, strength_lens) +
  Lens.view!(powers, speed_lens) +
  Lens.view!(powers, intelligence_lens)
end
```

This function is read-only. It defines how the derived value is computed from the underlying structure, but it has no authority to rewrite anything.

Next, we define the inverse operation: how a new derived value is *redistributed* back into concrete fields as a coordinated rewrite.

```elixir
rebalance = fn level ->
  avg = div(level, 3)
  rem = rem(level, 3)

  %Powers{}
  |> Lens.set!(Lens.key(:strength), avg + rem)
  |> Lens.set!(Lens.key(:speed), avg)
  |> Lens.set!(Lens.key(:intelligence), avg)
end
```

This function never reads from the structure. It only describes how a new derived value is projected back into concrete fields.

Now we bind those two directions into a *single lawful focus* using `make/2`.

```elixir
power_level_lens =
  Lens.make(
    fn hero ->
      hero
      |> Lens.view!(powers_lens)
      |> power_level.()
    end,
    fn hero, new_level ->
      Lens.set!(
        hero,
        powers_lens,
        rebalance.(new_level)
      )
    end
  )
```

This lens now behaves exactly like a real field:

• the viewer derives a value
• the setter performs a coordinated multi-field rewrite
• both sides agree on the same logical focus

We can read it:

```elixir
Lens.view!(iron_man, power_level_lens)
```

And we can update it:

```elixir
iron_man
|> Lens.set!(power_level_lens, 50)
|> Lens.view!(power_level_lens)
```

From the call site, there is no distinction between this derived value and a stored field. The difference is not in how it is used. The difference is that the lens enforces a coordinated rewrite instead of a simple assignment.

And again, if we mess up and try to set the power level for Garfield:

```elixir
garfield
|> Lens.set!(power_level_lens, 50)
```

We get a clear error.
