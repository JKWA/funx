# Funx.Optics.Iso

```elixir
Mix.install([
{:funx, github: "JKWA/funx", ref: "738d63f"}
])
```

## What’s an Iso?

```elixir
alias Funx.Optics.{Iso, Lens, Prism}
```

An iso represents a reversible change of representation. Nothing is added, nothing is lost.

<!-- livebook:{"break_markdown":true} -->

Let's start simple. Here is an iso that adds one.

```elixir
add_one_iso =
  Iso.make(
    fn n -> n + 1 end,
    fn n -> n - 1 end
  )
```

`view/2` applies the forward transformation.

```elixir
Iso.view(42, add_one_iso)
```

`review/2` applies the inverse transformation.

```elixir
Iso.review(43, add_one_iso)
```

An iso always round-trips. The inverse is exact, not a fallback.

### Composing Isos

Isomorphisms are composable:

```elixir
add_two_iso = Iso.compose(add_one_iso, add_one_iso)
Iso.view(42, add_two_iso)
```

And we still have reversibility:

```elixir
Iso.review(44, add_two_iso)
```

Because the inverse remains valid, composition can scale arbitrarily.

```elixir
add_five_iso = Iso.compose([add_two_iso, add_two_iso, add_one_iso])
add_ten_iso = Iso.compose([add_five_iso, add_five_iso])
add_fifty_iso = Iso.compose([add_ten_iso, add_ten_iso, add_ten_iso, add_ten_iso, add_ten_iso])
add_one_hundred_three_iso = Iso.compose([add_fifty_iso, add_fifty_iso, add_two_iso, add_one_iso])

updated_value = Iso.view(42, add_one_hundred_three_iso)
```

And the original value can always be recovered.

```elixir
Iso.review(updated_value, add_one_hundred_three_iso)
```

Within the context of `add_one_hundred_three_iso`, `145` and `42` are different representations of the same thing.

These examples show how isos work. Now let's see what happens when we don't have an iso enforcing the boundary between representations.

## Unit conversion

We're building a spacecraft navigation system with multiple contractors. One team's thrusters output data in pound-force seconds. Another team's navigation software expects newton-seconds. Same thrust, different representations.

In 1999, [NASA lost the Mars Climate Orbiter](https://science.nasa.gov/mission/mars-climate-orbiter/) because one team's software output thrust data in pound-force seconds while another team's navigation software expected newton-seconds. The orbiter approached Mars at the wrong altitude and burned up in the atmosphere.

That wasn't a calculation error. It was a representation error. Two teams looking at the same data, seeing different things, with no enforcement at the boundary.

That's a job for `Iso`.

Pound-force seconds and newton-seconds are two representations of impulse (thrust over time). Let's start with an `Iso` to switch between them:

```elixir
lbf_seconds_to_newton_seconds =
  Iso.make(
    fn lbf_s -> lbf_s * 4.44822 end,
    fn n_s -> n_s / 4.44822 end
  )
```

In production, we would represent impulse in an exact form - an integer base unit or `Decimal` - so the inverse is genuinely lossless. Floats accumulate rounding errors that break the round-trip guarantee. But for this example, we'll use floats to keep the math simple.

To track which unit we're using, we need types - two structs that represent the same data:

```elixir
defmodule LbfSeconds do
  defstruct [:value]
end

defmodule NewtonSeconds do
  defstruct [:value]
end
```

Now we compose an `Iso` that converts between our structs:

```elixir
impulse_iso =
  Iso.make(
    fn %LbfSeconds{value: lbf} ->
      %NewtonSeconds{value: Iso.view(lbf, lbf_seconds_to_newton_seconds)}
    end,
    fn %NewtonSeconds{value: ns} ->
      %LbfSeconds{value: Iso.review(ns, lbf_seconds_to_newton_seconds)}
    end
  )
```

This let's us swap representations:

```elixir
thruster_output = %LbfSeconds{value: 100}
```

```elixir
nav_input = Iso.view(thruster_output, impulse_iso)
```

And reverse:

```elixir
Iso.review(nav_input, impulse_iso)
```

Next, we need a way to modify our impulse:

```elixir
add_ten = fn n -> n + 10.0 end
```

And a `Lens`:

```elixir
impulse_lens = Lens.key(:value)
```

We can use `Lens.over!/3` to update our value:

```elixir
thruster_output
|> Lens.over!(impulse_lens, add_ten)
```

```elixir
nav_input
|> Lens.over!(impulse_lens, add_ten)
```

This works as expected, adding `10` to each value.

But what if we mean 10 in the context of `NewtonSeconds`?

What about a `Prism`?

```elixir
newton_seconds_prism = Prism.path([{NewtonSeconds, :value}])
```

Now, if our current value is `NewtonSeconds`:

```elixir
alias Funx.Monad

nav_input
|> Prism.preview(newton_seconds_prism)
|> Monad.map(add_ten)
```

We get back `Just` the new value.

If we are in `LbfSeconds`:

```elixir
thruster_output
|> Prism.preview(newton_seconds_prism)
|> Monad.map(add_ten)
```

`LbfSeconds` is `Nothing`.

But here's the key insight: `LbfSeconds` and `NewtonSeconds` aren't two separate things where one might be `Nothing`. They're the *same thing* viewed two different ways. `Impulse` isn't a `Prism`, it is an `Iso`.

With an iso, we don't fail when we're in the "wrong" representation. We just swap to the right context, do our work, and swap back:

```elixir
thruster_output
|> Iso.view(impulse_iso)
|> Lens.over!(impulse_lens, add_ten)
|> Iso.review(impulse_iso)
```

Here, `100` lbf·s plus `10` N·s is `102.248` lbf·s.

That manual swap works, but `Iso` includes `over/3` to do this automatically. It views to the opposite representation, applies your function there, and reviews back:

```elixir
thruster_output
|> Iso.over(
  impulse_iso,
  &Lens.over!(&1, impulse_lens, add_ten)
)
```

Same result: starting from `LbfSeconds`, we apply `10` `NewtonSeconds`.

And `Iso` has the inverse: `under/3` reviews to the opposite representation, applies your function, and views back:

```elixir
nav_input
|> Iso.under(
  impulse_iso,
  &Lens.over!(&1, impulse_lens, add_ten)
)
```

Starting from `NewtonSeconds`, we apply `10` `LbfSeconds`.

### Handling nested data with Lens and Iso

Our thruster and navigation data isn't just raw values. It's nested inside a larger spacecraft structure:

```elixir
defmodule ThrusterData do
  defstruct [:impulse, :fuel_remaining, :status]
end

defmodule NavData do
  defstruct [:target_impulse, :trajectory, :eta]
end

defmodule Spacecraft do
  defstruct [:id, :thrusters, :navigation]
end
```

Here's our current spacecraft:

```elixir
spacecraft = %Spacecraft{
  id: "MCO-1999",
  thrusters: %ThrusterData{
    impulse: %LbfSeconds{value: 100},
    fuel_remaining: 75.5,
    status: :active
  },
  navigation: %NavData{
    target_impulse: %NewtonSeconds{value: 501},
    trajectory: :mars_orbit,
    eta: ~U[1999-09-23 09:01:00Z]
  }
}
```

Let's start by getting our current thruster impulse value.

For that, we'll need a lens:

```elixir
thrusters_impulse_lens = Lens.path([:thrusters, :impulse])
spacecraft |> Lens.view!(thrusters_impulse_lens)
```

Except we need it in newton seconds.

It turns out that `Iso` can act as a `Lens`, so we can convert it with `as_lens/1`:

```elixir
thruster_impulse_ns_lens =
  Lens.compose([
    thrusters_impulse_lens,
    Iso.as_lens(impulse_iso)
  ])
```

Now, we have our current thrust in `NewtonSeconds`:

```elixir
spacecraft |> Lens.view!(thruster_impulse_ns_lens)
```

We can extend our lens to get the actual value:

```elixir
thruster_impulse_ns_value_lens =
  Lens.compose(thruster_impulse_ns_lens, Lens.key(:value))

Lens.view!(spacecraft, thruster_impulse_ns_value_lens)
```

Have we met our navigation's impulse target?

```elixir
navigation_target_impulse_lens = Lens.path([:navigation, :target_impulse, :value])

target = Lens.view!(spacecraft, navigation_target_impulse_lens)
```

No, our target is `501` newton seconds and our current thrusters are at `444.822`.

We can set our thrust to match our navigation target, trusting our lens to do the conversion:

```elixir
spacecraft |> Lens.set!(thruster_impulse_ns_value_lens, target)
```

It turns out that we needed about 12.6 additional pound-force seconds to match our `Navigation` module's target impulse.

<!-- livebook:{"break_markdown":true} -->

The iso handles the conversion. The lens handles the navigation. Together, they let us work with nested data in the representation that makes sense at each level.

### Handling unreliable data with Prism and Iso

Space communications are unreliable. Solar flares, distance from Earth, hardware faults. We need to handle our navigation module sometimes dropping out.

When it's online, we have navigation data. When it's not, the field is `nil`:

```elixir
spacecraft_connected = %Spacecraft{
  id: "MCO-1999",
  thrusters: %ThrusterData{
    impulse: %LbfSeconds{value: 40},
    fuel_remaining: 75.5,
    status: :active
  },
  navigation: %NavData{
    target_impulse: %NewtonSeconds{value: 345},
    trajectory: :mars_orbit,
    eta: ~U[1999-09-23 09:01:00Z]
  }
}
```

```elixir
spacecraft_disconnected = %Spacecraft{
  id: "MCO-1999",
  thrusters: %ThrusterData{
    impulse: %LbfSeconds{value: 76},
    fuel_remaining: 75.5,
    status: :active
  },
  navigation: nil  # Communication lost
}
```

We need to check if our thruster impulse matches the navigation target. But we can't assume navigation data exists.

With `Prism`, we can safely access optional data. With `Iso`, we can convert units. We need both.

An `Iso` can act as a `Prism`, so we can convert it with `as_prism/1`:

```elixir
nav_target_prism =
  Prism.path([:navigation, :target_impulse])
```

With a good connection, we get the target:

```elixir
Prism.preview(spacecraft_connected, nav_target_prism)
```

But our thruster module needs pound-force seconds.

```elixir
nav_target_lbf_prism = 
  Prism.compose(
    nav_target_prism, 
    Iso.as_prism(Iso.from(impulse_iso)))

Prism.preview(spacecraft_connected, nav_target_lbf_prism)
```

We can extend this into the value itself:

```elixir
nav_target_lbf_value_prism = 
  Prism.compose(
    nav_target_lbf_prism, 
    Prism.path([{LbfSeconds, :value}])
  )

Prism.preview(spacecraft_connected, nav_target_lbf_value_prism)
```

With a lost connection, we get `Nothing`:

```elixir
Prism.preview(spacecraft_disconnected, nav_target_lbf_value_prism)
```

We can check our entire fleet, asking if all have comms:

```elixir
alias Funx.Monad.Maybe

fleet = [spacecraft, spacecraft_connected]

fleet
|> Maybe.traverse(fn ship -> Prism.preview(ship, nav_target_lbf_value_prism) end)

```

Here we get `Just`, letting us know all have comms, and the list of nav targets, in pound-force seconds.

If we add our disconnected spacecraft:

```elixir
fleet = [spacecraft_connected, spacecraft_disconnected]

fleet
|> Maybe.traverse(fn ship -> Prism.preview(ship, nav_target_lbf_value_prism) end)
```

We get `Nothing`. From the context of our fleet, not all have nav target information.

The prism handles the missing data. The iso handles the conversion. Together, they let us work with unreliable systems in the representation we need.

The Mars Climate Orbiter crashed because there was no enforced isomorphism. Just implicit assumptions about units that failed silently.

Our system is different. The boundary between pound-force seconds and newton-seconds is explicit. We cannot mix representations without going through the iso. And because the transformation is bidirectional and total, we know exactly what we're getting on both sides.

When our thruster team and navigation team share data, the iso handles it. No `Maybe`, no silent failures, no confusion about which representation we're in. Just the same impulse, viewed two ways, with guaranteed correctness in both directions.

## GIS ISO Boundary

We are in the early stages of our project, and folks are enamored with SupGIS: a bespoke solution that gets us out of the starting blocks quickly.

SupGIS has a free tier, but if we are successful it will be expensive. The worst case scenario is that we are only moderately successful, where SupGIS costs will significantly shorten our runway.

We need to choose now without losing the ability to change our mind later.

The data from SupGIS looks like this.

```elixir
defmodule SupGis.Point do
  defstruct [:x, :y]
end

defmodule SupGis.Attributes do
  defstruct [
    :object_id,
    :name,
    :category,
    :rating,
    :created_at
  ]
end

defmodule SupGis.Feature do
  defstruct [
    geometry: SupGis.Point,
    attributes: SupGis.Attributes
  ]
end
```

We do not know what we will choose later, so we pick GeoJson as our boundary representation: a general schema meant to bridge GIS platforms.

Here is our GeoJson.

```elixir
defmodule GeoJson.Point do
  defstruct [:lon, :lat]
end

defmodule GeoJson.Properties do
  defstruct [
    :id,
    :name,
    :category,
    :rating,
    :created_at
  ]
end

defmodule GeoJson.Feature do
  defstruct [
    geometry: GeoJson.Point,
    properties: GeoJson.Properties
  ]
end
```

Our `point_iso` converts SupGIS points from `x` and `y` to `lon` and `lat`.

```elixir
point_iso =
  Iso.make(
    fn %SupGis.Point{x: x, y: y} ->
      %GeoJson.Point{lon: x, lat: y}
    end,
    fn %GeoJson.Point{lon: lon, lat: lat} ->
      %SupGis.Point{x: lon, y: lat}
    end
  )
```

Next we handle the attributes, establishing the relationship between SupGIS and GeoJson properties.

```elixir
attributes_iso =
  Iso.make(
    fn %SupGis.Attributes{
         object_id: id,
         name: name,
         category: category,
         rating: rating,
         created_at: created_at
       } ->
      %GeoJson.Properties{
        id: id,
        name: name,
        category: category,
        rating: rating,
        created_at: created_at
      }
    end,
    fn %GeoJson.Properties{
         id: id,
         name: name,
         category: category,
         rating: rating,
         created_at: created_at
       } ->
      %SupGis.Attributes{
        object_id: id,
        name: name,
        category: category,
        rating: rating,
        created_at: created_at
      }
    end
  )
```

Finally, a feature iso, composed the point and attribute isos. This lets us swap feature representations without losing information.

```elixir
feature_iso =
  Iso.make(
    fn %SupGis.Feature{geometry: geom, attributes: attrs} ->
      %GeoJson.Feature{
        geometry: Iso.view(geom, point_iso),
        properties: Iso.view(attrs, attributes_iso)
      }
    end,
    fn %GeoJson.Feature{geometry: geom, properties: props} ->
      %SupGis.Feature{
        geometry: Iso.review(geom, point_iso),
        attributes: Iso.review(props, attributes_iso)
      }
    end
  )
```

Now when we receive a SupGIS feature:

```elixir
supgis_feature =
  %SupGis.Feature{
    geometry: %SupGis.Point{
      x: -122.335167,
      y: 47.608013
    },
    attributes: %SupGis.Attributes{
      object_id: 1,
      name: "Coffee Shop",
      category: "Retail",
      rating: 4.6,
      created_at: ~U[2023-08-15 00:00:00Z]
    }
  }
```

We can `view/2` it as GeoJson:

```elixir
geo_json_feature = Iso.view(supgis_feature, feature_iso)
```

And we can go back:

```elixir
Iso.review(geo_json_feature, feature_iso)
```

The key is that an `Iso` is not a one-way mapping. It is a statement that these two representations are the same information.

Inside the system, we can choose the representation that makes sense in that part of the code: GeoJson when we want portability, SupGIS when we need vendor-specific capabilities.

Later, if SupGIS costs start to dominate, the migration is not a rewrite. We add a new iso between the new provider and GeoJson.

More importantly, we do not need to migrate all at once. Because the boundary is explicit and reversible, we can replace the most expensive SupGIS calls first, move gradually, and keep the system coherent the entire time.

## Why No Bang Variants?

Notice that Iso operations have no `!` suffix and no safe alternatives.

This is intentional. An Iso models **no failure**.

The bang convention in Elixir means "this has a non-bang counterpart that models failure." But isos are total - if the transformation can fail, you don't have an iso. (This is why our unit conversion example noted that production code needs exact numeric representations: floats don't actually round-trip, so they break the iso contract.)

If an iso operation crashes, that's a contract violation (a broken iso), not an expected failure mode. The crash is loud, immediate, and correct.

## When to Use Isos

Use isos when you have:

* **Lossless transformations**: Converting between equivalent representations (string ↔ integer, JSON ↔ struct)
* **Unit conversions**: Temperature, distance, currency, etc.
* **Encoding/decoding**: Serialization, format conversions
* **Type conversions**: Between isomorphic data structures

Don't use isos when:

* The transformation is not reversible (use a function or lens instead)
* The transformation loses information
* You need partial/optional transformations (use a prism instead)
* The focus might not exist (use a lens with safe variants)

## Wrapping Up

Isos enforce a simple invariant: two representations of the same thing must convert cleanly in both directions. When that invariant holds, you get guarantees that matter.

The Mars Climate Orbiter shows the cost of implicit conversions. The GIS example shows the value of explicit boundaries. In both cases, the iso is the same tool: a way to say "these two things are identical, just viewed differently," and make that boundary explicit and executable.

No silent failures. No information loss. Just reversible transformations you can trust.
