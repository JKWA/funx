# Funx.Optics.Prism

```elixir
Mix.install([
  {:funx, github: "JKWA/funx", ref: "2518f7d", force: true}
])
```

## Section

The `Funx.Optics.Prism` module provides a lawful partial optic for focusing on branches of data structures.

Unlike a Lens, a Prism never raises on failure. Instead, it returns the `Maybe` monad’s `Just(value)` or `Nothing`.

Because Prisms are built on top of `Maybe`, it can be helpful to understand `Maybe` first before diving into `Prism`.

## What is Prism for?

Let’s say we have a `Payment`, which can be either a `CreditCard` or a `Check`.

In a dynamically typed language, we can represent these as plain maps:

* `CreditCard` is `{name: "John", number: "1234", expiry: "12/26"}`
* `Check` is `{name: "Dave", routing_number: "111000025", account_number: "987654"}`

To tell them apart, we might rely on duck typing, such as checking whether the `expiry` key exists. Or we might introduce an internal key like `_type` to explicitly track which variant we’re dealing with.

In algebraic data types, this is a `Sum` type, where `Payment -> CreditCard | Check`.

A Prism exists specifically to work with this kind of structure: data that can be one of several variants, where choosing the wrong branch is not an error but an expected outcome.

Let’s model this more explicitly using structs:

```elixir
alias Funx.Optics.Prism
defmodule CreditCard do
  defstruct [:name, :number, :expiry]
end

defmodule Check do
  defstruct [:name, :routing_number, :account_number]
end
```

And some example payments:

```elixir
cc_payment = %CreditCard{name: "John", number: "1234", expiry: "12/26"}
check_payment = %Check{name: "Dave", routing_number: "111000025", account_number: "987654"}
```

Suppose we want to extract the `name` field. We can start with a simple prism that focuses on a key:

```elixir
name_prism = Prism.key(:name)
```

Now we can preview the name from either payment:

```elixir
Prism.preview(cc_payment, name_prism)
```

```elixir
Prism.preview(check_payment, name_prism)
```

Both succeed. At this level, we haven’t distinguished between payment types at all. We’re only saying “if there is a `:name` key, give it to me.”

That isn’t enough. We need to know whether we’re dealing with a `CreditCard` or a `Check`.

For this, we can use `struct/1`:

```elixir
cc_prism = Prism.struct(CreditCard)
check_prism = Prism.struct(Check)
```

Now we can explicitly select a branch.

```elixir
Prism.preview(cc_payment, cc_prism)
```

When the payment is with a credit card, the preview succeeds and returns `Just` the `CreditCard`.

```elixir
Prism.preview(check_payment, cc_prism)
```

When the payment is a `Check`, preview returns `Nothing`.

But when we focus on checks:

```elixir
Prism.preview(check_payment, check_prism)
```

Here we get `Just` a `Check`.

The prism’s `review/2` operation builds the minimum structure required to represent the focused value:

```elixir
Prism.review(%Check{}, check_prism)
```

This is the smallest structure that satisfies the prism’s contract.

### Composing

Like a Lens, a Prism can be composed.

We can combine the credit card prism with the name prism:

```elixir
cc_name_prism = Prism.compose(cc_prism, name_prism)
```

This creates a prism that focuses on the `name` field, but only when the payment is a `CreditCard`.

```elixir
Prism.preview(cc_payment, cc_name_prism)
```

For our credit card payment, we get `Just` the name.

```elixir
Prism.preview(check_payment, cc_name_prism)
```

And for a check payment, we get `Nothing`.

Now, looking at `review/2` for this composed prism:

```elixir
Prism.review("Sarah", cc_name_prism)
```

**Stop for a minute here and notice what `review/2` does.**

Our prism is for the name on the credit card, so our `review/2` generates a credit card with just a name.

Its primary purpose is to satisfy the laws that make prisms well-behaved optics, not to be a practical construction tool. Without review, we'd just have a partial getter, not a lawful optic.

That said, `review/2` can be useful for things like generating test data or creating minimal valid structures.

### path/1

Like `Lens`, our `Prism` includes `path/1`, which is a convenient way to compose multiple optics in a single step.

Let's extract the `CreditCard` from the payment information within our transaction:

```elixir
defmodule Transaction do
  defstruct [:amount, :payment]
end

```

```elixir
cc_transaction = %Transaction{amount: 100, payment: cc_payment}
check_transaction = %Transaction{amount: 100, payment: check_payment}

```

```elixir
cc_transaction_prism = Prism.path([:payment, CreditCard])
```

We can focus on the `CreditCard`:

```elixir
cc_transaction |> Prism.preview(cc_transaction_prism)
```

And we can extend to focus on the name in the `CreditCard`:

```elixir
payment_cc_name_prism = Prism.path([:payment, CreditCard, :name])

```

And get `Just` name on the credit card:

```elixir
cc_transaction |> Prism.preview(payment_cc_name_prism)
```

And `path/1` includes the an optional tuple option to group the struct and key together, which can  make our intent a bit easier to read.

Let's tighen our focus to only a `Transaction` with a payment by `CreditCard`:

```elixir
payment_cc_name_prism = Prism.path([{Transaction, :payment}, {CreditCard, :name}])
```

We still get the name:

```elixir
cc_transaction |> Prism.preview(payment_cc_name_prism)
```

But now, if we get a transaction represented as a map, even if it has the same shape:

```elixir
%{payment: cc_payment} |> Prism.preview(payment_cc_name_prism)
```

Since this isn't a `Transaction`, we get `Nothing`.

And as always:

```elixir
check_transaction |> Prism.preview(payment_cc_name_prism)
```

Our `CreditCard` prism returns `Nothing` for the name on a `Check`.

## Prisms with Map

In a dynamically typed language like Elixir, a Map may, or may not, have a certain key. This is another problem we can solve with a Prism.

Let's start with some Superhero data:

```elixir
hero_map = %{
  name: "Tony Stark",
  alias: "Iron Man",
  powers: %{strength: 85, speed: 70, intelligence: 100}
}
```

And an incomplete hero map:

```elixir
incomplete_hero = %{
  alias: "Mysterious"
}
```

If we are working with possibly malformed or incomplete data, we use a prism.

```elixir
name_prism = Prism.key(:name)
alias_prism = Prism.key(:alias)
powers_prism = Prism.key(:powers)
```

With alias:

```elixir
Prism.preview(hero_map, alias_prism)
```

```elixir
Prism.preview(incomplete_hero, alias_prism)
```

Both give us `Just` the hero's alias.

But with name we get:

```elixir
Prism.preview(hero_map, name_prism)
```

```elixir
Prism.preview(incomplete_hero, name_prism)
```

Like lens, we can compose our prism:

```elixir
strength_prism = Prism.compose(powers_prism, Prism.key(:strength))
```

Or focus contract is for `Maybe` strength:

```elixir
Prism.preview(hero_map, strength_prism)
```

Iron Many has a strength of `Just` 85

```elixir
Prism.preview(incomplete_hero, strength_prism)
```

And Mysterious has `Nothing`

Notice we didn't need to check `powers`, our prism knows how to handle missing intermediate keys.

<!-- livebook:{"break_markdown":true} -->

And with get with `review/2`:

```elixir
Prism.review(100, strength_prism)
```

We get the minimum structure to fulfil our strength_prism focus.

### Why can't review just use original data structure and repair the broken field?

Unlike Lens, Prism has no contract about what it receives.

For instance, what if our caller sends us a `:cat`?

```elixir
Prism.preview(:cat, strength_prism)
```

Here, a cat does not produce a focus, so the result is `Nothing`. But notice that we have zero information by which to make a new leader name. This is why `review` can only create the minimum structure by which to satisfy the `preview/2`.

## Prism with Struct

Let's define some structs:

```elixir
defmodule Powers do
  defstruct strength: 50,
            speed: 40,
            intelligence: 60
end

defmodule Hero do
  defstruct [:name, :alias, powers: %Powers{}]
end
```

```elixir
hero_struct = %Hero{
  name: "Tony Stark",
  alias: "Iron Man",
  powers: %Powers{strength: 85, speed: 70, intelligence: 100}
}
```

```elixir
incomplete_hero_struct = %Hero{
  alias: "Mysterious"
}
```

Like Lens, our map prisms work with structs:

```elixir
Prism.preview(hero_struct, alias_prism)
```

```elixir
Prism.preview(incomplete_hero_struct, alias_prism)
```

And for the name focus:

```elixir
Prism.preview(hero_struct, name_prism)
```

```elixir
Prism.preview(incomplete_hero_struct, name_prism)
```

Even though Mysterious has a name field, it is `nil`. In the context of `Maybe` there is no concept of `Just` `nil`.

Let's create a team:

```elixir
defmodule Team do
  defstruct [:name, founded: nil, leader: %Hero{}]
end
```

```elixir
team_struct = %Team{
  name: "Avengers",
  leader: hero_struct,
  founded: 1963
}
```

Our name_prism works on a hero:

```elixir
Prism.preview(hero_struct, name_prism)
```

But also a team:

```elixir
Prism.preview(team_struct, name_prism)
```

That's probably not what we want. Instead, we want to be able to tell the difference between a team's name and a hero' name.

```elixir
hero_name_prism = Prism.compose(Prism.struct(Hero), name_prism)
```

```elixir
Prism.preview(hero_struct, hero_name_prism)
```

```elixir
Prism.preview(team_struct, hero_name_prism)
```

And we can use `path/1` to make a team focus:

```elixir
team_name_prism = Prism.path([{Team, :name}])
```

```elixir
Prism.preview(hero_struct, team_name_prism)
```

```elixir
Prism.preview(team_struct, team_name_prism)
```

```elixir
team_leader_strength_prism = 
  Prism.path([
    {Team, :leader}, 
    {Hero, :powers}, 
    {Powers, :strength}
  ])
```

```elixir
Prism.preview(team_struct, team_leader_strength_prism)
```

```elixir
Prism.review(500, team_leader_strength_prism)
```

A prism let's us skip a lot of defensive coding.

For instance, we can just sent it a `:cat`:

```elixir
Prism.preview(nil, team_leader_strength_prism)
```

## Advanced

Until now we have used the constructors to make simple prisms, but with `make/2` we can implement custom logic.

```elixir
alias Funx.Monad.Maybe

first_is_greater_prism =
  Prism.make(
    fn
      {a, b} when a > b -> Maybe.just(a)
      _ -> Maybe.nothing()
    end,
    fn new_a -> {new_a, 0} end
  )

```

*For prisms built with* `make/2`*, it is your responsibility to ensure the preview and review functions obey the prism laws. Specifically: preview and review must round-trip appropriately. Funx does not enforce this for you.*

```elixir
Prism.preview({5, 100}, first_is_greater_prism)
```

```elixir
Prism.preview({200, 100}, first_is_greater_prism)
```

Review reconstructs the tuple structure, placing our value in the first position:

```elixir
Prism.review(-4, first_is_greater_prism)
```

## Patterns with Maybe

A Prism returns `Maybe`, so we can leverage the `Maybe` monad to solve common patterns.

### Default Values

Use `get_or_else` to provide a fallback when preview fails:

```elixir
hero_struct
|> Prism.preview(name_prism)
|> Maybe.get_or_else("Unknown Hero")
```

```elixir
incomplete_hero_struct
|> Prism.preview(name_prism)
|> Maybe.get_or_else("Unknown Hero")
```

### Folding to a Decision

Use `fold_l` to collapse the `Maybe` into a specific value:

```elixir
alias Funx.Foldable

team_leader_prism = Prism.path([{Team, :leader}, Hero])

team_struct
|> Prism.preview(team_leader_prism)
|> Foldable.fold_l(
  fn hero -> "Leader: #{hero.name}" end,  # called if Just(hero)
  fn -> "No leader assigned" end           # called if Nothing
)
```

```elixir
team_without_leader = %Team{name: "New Team", founded: 2024, leader: nil}

team_without_leader
|> Prism.preview(team_leader_prism)
|> Foldable.fold_l(
  fn hero -> "Leader: #{hero.name}" end,
  fn -> "No leader assigned" end
)
```

### Transforming Success Cases

Use `map` and `tap` to transform or react to successful previews only:

```elixir
hero_struct
|> Prism.preview(name_prism)
|> Monad.map(&String.upcase/1)
|> Funx.Tappable.tap(fn name ->
  IO.puts("Found hero: #{name}")
end)
```

When the prism fails, map and tap are skipped:

```elixir
incomplete_hero_struct
|> Prism.preview(name_prism)
|> Monad.map(&String.upcase/1)
|> Funx.Tappable.tap(fn name ->
  IO.puts("Found hero: #{name}")
end)
```

### Collecting Successes from Lists

Use `concat` to collect only the successful previews:

```elixir
teams = [
  %Team{name: "Avengers", leader: hero_struct},
  %Team{name: "New Team", leader: nil},
  %Team{name: "Justice League", leader: %Hero{name: "Superman", alias: "Clark Kent"}}
]

teams
|> Enum.map(&Prism.preview(&1, team_leader_prism))
|> Maybe.concat()
```

Or use `concat_map` to combine the mapping and concatenation:

```elixir
teams
|> Maybe.concat_map(&Prism.preview(&1, team_leader_prism))
```

### Requiring All Successes

Use `traverse` when you need all previews to succeed:

```elixir
# Returns Just([leaders]) if all teams have leaders
teams
|> Maybe.traverse(&Prism.preview(&1, team_leader_prism))
```

```elixir
# Returns Just([leaders]) when all teams have leaders
teams_with_leaders = [
  %Team{name: "Avengers", leader: hero_struct},
  %Team{name: "Justice League", leader: %Hero{name: "Superman", alias: "Clark Kent"}}
]

teams_with_leaders
|> Maybe.traverse(&Prism.preview(&1, team_leader_prism))
```

These patterns let you handle optional data elegantly, leveraging the `Maybe` monad to avoid explicit nil checks and nested conditionals.
