# Traversal

```elixir
Mix.install([
  {:funx, github: "JKWA/funx", ref: "9cc278a"}
])
```

## Why Traversal?

We have seen `Lens` and `Prism`, which focus on one location at a time.

A `Traversal` answers a different question:

Do the foci required by this operation exist together, in the same context?

That matters when an operation depends on more than one focus, and when domain rules relate those foci.

## The Problem

We are building a system to process transactions. A transaction can be a charge or a refund, and it can be paid by check or credit card.

```text
Transaction
└─ type
   ├─ Charge
   │  ├─ item
   │  │  └─ amount
   │  └─ payment
   │     ├─ CreditCard
   │     │  └─ amount   ← cc_payment
   │     └─ Check
   │        └─ amount   ← check_payment
   │
   └─ Refund
      ├─ item
      │  └─ amount
      └─ payment
         ├─ CreditCard
         │  └─ amount   ← cc_refund
         └─ Check
            └─ amount   ← check_refund
```

The transaction always has an `Item`. The path `type.item` refers to the same concept for both `Charge` and `Refund`, so a `Lens` is a good fit.

The payment is conditional. The path `type.payment` is one location, but the meaning depends on which branch exists. That is what `Prism` models.

The operation depends on both.

We need the item and the relevant payment present in the same transaction and traversal gives us a single boundary.

## Building the Transaction Processor

```elixir
alias Funx.Optics.{Lens, Prism}
require Logger
use Funx.Monad.Maybe

defmodule CreditCard do
  defstruct [:name, :number, :expiry, :amount]
  alias Funx.Optics.Prism
  
  def amount_prism do
    Prism.path([{__MODULE__, :amount}])
  end
end

defmodule Check do
  defstruct [:name, :routing_number, :account_number, :amount]
  alias Funx.Optics.Prism

  def amount_prism do
    Prism.path([{__MODULE__, :amount}])
  end
end

defmodule Item do
  defstruct [:name, :amount]
end

defmodule Charge do
  defstruct [:item, :payment, :status]
  alias Funx.Optics.Prism

  def payment_prism do
    Prism.path([{__MODULE__, :payment}])
  end
end

defmodule Refund do
  defstruct [:item, :payment, :status]
  alias Funx.Optics.Prism

  def payment_prism do
    Prism.path([{__MODULE__, :payment}])
  end
end

defmodule Transaction do
  defstruct [:type]
  alias Funx.Optics.Prism

  def type_prism do
    Prism.path([{__MODULE__, :type}])
  end
end
```

Next, some transactions:

```elixir
charge_cc =
  %Transaction{
    type: %Charge{
      item: %Item{name: "Camera", amount: 500},
      payment: %CreditCard{name: "Alice", number: "4111", expiry: "12/26", amount: 500},
      status: :pending
    }
  }

invalid_charge_cc =
  %Transaction{
    type: %Charge{
      item: %Item{name: "Camera", amount: 500},
      payment: %CreditCard{name: "Alice", number: "4111", expiry: "12/26", amount: 400},
      status: :pending
    }
  }

charge_check =
  %Transaction{
    type: %Charge{
      item: %Item{name: "Lens", amount: 300},
      payment: %Check{name: "Bob", routing_number: "111000025", account_number: "987654", amount: 300},
      status: :pending
    }
  }

refund_cc =
  %Transaction{
    type: %Refund{
      item: %Item{name: "Tripod", amount: 150},
      payment: %CreditCard{name: "Carol", number: "4333", expiry: "10/27", amount: 150},
      status: :pending
    }
  }

refund_check =
  %Transaction{
    type: %Refund{
      item: %Item{name: "Flash", amount: 200},
      payment: %Check{name: "Dave", routing_number: "222000025", account_number: "123456", amount: 200},
      status: :pending
    }
  }

transactions = [charge_cc, charge_check, refund_cc, refund_check]
```

## Pattern Matching in Function Heads

The idiomatic Elixir approach is to encode applicability directly in the function head.

```elixir
defmodule Guarded.TransactionProcessor do
  def cc_payment(
        %Transaction{
          type: %Charge{
            item: %Item{amount: item_amount, name: name},
            payment: %CreditCard{amount: payment_amount}
          } = charge
        } = transaction
      ) when item_amount == payment_amount do
    Logger.info("Charge cc $#{payment_amount} for #{name}")

    %{
      transaction
      | type: %{charge | status: :complete}
    }
  end

  def check_payment(
        %Transaction{
          type: %Charge{
            item: %Item{amount: item_amount, name: name},
            payment: %Check{amount: payment_amount}
          } = charge
        } = transaction
      ) when item_amount == payment_amount do
    Logger.info("Charge check $#{payment_amount} for #{name}")

    %{
      transaction
      | type: %{charge | status: :complete}
    }
  end

  def cc_refund(
        %Transaction{
          type: %Refund{
            item: %Item{amount: item_amount, name: name},
            payment: %CreditCard{amount: payment_amount}
          } = refund
        } = transaction
      ) when item_amount == payment_amount do
    Logger.info("Refund cc $#{payment_amount} for #{name}")

    %{
      transaction
      | type: %{refund | status: :complete}
    }
  end

  def check_refund(
        %Transaction{
          type: %Refund{
            item: %Item{amount: item_amount, name: name},
            payment: %Check{amount: payment_amount}
          } = refund
        } = transaction
      ) when item_amount == payment_amount do
    Logger.info("Refund check $#{payment_amount} for #{name}")

    %{
      transaction
      | type: %{refund | status: :complete}
    }
  end
end
```

Our domain includes a `item_amount == payment_amount` rule.

The happy path works:

```elixir
Guarded.TransactionProcessor.cc_payment(charge_cc)
```

A mismatch raises:

```elixir
Guarded.TransactionProcessor.cc_payment(refund_check)
```

An invalid charge also raises:

```elixir
Guarded.TransactionProcessor.cc_payment(invalid_charge_cc)
```

This function head does three things at once:

* It selects the shape required by the operation.
* It extracts the foci needed by the operation.
* It enforces the domain rule that relates those foci.

It works, but it is not a reusable boundary. If the same applicability rule matters in another workflow, the rule has to be re-expressed in a new function head. Worse, if they change we need to find all and change all the rules in lockstep.

## The Functional Way

A traversal lets us treat applicability as data.

Instead of encoding “what must exist together for this operation to apply” in syntax, we define that requirement as an optic and pass it around.

The traversal establishes the required foci. Validation applies the domain rule. The operation runs only after both hold.

### Optics for the boundary

```elixir
defmodule Processor do
  alias Funx.Optics.{Lens, Prism, Traversal}

  def item_lens do
    Lens.path([:type, :item])
  end
  
  def cc_payment_trav do
    Traversal.combine([
      Processor.item_lens,
      Prism.compose([
        Transaction.type_prism,
        Charge.payment_prism,
        Prism.struct(CreditCard)
      ])
    ])
  end

  def check_payment_trav do
    Traversal.combine([
      Processor.item_lens,
      Prism.compose([
        Transaction.type_prism,
        Charge.payment_prism,
        Prism.struct(Check)
      ])
    ])
  end

  def cc_refund_trav do
    Traversal.combine([
      Processor.item_lens,
      Prism.compose([
        Transaction.type_prism,
        Refund.payment_prism,
        Prism.struct(CreditCard)
      ])
    ])
  end

  def check_refund_trav do
    Traversal.combine([
      Processor.item_lens,
      Prism.compose([
        Transaction.type_prism,
        Refund.payment_prism,
        Prism.struct(Check)
      ])
    ])
  end

  def payment_status_lens do
    Lens.path([:type, :status])
  end
end
```

Each traversal describes the structural requirement for an operation: the item must exist, and the relevant payment branch must exist, in the same transaction.

### Domain validation

```elixir
defmodule ValidateTransaction do
  def run_maybe([item, payment], _opt, _env) do
    item.amount == payment.amount
  end
end
```

This is not a structural check. It is a rule that relates the extracted foci.

### Logging as an effect

```elixir
defmodule LogTransaction do
  def run_maybe([item, payment], opts, _env) do
    prefix = Keyword.get(opts, :prefix)

    Logger.info("#{prefix} $#{payment.amount} for #{item.name}")
    :ok
  end
end
```

### Completing the transaction

```elixir
defmodule CompleteTransaction do
  alias Funx.Optics.Lens

  def run_maybe(_traversal, opts, _env) do
    transaction = Keyword.get(opts, :original)

    Lens.set(transaction, Processor.payment_status_lens, :complete)
  end
end
```

This uses `Lens.set` rather than `Lens.set!`, so the update itself is modeled as a fallible step.

## The processor

```elixir
defmodule Traversal.TransactionProcessor do
  alias Funx.Optics.Traversal

  def cc_payment(transaction) do
    maybe transaction, as: :raise do
      bind Traversal.to_list_maybe(Processor.cc_payment_trav)
      guard ValidateTransaction
      tap {LogTransaction, prefix: "Charging cc"}
      bind {CompleteTransaction, original: transaction}
    end
  end

  def check_payment(transaction) do
    maybe transaction, as: :raise do
      bind Traversal.to_list_maybe(Processor.check_payment_trav)
      guard ValidateTransaction
      tap {LogTransaction, prefix: "Charging check"}
      bind {CompleteTransaction, original: transaction}
    end
  end

  def cc_refund(transaction) do
    maybe transaction, as: :raise do
      bind Traversal.to_list_maybe(Processor.cc_refund_trav)
      guard ValidateTransaction
      tap {LogTransaction, prefix: "Refunding cc"}
      bind {CompleteTransaction, original: transaction}
    end
  end

  def check_refund(transaction) do
    maybe transaction, as: :raise do
      bind Traversal.to_list_maybe(Processor.check_refund_trav)
      guard ValidateTransaction
      tap {LogTransaction, prefix: "Refunding check"}
      bind {CompleteTransaction, original: transaction}
    end
  end
end
```

This pipeline has a specific shape:

The traversal establishes which foci exist together for the operation.

The guard enforces the rule that relates those foci.

The remaining steps describe the operation itself.

A valid credit card charge succeeds:

```elixir
Traversal.TransactionProcessor.cc_payment(charge_cc)
```

A mismatch raises:

```elixir
Traversal.TransactionProcessor.cc_payment(refund_cc)
```

An invalid credit card charge also raises:

```elixir
Traversal.TransactionProcessor.cc_payment(invalid_charge_cc)
```

## Applicability

Applicability is often encoded as control flow:

* selecting a function clause
* checks inside the function body
* `if` statements that guard execution
* failure paths that implicitly signal inapplicability

Optics let us separate the concerns:

The traversal names the structural requirement for an operation.

Validation names the domain rule for the extracted foci.

The operation is written as a straight pipeline that runs only after both hold.

This is not about replacing pattern matching. Pattern matching remains a strong tool. The difference is that the requirements for an operation can exist as values: named, reusable, testable, and composable.
