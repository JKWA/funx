# Funx.List

```elixir
Mix.install([
  {:funx, "0.6.1"}
])
```

The `Funx.List` module provides utility functions for working with lists while respecting `Eq` and `Ord` instances. This allows for set-like operations, uniqueness constraints, and sorted collections that align with functional programming principles.

## Features

- **Equality-based Operations**: Use `Eq` instances to compare elements for uniqueness, intersection, and difference.
- **Ordering Functions**: Leverage `Ord` instances to sort and enforce uniqueness in sorted collections.
- **Set Operations**: Perform union, intersection, difference, and symmetric difference while preserving custom equality logic.
- **Subset & Superset Checks**: Verify relationships between lists in terms of inclusion.
- **Functional Constructs**: Implements `Monad` and `Foldable` protocols for lists, supporting mapping, binding, and folding.

### Usage Overview

1. **Deduplicate**: Use `uniq/1` to remove duplicates based on `Eq`.
2. **Combine**: Use `union/2` to merge lists without duplicates.
3. **Filter**: Use `intersection/2` or `difference/2` for set operations.
4. **Sort**: Use `sort/2` or `strict_sort/2` with `Ord` instances.
5. **Check Membership**: Use `subset?/2` or `superset?/2` to verify inclusion relationships.

### Equality-Based Operations

- `uniq/1`: Removes duplicates using `Eq`.
- `union/2`: Merges lists while preserving uniqueness.
- `intersection/2`: Returns elements common to both lists.
- `difference/2`: Returns elements from the first list not in the second.
- `symmetric_difference/2`: Returns elements unique to each list.

### Ordering Functions

- `sort/2`: Sorts a list using `Ord`.
- `strict_sort/2`: Sorts while ensuring uniqueness.

### Set Operations

- `subset?/2`: Checks if one list is a subset of another.
- `superset?/2`: Checks if one list is a superset of another.

### Monad Implementation

- `map/2`: Transforms list elements.
- `bind/2`: Applies a function returning lists and flattens the result.
- `ap/2`: Applies functions in a list to elements in another list.

### Foldable Implementation

- `fold_l/3`: Performs left-associative folding.
- `fold_r/3`: Performs right-associative folding.

## Function Examples

```elixir
import Funx.List
```

## uniq/2

Removes duplicate elements from a list based on the given equality module.

### Examples

```elixir
uniq([1, 2, 2, 3, 1, 4, 5])
```

## union/3

Returns the union of two lists, removing duplicates.

### Examples

```elixir
union([1, 2, 3], [3, 4, 5])
```

## intersection/3

Returns the intersection of two lists.

### Examples

```elixir
intersection([1, 2, 3, 4], [3, 4, 5])
```

## difference/3

Returns the difference of two lists.

### Examples

```elixir
difference([1, 2, 3, 4], [3, 4, 5])
```

## symmetric_difference/3

Returns the symmetric difference of two lists.

### Examples

```elixir
symmetric_difference([1, 2, 3], [3, 4, 5])
```

## subset?/3

Checks if the first list is a subset of the second.

### Examples

```elixir
subset?([1, 2], [1, 2, 3, 4])
```

```elixir
subset?([1, 5], [1, 2, 3, 4])
```

## superset?/3

Checks if the first list is a superset of the second.

### Examples

```elixir
superset?([1, 2, 3, 4], [1, 2])
```

```elixir
superset?([1, 2, 3, 4], [1, 5])
```

## sort/2

Sorts a list using the given ordering module.

### Examples

```elixir
sort([3, 1, 4, 1, 5])
```

## strict_sort/2

Sorts a list while ensuring uniqueness.

### Examples

```elixir
strict_sort([3, 1, 4, 1, 5])
```

## concat/1

Concatenates a list of lists from left to right.

This uses the `ListConcat` monoid, preserving the original order of elements.

### Examples

```elixir
concat([[1], [2, 3], [4]])
```