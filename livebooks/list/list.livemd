# Funx.List

```elixir
Mix.install([
  {:funx, "0.8.2"}
])
```

The `Funx.List` module provides utility functions for working with lists while respecting `Eq` and `Ord` instances. This allows for set-like operations, uniqueness constraints, and sorted collections that align with functional programming principles.

## Features

- **Equality-based Operations**: Use `Eq` instances to compare elements for uniqueness, intersection, and difference.
- **Ordering Functions**: Leverage `Ord` instances to sort and enforce uniqueness in sorted collections.
- **Set Operations**: Perform union, intersection, difference, and symmetric difference while preserving custom equality logic.
- **Subset & Superset Checks**: Verify relationships between lists in terms of inclusion.
- **Functional Constructs**: Implements `Monad` and `Foldable` protocols for lists, supporting mapping, binding, and folding.

### Usage Overview

1. **Deduplicate**: Use `uniq/1` to remove duplicates based on `Eq`.
2. **Combine**: Use `union/2` to merge lists without duplicates.
3. **Filter**: Use `intersection/2` or `difference/2` for set operations.
4. **Sort**: Use `sort/2` or `strict_sort/2` with `Ord` instances.
5. **Check Membership**: Use `subset?/2` or `superset?/2` to verify inclusion relationships.
6. **Find Extremes**: Use `min/2`, `max/2` for safe min/max, or `min!/2`, `max!/2` to raise on empty.
7. **Group**: Use `group/1` to group consecutive equal elements.

### Equality-Based Operations

- `uniq/1`: Removes duplicates using `Eq`.
- `union/2`: Merges lists while preserving uniqueness.
- `intersection/2`: Returns elements common to both lists.
- `difference/2`: Returns elements from the first list not in the second.
- `symmetric_difference/2`: Returns elements unique to each list.
- `group/1`: Groups consecutive equal elements into sublists.
- `partition/2`: Partitions into elements equal to a value and those not.

### Ordering Functions

- `sort/2`: Sorts a list using `Ord`.
- `strict_sort/2`: Sorts while ensuring uniqueness.
- `group_sort/2`: Sorts and groups consecutive equal elements.

### Set Operations

- `subset?/2`: Checks if one list is a subset of another.
- `superset?/2`: Checks if one list is a superset of another.

### Min/Max Operations

- `min/2`: Returns the minimum element wrapped in `Maybe`.
- `min!/2`: Returns the minimum element, raises on empty list.
- `max/2`: Returns the maximum element wrapped in `Maybe`.
- `max!/2`: Returns the maximum element, raises on empty list.

### List Operations

- `head/1`: Returns the head of a list wrapped in `Maybe`.
- `head!/1`: Returns the head of a list, raises on empty.
- `tail/1`: Returns the tail of a list.
- `elem?/3`: Checks if a value is an element of the list.

### Monad Implementation

- `map/2`: Transforms list elements.
- `bind/2`: Applies a function returning lists and flattens the result.
- `ap/2`: Applies functions in a list to elements in another list.

### Foldable Implementation

- `fold_l/3`: Performs left-associative folding.
- `fold_r/3`: Performs right-associative folding.

## Function Examples

```elixir
import Funx.List
```

## uniq/2

Removes duplicate elements from a list based on the given equality module.

### Examples

```elixir
uniq([1, 2, 2, 3, 1, 4, 5])
```

## union/3

Returns the union of two lists, removing duplicates.

### Examples

```elixir
union([1, 2, 3], [3, 4, 5])
```

## intersection/3

Returns the intersection of two lists.

### Examples

```elixir
intersection([1, 2, 3, 4], [3, 4, 5])
```

## difference/3

Returns the difference of two lists.

### Examples

```elixir
difference([1, 2, 3, 4], [3, 4, 5])
```

## symmetric_difference/3

Returns the symmetric difference of two lists.

### Examples

```elixir
symmetric_difference([1, 2, 3], [3, 4, 5])
```

## group/2

Groups consecutive equal elements into sublists.

This is the Eq-based equivalent of Haskell's `group`.

### Examples

```elixir
group([1, 1, 2, 2, 2, 3, 1, 1])
```

```elixir
group([])
```

```elixir
group([:a, :a, :b, :c, :c, :c])
```

## partition/3

Partitions a list into elements equal to a value and elements not equal.

### Examples

```elixir
partition([1, 2, 1, 3, 1], 1)
```

```elixir
partition([1, 2, 3], 4)
```

## subset?/3

Checks if the first list is a subset of the second.

### Examples

```elixir
subset?([1, 2], [1, 2, 3, 4])
```

```elixir
subset?([1, 5], [1, 2, 3, 4])
```

## superset?/3

Checks if the first list is a superset of the second.

### Examples

```elixir
superset?([1, 2, 3, 4], [1, 2])
```

```elixir
superset?([1, 2, 3, 4], [1, 5])
```

## sort/2

Sorts a list using the given ordering module.

### Examples

```elixir
sort([3, 1, 4, 1, 5])
```

## strict_sort/2

Sorts a list while ensuring uniqueness.

### Examples

```elixir
strict_sort([3, 1, 4, 1, 5])
```

## group_sort/2

Sorts a list and then groups consecutive equal elements.

### Examples

```elixir
group_sort([1, 2, 1, 2, 1])
```

```elixir
group_sort([3, 1, 2, 1, 3])
```

## concat/1

Concatenates a list of lists from left to right.

This uses the `ListConcat` monoid, preserving the original order of elements.

### Examples

```elixir
concat([[1], [2, 3], [4]])
```

## elem?/3

Returns true if the given value is an element of the list under the provided `Eq`.

This is the Eq-based equivalent of Haskell's `elem`.

### Examples

```elixir
elem?([1, 2, 3], 1)
```

```elixir
elem?([1, 3], 2)
```

## head/1

Returns the head of a list wrapped in `Maybe.Just`, or `Maybe.Nothing` if empty.

This is a safe version of `hd/1` that returns `Maybe` instead of raising.

### Examples

```elixir
head([1, 2, 3])
```

```elixir
head([])
```

## head!/1

Returns the head of a list.

Raises `ArgumentError` if the list is empty.

### Examples

```elixir
head!([1, 2, 3])
```

```elixir
head!([42])
```

## tail/1

Returns the tail of a list.

The tail of an empty list is an empty list.

### Examples

```elixir
tail([1, 2, 3])
```

```elixir
tail([1])
```

```elixir
tail([])
```

## min/2

Returns the minimum element in a list according to the given ordering.

Returns `Just(element)` for non-empty lists, `Nothing` for empty lists.

This is a safe version that returns `Maybe` instead of raising.

### Examples

```elixir
min([3, 1, 4, 1, 5])
```

```elixir
min([])
```

```elixir
ord = Funx.Ord.contramap(&String.length/1)
min(["cat", "elephant", "ox"], ord)
```

## min!/2

Returns the minimum element in a list according to the given ordering.

Raises `Enum.EmptyError` if the list is empty.

### Examples

```elixir
min!([3, 1, 4, 1, 5])
```

```elixir
ord = Funx.Ord.contramap(&String.length/1)
min!(["cat", "elephant", "ox"], ord)
```

## max/2

Returns the maximum element in a list according to the given ordering.

Returns `Just(element)` for non-empty lists, `Nothing` for empty lists.

This is a safe version that returns `Maybe` instead of raising.

### Examples

```elixir
max([3, 1, 4, 1, 5])
```

```elixir
max([])
```

```elixir
ord = Funx.Ord.contramap(&String.length/1)
max(["cat", "elephant", "ox"], ord)
```

## max!/2

Returns the maximum element in a list according to the given ordering.

Raises `Enum.EmptyError` if the list is empty.

### Examples

```elixir
max!([3, 1, 4, 1, 5])
```

```elixir
ord = Funx.Ord.contramap(&String.length/1)
max!(["cat", "elephant", "ox"], ord)
```