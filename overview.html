<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.39.3">
    <meta name="project" content="funx v0.6.1">


    <title>Overview — funx v0.6.1</title>

    <link rel="stylesheet" href="dist/html-elixir-VYWJUHZE.css" />

      <link rel="canonical" href="https://hexdocs.pm/funx/overview.html" />

    <script defer src="dist/sidebar_items-4A58368C.js"></script>
    <script defer src="docs_config.js"></script>
    <script defer src="dist/html-XBCM4BHM.js"></script>

  </head>
  <body>
    <script>(()=>{var t="ex_doc:settings",e="dark";var o="dark",s="light";var E="sidebar_state",n="closed";var r="sidebar_width";var a="sidebar-open";var i=new URLSearchParams(window.location.search),S=i.get("theme")||JSON.parse(localStorage.getItem(t)||"{}").theme;(S===o||S!==s&&window.matchMedia("(prefers-color-scheme: dark)").matches)&&document.body.classList.add(e);var d=sessionStorage.getItem(E),A=d!==n&&!window.matchMedia(`screen and (max-width: ${768}px)`).matches;document.body.classList.toggle(a,A);var c=sessionStorage.getItem(r);c&&document.body.style.setProperty("--sidebarWidth",`${c}px`);var p=/(Macintosh|iPhone|iPad|iPod)/.test(window.navigator.userAgent);document.documentElement.classList.toggle("apple-os",p);})();
</script>

<div class="body-wrapper">

<button id="sidebar-menu" class="sidebar-button sidebar-toggle" aria-label="toggle sidebar" aria-controls="sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<nav id="sidebar" class="sidebar">

  <div class="sidebar-header">
    <div class="sidebar-projectInfo">

      <div>
        <a href="readme.html" class="sidebar-projectName" translate="no">
funx
        </a>
        <div class="sidebar-projectVersion" translate="no">
          v0.6.1
        </div>
      </div>
    </div>
    <ul id="sidebar-list-nav" class="sidebar-list-nav" role="tablist" data-extras=""></ul>
  </div>
</nav>

<output role="status" id="toast"></output>

<main class="content page-extra" id="main" data-type="extras">
  <div id="content" class="content-inner">
    <div class="top-search">
      <div class="search-settings">
        <form class="search-bar" action="search.html">
          <label class="search-label">
            <span class="sr-only">Search documentation of funx</span>
            <div class="search-input-wrapper">
              <input name="q" type="text" class="search-input" placeholder="Press / to search" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
              <button type="button" tabindex="-1" class="search-close-button" aria-hidden="true">
                <i class="ri-close-line ri-lg" title="Cancel search"></i>
              </button>
            </div>
          </label>
        </form>
        <div class="autocomplete">
        </div>
        <div class="engine-selector" data-multiple="false">
          <button type="button" class="engine-button" aria-label="Select search engine" aria-haspopup="true" aria-expanded="false">
            <i class="ri-search-2-line" aria-hidden="true"></i>
            <span class="engine-name">Default</span>
            <i class="ri-arrow-down-s-line" aria-hidden="true"></i>
          </button>
          <div class="engine-dropdown" hidden role="menu">

              <button type="button"
                      class="engine-option"
                      data-engine-url="search.html?q="
                      role="menuitemradio"
                      aria-checked="true">
                <span class="name">Default</span>
                <span class="help">In-browser search</span>
              </button>

          </div>
        </div>
        <button class="icon-settings display-settings">
          <i class="ri-settings-3-line"></i>
          <span class="sr-only">Settings</span>
        </button>
      </div>
    </div>

<div id="top-content">
  <div class="heading-with-actions top-heading">
    <h1>Overview</h1>


      <a href="https://github.com/JKWA/funx/blob/v0.6.1/guides/dsl/overview.md#L1" title="View Source" class="icon-action" rel="help">
        <i class="ri-code-s-slash-line" aria-hidden="true"></i>
        <span class="sr-only">View Source</span>
      </a>

  </div>


<p>Funx provides two distinct categories of DSLs with different purposes and semantics.</p><h2 id="dsl-categories" class="section-heading"><a href="#dsl-categories" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">DSL Categories</span></h2><h3 id="builder-dsls" class="section-heading"><a href="#builder-dsls" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Builder DSLs</span></h3><p>Builder DSLs construct data structures (comparators, orderings, predicates) for later use.</p><p>Examples: <code class="inline">eq</code>, <code class="inline">ord</code>, <code class="inline">pred</code></p><p>Characteristics:</p><ul><li>No input parameter — builds a reusable function or comparator</li><li>Returns a data structure — built via monoidal composition (Eq.All, Ord monoid, predicate function)</li><li>Used with utility functions — <code class="inline">Eq.eq?/3</code>, <code class="inline">Ord.compare/3</code>, <a href="https://hexdocs.pm/elixir/Enum.html#filter/2"><code class="inline">Enum.filter/2</code></a></li><li>May support nesting — <code class="inline">any</code>/<code class="inline">all</code> blocks for boolean composition (Eq, Pred only)</li></ul><p>Example:</p><pre><code class="makeup elixir" translate="no"><span class="c1"># Build a comparator</span><span class="w">
</span><span class="n">user_eq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eq</span><span class="w"> </span><span class="k" data-group-id="4467232678-1">do</span><span class="w">
  </span><span class="n">on</span><span class="w"> </span><span class="ss">:name</span><span class="w">
  </span><span class="n">on</span><span class="w"> </span><span class="ss">:email</span><span class="w">
</span><span class="k" data-group-id="4467232678-1">end</span><span class="w">

</span><span class="c1"># Use it later</span><span class="w">
</span><span class="nc">Eq</span><span class="o">.</span><span class="n">eq?</span><span class="p" data-group-id="4467232678-2">(</span><span class="n">user1</span><span class="p">,</span><span class="w"> </span><span class="n">user2</span><span class="p">,</span><span class="w"> </span><span class="n">user_eq</span><span class="p" data-group-id="4467232678-2">)</span></code></pre><h3 id="pipeline-dsls" class="section-heading"><a href="#pipeline-dsls" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Pipeline DSLs</span></h3><p>Pipeline DSLs execute a sequence of operations on an input value.</p><p>Examples: <code class="inline">maybe</code>, <code class="inline">either</code></p><p>Characteristics:</p><ul><li>Takes input parameter — transforms/validates the input</li><li>Returns a result — Maybe.t() or Either.t() with the transformed value</li><li>Sequential execution — steps run in order, short-circuit on failure</li><li>Supports transformers — compile-time pipeline optimization</li></ul><p>Example:</p><pre><code class="makeup elixir" translate="no"><span class="c1"># Execute pipeline on input</span><span class="w">
</span><span class="n">maybe</span><span class="w"> </span><span class="n">user_id</span><span class="w"> </span><span class="k" data-group-id="5308646494-1">do</span><span class="w">
  </span><span class="n">bind</span><span class="w"> </span><span class="nc">GetUser</span><span class="w">
  </span><span class="n">bind</span><span class="w"> </span><span class="nc">ValidateActive</span><span class="w">
  </span><span class="n">map</span><span class="w"> </span><span class="nc">FormatResponse</span><span class="w">
</span><span class="k" data-group-id="5308646494-1">end</span><span class="w">
</span><span class="c1"># Returns Maybe.t()</span></code></pre><h3 id="key-differences" class="section-heading"><a href="#key-differences" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Key Differences</span></h3><table><thead><tr><th style="text-align: left;">Aspect</th><th style="text-align: left;">Builder DSLs</th><th style="text-align: left;">Pipeline DSLs</th></tr></thead><tbody><tr><td style="text-align: left;">Signature</td><td style="text-align: left;"><code class="inline">dsl do ... end</code></td><td style="text-align: left;"><code class="inline">dsl input do ... end</code></td></tr><tr><td style="text-align: left;">Purpose</td><td style="text-align: left;">Build reusable structures</td><td style="text-align: left;">Transform input values</td></tr><tr><td style="text-align: left;">Execution</td><td style="text-align: left;">Deferred (used later)</td><td style="text-align: left;">Immediate (on input)</td></tr><tr><td style="text-align: left;">Return Type</td><td style="text-align: left;">Monoid/Function</td><td style="text-align: left;">Monad (Maybe/Either)</td></tr><tr><td style="text-align: left;">Nesting</td><td style="text-align: left;">Supports <code class="inline">any</code>/<code class="inline">all</code> blocks</td><td style="text-align: left;">Linear (sequential steps)</td></tr></tbody></table><h2 id="structure" class="section-heading"><a href="#structure" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Structure</span></h2><p>A Funx DSL block compiles at macro-expansion time. The compiler parses the block syntax, applies transformations, and produces executable code. The compiled representation varies by DSL but typically involves structured data describing the operations to perform.</p><pre><code class="text">Compilation
    ├── DSL Block (AST)
    ├── Parser
    │     └── Builds internal representation
    ├── Transformers
    │     └── Optional rewrites
    ├── Compiled Form
    └── Executor
          └── Produces result</code></pre><h2 id="operations" class="section-heading"><a href="#operations" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Operations</span></h2><p>Each DSL defines its own internal representation of operations. For pipeline DSLs, these are typically step structs describing transformations. For builder DSLs, operations describe composition rules. The executor interprets these representations to produce the final result.</p><pre><code class="text">Parsed Operations
    ├── Operation
    ├── Operation
    ├── Operation
    └── Operation</code></pre><h2 id="parser" class="section-heading"><a href="#parser" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Parser</span></h2><p>Each DSL provides its own parser. The parser converts the DSL block into an internal representation, applies lifting and alias-expansion rules, and raises compile-time errors for invalid or unsupported forms.</p><h2 id="transformers" class="section-heading"><a href="#transformers" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Transformers</span></h2><p>Transformers run during compilation and may rewrite the parsed operations before code generation. They can insert, remove, or modify operations. A transformer must return a valid representation for that DSL and introduces a compile-time dependency. Currently supported by pipeline DSLs (Maybe, Either).</p><h2 id="execution" class="section-heading"><a href="#execution" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Execution</span></h2><p>Each DSL has a dedicated executor. The executor interprets the compiled representation and produces the final result. It does not inspect source code; it operates only on the compiled form.</p><h2 id="behaviours" class="section-heading"><a href="#behaviours" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Behaviours</span></h2><p>Each DSL defines a behaviour for modules that participate in the DSL. Modules implementing this behaviour supply the callback the executor invokes. The DSL determines how the callback's return value is interpreted.</p><h2 id="architectural-choices" class="section-heading"><a href="#architectural-choices" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Architectural Choices</span></h2><h3 id="why-ord-doesn-t-support-nesting" class="section-heading"><a href="#why-ord-doesn-t-support-nesting" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Why Ord Doesn't Support Nesting</span></h3><p>The <code class="inline">ord</code> DSL does not support <code class="inline">any</code>/<code class="inline">all</code> blocks like <code class="inline">eq</code> and <code class="inline">pred</code> do. This is intentional.</p><p>Total orderings compose linearly. When you combine orderings with <code class="inline">Ord.concat/1</code>, you get a lexicographic ordering where the first comparison that returns <code class="inline">:lt</code> or <code class="inline">:gt</code> determines the result. This is fundamentally different from the boolean logic of equality or predicates.</p><pre><code class="makeup elixir" translate="no"><span class="c1"># Ord: Linear composition (lexicographic)</span><span class="w">
</span><span class="n">ord</span><span class="w"> </span><span class="k" data-group-id="5420416394-1">do</span><span class="w">
  </span><span class="n">asc</span><span class="w"> </span><span class="ss">:last_name</span><span class="w">   </span><span class="c1"># First comparison</span><span class="w">
  </span><span class="n">asc</span><span class="w"> </span><span class="ss">:first_name</span><span class="w">  </span><span class="c1"># Tiebreaker if last names equal</span><span class="w">
  </span><span class="n">desc</span><span class="w"> </span><span class="ss">:age</span><span class="w">        </span><span class="c1"># Further tiebreaker</span><span class="w">
</span><span class="k" data-group-id="5420416394-1">end</span><span class="w">

</span><span class="c1"># Eq: Can express OR logic</span><span class="w">
</span><span class="n">eq</span><span class="w"> </span><span class="k" data-group-id="5420416394-2">do</span><span class="w">
  </span><span class="n">any</span><span class="w"> </span><span class="k" data-group-id="5420416394-3">do</span><span class="w">
    </span><span class="n">on</span><span class="w"> </span><span class="ss">:email</span><span class="w">
    </span><span class="n">on</span><span class="w"> </span><span class="ss">:username</span><span class="w">
  </span><span class="k" data-group-id="5420416394-3">end</span><span class="w">
</span><span class="k" data-group-id="5420416394-2">end</span></code></pre><p>There's no meaningful &quot;OR&quot; for orderings - you can't say &quot;order by name OR age&quot;. The order is always determined by a sequence of tiebreakers.</p><h3 id="why-pipeline-dsls-don-t-support-nesting" class="section-heading"><a href="#why-pipeline-dsls-don-t-support-nesting" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i></a><span class="text">Why Pipeline DSLs Don't Support Nesting</span></h3><p>Pipeline DSLs (<code class="inline">maybe</code>, <code class="inline">either</code>) execute sequentially and short-circuit on failure. They don't support <code class="inline">any</code>/<code class="inline">all</code> blocks because monadic composition is inherently sequential — each operation depends on the result of the previous one. There's no boolean combination to express; operations either succeed (Right/Just) or fail (Left/Nothing), and failure stops the pipeline.</p><p>For conditional logic in pipelines, use the monad's native operations:</p><ul><li><code class="inline">filter</code> - conditionally keep/drop values</li><li><code class="inline">guard</code> - assert a condition</li><li>Pattern matching in behaviour callbacks</li></ul>

</div>

<div class="bottom-actions" id="bottom-actions">
  <div class="bottom-actions-item">

      <a href="formatter_export.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
Formatter Rules
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="either.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
Either
        </span>
      </a>

  </div>
</div>
    <footer class="footer">

        <p>

            <span class="line">
              <a href="https://hex.pm/packages/funx/0.6.1" class="footer-hex-package">Hex Package</a>

              <a href="https://preview.hex.pm/preview/funx/0.6.1">Hex Preview</a>

                (<a href="https://preview.hex.pm/preview/funx/0.6.1/show/guides/dsl/overview.md">current file</a>)

            </span>

          <span class="line">
            <button class="a-main footer-button display-quick-switch" title="Go to package docs">
              Go to package docs
            </button>

              <a href="funx.epub" title="ePub version">
                Download ePub version
              </a>

          </span>
        </p>

        <p class="built-using">
          Built using
          <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.39.3) for the

            <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a>

        </p>


    </footer>
  </div>
</main>
</div>

  </body>
</html>
